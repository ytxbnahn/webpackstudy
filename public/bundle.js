/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 20);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__main_css__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__main_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__main_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vue_vue__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vue_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__vue_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vue__ = __webpack_require__(14);\nvar greeter = __webpack_require__(4);\r\n\r\n\r\n\r\n\r\n\r\nnew __WEBPACK_IMPORTED_MODULE_2_vue__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__vue_vue___default.a);\r\ndocument.getElementById('root').appendChild(greeter());\r\nconsole.log(\"ddddddddddddddddd-----ddd --sssssssssssss-----\");//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbWFpbi5qcz82YTRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ3JlZXRlciA9IHJlcXVpcmUoJy4vR3JlZXRlci5qcycpO1xyXG5cclxuaW1wb3J0ICcuL21haW4uY3NzJ1xyXG5cclxuaW1wb3J0IGFwcCBmcm9tICcuL3Z1ZS52dWUnXHJcbmltcG9ydCBWdWUgZnJvbSAndnVlJ1xyXG5uZXcgVnVlKGFwcCk7XHJcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290JykuYXBwZW5kQ2hpbGQoZ3JlZXRlcigpKTtcclxuY29uc29sZS5sb2coXCJkZGRkZGRkZGRkZGRkZGRkZC0tLS0tZGRkIC0tc3Nzc3Nzc3Nzc3Nzcy0tLS0tXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Component = __webpack_require__(12)(\n  /* script */\n  __webpack_require__(5),\n  /* template */\n  __webpack_require__(13),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"C:\\\\材料\\\\文件\\\\nodeProject\\\\webpack\\\\app\\\\vue.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] vue.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-7de3e7d8\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-7de3e7d8\", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvdnVlLnZ1ZT8zY2ZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQW9IO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxpREFBaUQsSUFBSTtBQUNwSSxtQ0FBbUM7O0FBRW5DO0FBQ0EsWUFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvLl92dWUtbG9hZGVyQDExLjMuNEB2dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvLl92dWUtbG9hZGVyQDExLjMuNEB2dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vdnVlLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzLy5fdnVlLWxvYWRlckAxMS4zLjRAdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi03ZGUzZTdkOFxcXCJ9IS4uL25vZGVfbW9kdWxlcy8uX3Z1ZS1sb2FkZXJAMTEuMy40QHZ1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3Z1ZS52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkM6XFxcXOadkOaWmVxcXFzmlofku7ZcXFxcbm9kZVByb2plY3RcXFxcd2VicGFja1xcXFxhcHBcXFxcdnVlLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIHZ1ZS52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtN2RlM2U3ZDhcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi03ZGUzZTdkOFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvdnVlLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

eval("/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"var Component = __webpack_require__(12)(\\n  /* script */\\n  __webpack_require__(6),\\n  /* template */\\n  __webpack_require__(13),\\n  /* scopeId */\\n  null,\\n  /* cssModules */\\n  null\\n)\\nComponent.options.__file = \\\"C:\\\\\\\\材料\\\\\\\\文件\\\\\\\\nodeProject\\\\\\\\webpack\\\\\\\\app\\\\\\\\vue.vue\\\"\\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \\\"default\\\" && key !== \\\"__esModule\\\"})) {console.error(\\\"named exports are not supported in *.vue files.\\\")}\\nif (Component.options.functional) {console.error(\\\"[vue-loader] vue.vue: functional components are not supported with templates, they should use render functions.\\\")}\\n\\n/* hot reload */\\nif (false) {(function () {\\n  var hotAPI = require(\\\"vue-loader/node_modules/vue-hot-reload-api\\\")\\n  hotAPI.install(require(\\\"vue\\\"), false)\\n  if (!hotAPI.compatible) return\\n  module.hot.accept()\\n  if (!module.hot.data) {\\n    hotAPI.createRecord(\\\"data-v-7de3e7d8\\\", Component.options)\\n  } else {\\n    hotAPI.reload(\\\"data-v-7de3e7d8\\\", Component.options)\\n  }\\n})()}\\n\\nmodule.exports = Component.exports\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvdnVlLnZ1ZT8zY2ZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQW9IO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxpREFBaUQsSUFBSTtBQUNwSSxtQ0FBbUM7O0FBRW5DO0FBQ0EsWUFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvLl92dWUtbG9hZGVyQDExLjMuNEB2dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvLl92dWUtbG9hZGVyQDExLjMuNEB2dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vdnVlLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzLy5fdnVlLWxvYWRlckAxMS4zLjRAdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi03ZGUzZTdkOFxcXCJ9IS4uL25vZGVfbW9kdWxlcy8uX3Z1ZS1sb2FkZXJAMTEuMy40QHZ1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3Z1ZS52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkM6XFxcXOadkOaWmVxcXFzmlofku7ZcXFxcbm9kZVByb2plY3RcXFxcd2VicGFja1xcXFxhcHBcXFxcdnVlLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIHZ1ZS52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtN2RlM2U3ZDhcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi03ZGUzZTdkOFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvdnVlLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\");\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\neval(\"var g;\\r\\n\\r\\n// This works in non-strict mode\\r\\ng = (function() {\\r\\n\\treturn this;\\r\\n})();\\r\\n\\r\\ntry {\\r\\n\\t// This works if eval is allowed (see CSP)\\r\\n\\tg = g || Function(\\\"return this\\\")() || (1,eval)(\\\"this\\\");\\r\\n} catch(e) {\\r\\n\\t// This works if the window reference is available\\r\\n\\tif(typeof window === \\\"object\\\")\\r\\n\\t\\tg = window;\\r\\n}\\r\\n\\r\\n// g can still be undefined, but nothing to do about it...\\r\\n// We return undefined, instead of nothing here, so it's\\r\\n// easier to handle this case. if(!global) { ...}\\r\\n\\r\\nmodule.exports = g;\\r\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\");\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"var config = __webpack_require__(9);\\r\\nvar vue = __webpack_require__(0);\\r\\nmodule.exports = function() {\\r\\n  var greet = document.createElement('div');\\r\\n  var Vue = document.createElement('div');\\r\\n  greet.textContent = config.greetText;\\r\\n  return greet;\\r\\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvR3JlZXRlci5qcz9lYjg0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZy5qc29uJyk7XHJcbnZhciB2dWUgPSByZXF1aXJlKCcuL3Z1ZS52dWUnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgZ3JlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICB2YXIgVnVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgZ3JlZXQudGV4dENvbnRlbnQgPSBjb25maWcuZ3JlZXRUZXh0O1xyXG4gIHJldHVybiBncmVldDtcclxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9HcmVldGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\");\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"// style-loader: Adds some css to the DOM by adding a <style> tag\\n\\n// load the styles\\nvar content = __webpack_require__(7);\\nif(typeof content === 'string') content = [[module.i, content, '']];\\n// add the styles to the DOM\\nvar update = __webpack_require__(10)(content, {});\\nif(content.locals) module.exports = content.locals;\\n// Hot Module Replacement\\nif(false) {\\n\\t// When the styles change, update the <style> tags\\n\\tif(!content.locals) {\\n\\t\\tmodule.hot.accept(\\\"!!../node_modules/._css-loader@0.28.0@css-loader/index.js?modules!./main.css\\\", function() {\\n\\t\\t\\tvar newContent = require(\\\"!!../node_modules/._css-loader@0.28.0@css-loader/index.js?modules!./main.css\\\");\\n\\t\\t\\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\\n\\t\\t\\tupdate(newContent);\\n\\t\\t});\\n\\t}\\n\\t// When the module is disposed, remove the <style> tags\\n\\tmodule.hot.dispose(function() { update(); });\\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbWFpbi5jc3M/ODI3YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFvRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvLl9jc3MtbG9hZGVyQDAuMjguMEBjc3MtbG9hZGVyL2luZGV4LmpzP21vZHVsZXMhLi9tYWluLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzLy5fc3R5bGUtbG9hZGVyQDAuMTYuMUBzdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzLy5fY3NzLWxvYWRlckAwLjI4LjBAY3NzLWxvYWRlci9pbmRleC5qcz9tb2R1bGVzIS4vbWFpbi5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy8uX2Nzcy1sb2FkZXJAMC4yOC4wQGNzcy1sb2FkZXIvaW5kZXguanM/bW9kdWxlcyEuL21haW4uY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9tYWluLmNzc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\");\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"/* WEBPACK VAR INJECTION */(function(process, global) {/*!\\n * Vue.js v2.2.6\\n * (c) 2014-2017 Evan You\\n * Released under the MIT License.\\n */\\n/*  */\\n\\n/**\\n * Convert a value to a string that is actually rendered.\\n */\\nfunction _toString (val) {\\n  return val == null\\n    ? ''\\n    : typeof val === 'object'\\n      ? JSON.stringify(val, null, 2)\\n      : String(val)\\n}\\n\\n/**\\n * Convert a input value to a number for persistence.\\n * If the conversion fails, return original string.\\n */\\nfunction toNumber (val) {\\n  var n = parseFloat(val);\\n  return isNaN(n) ? val : n\\n}\\n\\n/**\\n * Make a map and return a function for checking if a key\\n * is in that map.\\n */\\nfunction makeMap (\\n  str,\\n  expectsLowerCase\\n) {\\n  var map = Object.create(null);\\n  var list = str.split(',');\\n  for (var i = 0; i < list.length; i++) {\\n    map[list[i]] = true;\\n  }\\n  return expectsLowerCase\\n    ? function (val) { return map[val.toLowerCase()]; }\\n    : function (val) { return map[val]; }\\n}\\n\\n/**\\n * Check if a tag is a built-in tag.\\n */\\nvar isBuiltInTag = makeMap('slot,component', true);\\n\\n/**\\n * Remove an item from an array\\n */\\nfunction remove (arr, item) {\\n  if (arr.length) {\\n    var index = arr.indexOf(item);\\n    if (index > -1) {\\n      return arr.splice(index, 1)\\n    }\\n  }\\n}\\n\\n/**\\n * Check whether the object has the property.\\n */\\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\\nfunction hasOwn (obj, key) {\\n  return hasOwnProperty.call(obj, key)\\n}\\n\\n/**\\n * Check if value is primitive\\n */\\nfunction isPrimitive (value) {\\n  return typeof value === 'string' || typeof value === 'number'\\n}\\n\\n/**\\n * Create a cached version of a pure function.\\n */\\nfunction cached (fn) {\\n  var cache = Object.create(null);\\n  return (function cachedFn (str) {\\n    var hit = cache[str];\\n    return hit || (cache[str] = fn(str))\\n  })\\n}\\n\\n/**\\n * Camelize a hyphen-delimited string.\\n */\\nvar camelizeRE = /-(\\\\w)/g;\\nvar camelize = cached(function (str) {\\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\\n});\\n\\n/**\\n * Capitalize a string.\\n */\\nvar capitalize = cached(function (str) {\\n  return str.charAt(0).toUpperCase() + str.slice(1)\\n});\\n\\n/**\\n * Hyphenate a camelCase string.\\n */\\nvar hyphenateRE = /([^-])([A-Z])/g;\\nvar hyphenate = cached(function (str) {\\n  return str\\n    .replace(hyphenateRE, '$1-$2')\\n    .replace(hyphenateRE, '$1-$2')\\n    .toLowerCase()\\n});\\n\\n/**\\n * Simple bind, faster than native\\n */\\nfunction bind (fn, ctx) {\\n  function boundFn (a) {\\n    var l = arguments.length;\\n    return l\\n      ? l > 1\\n        ? fn.apply(ctx, arguments)\\n        : fn.call(ctx, a)\\n      : fn.call(ctx)\\n  }\\n  // record original fn length\\n  boundFn._length = fn.length;\\n  return boundFn\\n}\\n\\n/**\\n * Convert an Array-like object to a real Array.\\n */\\nfunction toArray (list, start) {\\n  start = start || 0;\\n  var i = list.length - start;\\n  var ret = new Array(i);\\n  while (i--) {\\n    ret[i] = list[i + start];\\n  }\\n  return ret\\n}\\n\\n/**\\n * Mix properties into target object.\\n */\\nfunction extend (to, _from) {\\n  for (var key in _from) {\\n    to[key] = _from[key];\\n  }\\n  return to\\n}\\n\\n/**\\n * Quick object check - this is primarily used to tell\\n * Objects from primitive values when we know the value\\n * is a JSON-compliant type.\\n */\\nfunction isObject (obj) {\\n  return obj !== null && typeof obj === 'object'\\n}\\n\\n/**\\n * Strict object type check. Only returns true\\n * for plain JavaScript objects.\\n */\\nvar toString = Object.prototype.toString;\\nvar OBJECT_STRING = '[object Object]';\\nfunction isPlainObject (obj) {\\n  return toString.call(obj) === OBJECT_STRING\\n}\\n\\n/**\\n * Merge an Array of Objects into a single Object.\\n */\\nfunction toObject (arr) {\\n  var res = {};\\n  for (var i = 0; i < arr.length; i++) {\\n    if (arr[i]) {\\n      extend(res, arr[i]);\\n    }\\n  }\\n  return res\\n}\\n\\n/**\\n * Perform no operation.\\n */\\nfunction noop () {}\\n\\n/**\\n * Always return false.\\n */\\nvar no = function () { return false; };\\n\\n/**\\n * Return same value\\n */\\nvar identity = function (_) { return _; };\\n\\n/**\\n * Generate a static keys string from compiler modules.\\n */\\n\\n\\n/**\\n * Check if two values are loosely equal - that is,\\n * if they are plain objects, do they have the same shape?\\n */\\nfunction looseEqual (a, b) {\\n  var isObjectA = isObject(a);\\n  var isObjectB = isObject(b);\\n  if (isObjectA && isObjectB) {\\n    try {\\n      return JSON.stringify(a) === JSON.stringify(b)\\n    } catch (e) {\\n      // possible circular reference\\n      return a === b\\n    }\\n  } else if (!isObjectA && !isObjectB) {\\n    return String(a) === String(b)\\n  } else {\\n    return false\\n  }\\n}\\n\\nfunction looseIndexOf (arr, val) {\\n  for (var i = 0; i < arr.length; i++) {\\n    if (looseEqual(arr[i], val)) { return i }\\n  }\\n  return -1\\n}\\n\\n/**\\n * Ensure a function is called only once.\\n */\\nfunction once (fn) {\\n  var called = false;\\n  return function () {\\n    if (!called) {\\n      called = true;\\n      fn();\\n    }\\n  }\\n}\\n\\n/*  */\\n\\nvar config = {\\n  /**\\n   * Option merge strategies (used in core/util/options)\\n   */\\n  optionMergeStrategies: Object.create(null),\\n\\n  /**\\n   * Whether to suppress warnings.\\n   */\\n  silent: false,\\n\\n  /**\\n   * Show production mode tip message on boot?\\n   */\\n  productionTip: process.env.NODE_ENV !== 'production',\\n\\n  /**\\n   * Whether to enable devtools\\n   */\\n  devtools: process.env.NODE_ENV !== 'production',\\n\\n  /**\\n   * Whether to record perf\\n   */\\n  performance: false,\\n\\n  /**\\n   * Error handler for watcher errors\\n   */\\n  errorHandler: null,\\n\\n  /**\\n   * Ignore certain custom elements\\n   */\\n  ignoredElements: [],\\n\\n  /**\\n   * Custom user key aliases for v-on\\n   */\\n  keyCodes: Object.create(null),\\n\\n  /**\\n   * Check if a tag is reserved so that it cannot be registered as a\\n   * component. This is platform-dependent and may be overwritten.\\n   */\\n  isReservedTag: no,\\n\\n  /**\\n   * Check if a tag is an unknown element.\\n   * Platform-dependent.\\n   */\\n  isUnknownElement: no,\\n\\n  /**\\n   * Get the namespace of an element\\n   */\\n  getTagNamespace: noop,\\n\\n  /**\\n   * Parse the real tag name for the specific platform.\\n   */\\n  parsePlatformTagName: identity,\\n\\n  /**\\n   * Check if an attribute must be bound using property, e.g. value\\n   * Platform-dependent.\\n   */\\n  mustUseProp: no,\\n\\n  /**\\n   * List of asset types that a component can own.\\n   */\\n  _assetTypes: [\\n    'component',\\n    'directive',\\n    'filter'\\n  ],\\n\\n  /**\\n   * List of lifecycle hooks.\\n   */\\n  _lifecycleHooks: [\\n    'beforeCreate',\\n    'created',\\n    'beforeMount',\\n    'mounted',\\n    'beforeUpdate',\\n    'updated',\\n    'beforeDestroy',\\n    'destroyed',\\n    'activated',\\n    'deactivated'\\n  ],\\n\\n  /**\\n   * Max circular updates allowed in a scheduler flush cycle.\\n   */\\n  _maxUpdateCount: 100\\n};\\n\\n/*  */\\n\\nvar emptyObject = Object.freeze({});\\n\\n/**\\n * Check if a string starts with $ or _\\n */\\nfunction isReserved (str) {\\n  var c = (str + '').charCodeAt(0);\\n  return c === 0x24 || c === 0x5F\\n}\\n\\n/**\\n * Define a property.\\n */\\nfunction def (obj, key, val, enumerable) {\\n  Object.defineProperty(obj, key, {\\n    value: val,\\n    enumerable: !!enumerable,\\n    writable: true,\\n    configurable: true\\n  });\\n}\\n\\n/**\\n * Parse simple path.\\n */\\nvar bailRE = /[^\\\\w.$]/;\\nfunction parsePath (path) {\\n  if (bailRE.test(path)) {\\n    return\\n  }\\n  var segments = path.split('.');\\n  return function (obj) {\\n    for (var i = 0; i < segments.length; i++) {\\n      if (!obj) { return }\\n      obj = obj[segments[i]];\\n    }\\n    return obj\\n  }\\n}\\n\\n/*  */\\n/* globals MutationObserver */\\n\\n// can we use __proto__?\\nvar hasProto = '__proto__' in {};\\n\\n// Browser environment sniffing\\nvar inBrowser = typeof window !== 'undefined';\\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\\nvar isIE = UA && /msie|trident/.test(UA);\\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\\nvar isEdge = UA && UA.indexOf('edge/') > 0;\\nvar isAndroid = UA && UA.indexOf('android') > 0;\\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\\nvar isChrome = UA && /chrome\\\\/\\\\d+/.test(UA) && !isEdge;\\n\\n// this needs to be lazy-evaled because vue may be required before\\n// vue-server-renderer can set VUE_ENV\\nvar _isServer;\\nvar isServerRendering = function () {\\n  if (_isServer === undefined) {\\n    /* istanbul ignore if */\\n    if (!inBrowser && typeof global !== 'undefined') {\\n      // detect presence of vue-server-renderer and avoid\\n      // Webpack shimming the process\\n      _isServer = global['process'].env.VUE_ENV === 'server';\\n    } else {\\n      _isServer = false;\\n    }\\n  }\\n  return _isServer\\n};\\n\\n// detect devtools\\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\\n\\n/* istanbul ignore next */\\nfunction isNative (Ctor) {\\n  return /native code/.test(Ctor.toString())\\n}\\n\\nvar hasSymbol =\\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\\n\\n/**\\n * Defer a task to execute it asynchronously.\\n */\\nvar nextTick = (function () {\\n  var callbacks = [];\\n  var pending = false;\\n  var timerFunc;\\n\\n  function nextTickHandler () {\\n    pending = false;\\n    var copies = callbacks.slice(0);\\n    callbacks.length = 0;\\n    for (var i = 0; i < copies.length; i++) {\\n      copies[i]();\\n    }\\n  }\\n\\n  // the nextTick behavior leverages the microtask queue, which can be accessed\\n  // via either native Promise.then or MutationObserver.\\n  // MutationObserver has wider support, however it is seriously bugged in\\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\\n  // completely stops working after triggering a few times... so, if native\\n  // Promise is available, we will use it:\\n  /* istanbul ignore if */\\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\\n    var p = Promise.resolve();\\n    var logError = function (err) { console.error(err); };\\n    timerFunc = function () {\\n      p.then(nextTickHandler).catch(logError);\\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\\n      // it can get stuck in a weird state where callbacks are pushed into the\\n      // microtask queue but the queue isn't being flushed, until the browser\\n      // needs to do some other work, e.g. handle a timer. Therefore we can\\n      // \\\"force\\\" the microtask queue to be flushed by adding an empty timer.\\n      if (isIOS) { setTimeout(noop); }\\n    };\\n  } else if (typeof MutationObserver !== 'undefined' && (\\n    isNative(MutationObserver) ||\\n    // PhantomJS and iOS 7.x\\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\\n  )) {\\n    // use MutationObserver where native Promise is not available,\\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\\n    var counter = 1;\\n    var observer = new MutationObserver(nextTickHandler);\\n    var textNode = document.createTextNode(String(counter));\\n    observer.observe(textNode, {\\n      characterData: true\\n    });\\n    timerFunc = function () {\\n      counter = (counter + 1) % 2;\\n      textNode.data = String(counter);\\n    };\\n  } else {\\n    // fallback to setTimeout\\n    /* istanbul ignore next */\\n    timerFunc = function () {\\n      setTimeout(nextTickHandler, 0);\\n    };\\n  }\\n\\n  return function queueNextTick (cb, ctx) {\\n    var _resolve;\\n    callbacks.push(function () {\\n      if (cb) { cb.call(ctx); }\\n      if (_resolve) { _resolve(ctx); }\\n    });\\n    if (!pending) {\\n      pending = true;\\n      timerFunc();\\n    }\\n    if (!cb && typeof Promise !== 'undefined') {\\n      return new Promise(function (resolve) {\\n        _resolve = resolve;\\n      })\\n    }\\n  }\\n})();\\n\\nvar _Set;\\n/* istanbul ignore if */\\nif (typeof Set !== 'undefined' && isNative(Set)) {\\n  // use native Set when available.\\n  _Set = Set;\\n} else {\\n  // a non-standard Set polyfill that only works with primitive keys.\\n  _Set = (function () {\\n    function Set () {\\n      this.set = Object.create(null);\\n    }\\n    Set.prototype.has = function has (key) {\\n      return this.set[key] === true\\n    };\\n    Set.prototype.add = function add (key) {\\n      this.set[key] = true;\\n    };\\n    Set.prototype.clear = function clear () {\\n      this.set = Object.create(null);\\n    };\\n\\n    return Set;\\n  }());\\n}\\n\\nvar warn = noop;\\nvar tip = noop;\\nvar formatComponentName;\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  var hasConsole = typeof console !== 'undefined';\\n  var classifyRE = /(?:^|[-_])(\\\\w)/g;\\n  var classify = function (str) { return str\\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\\n    .replace(/[-_]/g, ''); };\\n\\n  warn = function (msg, vm) {\\n    if (hasConsole && (!config.silent)) {\\n      console.error(\\\"[Vue warn]: \\\" + msg + \\\" \\\" + (\\n        vm ? formatLocation(formatComponentName(vm)) : ''\\n      ));\\n    }\\n  };\\n\\n  tip = function (msg, vm) {\\n    if (hasConsole && (!config.silent)) {\\n      console.warn(\\\"[Vue tip]: \\\" + msg + \\\" \\\" + (\\n        vm ? formatLocation(formatComponentName(vm)) : ''\\n      ));\\n    }\\n  };\\n\\n  formatComponentName = function (vm, includeFile) {\\n    if (vm.$root === vm) {\\n      return '<Root>'\\n    }\\n    var name = typeof vm === 'string'\\n      ? vm\\n      : typeof vm === 'function' && vm.options\\n        ? vm.options.name\\n        : vm._isVue\\n          ? vm.$options.name || vm.$options._componentTag\\n          : vm.name;\\n\\n    var file = vm._isVue && vm.$options.__file;\\n    if (!name && file) {\\n      var match = file.match(/([^/\\\\\\\\]+)\\\\.vue$/);\\n      name = match && match[1];\\n    }\\n\\n    return (\\n      (name ? (\\\"<\\\" + (classify(name)) + \\\">\\\") : \\\"<Anonymous>\\\") +\\n      (file && includeFile !== false ? (\\\" at \\\" + file) : '')\\n    )\\n  };\\n\\n  var formatLocation = function (str) {\\n    if (str === \\\"<Anonymous>\\\") {\\n      str += \\\" - use the \\\\\\\"name\\\\\\\" option for better debugging messages.\\\";\\n    }\\n    return (\\\"\\\\n(found in \\\" + str + \\\")\\\")\\n  };\\n}\\n\\n/*  */\\n\\n\\nvar uid$1 = 0;\\n\\n/**\\n * A dep is an observable that can have multiple\\n * directives subscribing to it.\\n */\\nvar Dep = function Dep () {\\n  this.id = uid$1++;\\n  this.subs = [];\\n};\\n\\nDep.prototype.addSub = function addSub (sub) {\\n  this.subs.push(sub);\\n};\\n\\nDep.prototype.removeSub = function removeSub (sub) {\\n  remove(this.subs, sub);\\n};\\n\\nDep.prototype.depend = function depend () {\\n  if (Dep.target) {\\n    Dep.target.addDep(this);\\n  }\\n};\\n\\nDep.prototype.notify = function notify () {\\n  // stabilize the subscriber list first\\n  var subs = this.subs.slice();\\n  for (var i = 0, l = subs.length; i < l; i++) {\\n    subs[i].update();\\n  }\\n};\\n\\n// the current target watcher being evaluated.\\n// this is globally unique because there could be only one\\n// watcher being evaluated at any time.\\nDep.target = null;\\nvar targetStack = [];\\n\\nfunction pushTarget (_target) {\\n  if (Dep.target) { targetStack.push(Dep.target); }\\n  Dep.target = _target;\\n}\\n\\nfunction popTarget () {\\n  Dep.target = targetStack.pop();\\n}\\n\\n/*\\n * not type checking this file because flow doesn't play well with\\n * dynamically accessing methods on Array prototype\\n */\\n\\nvar arrayProto = Array.prototype;\\nvar arrayMethods = Object.create(arrayProto);[\\n  'push',\\n  'pop',\\n  'shift',\\n  'unshift',\\n  'splice',\\n  'sort',\\n  'reverse'\\n]\\n.forEach(function (method) {\\n  // cache original method\\n  var original = arrayProto[method];\\n  def(arrayMethods, method, function mutator () {\\n    var arguments$1 = arguments;\\n\\n    // avoid leaking arguments:\\n    // http://jsperf.com/closure-with-arguments\\n    var i = arguments.length;\\n    var args = new Array(i);\\n    while (i--) {\\n      args[i] = arguments$1[i];\\n    }\\n    var result = original.apply(this, args);\\n    var ob = this.__ob__;\\n    var inserted;\\n    switch (method) {\\n      case 'push':\\n        inserted = args;\\n        break\\n      case 'unshift':\\n        inserted = args;\\n        break\\n      case 'splice':\\n        inserted = args.slice(2);\\n        break\\n    }\\n    if (inserted) { ob.observeArray(inserted); }\\n    // notify change\\n    ob.dep.notify();\\n    return result\\n  });\\n});\\n\\n/*  */\\n\\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\\n\\n/**\\n * By default, when a reactive property is set, the new value is\\n * also converted to become reactive. However when passing down props,\\n * we don't want to force conversion because the value may be a nested value\\n * under a frozen data structure. Converting it would defeat the optimization.\\n */\\nvar observerState = {\\n  shouldConvert: true,\\n  isSettingProps: false\\n};\\n\\n/**\\n * Observer class that are attached to each observed\\n * object. Once attached, the observer converts target\\n * object's property keys into getter/setters that\\n * collect dependencies and dispatches updates.\\n */\\nvar Observer = function Observer (value) {\\n  this.value = value;\\n  this.dep = new Dep();\\n  this.vmCount = 0;\\n  def(value, '__ob__', this);\\n  if (Array.isArray(value)) {\\n    var augment = hasProto\\n      ? protoAugment\\n      : copyAugment;\\n    augment(value, arrayMethods, arrayKeys);\\n    this.observeArray(value);\\n  } else {\\n    this.walk(value);\\n  }\\n};\\n\\n/**\\n * Walk through each property and convert them into\\n * getter/setters. This method should only be called when\\n * value type is Object.\\n */\\nObserver.prototype.walk = function walk (obj) {\\n  var keys = Object.keys(obj);\\n  for (var i = 0; i < keys.length; i++) {\\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\\n  }\\n};\\n\\n/**\\n * Observe a list of Array items.\\n */\\nObserver.prototype.observeArray = function observeArray (items) {\\n  for (var i = 0, l = items.length; i < l; i++) {\\n    observe(items[i]);\\n  }\\n};\\n\\n// helpers\\n\\n/**\\n * Augment an target Object or Array by intercepting\\n * the prototype chain using __proto__\\n */\\nfunction protoAugment (target, src) {\\n  /* eslint-disable no-proto */\\n  target.__proto__ = src;\\n  /* eslint-enable no-proto */\\n}\\n\\n/**\\n * Augment an target Object or Array by defining\\n * hidden properties.\\n */\\n/* istanbul ignore next */\\nfunction copyAugment (target, src, keys) {\\n  for (var i = 0, l = keys.length; i < l; i++) {\\n    var key = keys[i];\\n    def(target, key, src[key]);\\n  }\\n}\\n\\n/**\\n * Attempt to create an observer instance for a value,\\n * returns the new observer if successfully observed,\\n * or the existing observer if the value already has one.\\n */\\nfunction observe (value, asRootData) {\\n  if (!isObject(value)) {\\n    return\\n  }\\n  var ob;\\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\\n    ob = value.__ob__;\\n  } else if (\\n    observerState.shouldConvert &&\\n    !isServerRendering() &&\\n    (Array.isArray(value) || isPlainObject(value)) &&\\n    Object.isExtensible(value) &&\\n    !value._isVue\\n  ) {\\n    ob = new Observer(value);\\n  }\\n  if (asRootData && ob) {\\n    ob.vmCount++;\\n  }\\n  return ob\\n}\\n\\n/**\\n * Define a reactive property on an Object.\\n */\\nfunction defineReactive$$1 (\\n  obj,\\n  key,\\n  val,\\n  customSetter\\n) {\\n  var dep = new Dep();\\n\\n  var property = Object.getOwnPropertyDescriptor(obj, key);\\n  if (property && property.configurable === false) {\\n    return\\n  }\\n\\n  // cater for pre-defined getter/setters\\n  var getter = property && property.get;\\n  var setter = property && property.set;\\n\\n  var childOb = observe(val);\\n  Object.defineProperty(obj, key, {\\n    enumerable: true,\\n    configurable: true,\\n    get: function reactiveGetter () {\\n      var value = getter ? getter.call(obj) : val;\\n      if (Dep.target) {\\n        dep.depend();\\n        if (childOb) {\\n          childOb.dep.depend();\\n        }\\n        if (Array.isArray(value)) {\\n          dependArray(value);\\n        }\\n      }\\n      return value\\n    },\\n    set: function reactiveSetter (newVal) {\\n      var value = getter ? getter.call(obj) : val;\\n      /* eslint-disable no-self-compare */\\n      if (newVal === value || (newVal !== newVal && value !== value)) {\\n        return\\n      }\\n      /* eslint-enable no-self-compare */\\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\\n        customSetter();\\n      }\\n      if (setter) {\\n        setter.call(obj, newVal);\\n      } else {\\n        val = newVal;\\n      }\\n      childOb = observe(newVal);\\n      dep.notify();\\n    }\\n  });\\n}\\n\\n/**\\n * Set a property on an object. Adds the new property and\\n * triggers change notification if the property doesn't\\n * already exist.\\n */\\nfunction set (target, key, val) {\\n  if (Array.isArray(target) && typeof key === 'number') {\\n    target.length = Math.max(target.length, key);\\n    target.splice(key, 1, val);\\n    return val\\n  }\\n  if (hasOwn(target, key)) {\\n    target[key] = val;\\n    return val\\n  }\\n  var ob = (target ).__ob__;\\n  if (target._isVue || (ob && ob.vmCount)) {\\n    process.env.NODE_ENV !== 'production' && warn(\\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\\n      'at runtime - declare it upfront in the data option.'\\n    );\\n    return val\\n  }\\n  if (!ob) {\\n    target[key] = val;\\n    return val\\n  }\\n  defineReactive$$1(ob.value, key, val);\\n  ob.dep.notify();\\n  return val\\n}\\n\\n/**\\n * Delete a property and trigger change if necessary.\\n */\\nfunction del (target, key) {\\n  if (Array.isArray(target) && typeof key === 'number') {\\n    target.splice(key, 1);\\n    return\\n  }\\n  var ob = (target ).__ob__;\\n  if (target._isVue || (ob && ob.vmCount)) {\\n    process.env.NODE_ENV !== 'production' && warn(\\n      'Avoid deleting properties on a Vue instance or its root $data ' +\\n      '- just set it to null.'\\n    );\\n    return\\n  }\\n  if (!hasOwn(target, key)) {\\n    return\\n  }\\n  delete target[key];\\n  if (!ob) {\\n    return\\n  }\\n  ob.dep.notify();\\n}\\n\\n/**\\n * Collect dependencies on array elements when the array is touched, since\\n * we cannot intercept array element access like property getters.\\n */\\nfunction dependArray (value) {\\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\\n    e = value[i];\\n    e && e.__ob__ && e.__ob__.dep.depend();\\n    if (Array.isArray(e)) {\\n      dependArray(e);\\n    }\\n  }\\n}\\n\\n/*  */\\n\\n/**\\n * Option overwriting strategies are functions that handle\\n * how to merge a parent option value and a child option\\n * value into the final value.\\n */\\nvar strats = config.optionMergeStrategies;\\n\\n/**\\n * Options with restrictions\\n */\\nif (process.env.NODE_ENV !== 'production') {\\n  strats.el = strats.propsData = function (parent, child, vm, key) {\\n    if (!vm) {\\n      warn(\\n        \\\"option \\\\\\\"\\\" + key + \\\"\\\\\\\" can only be used during instance \\\" +\\n        'creation with the `new` keyword.'\\n      );\\n    }\\n    return defaultStrat(parent, child)\\n  };\\n}\\n\\n/**\\n * Helper that recursively merges two data objects together.\\n */\\nfunction mergeData (to, from) {\\n  if (!from) { return to }\\n  var key, toVal, fromVal;\\n  var keys = Object.keys(from);\\n  for (var i = 0; i < keys.length; i++) {\\n    key = keys[i];\\n    toVal = to[key];\\n    fromVal = from[key];\\n    if (!hasOwn(to, key)) {\\n      set(to, key, fromVal);\\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\\n      mergeData(toVal, fromVal);\\n    }\\n  }\\n  return to\\n}\\n\\n/**\\n * Data\\n */\\nstrats.data = function (\\n  parentVal,\\n  childVal,\\n  vm\\n) {\\n  if (!vm) {\\n    // in a Vue.extend merge, both should be functions\\n    if (!childVal) {\\n      return parentVal\\n    }\\n    if (typeof childVal !== 'function') {\\n      process.env.NODE_ENV !== 'production' && warn(\\n        'The \\\"data\\\" option should be a function ' +\\n        'that returns a per-instance value in component ' +\\n        'definitions.',\\n        vm\\n      );\\n      return parentVal\\n    }\\n    if (!parentVal) {\\n      return childVal\\n    }\\n    // when parentVal & childVal are both present,\\n    // we need to return a function that returns the\\n    // merged result of both functions... no need to\\n    // check if parentVal is a function here because\\n    // it has to be a function to pass previous merges.\\n    return function mergedDataFn () {\\n      return mergeData(\\n        childVal.call(this),\\n        parentVal.call(this)\\n      )\\n    }\\n  } else if (parentVal || childVal) {\\n    return function mergedInstanceDataFn () {\\n      // instance merge\\n      var instanceData = typeof childVal === 'function'\\n        ? childVal.call(vm)\\n        : childVal;\\n      var defaultData = typeof parentVal === 'function'\\n        ? parentVal.call(vm)\\n        : undefined;\\n      if (instanceData) {\\n        return mergeData(instanceData, defaultData)\\n      } else {\\n        return defaultData\\n      }\\n    }\\n  }\\n};\\n\\n/**\\n * Hooks and props are merged as arrays.\\n */\\nfunction mergeHook (\\n  parentVal,\\n  childVal\\n) {\\n  return childVal\\n    ? parentVal\\n      ? parentVal.concat(childVal)\\n      : Array.isArray(childVal)\\n        ? childVal\\n        : [childVal]\\n    : parentVal\\n}\\n\\nconfig._lifecycleHooks.forEach(function (hook) {\\n  strats[hook] = mergeHook;\\n});\\n\\n/**\\n * Assets\\n *\\n * When a vm is present (instance creation), we need to do\\n * a three-way merge between constructor options, instance\\n * options and parent options.\\n */\\nfunction mergeAssets (parentVal, childVal) {\\n  var res = Object.create(parentVal || null);\\n  return childVal\\n    ? extend(res, childVal)\\n    : res\\n}\\n\\nconfig._assetTypes.forEach(function (type) {\\n  strats[type + 's'] = mergeAssets;\\n});\\n\\n/**\\n * Watchers.\\n *\\n * Watchers hashes should not overwrite one\\n * another, so we merge them as arrays.\\n */\\nstrats.watch = function (parentVal, childVal) {\\n  /* istanbul ignore if */\\n  if (!childVal) { return Object.create(parentVal || null) }\\n  if (!parentVal) { return childVal }\\n  var ret = {};\\n  extend(ret, parentVal);\\n  for (var key in childVal) {\\n    var parent = ret[key];\\n    var child = childVal[key];\\n    if (parent && !Array.isArray(parent)) {\\n      parent = [parent];\\n    }\\n    ret[key] = parent\\n      ? parent.concat(child)\\n      : [child];\\n  }\\n  return ret\\n};\\n\\n/**\\n * Other object hashes.\\n */\\nstrats.props =\\nstrats.methods =\\nstrats.computed = function (parentVal, childVal) {\\n  if (!childVal) { return Object.create(parentVal || null) }\\n  if (!parentVal) { return childVal }\\n  var ret = Object.create(null);\\n  extend(ret, parentVal);\\n  extend(ret, childVal);\\n  return ret\\n};\\n\\n/**\\n * Default strategy.\\n */\\nvar defaultStrat = function (parentVal, childVal) {\\n  return childVal === undefined\\n    ? parentVal\\n    : childVal\\n};\\n\\n/**\\n * Validate component names\\n */\\nfunction checkComponents (options) {\\n  for (var key in options.components) {\\n    var lower = key.toLowerCase();\\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\\n      warn(\\n        'Do not use built-in or reserved HTML elements as component ' +\\n        'id: ' + key\\n      );\\n    }\\n  }\\n}\\n\\n/**\\n * Ensure all props option syntax are normalized into the\\n * Object-based format.\\n */\\nfunction normalizeProps (options) {\\n  var props = options.props;\\n  if (!props) { return }\\n  var res = {};\\n  var i, val, name;\\n  if (Array.isArray(props)) {\\n    i = props.length;\\n    while (i--) {\\n      val = props[i];\\n      if (typeof val === 'string') {\\n        name = camelize(val);\\n        res[name] = { type: null };\\n      } else if (process.env.NODE_ENV !== 'production') {\\n        warn('props must be strings when using array syntax.');\\n      }\\n    }\\n  } else if (isPlainObject(props)) {\\n    for (var key in props) {\\n      val = props[key];\\n      name = camelize(key);\\n      res[name] = isPlainObject(val)\\n        ? val\\n        : { type: val };\\n    }\\n  }\\n  options.props = res;\\n}\\n\\n/**\\n * Normalize raw function directives into object format.\\n */\\nfunction normalizeDirectives (options) {\\n  var dirs = options.directives;\\n  if (dirs) {\\n    for (var key in dirs) {\\n      var def = dirs[key];\\n      if (typeof def === 'function') {\\n        dirs[key] = { bind: def, update: def };\\n      }\\n    }\\n  }\\n}\\n\\n/**\\n * Merge two option objects into a new one.\\n * Core utility used in both instantiation and inheritance.\\n */\\nfunction mergeOptions (\\n  parent,\\n  child,\\n  vm\\n) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    checkComponents(child);\\n  }\\n  normalizeProps(child);\\n  normalizeDirectives(child);\\n  var extendsFrom = child.extends;\\n  if (extendsFrom) {\\n    parent = typeof extendsFrom === 'function'\\n      ? mergeOptions(parent, extendsFrom.options, vm)\\n      : mergeOptions(parent, extendsFrom, vm);\\n  }\\n  if (child.mixins) {\\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\\n      var mixin = child.mixins[i];\\n      if (mixin.prototype instanceof Vue$2) {\\n        mixin = mixin.options;\\n      }\\n      parent = mergeOptions(parent, mixin, vm);\\n    }\\n  }\\n  var options = {};\\n  var key;\\n  for (key in parent) {\\n    mergeField(key);\\n  }\\n  for (key in child) {\\n    if (!hasOwn(parent, key)) {\\n      mergeField(key);\\n    }\\n  }\\n  function mergeField (key) {\\n    var strat = strats[key] || defaultStrat;\\n    options[key] = strat(parent[key], child[key], vm, key);\\n  }\\n  return options\\n}\\n\\n/**\\n * Resolve an asset.\\n * This function is used because child instances need access\\n * to assets defined in its ancestor chain.\\n */\\nfunction resolveAsset (\\n  options,\\n  type,\\n  id,\\n  warnMissing\\n) {\\n  /* istanbul ignore if */\\n  if (typeof id !== 'string') {\\n    return\\n  }\\n  var assets = options[type];\\n  // check local registration variations first\\n  if (hasOwn(assets, id)) { return assets[id] }\\n  var camelizedId = camelize(id);\\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\\n  var PascalCaseId = capitalize(camelizedId);\\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\\n  // fallback to prototype chain\\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\\n    warn(\\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\\n      options\\n    );\\n  }\\n  return res\\n}\\n\\n/*  */\\n\\nfunction validateProp (\\n  key,\\n  propOptions,\\n  propsData,\\n  vm\\n) {\\n  var prop = propOptions[key];\\n  var absent = !hasOwn(propsData, key);\\n  var value = propsData[key];\\n  // handle boolean props\\n  if (isType(Boolean, prop.type)) {\\n    if (absent && !hasOwn(prop, 'default')) {\\n      value = false;\\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\\n      value = true;\\n    }\\n  }\\n  // check default value\\n  if (value === undefined) {\\n    value = getPropDefaultValue(vm, prop, key);\\n    // since the default value is a fresh copy,\\n    // make sure to observe it.\\n    var prevShouldConvert = observerState.shouldConvert;\\n    observerState.shouldConvert = true;\\n    observe(value);\\n    observerState.shouldConvert = prevShouldConvert;\\n  }\\n  if (process.env.NODE_ENV !== 'production') {\\n    assertProp(prop, key, value, vm, absent);\\n  }\\n  return value\\n}\\n\\n/**\\n * Get the default value of a prop.\\n */\\nfunction getPropDefaultValue (vm, prop, key) {\\n  // no default, return undefined\\n  if (!hasOwn(prop, 'default')) {\\n    return undefined\\n  }\\n  var def = prop.default;\\n  // warn against non-factory defaults for Object & Array\\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\\n    warn(\\n      'Invalid default value for prop \\\"' + key + '\\\": ' +\\n      'Props with type Object/Array must use a factory function ' +\\n      'to return the default value.',\\n      vm\\n    );\\n  }\\n  // the raw prop value was also undefined from previous render,\\n  // return previous default value to avoid unnecessary watcher trigger\\n  if (vm && vm.$options.propsData &&\\n    vm.$options.propsData[key] === undefined &&\\n    vm._props[key] !== undefined) {\\n    return vm._props[key]\\n  }\\n  // call factory function for non-Function types\\n  // a value is Function if its prototype is function even across different execution context\\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\\n    ? def.call(vm)\\n    : def\\n}\\n\\n/**\\n * Assert whether a prop is valid.\\n */\\nfunction assertProp (\\n  prop,\\n  name,\\n  value,\\n  vm,\\n  absent\\n) {\\n  if (prop.required && absent) {\\n    warn(\\n      'Missing required prop: \\\"' + name + '\\\"',\\n      vm\\n    );\\n    return\\n  }\\n  if (value == null && !prop.required) {\\n    return\\n  }\\n  var type = prop.type;\\n  var valid = !type || type === true;\\n  var expectedTypes = [];\\n  if (type) {\\n    if (!Array.isArray(type)) {\\n      type = [type];\\n    }\\n    for (var i = 0; i < type.length && !valid; i++) {\\n      var assertedType = assertType(value, type[i]);\\n      expectedTypes.push(assertedType.expectedType || '');\\n      valid = assertedType.valid;\\n    }\\n  }\\n  if (!valid) {\\n    warn(\\n      'Invalid prop: type check failed for prop \\\"' + name + '\\\".' +\\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\\n      vm\\n    );\\n    return\\n  }\\n  var validator = prop.validator;\\n  if (validator) {\\n    if (!validator(value)) {\\n      warn(\\n        'Invalid prop: custom validator check failed for prop \\\"' + name + '\\\".',\\n        vm\\n      );\\n    }\\n  }\\n}\\n\\n/**\\n * Assert the type of a value\\n */\\nfunction assertType (value, type) {\\n  var valid;\\n  var expectedType = getType(type);\\n  if (expectedType === 'String') {\\n    valid = typeof value === (expectedType = 'string');\\n  } else if (expectedType === 'Number') {\\n    valid = typeof value === (expectedType = 'number');\\n  } else if (expectedType === 'Boolean') {\\n    valid = typeof value === (expectedType = 'boolean');\\n  } else if (expectedType === 'Function') {\\n    valid = typeof value === (expectedType = 'function');\\n  } else if (expectedType === 'Object') {\\n    valid = isPlainObject(value);\\n  } else if (expectedType === 'Array') {\\n    valid = Array.isArray(value);\\n  } else {\\n    valid = value instanceof type;\\n  }\\n  return {\\n    valid: valid,\\n    expectedType: expectedType\\n  }\\n}\\n\\n/**\\n * Use function string name to check built-in types,\\n * because a simple equality check will fail when running\\n * across different vms / iframes.\\n */\\nfunction getType (fn) {\\n  var match = fn && fn.toString().match(/^\\\\s*function (\\\\w+)/);\\n  return match && match[1]\\n}\\n\\nfunction isType (type, fn) {\\n  if (!Array.isArray(fn)) {\\n    return getType(fn) === getType(type)\\n  }\\n  for (var i = 0, len = fn.length; i < len; i++) {\\n    if (getType(fn[i]) === getType(type)) {\\n      return true\\n    }\\n  }\\n  /* istanbul ignore next */\\n  return false\\n}\\n\\nfunction handleError (err, vm, info) {\\n  if (config.errorHandler) {\\n    config.errorHandler.call(null, err, vm, info);\\n  } else {\\n    if (process.env.NODE_ENV !== 'production') {\\n      warn((\\\"Error in \\\" + info + \\\":\\\"), vm);\\n    }\\n    /* istanbul ignore else */\\n    if (inBrowser && typeof console !== 'undefined') {\\n      console.error(err);\\n    } else {\\n      throw err\\n    }\\n  }\\n}\\n\\n/* not type checking this file because flow doesn't play well with Proxy */\\n\\nvar initProxy;\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  var allowedGlobals = makeMap(\\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\\n    'require' // for Webpack/Browserify\\n  );\\n\\n  var warnNonPresent = function (target, key) {\\n    warn(\\n      \\\"Property or method \\\\\\\"\\\" + key + \\\"\\\\\\\" is not defined on the instance but \\\" +\\n      \\\"referenced during render. Make sure to declare reactive data \\\" +\\n      \\\"properties in the data option.\\\",\\n      target\\n    );\\n  };\\n\\n  var hasProxy =\\n    typeof Proxy !== 'undefined' &&\\n    Proxy.toString().match(/native code/);\\n\\n  if (hasProxy) {\\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\\n    config.keyCodes = new Proxy(config.keyCodes, {\\n      set: function set (target, key, value) {\\n        if (isBuiltInModifier(key)) {\\n          warn((\\\"Avoid overwriting built-in modifier in config.keyCodes: .\\\" + key));\\n          return false\\n        } else {\\n          target[key] = value;\\n          return true\\n        }\\n      }\\n    });\\n  }\\n\\n  var hasHandler = {\\n    has: function has (target, key) {\\n      var has = key in target;\\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\\n      if (!has && !isAllowed) {\\n        warnNonPresent(target, key);\\n      }\\n      return has || !isAllowed\\n    }\\n  };\\n\\n  var getHandler = {\\n    get: function get (target, key) {\\n      if (typeof key === 'string' && !(key in target)) {\\n        warnNonPresent(target, key);\\n      }\\n      return target[key]\\n    }\\n  };\\n\\n  initProxy = function initProxy (vm) {\\n    if (hasProxy) {\\n      // determine which proxy handler to use\\n      var options = vm.$options;\\n      var handlers = options.render && options.render._withStripped\\n        ? getHandler\\n        : hasHandler;\\n      vm._renderProxy = new Proxy(vm, handlers);\\n    } else {\\n      vm._renderProxy = vm;\\n    }\\n  };\\n}\\n\\nvar mark;\\nvar measure;\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  var perf = inBrowser && window.performance;\\n  /* istanbul ignore if */\\n  if (\\n    perf &&\\n    perf.mark &&\\n    perf.measure &&\\n    perf.clearMarks &&\\n    perf.clearMeasures\\n  ) {\\n    mark = function (tag) { return perf.mark(tag); };\\n    measure = function (name, startTag, endTag) {\\n      perf.measure(name, startTag, endTag);\\n      perf.clearMarks(startTag);\\n      perf.clearMarks(endTag);\\n      perf.clearMeasures(name);\\n    };\\n  }\\n}\\n\\n/*  */\\n\\nvar VNode = function VNode (\\n  tag,\\n  data,\\n  children,\\n  text,\\n  elm,\\n  context,\\n  componentOptions\\n) {\\n  this.tag = tag;\\n  this.data = data;\\n  this.children = children;\\n  this.text = text;\\n  this.elm = elm;\\n  this.ns = undefined;\\n  this.context = context;\\n  this.functionalContext = undefined;\\n  this.key = data && data.key;\\n  this.componentOptions = componentOptions;\\n  this.componentInstance = undefined;\\n  this.parent = undefined;\\n  this.raw = false;\\n  this.isStatic = false;\\n  this.isRootInsert = true;\\n  this.isComment = false;\\n  this.isCloned = false;\\n  this.isOnce = false;\\n};\\n\\nvar prototypeAccessors = { child: {} };\\n\\n// DEPRECATED: alias for componentInstance for backwards compat.\\n/* istanbul ignore next */\\nprototypeAccessors.child.get = function () {\\n  return this.componentInstance\\n};\\n\\nObject.defineProperties( VNode.prototype, prototypeAccessors );\\n\\nvar createEmptyVNode = function () {\\n  var node = new VNode();\\n  node.text = '';\\n  node.isComment = true;\\n  return node\\n};\\n\\nfunction createTextVNode (val) {\\n  return new VNode(undefined, undefined, undefined, String(val))\\n}\\n\\n// optimized shallow clone\\n// used for static nodes and slot nodes because they may be reused across\\n// multiple renders, cloning them avoids errors when DOM manipulations rely\\n// on their elm reference.\\nfunction cloneVNode (vnode) {\\n  var cloned = new VNode(\\n    vnode.tag,\\n    vnode.data,\\n    vnode.children,\\n    vnode.text,\\n    vnode.elm,\\n    vnode.context,\\n    vnode.componentOptions\\n  );\\n  cloned.ns = vnode.ns;\\n  cloned.isStatic = vnode.isStatic;\\n  cloned.key = vnode.key;\\n  cloned.isCloned = true;\\n  return cloned\\n}\\n\\nfunction cloneVNodes (vnodes) {\\n  var len = vnodes.length;\\n  var res = new Array(len);\\n  for (var i = 0; i < len; i++) {\\n    res[i] = cloneVNode(vnodes[i]);\\n  }\\n  return res\\n}\\n\\n/*  */\\n\\nvar normalizeEvent = cached(function (name) {\\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\\n  name = once$$1 ? name.slice(1) : name;\\n  var capture = name.charAt(0) === '!';\\n  name = capture ? name.slice(1) : name;\\n  return {\\n    name: name,\\n    once: once$$1,\\n    capture: capture\\n  }\\n});\\n\\nfunction createFnInvoker (fns) {\\n  function invoker () {\\n    var arguments$1 = arguments;\\n\\n    var fns = invoker.fns;\\n    if (Array.isArray(fns)) {\\n      for (var i = 0; i < fns.length; i++) {\\n        fns[i].apply(null, arguments$1);\\n      }\\n    } else {\\n      // return handler return value for single handlers\\n      return fns.apply(null, arguments)\\n    }\\n  }\\n  invoker.fns = fns;\\n  return invoker\\n}\\n\\nfunction updateListeners (\\n  on,\\n  oldOn,\\n  add,\\n  remove$$1,\\n  vm\\n) {\\n  var name, cur, old, event;\\n  for (name in on) {\\n    cur = on[name];\\n    old = oldOn[name];\\n    event = normalizeEvent(name);\\n    if (!cur) {\\n      process.env.NODE_ENV !== 'production' && warn(\\n        \\\"Invalid handler for event \\\\\\\"\\\" + (event.name) + \\\"\\\\\\\": got \\\" + String(cur),\\n        vm\\n      );\\n    } else if (!old) {\\n      if (!cur.fns) {\\n        cur = on[name] = createFnInvoker(cur);\\n      }\\n      add(event.name, cur, event.once, event.capture);\\n    } else if (cur !== old) {\\n      old.fns = cur;\\n      on[name] = old;\\n    }\\n  }\\n  for (name in oldOn) {\\n    if (!on[name]) {\\n      event = normalizeEvent(name);\\n      remove$$1(event.name, oldOn[name], event.capture);\\n    }\\n  }\\n}\\n\\n/*  */\\n\\nfunction mergeVNodeHook (def, hookKey, hook) {\\n  var invoker;\\n  var oldHook = def[hookKey];\\n\\n  function wrappedHook () {\\n    hook.apply(this, arguments);\\n    // important: remove merged hook to ensure it's called only once\\n    // and prevent memory leak\\n    remove(invoker.fns, wrappedHook);\\n  }\\n\\n  if (!oldHook) {\\n    // no existing hook\\n    invoker = createFnInvoker([wrappedHook]);\\n  } else {\\n    /* istanbul ignore if */\\n    if (oldHook.fns && oldHook.merged) {\\n      // already a merged invoker\\n      invoker = oldHook;\\n      invoker.fns.push(wrappedHook);\\n    } else {\\n      // existing plain hook\\n      invoker = createFnInvoker([oldHook, wrappedHook]);\\n    }\\n  }\\n\\n  invoker.merged = true;\\n  def[hookKey] = invoker;\\n}\\n\\n/*  */\\n\\n// The template compiler attempts to minimize the need for normalization by\\n// statically analyzing the template at compile time.\\n//\\n// For plain HTML markup, normalization can be completely skipped because the\\n// generated render function is guaranteed to return Array<VNode>. There are\\n// two cases where extra normalization is needed:\\n\\n// 1. When the children contains components - because a functional component\\n// may return an Array instead of a single root. In this case, just a simple\\n// normalization is needed - if any child is an Array, we flatten the whole\\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\\n// because functional components already normalize their own children.\\nfunction simpleNormalizeChildren (children) {\\n  for (var i = 0; i < children.length; i++) {\\n    if (Array.isArray(children[i])) {\\n      return Array.prototype.concat.apply([], children)\\n    }\\n  }\\n  return children\\n}\\n\\n// 2. When the children contains constructs that always generated nested Arrays,\\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\\n// with hand-written render functions / JSX. In such cases a full normalization\\n// is needed to cater to all possible types of children values.\\nfunction normalizeChildren (children) {\\n  return isPrimitive(children)\\n    ? [createTextVNode(children)]\\n    : Array.isArray(children)\\n      ? normalizeArrayChildren(children)\\n      : undefined\\n}\\n\\nfunction normalizeArrayChildren (children, nestedIndex) {\\n  var res = [];\\n  var i, c, last;\\n  for (i = 0; i < children.length; i++) {\\n    c = children[i];\\n    if (c == null || typeof c === 'boolean') { continue }\\n    last = res[res.length - 1];\\n    //  nested\\n    if (Array.isArray(c)) {\\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \\\"_\\\" + i)));\\n    } else if (isPrimitive(c)) {\\n      if (last && last.text) {\\n        last.text += String(c);\\n      } else if (c !== '') {\\n        // convert primitive to vnode\\n        res.push(createTextVNode(c));\\n      }\\n    } else {\\n      if (c.text && last && last.text) {\\n        res[res.length - 1] = createTextVNode(last.text + c.text);\\n      } else {\\n        // default key for nested array children (likely generated by v-for)\\n        if (c.tag && c.key == null && nestedIndex != null) {\\n          c.key = \\\"__vlist\\\" + nestedIndex + \\\"_\\\" + i + \\\"__\\\";\\n        }\\n        res.push(c);\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\n/*  */\\n\\nfunction getFirstComponentChild (children) {\\n  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\\n}\\n\\n/*  */\\n\\nfunction initEvents (vm) {\\n  vm._events = Object.create(null);\\n  vm._hasHookEvent = false;\\n  // init parent attached events\\n  var listeners = vm.$options._parentListeners;\\n  if (listeners) {\\n    updateComponentListeners(vm, listeners);\\n  }\\n}\\n\\nvar target;\\n\\nfunction add (event, fn, once$$1) {\\n  if (once$$1) {\\n    target.$once(event, fn);\\n  } else {\\n    target.$on(event, fn);\\n  }\\n}\\n\\nfunction remove$1 (event, fn) {\\n  target.$off(event, fn);\\n}\\n\\nfunction updateComponentListeners (\\n  vm,\\n  listeners,\\n  oldListeners\\n) {\\n  target = vm;\\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\\n}\\n\\nfunction eventsMixin (Vue) {\\n  var hookRE = /^hook:/;\\n  Vue.prototype.$on = function (event, fn) {\\n    var this$1 = this;\\n\\n    var vm = this;\\n    if (Array.isArray(event)) {\\n      for (var i = 0, l = event.length; i < l; i++) {\\n        this$1.$on(event[i], fn);\\n      }\\n    } else {\\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\\n      // optimize hook:event cost by using a boolean flag marked at registration\\n      // instead of a hash lookup\\n      if (hookRE.test(event)) {\\n        vm._hasHookEvent = true;\\n      }\\n    }\\n    return vm\\n  };\\n\\n  Vue.prototype.$once = function (event, fn) {\\n    var vm = this;\\n    function on () {\\n      vm.$off(event, on);\\n      fn.apply(vm, arguments);\\n    }\\n    on.fn = fn;\\n    vm.$on(event, on);\\n    return vm\\n  };\\n\\n  Vue.prototype.$off = function (event, fn) {\\n    var this$1 = this;\\n\\n    var vm = this;\\n    // all\\n    if (!arguments.length) {\\n      vm._events = Object.create(null);\\n      return vm\\n    }\\n    // array of events\\n    if (Array.isArray(event)) {\\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\\n        this$1.$off(event[i$1], fn);\\n      }\\n      return vm\\n    }\\n    // specific event\\n    var cbs = vm._events[event];\\n    if (!cbs) {\\n      return vm\\n    }\\n    if (arguments.length === 1) {\\n      vm._events[event] = null;\\n      return vm\\n    }\\n    // specific handler\\n    var cb;\\n    var i = cbs.length;\\n    while (i--) {\\n      cb = cbs[i];\\n      if (cb === fn || cb.fn === fn) {\\n        cbs.splice(i, 1);\\n        break\\n      }\\n    }\\n    return vm\\n  };\\n\\n  Vue.prototype.$emit = function (event) {\\n    var vm = this;\\n    if (process.env.NODE_ENV !== 'production') {\\n      var lowerCaseEvent = event.toLowerCase();\\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\\n        tip(\\n          \\\"Event \\\\\\\"\\\" + lowerCaseEvent + \\\"\\\\\\\" is emitted in component \\\" +\\n          (formatComponentName(vm)) + \\\" but the handler is registered for \\\\\\\"\\\" + event + \\\"\\\\\\\". \\\" +\\n          \\\"Note that HTML attributes are case-insensitive and you cannot use \\\" +\\n          \\\"v-on to listen to camelCase events when using in-DOM templates. \\\" +\\n          \\\"You should probably use \\\\\\\"\\\" + (hyphenate(event)) + \\\"\\\\\\\" instead of \\\\\\\"\\\" + event + \\\"\\\\\\\".\\\"\\n        );\\n      }\\n    }\\n    var cbs = vm._events[event];\\n    if (cbs) {\\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\\n      var args = toArray(arguments, 1);\\n      for (var i = 0, l = cbs.length; i < l; i++) {\\n        cbs[i].apply(vm, args);\\n      }\\n    }\\n    return vm\\n  };\\n}\\n\\n/*  */\\n\\n/**\\n * Runtime helper for resolving raw children VNodes into a slot object.\\n */\\nfunction resolveSlots (\\n  children,\\n  context\\n) {\\n  var slots = {};\\n  if (!children) {\\n    return slots\\n  }\\n  var defaultSlot = [];\\n  var name, child;\\n  for (var i = 0, l = children.length; i < l; i++) {\\n    child = children[i];\\n    // named slots should only be respected if the vnode was rendered in the\\n    // same context.\\n    if ((child.context === context || child.functionalContext === context) &&\\n        child.data && (name = child.data.slot)) {\\n      var slot = (slots[name] || (slots[name] = []));\\n      if (child.tag === 'template') {\\n        slot.push.apply(slot, child.children);\\n      } else {\\n        slot.push(child);\\n      }\\n    } else {\\n      defaultSlot.push(child);\\n    }\\n  }\\n  // ignore whitespace\\n  if (!defaultSlot.every(isWhitespace)) {\\n    slots.default = defaultSlot;\\n  }\\n  return slots\\n}\\n\\nfunction isWhitespace (node) {\\n  return node.isComment || node.text === ' '\\n}\\n\\nfunction resolveScopedSlots (\\n  fns\\n) {\\n  var res = {};\\n  for (var i = 0; i < fns.length; i++) {\\n    res[fns[i][0]] = fns[i][1];\\n  }\\n  return res\\n}\\n\\n/*  */\\n\\nvar activeInstance = null;\\n\\nfunction initLifecycle (vm) {\\n  var options = vm.$options;\\n\\n  // locate first non-abstract parent\\n  var parent = options.parent;\\n  if (parent && !options.abstract) {\\n    while (parent.$options.abstract && parent.$parent) {\\n      parent = parent.$parent;\\n    }\\n    parent.$children.push(vm);\\n  }\\n\\n  vm.$parent = parent;\\n  vm.$root = parent ? parent.$root : vm;\\n\\n  vm.$children = [];\\n  vm.$refs = {};\\n\\n  vm._watcher = null;\\n  vm._inactive = null;\\n  vm._directInactive = false;\\n  vm._isMounted = false;\\n  vm._isDestroyed = false;\\n  vm._isBeingDestroyed = false;\\n}\\n\\nfunction lifecycleMixin (Vue) {\\n  Vue.prototype._update = function (vnode, hydrating) {\\n    var vm = this;\\n    if (vm._isMounted) {\\n      callHook(vm, 'beforeUpdate');\\n    }\\n    var prevEl = vm.$el;\\n    var prevVnode = vm._vnode;\\n    var prevActiveInstance = activeInstance;\\n    activeInstance = vm;\\n    vm._vnode = vnode;\\n    // Vue.prototype.__patch__ is injected in entry points\\n    // based on the rendering backend used.\\n    if (!prevVnode) {\\n      // initial render\\n      vm.$el = vm.__patch__(\\n        vm.$el, vnode, hydrating, false /* removeOnly */,\\n        vm.$options._parentElm,\\n        vm.$options._refElm\\n      );\\n    } else {\\n      // updates\\n      vm.$el = vm.__patch__(prevVnode, vnode);\\n    }\\n    activeInstance = prevActiveInstance;\\n    // update __vue__ reference\\n    if (prevEl) {\\n      prevEl.__vue__ = null;\\n    }\\n    if (vm.$el) {\\n      vm.$el.__vue__ = vm;\\n    }\\n    // if parent is an HOC, update its $el as well\\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\\n      vm.$parent.$el = vm.$el;\\n    }\\n    // updated hook is called by the scheduler to ensure that children are\\n    // updated in a parent's updated hook.\\n  };\\n\\n  Vue.prototype.$forceUpdate = function () {\\n    var vm = this;\\n    if (vm._watcher) {\\n      vm._watcher.update();\\n    }\\n  };\\n\\n  Vue.prototype.$destroy = function () {\\n    var vm = this;\\n    if (vm._isBeingDestroyed) {\\n      return\\n    }\\n    callHook(vm, 'beforeDestroy');\\n    vm._isBeingDestroyed = true;\\n    // remove self from parent\\n    var parent = vm.$parent;\\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\\n      remove(parent.$children, vm);\\n    }\\n    // teardown watchers\\n    if (vm._watcher) {\\n      vm._watcher.teardown();\\n    }\\n    var i = vm._watchers.length;\\n    while (i--) {\\n      vm._watchers[i].teardown();\\n    }\\n    // remove reference from data ob\\n    // frozen object may not have observer.\\n    if (vm._data.__ob__) {\\n      vm._data.__ob__.vmCount--;\\n    }\\n    // call the last hook...\\n    vm._isDestroyed = true;\\n    // invoke destroy hooks on current rendered tree\\n    vm.__patch__(vm._vnode, null);\\n    // fire destroyed hook\\n    callHook(vm, 'destroyed');\\n    // turn off all instance listeners.\\n    vm.$off();\\n    // remove __vue__ reference\\n    if (vm.$el) {\\n      vm.$el.__vue__ = null;\\n    }\\n    // remove reference to DOM nodes (prevents leak)\\n    vm.$options._parentElm = vm.$options._refElm = null;\\n  };\\n}\\n\\nfunction mountComponent (\\n  vm,\\n  el,\\n  hydrating\\n) {\\n  vm.$el = el;\\n  if (!vm.$options.render) {\\n    vm.$options.render = createEmptyVNode;\\n    if (process.env.NODE_ENV !== 'production') {\\n      /* istanbul ignore if */\\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\\n        vm.$options.el || el) {\\n        warn(\\n          'You are using the runtime-only build of Vue where the template ' +\\n          'compiler is not available. Either pre-compile the templates into ' +\\n          'render functions, or use the compiler-included build.',\\n          vm\\n        );\\n      } else {\\n        warn(\\n          'Failed to mount component: template or render function not defined.',\\n          vm\\n        );\\n      }\\n    }\\n  }\\n  callHook(vm, 'beforeMount');\\n\\n  var updateComponent;\\n  /* istanbul ignore if */\\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\\n    updateComponent = function () {\\n      var name = vm._name;\\n      var id = vm._uid;\\n      var startTag = \\\"vue-perf-start:\\\" + id;\\n      var endTag = \\\"vue-perf-end:\\\" + id;\\n\\n      mark(startTag);\\n      var vnode = vm._render();\\n      mark(endTag);\\n      measure((name + \\\" render\\\"), startTag, endTag);\\n\\n      mark(startTag);\\n      vm._update(vnode, hydrating);\\n      mark(endTag);\\n      measure((name + \\\" patch\\\"), startTag, endTag);\\n    };\\n  } else {\\n    updateComponent = function () {\\n      vm._update(vm._render(), hydrating);\\n    };\\n  }\\n\\n  vm._watcher = new Watcher(vm, updateComponent, noop);\\n  hydrating = false;\\n\\n  // manually mounted instance, call mounted on self\\n  // mounted is called for render-created child components in its inserted hook\\n  if (vm.$vnode == null) {\\n    vm._isMounted = true;\\n    callHook(vm, 'mounted');\\n  }\\n  return vm\\n}\\n\\nfunction updateChildComponent (\\n  vm,\\n  propsData,\\n  listeners,\\n  parentVnode,\\n  renderChildren\\n) {\\n  // determine whether component has slot children\\n  // we need to do this before overwriting $options._renderChildren\\n  var hasChildren = !!(\\n    renderChildren ||               // has new static slots\\n    vm.$options._renderChildren ||  // has old static slots\\n    parentVnode.data.scopedSlots || // has new scoped slots\\n    vm.$scopedSlots !== emptyObject // has old scoped slots\\n  );\\n\\n  vm.$options._parentVnode = parentVnode;\\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\\n  if (vm._vnode) { // update child tree's parent\\n    vm._vnode.parent = parentVnode;\\n  }\\n  vm.$options._renderChildren = renderChildren;\\n\\n  // update props\\n  if (propsData && vm.$options.props) {\\n    observerState.shouldConvert = false;\\n    if (process.env.NODE_ENV !== 'production') {\\n      observerState.isSettingProps = true;\\n    }\\n    var props = vm._props;\\n    var propKeys = vm.$options._propKeys || [];\\n    for (var i = 0; i < propKeys.length; i++) {\\n      var key = propKeys[i];\\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\\n    }\\n    observerState.shouldConvert = true;\\n    if (process.env.NODE_ENV !== 'production') {\\n      observerState.isSettingProps = false;\\n    }\\n    // keep a copy of raw propsData\\n    vm.$options.propsData = propsData;\\n  }\\n  // update listeners\\n  if (listeners) {\\n    var oldListeners = vm.$options._parentListeners;\\n    vm.$options._parentListeners = listeners;\\n    updateComponentListeners(vm, listeners, oldListeners);\\n  }\\n  // resolve slots + force update if has children\\n  if (hasChildren) {\\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\\n    vm.$forceUpdate();\\n  }\\n}\\n\\nfunction isInInactiveTree (vm) {\\n  while (vm && (vm = vm.$parent)) {\\n    if (vm._inactive) { return true }\\n  }\\n  return false\\n}\\n\\nfunction activateChildComponent (vm, direct) {\\n  if (direct) {\\n    vm._directInactive = false;\\n    if (isInInactiveTree(vm)) {\\n      return\\n    }\\n  } else if (vm._directInactive) {\\n    return\\n  }\\n  if (vm._inactive || vm._inactive == null) {\\n    vm._inactive = false;\\n    for (var i = 0; i < vm.$children.length; i++) {\\n      activateChildComponent(vm.$children[i]);\\n    }\\n    callHook(vm, 'activated');\\n  }\\n}\\n\\nfunction deactivateChildComponent (vm, direct) {\\n  if (direct) {\\n    vm._directInactive = true;\\n    if (isInInactiveTree(vm)) {\\n      return\\n    }\\n  }\\n  if (!vm._inactive) {\\n    vm._inactive = true;\\n    for (var i = 0; i < vm.$children.length; i++) {\\n      deactivateChildComponent(vm.$children[i]);\\n    }\\n    callHook(vm, 'deactivated');\\n  }\\n}\\n\\nfunction callHook (vm, hook) {\\n  var handlers = vm.$options[hook];\\n  if (handlers) {\\n    for (var i = 0, j = handlers.length; i < j; i++) {\\n      try {\\n        handlers[i].call(vm);\\n      } catch (e) {\\n        handleError(e, vm, (hook + \\\" hook\\\"));\\n      }\\n    }\\n  }\\n  if (vm._hasHookEvent) {\\n    vm.$emit('hook:' + hook);\\n  }\\n}\\n\\n/*  */\\n\\n\\nvar queue = [];\\nvar has = {};\\nvar circular = {};\\nvar waiting = false;\\nvar flushing = false;\\nvar index = 0;\\n\\n/**\\n * Reset the scheduler's state.\\n */\\nfunction resetSchedulerState () {\\n  queue.length = 0;\\n  has = {};\\n  if (process.env.NODE_ENV !== 'production') {\\n    circular = {};\\n  }\\n  waiting = flushing = false;\\n}\\n\\n/**\\n * Flush both queues and run the watchers.\\n */\\nfunction flushSchedulerQueue () {\\n  flushing = true;\\n  var watcher, id, vm;\\n\\n  // Sort queue before flush.\\n  // This ensures that:\\n  // 1. Components are updated from parent to child. (because parent is always\\n  //    created before the child)\\n  // 2. A component's user watchers are run before its render watcher (because\\n  //    user watchers are created before the render watcher)\\n  // 3. If a component is destroyed during a parent component's watcher run,\\n  //    its watchers can be skipped.\\n  queue.sort(function (a, b) { return a.id - b.id; });\\n\\n  // do not cache length because more watchers might be pushed\\n  // as we run existing watchers\\n  for (index = 0; index < queue.length; index++) {\\n    watcher = queue[index];\\n    id = watcher.id;\\n    has[id] = null;\\n    watcher.run();\\n    // in dev build, check and stop circular updates.\\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\\n      circular[id] = (circular[id] || 0) + 1;\\n      if (circular[id] > config._maxUpdateCount) {\\n        warn(\\n          'You may have an infinite update loop ' + (\\n            watcher.user\\n              ? (\\\"in watcher with expression \\\\\\\"\\\" + (watcher.expression) + \\\"\\\\\\\"\\\")\\n              : \\\"in a component render function.\\\"\\n          ),\\n          watcher.vm\\n        );\\n        break\\n      }\\n    }\\n  }\\n\\n  // reset scheduler before updated hook called\\n  var oldQueue = queue.slice();\\n  resetSchedulerState();\\n\\n  // call updated hooks\\n  index = oldQueue.length;\\n  while (index--) {\\n    watcher = oldQueue[index];\\n    vm = watcher.vm;\\n    if (vm._watcher === watcher && vm._isMounted) {\\n      callHook(vm, 'updated');\\n    }\\n  }\\n\\n  // devtool hook\\n  /* istanbul ignore if */\\n  if (devtools && config.devtools) {\\n    devtools.emit('flush');\\n  }\\n}\\n\\n/**\\n * Push a watcher into the watcher queue.\\n * Jobs with duplicate IDs will be skipped unless it's\\n * pushed when the queue is being flushed.\\n */\\nfunction queueWatcher (watcher) {\\n  var id = watcher.id;\\n  if (has[id] == null) {\\n    has[id] = true;\\n    if (!flushing) {\\n      queue.push(watcher);\\n    } else {\\n      // if already flushing, splice the watcher based on its id\\n      // if already past its id, it will be run next immediately.\\n      var i = queue.length - 1;\\n      while (i >= 0 && queue[i].id > watcher.id) {\\n        i--;\\n      }\\n      queue.splice(Math.max(i, index) + 1, 0, watcher);\\n    }\\n    // queue the flush\\n    if (!waiting) {\\n      waiting = true;\\n      nextTick(flushSchedulerQueue);\\n    }\\n  }\\n}\\n\\n/*  */\\n\\nvar uid$2 = 0;\\n\\n/**\\n * A watcher parses an expression, collects dependencies,\\n * and fires callback when the expression value changes.\\n * This is used for both the $watch() api and directives.\\n */\\nvar Watcher = function Watcher (\\n  vm,\\n  expOrFn,\\n  cb,\\n  options\\n) {\\n  this.vm = vm;\\n  vm._watchers.push(this);\\n  // options\\n  if (options) {\\n    this.deep = !!options.deep;\\n    this.user = !!options.user;\\n    this.lazy = !!options.lazy;\\n    this.sync = !!options.sync;\\n  } else {\\n    this.deep = this.user = this.lazy = this.sync = false;\\n  }\\n  this.cb = cb;\\n  this.id = ++uid$2; // uid for batching\\n  this.active = true;\\n  this.dirty = this.lazy; // for lazy watchers\\n  this.deps = [];\\n  this.newDeps = [];\\n  this.depIds = new _Set();\\n  this.newDepIds = new _Set();\\n  this.expression = process.env.NODE_ENV !== 'production'\\n    ? expOrFn.toString()\\n    : '';\\n  // parse expression for getter\\n  if (typeof expOrFn === 'function') {\\n    this.getter = expOrFn;\\n  } else {\\n    this.getter = parsePath(expOrFn);\\n    if (!this.getter) {\\n      this.getter = function () {};\\n      process.env.NODE_ENV !== 'production' && warn(\\n        \\\"Failed watching path: \\\\\\\"\\\" + expOrFn + \\\"\\\\\\\" \\\" +\\n        'Watcher only accepts simple dot-delimited paths. ' +\\n        'For full control, use a function instead.',\\n        vm\\n      );\\n    }\\n  }\\n  this.value = this.lazy\\n    ? undefined\\n    : this.get();\\n};\\n\\n/**\\n * Evaluate the getter, and re-collect dependencies.\\n */\\nWatcher.prototype.get = function get () {\\n  pushTarget(this);\\n  var value;\\n  var vm = this.vm;\\n  if (this.user) {\\n    try {\\n      value = this.getter.call(vm, vm);\\n    } catch (e) {\\n      handleError(e, vm, (\\\"getter for watcher \\\\\\\"\\\" + (this.expression) + \\\"\\\\\\\"\\\"));\\n    }\\n  } else {\\n    value = this.getter.call(vm, vm);\\n  }\\n  // \\\"touch\\\" every property so they are all tracked as\\n  // dependencies for deep watching\\n  if (this.deep) {\\n    traverse(value);\\n  }\\n  popTarget();\\n  this.cleanupDeps();\\n  return value\\n};\\n\\n/**\\n * Add a dependency to this directive.\\n */\\nWatcher.prototype.addDep = function addDep (dep) {\\n  var id = dep.id;\\n  if (!this.newDepIds.has(id)) {\\n    this.newDepIds.add(id);\\n    this.newDeps.push(dep);\\n    if (!this.depIds.has(id)) {\\n      dep.addSub(this);\\n    }\\n  }\\n};\\n\\n/**\\n * Clean up for dependency collection.\\n */\\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\\n    var this$1 = this;\\n\\n  var i = this.deps.length;\\n  while (i--) {\\n    var dep = this$1.deps[i];\\n    if (!this$1.newDepIds.has(dep.id)) {\\n      dep.removeSub(this$1);\\n    }\\n  }\\n  var tmp = this.depIds;\\n  this.depIds = this.newDepIds;\\n  this.newDepIds = tmp;\\n  this.newDepIds.clear();\\n  tmp = this.deps;\\n  this.deps = this.newDeps;\\n  this.newDeps = tmp;\\n  this.newDeps.length = 0;\\n};\\n\\n/**\\n * Subscriber interface.\\n * Will be called when a dependency changes.\\n */\\nWatcher.prototype.update = function update () {\\n  /* istanbul ignore else */\\n  if (this.lazy) {\\n    this.dirty = true;\\n  } else if (this.sync) {\\n    this.run();\\n  } else {\\n    queueWatcher(this);\\n  }\\n};\\n\\n/**\\n * Scheduler job interface.\\n * Will be called by the scheduler.\\n */\\nWatcher.prototype.run = function run () {\\n  if (this.active) {\\n    var value = this.get();\\n    if (\\n      value !== this.value ||\\n      // Deep watchers and watchers on Object/Arrays should fire even\\n      // when the value is the same, because the value may\\n      // have mutated.\\n      isObject(value) ||\\n      this.deep\\n    ) {\\n      // set new value\\n      var oldValue = this.value;\\n      this.value = value;\\n      if (this.user) {\\n        try {\\n          this.cb.call(this.vm, value, oldValue);\\n        } catch (e) {\\n          handleError(e, this.vm, (\\\"callback for watcher \\\\\\\"\\\" + (this.expression) + \\\"\\\\\\\"\\\"));\\n        }\\n      } else {\\n        this.cb.call(this.vm, value, oldValue);\\n      }\\n    }\\n  }\\n};\\n\\n/**\\n * Evaluate the value of the watcher.\\n * This only gets called for lazy watchers.\\n */\\nWatcher.prototype.evaluate = function evaluate () {\\n  this.value = this.get();\\n  this.dirty = false;\\n};\\n\\n/**\\n * Depend on all deps collected by this watcher.\\n */\\nWatcher.prototype.depend = function depend () {\\n    var this$1 = this;\\n\\n  var i = this.deps.length;\\n  while (i--) {\\n    this$1.deps[i].depend();\\n  }\\n};\\n\\n/**\\n * Remove self from all dependencies' subscriber list.\\n */\\nWatcher.prototype.teardown = function teardown () {\\n    var this$1 = this;\\n\\n  if (this.active) {\\n    // remove self from vm's watcher list\\n    // this is a somewhat expensive operation so we skip it\\n    // if the vm is being destroyed.\\n    if (!this.vm._isBeingDestroyed) {\\n      remove(this.vm._watchers, this);\\n    }\\n    var i = this.deps.length;\\n    while (i--) {\\n      this$1.deps[i].removeSub(this$1);\\n    }\\n    this.active = false;\\n  }\\n};\\n\\n/**\\n * Recursively traverse an object to evoke all converted\\n * getters, so that every nested property inside the object\\n * is collected as a \\\"deep\\\" dependency.\\n */\\nvar seenObjects = new _Set();\\nfunction traverse (val) {\\n  seenObjects.clear();\\n  _traverse(val, seenObjects);\\n}\\n\\nfunction _traverse (val, seen) {\\n  var i, keys;\\n  var isA = Array.isArray(val);\\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\\n    return\\n  }\\n  if (val.__ob__) {\\n    var depId = val.__ob__.dep.id;\\n    if (seen.has(depId)) {\\n      return\\n    }\\n    seen.add(depId);\\n  }\\n  if (isA) {\\n    i = val.length;\\n    while (i--) { _traverse(val[i], seen); }\\n  } else {\\n    keys = Object.keys(val);\\n    i = keys.length;\\n    while (i--) { _traverse(val[keys[i]], seen); }\\n  }\\n}\\n\\n/*  */\\n\\nvar sharedPropertyDefinition = {\\n  enumerable: true,\\n  configurable: true,\\n  get: noop,\\n  set: noop\\n};\\n\\nfunction proxy (target, sourceKey, key) {\\n  sharedPropertyDefinition.get = function proxyGetter () {\\n    return this[sourceKey][key]\\n  };\\n  sharedPropertyDefinition.set = function proxySetter (val) {\\n    this[sourceKey][key] = val;\\n  };\\n  Object.defineProperty(target, key, sharedPropertyDefinition);\\n}\\n\\nfunction initState (vm) {\\n  vm._watchers = [];\\n  var opts = vm.$options;\\n  if (opts.props) { initProps(vm, opts.props); }\\n  if (opts.methods) { initMethods(vm, opts.methods); }\\n  if (opts.data) {\\n    initData(vm);\\n  } else {\\n    observe(vm._data = {}, true /* asRootData */);\\n  }\\n  if (opts.computed) { initComputed(vm, opts.computed); }\\n  if (opts.watch) { initWatch(vm, opts.watch); }\\n}\\n\\nvar isReservedProp = { key: 1, ref: 1, slot: 1 };\\n\\nfunction initProps (vm, propsOptions) {\\n  var propsData = vm.$options.propsData || {};\\n  var props = vm._props = {};\\n  // cache prop keys so that future props updates can iterate using Array\\n  // instead of dynamic object key enumeration.\\n  var keys = vm.$options._propKeys = [];\\n  var isRoot = !vm.$parent;\\n  // root instance props should be converted\\n  observerState.shouldConvert = isRoot;\\n  var loop = function ( key ) {\\n    keys.push(key);\\n    var value = validateProp(key, propsOptions, propsData, vm);\\n    /* istanbul ignore else */\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (isReservedProp[key]) {\\n        warn(\\n          (\\\"\\\\\\\"\\\" + key + \\\"\\\\\\\" is a reserved attribute and cannot be used as component prop.\\\"),\\n          vm\\n        );\\n      }\\n      defineReactive$$1(props, key, value, function () {\\n        if (vm.$parent && !observerState.isSettingProps) {\\n          warn(\\n            \\\"Avoid mutating a prop directly since the value will be \\\" +\\n            \\\"overwritten whenever the parent component re-renders. \\\" +\\n            \\\"Instead, use a data or computed property based on the prop's \\\" +\\n            \\\"value. Prop being mutated: \\\\\\\"\\\" + key + \\\"\\\\\\\"\\\",\\n            vm\\n          );\\n        }\\n      });\\n    } else {\\n      defineReactive$$1(props, key, value);\\n    }\\n    // static props are already proxied on the component's prototype\\n    // during Vue.extend(). We only need to proxy props defined at\\n    // instantiation here.\\n    if (!(key in vm)) {\\n      proxy(vm, \\\"_props\\\", key);\\n    }\\n  };\\n\\n  for (var key in propsOptions) loop( key );\\n  observerState.shouldConvert = true;\\n}\\n\\nfunction initData (vm) {\\n  var data = vm.$options.data;\\n  data = vm._data = typeof data === 'function'\\n    ? getData(data, vm)\\n    : data || {};\\n  if (!isPlainObject(data)) {\\n    data = {};\\n    process.env.NODE_ENV !== 'production' && warn(\\n      'data functions should return an object:\\\\n' +\\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\\n      vm\\n    );\\n  }\\n  // proxy data on instance\\n  var keys = Object.keys(data);\\n  var props = vm.$options.props;\\n  var i = keys.length;\\n  while (i--) {\\n    if (props && hasOwn(props, keys[i])) {\\n      process.env.NODE_ENV !== 'production' && warn(\\n        \\\"The data property \\\\\\\"\\\" + (keys[i]) + \\\"\\\\\\\" is already declared as a prop. \\\" +\\n        \\\"Use prop default value instead.\\\",\\n        vm\\n      );\\n    } else if (!isReserved(keys[i])) {\\n      proxy(vm, \\\"_data\\\", keys[i]);\\n    }\\n  }\\n  // observe data\\n  observe(data, true /* asRootData */);\\n}\\n\\nfunction getData (data, vm) {\\n  try {\\n    return data.call(vm)\\n  } catch (e) {\\n    handleError(e, vm, \\\"data()\\\");\\n    return {}\\n  }\\n}\\n\\nvar computedWatcherOptions = { lazy: true };\\n\\nfunction initComputed (vm, computed) {\\n  var watchers = vm._computedWatchers = Object.create(null);\\n\\n  for (var key in computed) {\\n    var userDef = computed[key];\\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (getter === undefined) {\\n        warn(\\n          (\\\"No getter function has been defined for computed property \\\\\\\"\\\" + key + \\\"\\\\\\\".\\\"),\\n          vm\\n        );\\n        getter = noop;\\n      }\\n    }\\n    // create internal watcher for the computed property.\\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\\n\\n    // component-defined computed properties are already defined on the\\n    // component prototype. We only need to define computed properties defined\\n    // at instantiation here.\\n    if (!(key in vm)) {\\n      defineComputed(vm, key, userDef);\\n    }\\n  }\\n}\\n\\nfunction defineComputed (target, key, userDef) {\\n  if (typeof userDef === 'function') {\\n    sharedPropertyDefinition.get = createComputedGetter(key);\\n    sharedPropertyDefinition.set = noop;\\n  } else {\\n    sharedPropertyDefinition.get = userDef.get\\n      ? userDef.cache !== false\\n        ? createComputedGetter(key)\\n        : userDef.get\\n      : noop;\\n    sharedPropertyDefinition.set = userDef.set\\n      ? userDef.set\\n      : noop;\\n  }\\n  Object.defineProperty(target, key, sharedPropertyDefinition);\\n}\\n\\nfunction createComputedGetter (key) {\\n  return function computedGetter () {\\n    var watcher = this._computedWatchers && this._computedWatchers[key];\\n    if (watcher) {\\n      if (watcher.dirty) {\\n        watcher.evaluate();\\n      }\\n      if (Dep.target) {\\n        watcher.depend();\\n      }\\n      return watcher.value\\n    }\\n  }\\n}\\n\\nfunction initMethods (vm, methods) {\\n  var props = vm.$options.props;\\n  for (var key in methods) {\\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (methods[key] == null) {\\n        warn(\\n          \\\"method \\\\\\\"\\\" + key + \\\"\\\\\\\" has an undefined value in the component definition. \\\" +\\n          \\\"Did you reference the function correctly?\\\",\\n          vm\\n        );\\n      }\\n      if (props && hasOwn(props, key)) {\\n        warn(\\n          (\\\"method \\\\\\\"\\\" + key + \\\"\\\\\\\" has already been defined as a prop.\\\"),\\n          vm\\n        );\\n      }\\n    }\\n  }\\n}\\n\\nfunction initWatch (vm, watch) {\\n  for (var key in watch) {\\n    var handler = watch[key];\\n    if (Array.isArray(handler)) {\\n      for (var i = 0; i < handler.length; i++) {\\n        createWatcher(vm, key, handler[i]);\\n      }\\n    } else {\\n      createWatcher(vm, key, handler);\\n    }\\n  }\\n}\\n\\nfunction createWatcher (vm, key, handler) {\\n  var options;\\n  if (isPlainObject(handler)) {\\n    options = handler;\\n    handler = handler.handler;\\n  }\\n  if (typeof handler === 'string') {\\n    handler = vm[handler];\\n  }\\n  vm.$watch(key, handler, options);\\n}\\n\\nfunction stateMixin (Vue) {\\n  // flow somehow has problems with directly declared definition object\\n  // when using Object.defineProperty, so we have to procedurally build up\\n  // the object here.\\n  var dataDef = {};\\n  dataDef.get = function () { return this._data };\\n  var propsDef = {};\\n  propsDef.get = function () { return this._props };\\n  if (process.env.NODE_ENV !== 'production') {\\n    dataDef.set = function (newData) {\\n      warn(\\n        'Avoid replacing instance root $data. ' +\\n        'Use nested data properties instead.',\\n        this\\n      );\\n    };\\n    propsDef.set = function () {\\n      warn(\\\"$props is readonly.\\\", this);\\n    };\\n  }\\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\\n\\n  Vue.prototype.$set = set;\\n  Vue.prototype.$delete = del;\\n\\n  Vue.prototype.$watch = function (\\n    expOrFn,\\n    cb,\\n    options\\n  ) {\\n    var vm = this;\\n    options = options || {};\\n    options.user = true;\\n    var watcher = new Watcher(vm, expOrFn, cb, options);\\n    if (options.immediate) {\\n      cb.call(vm, watcher.value);\\n    }\\n    return function unwatchFn () {\\n      watcher.teardown();\\n    }\\n  };\\n}\\n\\n/*  */\\n\\n// hooks to be invoked on component VNodes during patch\\nvar componentVNodeHooks = {\\n  init: function init (\\n    vnode,\\n    hydrating,\\n    parentElm,\\n    refElm\\n  ) {\\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\\n        vnode,\\n        activeInstance,\\n        parentElm,\\n        refElm\\n      );\\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\\n    } else if (vnode.data.keepAlive) {\\n      // kept-alive components, treat as a patch\\n      var mountedNode = vnode; // work around flow\\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\\n    }\\n  },\\n\\n  prepatch: function prepatch (oldVnode, vnode) {\\n    var options = vnode.componentOptions;\\n    var child = vnode.componentInstance = oldVnode.componentInstance;\\n    updateChildComponent(\\n      child,\\n      options.propsData, // updated props\\n      options.listeners, // updated listeners\\n      vnode, // new parent vnode\\n      options.children // new children\\n    );\\n  },\\n\\n  insert: function insert (vnode) {\\n    if (!vnode.componentInstance._isMounted) {\\n      vnode.componentInstance._isMounted = true;\\n      callHook(vnode.componentInstance, 'mounted');\\n    }\\n    if (vnode.data.keepAlive) {\\n      activateChildComponent(vnode.componentInstance, true /* direct */);\\n    }\\n  },\\n\\n  destroy: function destroy (vnode) {\\n    if (!vnode.componentInstance._isDestroyed) {\\n      if (!vnode.data.keepAlive) {\\n        vnode.componentInstance.$destroy();\\n      } else {\\n        deactivateChildComponent(vnode.componentInstance, true /* direct */);\\n      }\\n    }\\n  }\\n};\\n\\nvar hooksToMerge = Object.keys(componentVNodeHooks);\\n\\nfunction createComponent (\\n  Ctor,\\n  data,\\n  context,\\n  children,\\n  tag\\n) {\\n  if (!Ctor) {\\n    return\\n  }\\n\\n  var baseCtor = context.$options._base;\\n  if (isObject(Ctor)) {\\n    Ctor = baseCtor.extend(Ctor);\\n  }\\n\\n  if (typeof Ctor !== 'function') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      warn((\\\"Invalid Component definition: \\\" + (String(Ctor))), context);\\n    }\\n    return\\n  }\\n\\n  // async component\\n  if (!Ctor.cid) {\\n    if (Ctor.resolved) {\\n      Ctor = Ctor.resolved;\\n    } else {\\n      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\\n        // it's ok to queue this on every render because\\n        // $forceUpdate is buffered by the scheduler.\\n        context.$forceUpdate();\\n      });\\n      if (!Ctor) {\\n        // return nothing if this is indeed an async component\\n        // wait for the callback to trigger parent update.\\n        return\\n      }\\n    }\\n  }\\n\\n  // resolve constructor options in case global mixins are applied after\\n  // component constructor creation\\n  resolveConstructorOptions(Ctor);\\n\\n  data = data || {};\\n\\n  // transform component v-model data into props & events\\n  if (data.model) {\\n    transformModel(Ctor.options, data);\\n  }\\n\\n  // extract props\\n  var propsData = extractProps(data, Ctor, tag);\\n\\n  // functional component\\n  if (Ctor.options.functional) {\\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\\n  }\\n\\n  // extract listeners, since these needs to be treated as\\n  // child component listeners instead of DOM listeners\\n  var listeners = data.on;\\n  // replace with listeners with .native modifier\\n  data.on = data.nativeOn;\\n\\n  if (Ctor.options.abstract) {\\n    // abstract components do not keep anything\\n    // other than props & listeners\\n    data = {};\\n  }\\n\\n  // merge component management hooks onto the placeholder node\\n  mergeHooks(data);\\n\\n  // return a placeholder vnode\\n  var name = Ctor.options.name || tag;\\n  var vnode = new VNode(\\n    (\\\"vue-component-\\\" + (Ctor.cid) + (name ? (\\\"-\\\" + name) : '')),\\n    data, undefined, undefined, undefined, context,\\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\\n  );\\n  return vnode\\n}\\n\\nfunction createFunctionalComponent (\\n  Ctor,\\n  propsData,\\n  data,\\n  context,\\n  children\\n) {\\n  var props = {};\\n  var propOptions = Ctor.options.props;\\n  if (propOptions) {\\n    for (var key in propOptions) {\\n      props[key] = validateProp(key, propOptions, propsData);\\n    }\\n  }\\n  // ensure the createElement function in functional components\\n  // gets a unique context - this is necessary for correct named slot check\\n  var _context = Object.create(context);\\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\\n  var vnode = Ctor.options.render.call(null, h, {\\n    props: props,\\n    data: data,\\n    parent: context,\\n    children: children,\\n    slots: function () { return resolveSlots(children, context); }\\n  });\\n  if (vnode instanceof VNode) {\\n    vnode.functionalContext = context;\\n    if (data.slot) {\\n      (vnode.data || (vnode.data = {})).slot = data.slot;\\n    }\\n  }\\n  return vnode\\n}\\n\\nfunction createComponentInstanceForVnode (\\n  vnode, // we know it's MountedComponentVNode but flow doesn't\\n  parent, // activeInstance in lifecycle state\\n  parentElm,\\n  refElm\\n) {\\n  var vnodeComponentOptions = vnode.componentOptions;\\n  var options = {\\n    _isComponent: true,\\n    parent: parent,\\n    propsData: vnodeComponentOptions.propsData,\\n    _componentTag: vnodeComponentOptions.tag,\\n    _parentVnode: vnode,\\n    _parentListeners: vnodeComponentOptions.listeners,\\n    _renderChildren: vnodeComponentOptions.children,\\n    _parentElm: parentElm || null,\\n    _refElm: refElm || null\\n  };\\n  // check inline-template render functions\\n  var inlineTemplate = vnode.data.inlineTemplate;\\n  if (inlineTemplate) {\\n    options.render = inlineTemplate.render;\\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\\n  }\\n  return new vnodeComponentOptions.Ctor(options)\\n}\\n\\nfunction resolveAsyncComponent (\\n  factory,\\n  baseCtor,\\n  cb\\n) {\\n  if (factory.requested) {\\n    // pool callbacks\\n    factory.pendingCallbacks.push(cb);\\n  } else {\\n    factory.requested = true;\\n    var cbs = factory.pendingCallbacks = [cb];\\n    var sync = true;\\n\\n    var resolve = function (res) {\\n      if (isObject(res)) {\\n        res = baseCtor.extend(res);\\n      }\\n      // cache resolved\\n      factory.resolved = res;\\n      // invoke callbacks only if this is not a synchronous resolve\\n      // (async resolves are shimmed as synchronous during SSR)\\n      if (!sync) {\\n        for (var i = 0, l = cbs.length; i < l; i++) {\\n          cbs[i](res);\\n        }\\n      }\\n    };\\n\\n    var reject = function (reason) {\\n      process.env.NODE_ENV !== 'production' && warn(\\n        \\\"Failed to resolve async component: \\\" + (String(factory)) +\\n        (reason ? (\\\"\\\\nReason: \\\" + reason) : '')\\n      );\\n    };\\n\\n    var res = factory(resolve, reject);\\n\\n    // handle promise\\n    if (res && typeof res.then === 'function' && !factory.resolved) {\\n      res.then(resolve, reject);\\n    }\\n\\n    sync = false;\\n    // return in case resolved synchronously\\n    return factory.resolved\\n  }\\n}\\n\\nfunction extractProps (data, Ctor, tag) {\\n  // we are only extracting raw values here.\\n  // validation and default values are handled in the child\\n  // component itself.\\n  var propOptions = Ctor.options.props;\\n  if (!propOptions) {\\n    return\\n  }\\n  var res = {};\\n  var attrs = data.attrs;\\n  var props = data.props;\\n  var domProps = data.domProps;\\n  if (attrs || props || domProps) {\\n    for (var key in propOptions) {\\n      var altKey = hyphenate(key);\\n      if (process.env.NODE_ENV !== 'production') {\\n        var keyInLowerCase = key.toLowerCase();\\n        if (\\n          key !== keyInLowerCase &&\\n          attrs && attrs.hasOwnProperty(keyInLowerCase)\\n        ) {\\n          tip(\\n            \\\"Prop \\\\\\\"\\\" + keyInLowerCase + \\\"\\\\\\\" is passed to component \\\" +\\n            (formatComponentName(tag || Ctor)) + \\\", but the declared prop name is\\\" +\\n            \\\" \\\\\\\"\\\" + key + \\\"\\\\\\\". \\\" +\\n            \\\"Note that HTML attributes are case-insensitive and camelCased \\\" +\\n            \\\"props need to use their kebab-case equivalents when using in-DOM \\\" +\\n            \\\"templates. You should probably use \\\\\\\"\\\" + altKey + \\\"\\\\\\\" instead of \\\\\\\"\\\" + key + \\\"\\\\\\\".\\\"\\n          );\\n        }\\n      }\\n      checkProp(res, props, key, altKey, true) ||\\n      checkProp(res, attrs, key, altKey) ||\\n      checkProp(res, domProps, key, altKey);\\n    }\\n  }\\n  return res\\n}\\n\\nfunction checkProp (\\n  res,\\n  hash,\\n  key,\\n  altKey,\\n  preserve\\n) {\\n  if (hash) {\\n    if (hasOwn(hash, key)) {\\n      res[key] = hash[key];\\n      if (!preserve) {\\n        delete hash[key];\\n      }\\n      return true\\n    } else if (hasOwn(hash, altKey)) {\\n      res[key] = hash[altKey];\\n      if (!preserve) {\\n        delete hash[altKey];\\n      }\\n      return true\\n    }\\n  }\\n  return false\\n}\\n\\nfunction mergeHooks (data) {\\n  if (!data.hook) {\\n    data.hook = {};\\n  }\\n  for (var i = 0; i < hooksToMerge.length; i++) {\\n    var key = hooksToMerge[i];\\n    var fromParent = data.hook[key];\\n    var ours = componentVNodeHooks[key];\\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\\n  }\\n}\\n\\nfunction mergeHook$1 (one, two) {\\n  return function (a, b, c, d) {\\n    one(a, b, c, d);\\n    two(a, b, c, d);\\n  }\\n}\\n\\n// transform component v-model info (value and callback) into\\n// prop and event handler respectively.\\nfunction transformModel (options, data) {\\n  var prop = (options.model && options.model.prop) || 'value';\\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\\n  var on = data.on || (data.on = {});\\n  if (on[event]) {\\n    on[event] = [data.model.callback].concat(on[event]);\\n  } else {\\n    on[event] = data.model.callback;\\n  }\\n}\\n\\n/*  */\\n\\nvar SIMPLE_NORMALIZE = 1;\\nvar ALWAYS_NORMALIZE = 2;\\n\\n// wrapper function for providing a more flexible interface\\n// without getting yelled at by flow\\nfunction createElement (\\n  context,\\n  tag,\\n  data,\\n  children,\\n  normalizationType,\\n  alwaysNormalize\\n) {\\n  if (Array.isArray(data) || isPrimitive(data)) {\\n    normalizationType = children;\\n    children = data;\\n    data = undefined;\\n  }\\n  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\\n  return _createElement(context, tag, data, children, normalizationType)\\n}\\n\\nfunction _createElement (\\n  context,\\n  tag,\\n  data,\\n  children,\\n  normalizationType\\n) {\\n  if (data && data.__ob__) {\\n    process.env.NODE_ENV !== 'production' && warn(\\n      \\\"Avoid using observed data object as vnode data: \\\" + (JSON.stringify(data)) + \\\"\\\\n\\\" +\\n      'Always create fresh vnode data objects in each render!',\\n      context\\n    );\\n    return createEmptyVNode()\\n  }\\n  if (!tag) {\\n    // in case of component :is set to falsy value\\n    return createEmptyVNode()\\n  }\\n  // support single function children as default scoped slot\\n  if (Array.isArray(children) &&\\n      typeof children[0] === 'function') {\\n    data = data || {};\\n    data.scopedSlots = { default: children[0] };\\n    children.length = 0;\\n  }\\n  if (normalizationType === ALWAYS_NORMALIZE) {\\n    children = normalizeChildren(children);\\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\\n    children = simpleNormalizeChildren(children);\\n  }\\n  var vnode, ns;\\n  if (typeof tag === 'string') {\\n    var Ctor;\\n    ns = config.getTagNamespace(tag);\\n    if (config.isReservedTag(tag)) {\\n      // platform built-in elements\\n      vnode = new VNode(\\n        config.parsePlatformTagName(tag), data, children,\\n        undefined, undefined, context\\n      );\\n    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\\n      // component\\n      vnode = createComponent(Ctor, data, context, children, tag);\\n    } else {\\n      // unknown or unlisted namespaced elements\\n      // check at runtime because it may get assigned a namespace when its\\n      // parent normalizes children\\n      vnode = new VNode(\\n        tag, data, children,\\n        undefined, undefined, context\\n      );\\n    }\\n  } else {\\n    // direct component options / constructor\\n    vnode = createComponent(tag, data, context, children);\\n  }\\n  if (vnode) {\\n    if (ns) { applyNS(vnode, ns); }\\n    return vnode\\n  } else {\\n    return createEmptyVNode()\\n  }\\n}\\n\\nfunction applyNS (vnode, ns) {\\n  vnode.ns = ns;\\n  if (vnode.tag === 'foreignObject') {\\n    // use default namespace inside foreignObject\\n    return\\n  }\\n  if (vnode.children) {\\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\\n      var child = vnode.children[i];\\n      if (child.tag && !child.ns) {\\n        applyNS(child, ns);\\n      }\\n    }\\n  }\\n}\\n\\n/*  */\\n\\n/**\\n * Runtime helper for rendering v-for lists.\\n */\\nfunction renderList (\\n  val,\\n  render\\n) {\\n  var ret, i, l, keys, key;\\n  if (Array.isArray(val) || typeof val === 'string') {\\n    ret = new Array(val.length);\\n    for (i = 0, l = val.length; i < l; i++) {\\n      ret[i] = render(val[i], i);\\n    }\\n  } else if (typeof val === 'number') {\\n    ret = new Array(val);\\n    for (i = 0; i < val; i++) {\\n      ret[i] = render(i + 1, i);\\n    }\\n  } else if (isObject(val)) {\\n    keys = Object.keys(val);\\n    ret = new Array(keys.length);\\n    for (i = 0, l = keys.length; i < l; i++) {\\n      key = keys[i];\\n      ret[i] = render(val[key], key, i);\\n    }\\n  }\\n  return ret\\n}\\n\\n/*  */\\n\\n/**\\n * Runtime helper for rendering <slot>\\n */\\nfunction renderSlot (\\n  name,\\n  fallback,\\n  props,\\n  bindObject\\n) {\\n  var scopedSlotFn = this.$scopedSlots[name];\\n  if (scopedSlotFn) { // scoped slot\\n    props = props || {};\\n    if (bindObject) {\\n      extend(props, bindObject);\\n    }\\n    return scopedSlotFn(props) || fallback\\n  } else {\\n    var slotNodes = this.$slots[name];\\n    // warn duplicate slot usage\\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\\n      slotNodes._rendered && warn(\\n        \\\"Duplicate presence of slot \\\\\\\"\\\" + name + \\\"\\\\\\\" found in the same render tree \\\" +\\n        \\\"- this will likely cause render errors.\\\",\\n        this\\n      );\\n      slotNodes._rendered = true;\\n    }\\n    return slotNodes || fallback\\n  }\\n}\\n\\n/*  */\\n\\n/**\\n * Runtime helper for resolving filters\\n */\\nfunction resolveFilter (id) {\\n  return resolveAsset(this.$options, 'filters', id, true) || identity\\n}\\n\\n/*  */\\n\\n/**\\n * Runtime helper for checking keyCodes from config.\\n */\\nfunction checkKeyCodes (\\n  eventKeyCode,\\n  key,\\n  builtInAlias\\n) {\\n  var keyCodes = config.keyCodes[key] || builtInAlias;\\n  if (Array.isArray(keyCodes)) {\\n    return keyCodes.indexOf(eventKeyCode) === -1\\n  } else {\\n    return keyCodes !== eventKeyCode\\n  }\\n}\\n\\n/*  */\\n\\n/**\\n * Runtime helper for merging v-bind=\\\"object\\\" into a VNode's data.\\n */\\nfunction bindObjectProps (\\n  data,\\n  tag,\\n  value,\\n  asProp\\n) {\\n  if (value) {\\n    if (!isObject(value)) {\\n      process.env.NODE_ENV !== 'production' && warn(\\n        'v-bind without argument expects an Object or Array value',\\n        this\\n      );\\n    } else {\\n      if (Array.isArray(value)) {\\n        value = toObject(value);\\n      }\\n      var hash;\\n      for (var key in value) {\\n        if (key === 'class' || key === 'style') {\\n          hash = data;\\n        } else {\\n          var type = data.attrs && data.attrs.type;\\n          hash = asProp || config.mustUseProp(tag, type, key)\\n            ? data.domProps || (data.domProps = {})\\n            : data.attrs || (data.attrs = {});\\n        }\\n        if (!(key in hash)) {\\n          hash[key] = value[key];\\n        }\\n      }\\n    }\\n  }\\n  return data\\n}\\n\\n/*  */\\n\\n/**\\n * Runtime helper for rendering static trees.\\n */\\nfunction renderStatic (\\n  index,\\n  isInFor\\n) {\\n  var tree = this._staticTrees[index];\\n  // if has already-rendered static tree and not inside v-for,\\n  // we can reuse the same tree by doing a shallow clone.\\n  if (tree && !isInFor) {\\n    return Array.isArray(tree)\\n      ? cloneVNodes(tree)\\n      : cloneVNode(tree)\\n  }\\n  // otherwise, render a fresh tree.\\n  tree = this._staticTrees[index] =\\n    this.$options.staticRenderFns[index].call(this._renderProxy);\\n  markStatic(tree, (\\\"__static__\\\" + index), false);\\n  return tree\\n}\\n\\n/**\\n * Runtime helper for v-once.\\n * Effectively it means marking the node as static with a unique key.\\n */\\nfunction markOnce (\\n  tree,\\n  index,\\n  key\\n) {\\n  markStatic(tree, (\\\"__once__\\\" + index + (key ? (\\\"_\\\" + key) : \\\"\\\")), true);\\n  return tree\\n}\\n\\nfunction markStatic (\\n  tree,\\n  key,\\n  isOnce\\n) {\\n  if (Array.isArray(tree)) {\\n    for (var i = 0; i < tree.length; i++) {\\n      if (tree[i] && typeof tree[i] !== 'string') {\\n        markStaticNode(tree[i], (key + \\\"_\\\" + i), isOnce);\\n      }\\n    }\\n  } else {\\n    markStaticNode(tree, key, isOnce);\\n  }\\n}\\n\\nfunction markStaticNode (node, key, isOnce) {\\n  node.isStatic = true;\\n  node.key = key;\\n  node.isOnce = isOnce;\\n}\\n\\n/*  */\\n\\nfunction initRender (vm) {\\n  vm.$vnode = null; // the placeholder node in parent tree\\n  vm._vnode = null; // the root of the child tree\\n  vm._staticTrees = null;\\n  var parentVnode = vm.$options._parentVnode;\\n  var renderContext = parentVnode && parentVnode.context;\\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\\n  vm.$scopedSlots = emptyObject;\\n  // bind the createElement fn to this instance\\n  // so that we get proper render context inside it.\\n  // args order: tag, data, children, normalizationType, alwaysNormalize\\n  // internal version is used by render functions compiled from templates\\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\\n  // normalization is always applied for the public version, used in\\n  // user-written render functions.\\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\\n}\\n\\nfunction renderMixin (Vue) {\\n  Vue.prototype.$nextTick = function (fn) {\\n    return nextTick(fn, this)\\n  };\\n\\n  Vue.prototype._render = function () {\\n    var vm = this;\\n    var ref = vm.$options;\\n    var render = ref.render;\\n    var staticRenderFns = ref.staticRenderFns;\\n    var _parentVnode = ref._parentVnode;\\n\\n    if (vm._isMounted) {\\n      // clone slot nodes on re-renders\\n      for (var key in vm.$slots) {\\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\\n      }\\n    }\\n\\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\\n\\n    if (staticRenderFns && !vm._staticTrees) {\\n      vm._staticTrees = [];\\n    }\\n    // set parent vnode. this allows render functions to have access\\n    // to the data on the placeholder node.\\n    vm.$vnode = _parentVnode;\\n    // render self\\n    var vnode;\\n    try {\\n      vnode = render.call(vm._renderProxy, vm.$createElement);\\n    } catch (e) {\\n      handleError(e, vm, \\\"render function\\\");\\n      // return error render result,\\n      // or previous vnode to prevent render error causing blank component\\n      /* istanbul ignore else */\\n      if (process.env.NODE_ENV !== 'production') {\\n        vnode = vm.$options.renderError\\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\\n          : vm._vnode;\\n      } else {\\n        vnode = vm._vnode;\\n      }\\n    }\\n    // return empty vnode in case the render function errored out\\n    if (!(vnode instanceof VNode)) {\\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\\n        warn(\\n          'Multiple root nodes returned from render function. Render function ' +\\n          'should return a single root node.',\\n          vm\\n        );\\n      }\\n      vnode = createEmptyVNode();\\n    }\\n    // set parent\\n    vnode.parent = _parentVnode;\\n    return vnode\\n  };\\n\\n  // internal render helpers.\\n  // these are exposed on the instance prototype to reduce generated render\\n  // code size.\\n  Vue.prototype._o = markOnce;\\n  Vue.prototype._n = toNumber;\\n  Vue.prototype._s = _toString;\\n  Vue.prototype._l = renderList;\\n  Vue.prototype._t = renderSlot;\\n  Vue.prototype._q = looseEqual;\\n  Vue.prototype._i = looseIndexOf;\\n  Vue.prototype._m = renderStatic;\\n  Vue.prototype._f = resolveFilter;\\n  Vue.prototype._k = checkKeyCodes;\\n  Vue.prototype._b = bindObjectProps;\\n  Vue.prototype._v = createTextVNode;\\n  Vue.prototype._e = createEmptyVNode;\\n  Vue.prototype._u = resolveScopedSlots;\\n}\\n\\n/*  */\\n\\nfunction initProvide (vm) {\\n  var provide = vm.$options.provide;\\n  if (provide) {\\n    vm._provided = typeof provide === 'function'\\n      ? provide.call(vm)\\n      : provide;\\n  }\\n}\\n\\nfunction initInjections (vm) {\\n  var inject = vm.$options.inject;\\n  if (inject) {\\n    // inject is :any because flow is not smart enough to figure out cached\\n    // isArray here\\n    var isArray = Array.isArray(inject);\\n    var keys = isArray\\n      ? inject\\n      : hasSymbol\\n        ? Reflect.ownKeys(inject)\\n        : Object.keys(inject);\\n\\n    var loop = function ( i ) {\\n      var key = keys[i];\\n      var provideKey = isArray ? key : inject[key];\\n      var source = vm;\\n      while (source) {\\n        if (source._provided && provideKey in source._provided) {\\n          /* istanbul ignore else */\\n          if (process.env.NODE_ENV !== 'production') {\\n            defineReactive$$1(vm, key, source._provided[provideKey], function () {\\n              warn(\\n                \\\"Avoid mutating an injected value directly since the changes will be \\\" +\\n                \\\"overwritten whenever the provided component re-renders. \\\" +\\n                \\\"injection being mutated: \\\\\\\"\\\" + key + \\\"\\\\\\\"\\\",\\n                vm\\n              );\\n            });\\n          } else {\\n            defineReactive$$1(vm, key, source._provided[provideKey]);\\n          }\\n          break\\n        }\\n        source = source.$parent;\\n      }\\n    };\\n\\n    for (var i = 0; i < keys.length; i++) loop( i );\\n  }\\n}\\n\\n/*  */\\n\\nvar uid = 0;\\n\\nfunction initMixin (Vue) {\\n  Vue.prototype._init = function (options) {\\n    var vm = this;\\n    // a uid\\n    vm._uid = uid++;\\n\\n    var startTag, endTag;\\n    /* istanbul ignore if */\\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\\n      startTag = \\\"vue-perf-init:\\\" + (vm._uid);\\n      endTag = \\\"vue-perf-end:\\\" + (vm._uid);\\n      mark(startTag);\\n    }\\n\\n    // a flag to avoid this being observed\\n    vm._isVue = true;\\n    // merge options\\n    if (options && options._isComponent) {\\n      // optimize internal component instantiation\\n      // since dynamic options merging is pretty slow, and none of the\\n      // internal component options needs special treatment.\\n      initInternalComponent(vm, options);\\n    } else {\\n      vm.$options = mergeOptions(\\n        resolveConstructorOptions(vm.constructor),\\n        options || {},\\n        vm\\n      );\\n    }\\n    /* istanbul ignore else */\\n    if (process.env.NODE_ENV !== 'production') {\\n      initProxy(vm);\\n    } else {\\n      vm._renderProxy = vm;\\n    }\\n    // expose real self\\n    vm._self = vm;\\n    initLifecycle(vm);\\n    initEvents(vm);\\n    initRender(vm);\\n    callHook(vm, 'beforeCreate');\\n    initInjections(vm); // resolve injections before data/props\\n    initState(vm);\\n    initProvide(vm); // resolve provide after data/props\\n    callHook(vm, 'created');\\n\\n    /* istanbul ignore if */\\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\\n      vm._name = formatComponentName(vm, false);\\n      mark(endTag);\\n      measure(((vm._name) + \\\" init\\\"), startTag, endTag);\\n    }\\n\\n    if (vm.$options.el) {\\n      vm.$mount(vm.$options.el);\\n    }\\n  };\\n}\\n\\nfunction initInternalComponent (vm, options) {\\n  var opts = vm.$options = Object.create(vm.constructor.options);\\n  // doing this because it's faster than dynamic enumeration.\\n  opts.parent = options.parent;\\n  opts.propsData = options.propsData;\\n  opts._parentVnode = options._parentVnode;\\n  opts._parentListeners = options._parentListeners;\\n  opts._renderChildren = options._renderChildren;\\n  opts._componentTag = options._componentTag;\\n  opts._parentElm = options._parentElm;\\n  opts._refElm = options._refElm;\\n  if (options.render) {\\n    opts.render = options.render;\\n    opts.staticRenderFns = options.staticRenderFns;\\n  }\\n}\\n\\nfunction resolveConstructorOptions (Ctor) {\\n  var options = Ctor.options;\\n  if (Ctor.super) {\\n    var superOptions = resolveConstructorOptions(Ctor.super);\\n    var cachedSuperOptions = Ctor.superOptions;\\n    if (superOptions !== cachedSuperOptions) {\\n      // super option changed,\\n      // need to resolve new options.\\n      Ctor.superOptions = superOptions;\\n      // check if there are any late-modified/attached options (#4976)\\n      var modifiedOptions = resolveModifiedOptions(Ctor);\\n      // update base extend options\\n      if (modifiedOptions) {\\n        extend(Ctor.extendOptions, modifiedOptions);\\n      }\\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\\n      if (options.name) {\\n        options.components[options.name] = Ctor;\\n      }\\n    }\\n  }\\n  return options\\n}\\n\\nfunction resolveModifiedOptions (Ctor) {\\n  var modified;\\n  var latest = Ctor.options;\\n  var sealed = Ctor.sealedOptions;\\n  for (var key in latest) {\\n    if (latest[key] !== sealed[key]) {\\n      if (!modified) { modified = {}; }\\n      modified[key] = dedupe(latest[key], sealed[key]);\\n    }\\n  }\\n  return modified\\n}\\n\\nfunction dedupe (latest, sealed) {\\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\\n  // between merges\\n  if (Array.isArray(latest)) {\\n    var res = [];\\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\\n    for (var i = 0; i < latest.length; i++) {\\n      if (sealed.indexOf(latest[i]) < 0) {\\n        res.push(latest[i]);\\n      }\\n    }\\n    return res\\n  } else {\\n    return latest\\n  }\\n}\\n\\nfunction Vue$2 (options) {\\n  if (process.env.NODE_ENV !== 'production' &&\\n    !(this instanceof Vue$2)) {\\n    warn('Vue is a constructor and should be called with the `new` keyword');\\n  }\\n  this._init(options);\\n}\\n\\ninitMixin(Vue$2);\\nstateMixin(Vue$2);\\neventsMixin(Vue$2);\\nlifecycleMixin(Vue$2);\\nrenderMixin(Vue$2);\\n\\n/*  */\\n\\nfunction initUse (Vue) {\\n  Vue.use = function (plugin) {\\n    /* istanbul ignore if */\\n    if (plugin.installed) {\\n      return\\n    }\\n    // additional parameters\\n    var args = toArray(arguments, 1);\\n    args.unshift(this);\\n    if (typeof plugin.install === 'function') {\\n      plugin.install.apply(plugin, args);\\n    } else if (typeof plugin === 'function') {\\n      plugin.apply(null, args);\\n    }\\n    plugin.installed = true;\\n    return this\\n  };\\n}\\n\\n/*  */\\n\\nfunction initMixin$1 (Vue) {\\n  Vue.mixin = function (mixin) {\\n    this.options = mergeOptions(this.options, mixin);\\n  };\\n}\\n\\n/*  */\\n\\nfunction initExtend (Vue) {\\n  /**\\n   * Each instance constructor, including Vue, has a unique\\n   * cid. This enables us to create wrapped \\\"child\\n   * constructors\\\" for prototypal inheritance and cache them.\\n   */\\n  Vue.cid = 0;\\n  var cid = 1;\\n\\n  /**\\n   * Class inheritance\\n   */\\n  Vue.extend = function (extendOptions) {\\n    extendOptions = extendOptions || {};\\n    var Super = this;\\n    var SuperId = Super.cid;\\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\\n    if (cachedCtors[SuperId]) {\\n      return cachedCtors[SuperId]\\n    }\\n\\n    var name = extendOptions.name || Super.options.name;\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (!/^[a-zA-Z][\\\\w-]*$/.test(name)) {\\n        warn(\\n          'Invalid component name: \\\"' + name + '\\\". Component names ' +\\n          'can only contain alphanumeric characters and the hyphen, ' +\\n          'and must start with a letter.'\\n        );\\n      }\\n    }\\n\\n    var Sub = function VueComponent (options) {\\n      this._init(options);\\n    };\\n    Sub.prototype = Object.create(Super.prototype);\\n    Sub.prototype.constructor = Sub;\\n    Sub.cid = cid++;\\n    Sub.options = mergeOptions(\\n      Super.options,\\n      extendOptions\\n    );\\n    Sub['super'] = Super;\\n\\n    // For props and computed properties, we define the proxy getters on\\n    // the Vue instances at extension time, on the extended prototype. This\\n    // avoids Object.defineProperty calls for each instance created.\\n    if (Sub.options.props) {\\n      initProps$1(Sub);\\n    }\\n    if (Sub.options.computed) {\\n      initComputed$1(Sub);\\n    }\\n\\n    // allow further extension/mixin/plugin usage\\n    Sub.extend = Super.extend;\\n    Sub.mixin = Super.mixin;\\n    Sub.use = Super.use;\\n\\n    // create asset registers, so extended classes\\n    // can have their private assets too.\\n    config._assetTypes.forEach(function (type) {\\n      Sub[type] = Super[type];\\n    });\\n    // enable recursive self-lookup\\n    if (name) {\\n      Sub.options.components[name] = Sub;\\n    }\\n\\n    // keep a reference to the super options at extension time.\\n    // later at instantiation we can check if Super's options have\\n    // been updated.\\n    Sub.superOptions = Super.options;\\n    Sub.extendOptions = extendOptions;\\n    Sub.sealedOptions = extend({}, Sub.options);\\n\\n    // cache constructor\\n    cachedCtors[SuperId] = Sub;\\n    return Sub\\n  };\\n}\\n\\nfunction initProps$1 (Comp) {\\n  var props = Comp.options.props;\\n  for (var key in props) {\\n    proxy(Comp.prototype, \\\"_props\\\", key);\\n  }\\n}\\n\\nfunction initComputed$1 (Comp) {\\n  var computed = Comp.options.computed;\\n  for (var key in computed) {\\n    defineComputed(Comp.prototype, key, computed[key]);\\n  }\\n}\\n\\n/*  */\\n\\nfunction initAssetRegisters (Vue) {\\n  /**\\n   * Create asset registration methods.\\n   */\\n  config._assetTypes.forEach(function (type) {\\n    Vue[type] = function (\\n      id,\\n      definition\\n    ) {\\n      if (!definition) {\\n        return this.options[type + 's'][id]\\n      } else {\\n        /* istanbul ignore if */\\n        if (process.env.NODE_ENV !== 'production') {\\n          if (type === 'component' && config.isReservedTag(id)) {\\n            warn(\\n              'Do not use built-in or reserved HTML elements as component ' +\\n              'id: ' + id\\n            );\\n          }\\n        }\\n        if (type === 'component' && isPlainObject(definition)) {\\n          definition.name = definition.name || id;\\n          definition = this.options._base.extend(definition);\\n        }\\n        if (type === 'directive' && typeof definition === 'function') {\\n          definition = { bind: definition, update: definition };\\n        }\\n        this.options[type + 's'][id] = definition;\\n        return definition\\n      }\\n    };\\n  });\\n}\\n\\n/*  */\\n\\nvar patternTypes = [String, RegExp];\\n\\nfunction getComponentName (opts) {\\n  return opts && (opts.Ctor.options.name || opts.tag)\\n}\\n\\nfunction matches (pattern, name) {\\n  if (typeof pattern === 'string') {\\n    return pattern.split(',').indexOf(name) > -1\\n  } else if (pattern instanceof RegExp) {\\n    return pattern.test(name)\\n  }\\n  /* istanbul ignore next */\\n  return false\\n}\\n\\nfunction pruneCache (cache, filter) {\\n  for (var key in cache) {\\n    var cachedNode = cache[key];\\n    if (cachedNode) {\\n      var name = getComponentName(cachedNode.componentOptions);\\n      if (name && !filter(name)) {\\n        pruneCacheEntry(cachedNode);\\n        cache[key] = null;\\n      }\\n    }\\n  }\\n}\\n\\nfunction pruneCacheEntry (vnode) {\\n  if (vnode) {\\n    if (!vnode.componentInstance._inactive) {\\n      callHook(vnode.componentInstance, 'deactivated');\\n    }\\n    vnode.componentInstance.$destroy();\\n  }\\n}\\n\\nvar KeepAlive = {\\n  name: 'keep-alive',\\n  abstract: true,\\n\\n  props: {\\n    include: patternTypes,\\n    exclude: patternTypes\\n  },\\n\\n  created: function created () {\\n    this.cache = Object.create(null);\\n  },\\n\\n  destroyed: function destroyed () {\\n    var this$1 = this;\\n\\n    for (var key in this$1.cache) {\\n      pruneCacheEntry(this$1.cache[key]);\\n    }\\n  },\\n\\n  watch: {\\n    include: function include (val) {\\n      pruneCache(this.cache, function (name) { return matches(val, name); });\\n    },\\n    exclude: function exclude (val) {\\n      pruneCache(this.cache, function (name) { return !matches(val, name); });\\n    }\\n  },\\n\\n  render: function render () {\\n    var vnode = getFirstComponentChild(this.$slots.default);\\n    var componentOptions = vnode && vnode.componentOptions;\\n    if (componentOptions) {\\n      // check pattern\\n      var name = getComponentName(componentOptions);\\n      if (name && (\\n        (this.include && !matches(this.include, name)) ||\\n        (this.exclude && matches(this.exclude, name))\\n      )) {\\n        return vnode\\n      }\\n      var key = vnode.key == null\\n        // same constructor may get registered as different local components\\n        // so cid alone is not enough (#3269)\\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\\\"::\\\" + (componentOptions.tag)) : '')\\n        : vnode.key;\\n      if (this.cache[key]) {\\n        vnode.componentInstance = this.cache[key].componentInstance;\\n      } else {\\n        this.cache[key] = vnode;\\n      }\\n      vnode.data.keepAlive = true;\\n    }\\n    return vnode\\n  }\\n};\\n\\nvar builtInComponents = {\\n  KeepAlive: KeepAlive\\n};\\n\\n/*  */\\n\\nfunction initGlobalAPI (Vue) {\\n  // config\\n  var configDef = {};\\n  configDef.get = function () { return config; };\\n  if (process.env.NODE_ENV !== 'production') {\\n    configDef.set = function () {\\n      warn(\\n        'Do not replace the Vue.config object, set individual fields instead.'\\n      );\\n    };\\n  }\\n  Object.defineProperty(Vue, 'config', configDef);\\n\\n  // exposed util methods.\\n  // NOTE: these are not considered part of the public API - avoid relying on\\n  // them unless you are aware of the risk.\\n  Vue.util = {\\n    warn: warn,\\n    extend: extend,\\n    mergeOptions: mergeOptions,\\n    defineReactive: defineReactive$$1\\n  };\\n\\n  Vue.set = set;\\n  Vue.delete = del;\\n  Vue.nextTick = nextTick;\\n\\n  Vue.options = Object.create(null);\\n  config._assetTypes.forEach(function (type) {\\n    Vue.options[type + 's'] = Object.create(null);\\n  });\\n\\n  // this is used to identify the \\\"base\\\" constructor to extend all plain-object\\n  // components with in Weex's multi-instance scenarios.\\n  Vue.options._base = Vue;\\n\\n  extend(Vue.options.components, builtInComponents);\\n\\n  initUse(Vue);\\n  initMixin$1(Vue);\\n  initExtend(Vue);\\n  initAssetRegisters(Vue);\\n}\\n\\ninitGlobalAPI(Vue$2);\\n\\nObject.defineProperty(Vue$2.prototype, '$isServer', {\\n  get: isServerRendering\\n});\\n\\nVue$2.version = '2.2.6';\\n\\n/*  */\\n\\n// attributes that should be using props for binding\\nvar acceptValue = makeMap('input,textarea,option,select');\\nvar mustUseProp = function (tag, type, attr) {\\n  return (\\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\\n    (attr === 'selected' && tag === 'option') ||\\n    (attr === 'checked' && tag === 'input') ||\\n    (attr === 'muted' && tag === 'video')\\n  )\\n};\\n\\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\\n\\nvar isBooleanAttr = makeMap(\\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\\n  'truespeed,typemustmatch,visible'\\n);\\n\\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\\n\\nvar isXlink = function (name) {\\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\\n};\\n\\nvar getXlinkProp = function (name) {\\n  return isXlink(name) ? name.slice(6, name.length) : ''\\n};\\n\\nvar isFalsyAttrValue = function (val) {\\n  return val == null || val === false\\n};\\n\\n/*  */\\n\\nfunction genClassForVnode (vnode) {\\n  var data = vnode.data;\\n  var parentNode = vnode;\\n  var childNode = vnode;\\n  while (childNode.componentInstance) {\\n    childNode = childNode.componentInstance._vnode;\\n    if (childNode.data) {\\n      data = mergeClassData(childNode.data, data);\\n    }\\n  }\\n  while ((parentNode = parentNode.parent)) {\\n    if (parentNode.data) {\\n      data = mergeClassData(data, parentNode.data);\\n    }\\n  }\\n  return genClassFromData(data)\\n}\\n\\nfunction mergeClassData (child, parent) {\\n  return {\\n    staticClass: concat(child.staticClass, parent.staticClass),\\n    class: child.class\\n      ? [child.class, parent.class]\\n      : parent.class\\n  }\\n}\\n\\nfunction genClassFromData (data) {\\n  var dynamicClass = data.class;\\n  var staticClass = data.staticClass;\\n  if (staticClass || dynamicClass) {\\n    return concat(staticClass, stringifyClass(dynamicClass))\\n  }\\n  /* istanbul ignore next */\\n  return ''\\n}\\n\\nfunction concat (a, b) {\\n  return a ? b ? (a + ' ' + b) : a : (b || '')\\n}\\n\\nfunction stringifyClass (value) {\\n  var res = '';\\n  if (!value) {\\n    return res\\n  }\\n  if (typeof value === 'string') {\\n    return value\\n  }\\n  if (Array.isArray(value)) {\\n    var stringified;\\n    for (var i = 0, l = value.length; i < l; i++) {\\n      if (value[i]) {\\n        if ((stringified = stringifyClass(value[i]))) {\\n          res += stringified + ' ';\\n        }\\n      }\\n    }\\n    return res.slice(0, -1)\\n  }\\n  if (isObject(value)) {\\n    for (var key in value) {\\n      if (value[key]) { res += key + ' '; }\\n    }\\n    return res.slice(0, -1)\\n  }\\n  /* istanbul ignore next */\\n  return res\\n}\\n\\n/*  */\\n\\nvar namespaceMap = {\\n  svg: 'http://www.w3.org/2000/svg',\\n  math: 'http://www.w3.org/1998/Math/MathML'\\n};\\n\\nvar isHTMLTag = makeMap(\\n  'html,body,base,head,link,meta,style,title,' +\\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\\n  'output,progress,select,textarea,' +\\n  'details,dialog,menu,menuitem,summary,' +\\n  'content,element,shadow,template'\\n);\\n\\n// this map is intentionally selective, only covering SVG elements that may\\n// contain child elements.\\nvar isSVG = makeMap(\\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\\n  true\\n);\\n\\n\\n\\nvar isReservedTag = function (tag) {\\n  return isHTMLTag(tag) || isSVG(tag)\\n};\\n\\nfunction getTagNamespace (tag) {\\n  if (isSVG(tag)) {\\n    return 'svg'\\n  }\\n  // basic support for MathML\\n  // note it doesn't support other MathML elements being component roots\\n  if (tag === 'math') {\\n    return 'math'\\n  }\\n}\\n\\nvar unknownElementCache = Object.create(null);\\nfunction isUnknownElement (tag) {\\n  /* istanbul ignore if */\\n  if (!inBrowser) {\\n    return true\\n  }\\n  if (isReservedTag(tag)) {\\n    return false\\n  }\\n  tag = tag.toLowerCase();\\n  /* istanbul ignore if */\\n  if (unknownElementCache[tag] != null) {\\n    return unknownElementCache[tag]\\n  }\\n  var el = document.createElement(tag);\\n  if (tag.indexOf('-') > -1) {\\n    // http://stackoverflow.com/a/28210364/1070244\\n    return (unknownElementCache[tag] = (\\n      el.constructor === window.HTMLUnknownElement ||\\n      el.constructor === window.HTMLElement\\n    ))\\n  } else {\\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\\n  }\\n}\\n\\n/*  */\\n\\n/**\\n * Query an element selector if it's not an element already.\\n */\\nfunction query (el) {\\n  if (typeof el === 'string') {\\n    var selected = document.querySelector(el);\\n    if (!selected) {\\n      process.env.NODE_ENV !== 'production' && warn(\\n        'Cannot find element: ' + el\\n      );\\n      return document.createElement('div')\\n    }\\n    return selected\\n  } else {\\n    return el\\n  }\\n}\\n\\n/*  */\\n\\nfunction createElement$1 (tagName, vnode) {\\n  var elm = document.createElement(tagName);\\n  if (tagName !== 'select') {\\n    return elm\\n  }\\n  // false or null will remove the attribute but undefined will not\\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\\n    elm.setAttribute('multiple', 'multiple');\\n  }\\n  return elm\\n}\\n\\nfunction createElementNS (namespace, tagName) {\\n  return document.createElementNS(namespaceMap[namespace], tagName)\\n}\\n\\nfunction createTextNode (text) {\\n  return document.createTextNode(text)\\n}\\n\\nfunction createComment (text) {\\n  return document.createComment(text)\\n}\\n\\nfunction insertBefore (parentNode, newNode, referenceNode) {\\n  parentNode.insertBefore(newNode, referenceNode);\\n}\\n\\nfunction removeChild (node, child) {\\n  node.removeChild(child);\\n}\\n\\nfunction appendChild (node, child) {\\n  node.appendChild(child);\\n}\\n\\nfunction parentNode (node) {\\n  return node.parentNode\\n}\\n\\nfunction nextSibling (node) {\\n  return node.nextSibling\\n}\\n\\nfunction tagName (node) {\\n  return node.tagName\\n}\\n\\nfunction setTextContent (node, text) {\\n  node.textContent = text;\\n}\\n\\nfunction setAttribute (node, key, val) {\\n  node.setAttribute(key, val);\\n}\\n\\n\\nvar nodeOps = Object.freeze({\\n\\tcreateElement: createElement$1,\\n\\tcreateElementNS: createElementNS,\\n\\tcreateTextNode: createTextNode,\\n\\tcreateComment: createComment,\\n\\tinsertBefore: insertBefore,\\n\\tremoveChild: removeChild,\\n\\tappendChild: appendChild,\\n\\tparentNode: parentNode,\\n\\tnextSibling: nextSibling,\\n\\ttagName: tagName,\\n\\tsetTextContent: setTextContent,\\n\\tsetAttribute: setAttribute\\n});\\n\\n/*  */\\n\\nvar ref = {\\n  create: function create (_, vnode) {\\n    registerRef(vnode);\\n  },\\n  update: function update (oldVnode, vnode) {\\n    if (oldVnode.data.ref !== vnode.data.ref) {\\n      registerRef(oldVnode, true);\\n      registerRef(vnode);\\n    }\\n  },\\n  destroy: function destroy (vnode) {\\n    registerRef(vnode, true);\\n  }\\n};\\n\\nfunction registerRef (vnode, isRemoval) {\\n  var key = vnode.data.ref;\\n  if (!key) { return }\\n\\n  var vm = vnode.context;\\n  var ref = vnode.componentInstance || vnode.elm;\\n  var refs = vm.$refs;\\n  if (isRemoval) {\\n    if (Array.isArray(refs[key])) {\\n      remove(refs[key], ref);\\n    } else if (refs[key] === ref) {\\n      refs[key] = undefined;\\n    }\\n  } else {\\n    if (vnode.data.refInFor) {\\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\\n        refs[key].push(ref);\\n      } else {\\n        refs[key] = [ref];\\n      }\\n    } else {\\n      refs[key] = ref;\\n    }\\n  }\\n}\\n\\n/**\\n * Virtual DOM patching algorithm based on Snabbdom by\\n * Simon Friis Vindum (@paldepind)\\n * Licensed under the MIT License\\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\\n *\\n * modified by Evan You (@yyx990803)\\n *\\n\\n/*\\n * Not type-checking this because this file is perf-critical and the cost\\n * of making flow understand it is not worth it.\\n */\\n\\nvar emptyNode = new VNode('', {}, []);\\n\\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\\n\\nfunction isUndef (v) {\\n  return v === undefined || v === null\\n}\\n\\nfunction isDef (v) {\\n  return v !== undefined && v !== null\\n}\\n\\nfunction isTrue (v) {\\n  return v === true\\n}\\n\\nfunction sameVnode (a, b) {\\n  return (\\n    a.key === b.key &&\\n    a.tag === b.tag &&\\n    a.isComment === b.isComment &&\\n    isDef(a.data) === isDef(b.data) &&\\n    sameInputType(a, b)\\n  )\\n}\\n\\n// Some browsers do not support dynamically changing type for <input>\\n// so they need to be treated as different nodes\\nfunction sameInputType (a, b) {\\n  if (a.tag !== 'input') { return true }\\n  var i;\\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\\n  return typeA === typeB\\n}\\n\\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\\n  var i, key;\\n  var map = {};\\n  for (i = beginIdx; i <= endIdx; ++i) {\\n    key = children[i].key;\\n    if (isDef(key)) { map[key] = i; }\\n  }\\n  return map\\n}\\n\\nfunction createPatchFunction (backend) {\\n  var i, j;\\n  var cbs = {};\\n\\n  var modules = backend.modules;\\n  var nodeOps = backend.nodeOps;\\n\\n  for (i = 0; i < hooks.length; ++i) {\\n    cbs[hooks[i]] = [];\\n    for (j = 0; j < modules.length; ++j) {\\n      if (isDef(modules[j][hooks[i]])) {\\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\\n      }\\n    }\\n  }\\n\\n  function emptyNodeAt (elm) {\\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\\n  }\\n\\n  function createRmCb (childElm, listeners) {\\n    function remove$$1 () {\\n      if (--remove$$1.listeners === 0) {\\n        removeNode(childElm);\\n      }\\n    }\\n    remove$$1.listeners = listeners;\\n    return remove$$1\\n  }\\n\\n  function removeNode (el) {\\n    var parent = nodeOps.parentNode(el);\\n    // element may have already been removed due to v-html / v-text\\n    if (isDef(parent)) {\\n      nodeOps.removeChild(parent, el);\\n    }\\n  }\\n\\n  var inPre = 0;\\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\\n    vnode.isRootInsert = !nested; // for transition enter check\\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\\n      return\\n    }\\n\\n    var data = vnode.data;\\n    var children = vnode.children;\\n    var tag = vnode.tag;\\n    if (isDef(tag)) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        if (data && data.pre) {\\n          inPre++;\\n        }\\n        if (\\n          !inPre &&\\n          !vnode.ns &&\\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\\n          config.isUnknownElement(tag)\\n        ) {\\n          warn(\\n            'Unknown custom element: <' + tag + '> - did you ' +\\n            'register the component correctly? For recursive components, ' +\\n            'make sure to provide the \\\"name\\\" option.',\\n            vnode.context\\n          );\\n        }\\n      }\\n      vnode.elm = vnode.ns\\n        ? nodeOps.createElementNS(vnode.ns, tag)\\n        : nodeOps.createElement(tag, vnode);\\n      setScope(vnode);\\n\\n      /* istanbul ignore if */\\n      {\\n        createChildren(vnode, children, insertedVnodeQueue);\\n        if (isDef(data)) {\\n          invokeCreateHooks(vnode, insertedVnodeQueue);\\n        }\\n        insert(parentElm, vnode.elm, refElm);\\n      }\\n\\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\\n        inPre--;\\n      }\\n    } else if (isTrue(vnode.isComment)) {\\n      vnode.elm = nodeOps.createComment(vnode.text);\\n      insert(parentElm, vnode.elm, refElm);\\n    } else {\\n      vnode.elm = nodeOps.createTextNode(vnode.text);\\n      insert(parentElm, vnode.elm, refElm);\\n    }\\n  }\\n\\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\\n    var i = vnode.data;\\n    if (isDef(i)) {\\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\\n        i(vnode, false /* hydrating */, parentElm, refElm);\\n      }\\n      // after calling the init hook, if the vnode is a child component\\n      // it should've created a child instance and mounted it. the child\\n      // component also has set the placeholder vnode's elm.\\n      // in that case we can just return the element and be done.\\n      if (isDef(vnode.componentInstance)) {\\n        initComponent(vnode, insertedVnodeQueue);\\n        if (isTrue(isReactivated)) {\\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\\n        }\\n        return true\\n      }\\n    }\\n  }\\n\\n  function initComponent (vnode, insertedVnodeQueue) {\\n    if (isDef(vnode.data.pendingInsert)) {\\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\\n    }\\n    vnode.elm = vnode.componentInstance.$el;\\n    if (isPatchable(vnode)) {\\n      invokeCreateHooks(vnode, insertedVnodeQueue);\\n      setScope(vnode);\\n    } else {\\n      // empty component root.\\n      // skip all element-related modules except for ref (#3455)\\n      registerRef(vnode);\\n      // make sure to invoke the insert hook\\n      insertedVnodeQueue.push(vnode);\\n    }\\n  }\\n\\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\\n    var i;\\n    // hack for #4339: a reactivated component with inner transition\\n    // does not trigger because the inner node's created hooks are not called\\n    // again. It's not ideal to involve module-specific logic in here but\\n    // there doesn't seem to be a better way to do it.\\n    var innerNode = vnode;\\n    while (innerNode.componentInstance) {\\n      innerNode = innerNode.componentInstance._vnode;\\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\\n        for (i = 0; i < cbs.activate.length; ++i) {\\n          cbs.activate[i](emptyNode, innerNode);\\n        }\\n        insertedVnodeQueue.push(innerNode);\\n        break\\n      }\\n    }\\n    // unlike a newly created component,\\n    // a reactivated keep-alive component doesn't insert itself\\n    insert(parentElm, vnode.elm, refElm);\\n  }\\n\\n  function insert (parent, elm, ref) {\\n    if (isDef(parent)) {\\n      if (isDef(ref)) {\\n        nodeOps.insertBefore(parent, elm, ref);\\n      } else {\\n        nodeOps.appendChild(parent, elm);\\n      }\\n    }\\n  }\\n\\n  function createChildren (vnode, children, insertedVnodeQueue) {\\n    if (Array.isArray(children)) {\\n      for (var i = 0; i < children.length; ++i) {\\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\\n      }\\n    } else if (isPrimitive(vnode.text)) {\\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\\n    }\\n  }\\n\\n  function isPatchable (vnode) {\\n    while (vnode.componentInstance) {\\n      vnode = vnode.componentInstance._vnode;\\n    }\\n    return isDef(vnode.tag)\\n  }\\n\\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\\n      cbs.create[i$1](emptyNode, vnode);\\n    }\\n    i = vnode.data.hook; // Reuse variable\\n    if (isDef(i)) {\\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\\n    }\\n  }\\n\\n  // set scope id attribute for scoped CSS.\\n  // this is implemented as a special case to avoid the overhead\\n  // of going through the normal attribute patching process.\\n  function setScope (vnode) {\\n    var i;\\n    var ancestor = vnode;\\n    while (ancestor) {\\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\\n        nodeOps.setAttribute(vnode.elm, i, '');\\n      }\\n      ancestor = ancestor.parent;\\n    }\\n    // for slot content they should also get the scopeId from the host instance.\\n    if (isDef(i = activeInstance) &&\\n        i !== vnode.context &&\\n        isDef(i = i.$options._scopeId)) {\\n      nodeOps.setAttribute(vnode.elm, i, '');\\n    }\\n  }\\n\\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\\n    for (; startIdx <= endIdx; ++startIdx) {\\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\\n    }\\n  }\\n\\n  function invokeDestroyHook (vnode) {\\n    var i, j;\\n    var data = vnode.data;\\n    if (isDef(data)) {\\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\\n    }\\n    if (isDef(i = vnode.children)) {\\n      for (j = 0; j < vnode.children.length; ++j) {\\n        invokeDestroyHook(vnode.children[j]);\\n      }\\n    }\\n  }\\n\\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\\n    for (; startIdx <= endIdx; ++startIdx) {\\n      var ch = vnodes[startIdx];\\n      if (isDef(ch)) {\\n        if (isDef(ch.tag)) {\\n          removeAndInvokeRemoveHook(ch);\\n          invokeDestroyHook(ch);\\n        } else { // Text node\\n          removeNode(ch.elm);\\n        }\\n      }\\n    }\\n  }\\n\\n  function removeAndInvokeRemoveHook (vnode, rm) {\\n    if (isDef(rm) || isDef(vnode.data)) {\\n      var listeners = cbs.remove.length + 1;\\n      if (isDef(rm)) {\\n        // we have a recursively passed down rm callback\\n        // increase the listeners count\\n        rm.listeners += listeners;\\n      } else {\\n        // directly removing\\n        rm = createRmCb(vnode.elm, listeners);\\n      }\\n      // recursively invoke hooks on child component root node\\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\\n        removeAndInvokeRemoveHook(i, rm);\\n      }\\n      for (i = 0; i < cbs.remove.length; ++i) {\\n        cbs.remove[i](vnode, rm);\\n      }\\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\\n        i(vnode, rm);\\n      } else {\\n        rm();\\n      }\\n    } else {\\n      removeNode(vnode.elm);\\n    }\\n  }\\n\\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\\n    var oldStartIdx = 0;\\n    var newStartIdx = 0;\\n    var oldEndIdx = oldCh.length - 1;\\n    var oldStartVnode = oldCh[0];\\n    var oldEndVnode = oldCh[oldEndIdx];\\n    var newEndIdx = newCh.length - 1;\\n    var newStartVnode = newCh[0];\\n    var newEndVnode = newCh[newEndIdx];\\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\\n\\n    // removeOnly is a special flag used only by <transition-group>\\n    // to ensure removed elements stay in correct relative positions\\n    // during leaving transitions\\n    var canMove = !removeOnly;\\n\\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\\n      if (isUndef(oldStartVnode)) {\\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\\n      } else if (isUndef(oldEndVnode)) {\\n        oldEndVnode = oldCh[--oldEndIdx];\\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\\n        oldStartVnode = oldCh[++oldStartIdx];\\n        newStartVnode = newCh[++newStartIdx];\\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\\n        oldEndVnode = oldCh[--oldEndIdx];\\n        newEndVnode = newCh[--newEndIdx];\\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\\n        oldStartVnode = oldCh[++oldStartIdx];\\n        newEndVnode = newCh[--newEndIdx];\\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\\n        oldEndVnode = oldCh[--oldEndIdx];\\n        newStartVnode = newCh[++newStartIdx];\\n      } else {\\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\\n        if (isUndef(idxInOld)) { // New element\\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\\n          newStartVnode = newCh[++newStartIdx];\\n        } else {\\n          elmToMove = oldCh[idxInOld];\\n          /* istanbul ignore if */\\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\\n            warn(\\n              'It seems there are duplicate keys that is causing an update error. ' +\\n              'Make sure each v-for item has a unique key.'\\n            );\\n          }\\n          if (sameVnode(elmToMove, newStartVnode)) {\\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\\n            oldCh[idxInOld] = undefined;\\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\\n            newStartVnode = newCh[++newStartIdx];\\n          } else {\\n            // same key but different element. treat as new element\\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\\n            newStartVnode = newCh[++newStartIdx];\\n          }\\n        }\\n      }\\n    }\\n    if (oldStartIdx > oldEndIdx) {\\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\\n    } else if (newStartIdx > newEndIdx) {\\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\\n    }\\n  }\\n\\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\\n    if (oldVnode === vnode) {\\n      return\\n    }\\n    // reuse element for static trees.\\n    // note we only do this if the vnode is cloned -\\n    // if the new node is not cloned it means the render functions have been\\n    // reset by the hot-reload-api and we need to do a proper re-render.\\n    if (isTrue(vnode.isStatic) &&\\n        isTrue(oldVnode.isStatic) &&\\n        vnode.key === oldVnode.key &&\\n        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\\n      vnode.elm = oldVnode.elm;\\n      vnode.componentInstance = oldVnode.componentInstance;\\n      return\\n    }\\n    var i;\\n    var data = vnode.data;\\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\\n      i(oldVnode, vnode);\\n    }\\n    var elm = vnode.elm = oldVnode.elm;\\n    var oldCh = oldVnode.children;\\n    var ch = vnode.children;\\n    if (isDef(data) && isPatchable(vnode)) {\\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\\n    }\\n    if (isUndef(vnode.text)) {\\n      if (isDef(oldCh) && isDef(ch)) {\\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\\n      } else if (isDef(ch)) {\\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\\n      } else if (isDef(oldCh)) {\\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\\n      } else if (isDef(oldVnode.text)) {\\n        nodeOps.setTextContent(elm, '');\\n      }\\n    } else if (oldVnode.text !== vnode.text) {\\n      nodeOps.setTextContent(elm, vnode.text);\\n    }\\n    if (isDef(data)) {\\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\\n    }\\n  }\\n\\n  function invokeInsertHook (vnode, queue, initial) {\\n    // delay insert hooks for component root nodes, invoke them after the\\n    // element is really inserted\\n    if (isTrue(initial) && isDef(vnode.parent)) {\\n      vnode.parent.data.pendingInsert = queue;\\n    } else {\\n      for (var i = 0; i < queue.length; ++i) {\\n        queue[i].data.hook.insert(queue[i]);\\n      }\\n    }\\n  }\\n\\n  var bailed = false;\\n  // list of modules that can skip create hook during hydration because they\\n  // are already rendered on the client or has no need for initialization\\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\\n\\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\\n  function hydrate (elm, vnode, insertedVnodeQueue) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (!assertNodeMatch(elm, vnode)) {\\n        return false\\n      }\\n    }\\n    vnode.elm = elm;\\n    var tag = vnode.tag;\\n    var data = vnode.data;\\n    var children = vnode.children;\\n    if (isDef(data)) {\\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\\n      if (isDef(i = vnode.componentInstance)) {\\n        // child component. it should have hydrated its own tree.\\n        initComponent(vnode, insertedVnodeQueue);\\n        return true\\n      }\\n    }\\n    if (isDef(tag)) {\\n      if (isDef(children)) {\\n        // empty element, allow client to pick up and populate children\\n        if (!elm.hasChildNodes()) {\\n          createChildren(vnode, children, insertedVnodeQueue);\\n        } else {\\n          var childrenMatch = true;\\n          var childNode = elm.firstChild;\\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\\n              childrenMatch = false;\\n              break\\n            }\\n            childNode = childNode.nextSibling;\\n          }\\n          // if childNode is not null, it means the actual childNodes list is\\n          // longer than the virtual children list.\\n          if (!childrenMatch || childNode) {\\n            if (process.env.NODE_ENV !== 'production' &&\\n                typeof console !== 'undefined' &&\\n                !bailed) {\\n              bailed = true;\\n              console.warn('Parent: ', elm);\\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\\n            }\\n            return false\\n          }\\n        }\\n      }\\n      if (isDef(data)) {\\n        for (var key in data) {\\n          if (!isRenderedModule(key)) {\\n            invokeCreateHooks(vnode, insertedVnodeQueue);\\n            break\\n          }\\n        }\\n      }\\n    } else if (elm.data !== vnode.text) {\\n      elm.data = vnode.text;\\n    }\\n    return true\\n  }\\n\\n  function assertNodeMatch (node, vnode) {\\n    if (isDef(vnode.tag)) {\\n      return (\\n        vnode.tag.indexOf('vue-component') === 0 ||\\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\\n      )\\n    } else {\\n      return node.nodeType === (vnode.isComment ? 8 : 3)\\n    }\\n  }\\n\\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\\n    if (isUndef(vnode)) {\\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\\n      return\\n    }\\n\\n    var isInitialPatch = false;\\n    var insertedVnodeQueue = [];\\n\\n    if (isUndef(oldVnode)) {\\n      // empty mount (likely as component), create new root element\\n      isInitialPatch = true;\\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\\n    } else {\\n      var isRealElement = isDef(oldVnode.nodeType);\\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\\n        // patch existing root node\\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\\n      } else {\\n        if (isRealElement) {\\n          // mounting to a real element\\n          // check if this is server-rendered content and if we can perform\\n          // a successful hydration.\\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\\n            oldVnode.removeAttribute('server-rendered');\\n            hydrating = true;\\n          }\\n          if (isTrue(hydrating)) {\\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\\n              return oldVnode\\n            } else if (process.env.NODE_ENV !== 'production') {\\n              warn(\\n                'The client-side rendered virtual DOM tree is not matching ' +\\n                'server-rendered content. This is likely caused by incorrect ' +\\n                'HTML markup, for example nesting block-level elements inside ' +\\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\\n                'full client-side render.'\\n              );\\n            }\\n          }\\n          // either not server-rendered, or hydration failed.\\n          // create an empty node and replace it\\n          oldVnode = emptyNodeAt(oldVnode);\\n        }\\n        // replacing existing element\\n        var oldElm = oldVnode.elm;\\n        var parentElm$1 = nodeOps.parentNode(oldElm);\\n        createElm(\\n          vnode,\\n          insertedVnodeQueue,\\n          // extremely rare edge case: do not insert if old element is in a\\n          // leaving transition. Only happens when combining transition +\\n          // keep-alive + HOCs. (#4590)\\n          oldElm._leaveCb ? null : parentElm$1,\\n          nodeOps.nextSibling(oldElm)\\n        );\\n\\n        if (isDef(vnode.parent)) {\\n          // component root element replaced.\\n          // update parent placeholder node element, recursively\\n          var ancestor = vnode.parent;\\n          while (ancestor) {\\n            ancestor.elm = vnode.elm;\\n            ancestor = ancestor.parent;\\n          }\\n          if (isPatchable(vnode)) {\\n            for (var i = 0; i < cbs.create.length; ++i) {\\n              cbs.create[i](emptyNode, vnode.parent);\\n            }\\n          }\\n        }\\n\\n        if (isDef(parentElm$1)) {\\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\\n        } else if (isDef(oldVnode.tag)) {\\n          invokeDestroyHook(oldVnode);\\n        }\\n      }\\n    }\\n\\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\\n    return vnode.elm\\n  }\\n}\\n\\n/*  */\\n\\nvar directives = {\\n  create: updateDirectives,\\n  update: updateDirectives,\\n  destroy: function unbindDirectives (vnode) {\\n    updateDirectives(vnode, emptyNode);\\n  }\\n};\\n\\nfunction updateDirectives (oldVnode, vnode) {\\n  if (oldVnode.data.directives || vnode.data.directives) {\\n    _update(oldVnode, vnode);\\n  }\\n}\\n\\nfunction _update (oldVnode, vnode) {\\n  var isCreate = oldVnode === emptyNode;\\n  var isDestroy = vnode === emptyNode;\\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\\n\\n  var dirsWithInsert = [];\\n  var dirsWithPostpatch = [];\\n\\n  var key, oldDir, dir;\\n  for (key in newDirs) {\\n    oldDir = oldDirs[key];\\n    dir = newDirs[key];\\n    if (!oldDir) {\\n      // new directive, bind\\n      callHook$1(dir, 'bind', vnode, oldVnode);\\n      if (dir.def && dir.def.inserted) {\\n        dirsWithInsert.push(dir);\\n      }\\n    } else {\\n      // existing directive, update\\n      dir.oldValue = oldDir.value;\\n      callHook$1(dir, 'update', vnode, oldVnode);\\n      if (dir.def && dir.def.componentUpdated) {\\n        dirsWithPostpatch.push(dir);\\n      }\\n    }\\n  }\\n\\n  if (dirsWithInsert.length) {\\n    var callInsert = function () {\\n      for (var i = 0; i < dirsWithInsert.length; i++) {\\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\\n      }\\n    };\\n    if (isCreate) {\\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\\n    } else {\\n      callInsert();\\n    }\\n  }\\n\\n  if (dirsWithPostpatch.length) {\\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\\n      }\\n    });\\n  }\\n\\n  if (!isCreate) {\\n    for (key in oldDirs) {\\n      if (!newDirs[key]) {\\n        // no longer present, unbind\\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\\n      }\\n    }\\n  }\\n}\\n\\nvar emptyModifiers = Object.create(null);\\n\\nfunction normalizeDirectives$1 (\\n  dirs,\\n  vm\\n) {\\n  var res = Object.create(null);\\n  if (!dirs) {\\n    return res\\n  }\\n  var i, dir;\\n  for (i = 0; i < dirs.length; i++) {\\n    dir = dirs[i];\\n    if (!dir.modifiers) {\\n      dir.modifiers = emptyModifiers;\\n    }\\n    res[getRawDirName(dir)] = dir;\\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\\n  }\\n  return res\\n}\\n\\nfunction getRawDirName (dir) {\\n  return dir.rawName || ((dir.name) + \\\".\\\" + (Object.keys(dir.modifiers || {}).join('.')))\\n}\\n\\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\\n  var fn = dir.def && dir.def[hook];\\n  if (fn) {\\n    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\\n  }\\n}\\n\\nvar baseModules = [\\n  ref,\\n  directives\\n];\\n\\n/*  */\\n\\nfunction updateAttrs (oldVnode, vnode) {\\n  if (!oldVnode.data.attrs && !vnode.data.attrs) {\\n    return\\n  }\\n  var key, cur, old;\\n  var elm = vnode.elm;\\n  var oldAttrs = oldVnode.data.attrs || {};\\n  var attrs = vnode.data.attrs || {};\\n  // clone observed objects, as the user probably wants to mutate it\\n  if (attrs.__ob__) {\\n    attrs = vnode.data.attrs = extend({}, attrs);\\n  }\\n\\n  for (key in attrs) {\\n    cur = attrs[key];\\n    old = oldAttrs[key];\\n    if (old !== cur) {\\n      setAttr(elm, key, cur);\\n    }\\n  }\\n  // #4391: in IE9, setting type can reset value for input[type=radio]\\n  /* istanbul ignore if */\\n  if (isIE9 && attrs.value !== oldAttrs.value) {\\n    setAttr(elm, 'value', attrs.value);\\n  }\\n  for (key in oldAttrs) {\\n    if (attrs[key] == null) {\\n      if (isXlink(key)) {\\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\\n      } else if (!isEnumeratedAttr(key)) {\\n        elm.removeAttribute(key);\\n      }\\n    }\\n  }\\n}\\n\\nfunction setAttr (el, key, value) {\\n  if (isBooleanAttr(key)) {\\n    // set attribute for blank value\\n    // e.g. <option disabled>Select one</option>\\n    if (isFalsyAttrValue(value)) {\\n      el.removeAttribute(key);\\n    } else {\\n      el.setAttribute(key, key);\\n    }\\n  } else if (isEnumeratedAttr(key)) {\\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\\n  } else if (isXlink(key)) {\\n    if (isFalsyAttrValue(value)) {\\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\\n    } else {\\n      el.setAttributeNS(xlinkNS, key, value);\\n    }\\n  } else {\\n    if (isFalsyAttrValue(value)) {\\n      el.removeAttribute(key);\\n    } else {\\n      el.setAttribute(key, value);\\n    }\\n  }\\n}\\n\\nvar attrs = {\\n  create: updateAttrs,\\n  update: updateAttrs\\n};\\n\\n/*  */\\n\\nfunction updateClass (oldVnode, vnode) {\\n  var el = vnode.elm;\\n  var data = vnode.data;\\n  var oldData = oldVnode.data;\\n  if (!data.staticClass && !data.class &&\\n      (!oldData || (!oldData.staticClass && !oldData.class))) {\\n    return\\n  }\\n\\n  var cls = genClassForVnode(vnode);\\n\\n  // handle transition classes\\n  var transitionClass = el._transitionClasses;\\n  if (transitionClass) {\\n    cls = concat(cls, stringifyClass(transitionClass));\\n  }\\n\\n  // set the class\\n  if (cls !== el._prevClass) {\\n    el.setAttribute('class', cls);\\n    el._prevClass = cls;\\n  }\\n}\\n\\nvar klass = {\\n  create: updateClass,\\n  update: updateClass\\n};\\n\\n/*  */\\n\\nvar validDivisionCharRE = /[\\\\w).+\\\\-_$\\\\]]/;\\n\\n\\n\\nfunction wrapFilter (exp, filter) {\\n  var i = filter.indexOf('(');\\n  if (i < 0) {\\n    // _f: resolveFilter\\n    return (\\\"_f(\\\\\\\"\\\" + filter + \\\"\\\\\\\")(\\\" + exp + \\\")\\\")\\n  } else {\\n    var name = filter.slice(0, i);\\n    var args = filter.slice(i + 1);\\n    return (\\\"_f(\\\\\\\"\\\" + name + \\\"\\\\\\\")(\\\" + exp + \\\",\\\" + args)\\n  }\\n}\\n\\n/*  */\\n\\n/*  */\\n\\n/**\\n * Cross-platform code generation for component v-model\\n */\\n\\n\\n/**\\n * Cross-platform codegen helper for generating v-model value assignment code.\\n */\\n\\n\\n/**\\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\\n *\\n * for loop possible cases:\\n *\\n * - test\\n * - test[idx]\\n * - test[test1[idx]]\\n * - test[\\\"a\\\"][idx]\\n * - xxx.test[a[a].test1[idx]]\\n * - test.xxx.a[\\\"asa\\\"][test1[idx]]\\n *\\n */\\n\\nvar str;\\nvar index$1;\\n\\n/*  */\\n\\n// in some cases, the event used has to be determined at runtime\\n// so we used some reserved tokens during compile.\\nvar RANGE_TOKEN = '__r';\\nvar CHECKBOX_RADIO_TOKEN = '__c';\\n\\n/*  */\\n\\n// normalize v-model event tokens that can only be determined at runtime.\\n// it's important to place the event as the first in the array because\\n// the whole point is ensuring the v-model callback gets called before\\n// user-attached handlers.\\nfunction normalizeEvents (on) {\\n  var event;\\n  /* istanbul ignore if */\\n  if (on[RANGE_TOKEN]) {\\n    // IE input[type=range] only supports `change` event\\n    event = isIE ? 'change' : 'input';\\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\\n    delete on[RANGE_TOKEN];\\n  }\\n  if (on[CHECKBOX_RADIO_TOKEN]) {\\n    // Chrome fires microtasks in between click/change, leads to #4521\\n    event = isChrome ? 'click' : 'change';\\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\\n    delete on[CHECKBOX_RADIO_TOKEN];\\n  }\\n}\\n\\nvar target$1;\\n\\nfunction add$1 (\\n  event,\\n  handler,\\n  once,\\n  capture\\n) {\\n  if (once) {\\n    var oldHandler = handler;\\n    var _target = target$1; // save current target element in closure\\n    handler = function (ev) {\\n      var res = arguments.length === 1\\n        ? oldHandler(ev)\\n        : oldHandler.apply(null, arguments);\\n      if (res !== null) {\\n        remove$2(event, handler, capture, _target);\\n      }\\n    };\\n  }\\n  target$1.addEventListener(event, handler, capture);\\n}\\n\\nfunction remove$2 (\\n  event,\\n  handler,\\n  capture,\\n  _target\\n) {\\n  (_target || target$1).removeEventListener(event, handler, capture);\\n}\\n\\nfunction updateDOMListeners (oldVnode, vnode) {\\n  if (!oldVnode.data.on && !vnode.data.on) {\\n    return\\n  }\\n  var on = vnode.data.on || {};\\n  var oldOn = oldVnode.data.on || {};\\n  target$1 = vnode.elm;\\n  normalizeEvents(on);\\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\\n}\\n\\nvar events = {\\n  create: updateDOMListeners,\\n  update: updateDOMListeners\\n};\\n\\n/*  */\\n\\nfunction updateDOMProps (oldVnode, vnode) {\\n  if (!oldVnode.data.domProps && !vnode.data.domProps) {\\n    return\\n  }\\n  var key, cur;\\n  var elm = vnode.elm;\\n  var oldProps = oldVnode.data.domProps || {};\\n  var props = vnode.data.domProps || {};\\n  // clone observed objects, as the user probably wants to mutate it\\n  if (props.__ob__) {\\n    props = vnode.data.domProps = extend({}, props);\\n  }\\n\\n  for (key in oldProps) {\\n    if (props[key] == null) {\\n      elm[key] = '';\\n    }\\n  }\\n  for (key in props) {\\n    cur = props[key];\\n    // ignore children if the node has textContent or innerHTML,\\n    // as these will throw away existing DOM nodes and cause removal errors\\n    // on subsequent patches (#3360)\\n    if (key === 'textContent' || key === 'innerHTML') {\\n      if (vnode.children) { vnode.children.length = 0; }\\n      if (cur === oldProps[key]) { continue }\\n    }\\n\\n    if (key === 'value') {\\n      // store value as _value as well since\\n      // non-string values will be stringified\\n      elm._value = cur;\\n      // avoid resetting cursor position when value is the same\\n      var strCur = cur == null ? '' : String(cur);\\n      if (shouldUpdateValue(elm, vnode, strCur)) {\\n        elm.value = strCur;\\n      }\\n    } else {\\n      elm[key] = cur;\\n    }\\n  }\\n}\\n\\n// check platforms/web/util/attrs.js acceptValue\\n\\n\\nfunction shouldUpdateValue (\\n  elm,\\n  vnode,\\n  checkVal\\n) {\\n  return (!elm.composing && (\\n    vnode.tag === 'option' ||\\n    isDirty(elm, checkVal) ||\\n    isInputChanged(elm, checkVal)\\n  ))\\n}\\n\\nfunction isDirty (elm, checkVal) {\\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\\n  return document.activeElement !== elm && elm.value !== checkVal\\n}\\n\\nfunction isInputChanged (elm, newVal) {\\n  var value = elm.value;\\n  var modifiers = elm._vModifiers; // injected by v-model runtime\\n  if ((modifiers && modifiers.number) || elm.type === 'number') {\\n    return toNumber(value) !== toNumber(newVal)\\n  }\\n  if (modifiers && modifiers.trim) {\\n    return value.trim() !== newVal.trim()\\n  }\\n  return value !== newVal\\n}\\n\\nvar domProps = {\\n  create: updateDOMProps,\\n  update: updateDOMProps\\n};\\n\\n/*  */\\n\\nvar parseStyleText = cached(function (cssText) {\\n  var res = {};\\n  var listDelimiter = /;(?![^(]*\\\\))/g;\\n  var propertyDelimiter = /:(.+)/;\\n  cssText.split(listDelimiter).forEach(function (item) {\\n    if (item) {\\n      var tmp = item.split(propertyDelimiter);\\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\\n    }\\n  });\\n  return res\\n});\\n\\n// merge static and dynamic style data on the same vnode\\nfunction normalizeStyleData (data) {\\n  var style = normalizeStyleBinding(data.style);\\n  // static style is pre-processed into an object during compilation\\n  // and is always a fresh object, so it's safe to merge into it\\n  return data.staticStyle\\n    ? extend(data.staticStyle, style)\\n    : style\\n}\\n\\n// normalize possible array / string values into Object\\nfunction normalizeStyleBinding (bindingStyle) {\\n  if (Array.isArray(bindingStyle)) {\\n    return toObject(bindingStyle)\\n  }\\n  if (typeof bindingStyle === 'string') {\\n    return parseStyleText(bindingStyle)\\n  }\\n  return bindingStyle\\n}\\n\\n/**\\n * parent component style should be after child's\\n * so that parent component's style could override it\\n */\\nfunction getStyle (vnode, checkChild) {\\n  var res = {};\\n  var styleData;\\n\\n  if (checkChild) {\\n    var childNode = vnode;\\n    while (childNode.componentInstance) {\\n      childNode = childNode.componentInstance._vnode;\\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\\n        extend(res, styleData);\\n      }\\n    }\\n  }\\n\\n  if ((styleData = normalizeStyleData(vnode.data))) {\\n    extend(res, styleData);\\n  }\\n\\n  var parentNode = vnode;\\n  while ((parentNode = parentNode.parent)) {\\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\\n      extend(res, styleData);\\n    }\\n  }\\n  return res\\n}\\n\\n/*  */\\n\\nvar cssVarRE = /^--/;\\nvar importantRE = /\\\\s*!important$/;\\nvar setProp = function (el, name, val) {\\n  /* istanbul ignore if */\\n  if (cssVarRE.test(name)) {\\n    el.style.setProperty(name, val);\\n  } else if (importantRE.test(val)) {\\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\\n  } else {\\n    el.style[normalize(name)] = val;\\n  }\\n};\\n\\nvar prefixes = ['Webkit', 'Moz', 'ms'];\\n\\nvar testEl;\\nvar normalize = cached(function (prop) {\\n  testEl = testEl || document.createElement('div');\\n  prop = camelize(prop);\\n  if (prop !== 'filter' && (prop in testEl.style)) {\\n    return prop\\n  }\\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\\n  for (var i = 0; i < prefixes.length; i++) {\\n    var prefixed = prefixes[i] + upper;\\n    if (prefixed in testEl.style) {\\n      return prefixed\\n    }\\n  }\\n});\\n\\nfunction updateStyle (oldVnode, vnode) {\\n  var data = vnode.data;\\n  var oldData = oldVnode.data;\\n\\n  if (!data.staticStyle && !data.style &&\\n      !oldData.staticStyle && !oldData.style) {\\n    return\\n  }\\n\\n  var cur, name;\\n  var el = vnode.elm;\\n  var oldStaticStyle = oldVnode.data.staticStyle;\\n  var oldStyleBinding = oldVnode.data.style || {};\\n\\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\\n  var oldStyle = oldStaticStyle || oldStyleBinding;\\n\\n  var style = normalizeStyleBinding(vnode.data.style) || {};\\n\\n  vnode.data.style = style.__ob__ ? extend({}, style) : style;\\n\\n  var newStyle = getStyle(vnode, true);\\n\\n  for (name in oldStyle) {\\n    if (newStyle[name] == null) {\\n      setProp(el, name, '');\\n    }\\n  }\\n  for (name in newStyle) {\\n    cur = newStyle[name];\\n    if (cur !== oldStyle[name]) {\\n      // ie9 setting to null has no effect, must use empty string\\n      setProp(el, name, cur == null ? '' : cur);\\n    }\\n  }\\n}\\n\\nvar style = {\\n  create: updateStyle,\\n  update: updateStyle\\n};\\n\\n/*  */\\n\\n/**\\n * Add class with compatibility for SVG since classList is not supported on\\n * SVG elements in IE\\n */\\nfunction addClass (el, cls) {\\n  /* istanbul ignore if */\\n  if (!cls || !(cls = cls.trim())) {\\n    return\\n  }\\n\\n  /* istanbul ignore else */\\n  if (el.classList) {\\n    if (cls.indexOf(' ') > -1) {\\n      cls.split(/\\\\s+/).forEach(function (c) { return el.classList.add(c); });\\n    } else {\\n      el.classList.add(cls);\\n    }\\n  } else {\\n    var cur = \\\" \\\" + (el.getAttribute('class') || '') + \\\" \\\";\\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\\n      el.setAttribute('class', (cur + cls).trim());\\n    }\\n  }\\n}\\n\\n/**\\n * Remove class with compatibility for SVG since classList is not supported on\\n * SVG elements in IE\\n */\\nfunction removeClass (el, cls) {\\n  /* istanbul ignore if */\\n  if (!cls || !(cls = cls.trim())) {\\n    return\\n  }\\n\\n  /* istanbul ignore else */\\n  if (el.classList) {\\n    if (cls.indexOf(' ') > -1) {\\n      cls.split(/\\\\s+/).forEach(function (c) { return el.classList.remove(c); });\\n    } else {\\n      el.classList.remove(cls);\\n    }\\n  } else {\\n    var cur = \\\" \\\" + (el.getAttribute('class') || '') + \\\" \\\";\\n    var tar = ' ' + cls + ' ';\\n    while (cur.indexOf(tar) >= 0) {\\n      cur = cur.replace(tar, ' ');\\n    }\\n    el.setAttribute('class', cur.trim());\\n  }\\n}\\n\\n/*  */\\n\\nfunction resolveTransition (def$$1) {\\n  if (!def$$1) {\\n    return\\n  }\\n  /* istanbul ignore else */\\n  if (typeof def$$1 === 'object') {\\n    var res = {};\\n    if (def$$1.css !== false) {\\n      extend(res, autoCssTransition(def$$1.name || 'v'));\\n    }\\n    extend(res, def$$1);\\n    return res\\n  } else if (typeof def$$1 === 'string') {\\n    return autoCssTransition(def$$1)\\n  }\\n}\\n\\nvar autoCssTransition = cached(function (name) {\\n  return {\\n    enterClass: (name + \\\"-enter\\\"),\\n    enterToClass: (name + \\\"-enter-to\\\"),\\n    enterActiveClass: (name + \\\"-enter-active\\\"),\\n    leaveClass: (name + \\\"-leave\\\"),\\n    leaveToClass: (name + \\\"-leave-to\\\"),\\n    leaveActiveClass: (name + \\\"-leave-active\\\")\\n  }\\n});\\n\\nvar hasTransition = inBrowser && !isIE9;\\nvar TRANSITION = 'transition';\\nvar ANIMATION = 'animation';\\n\\n// Transition property/event sniffing\\nvar transitionProp = 'transition';\\nvar transitionEndEvent = 'transitionend';\\nvar animationProp = 'animation';\\nvar animationEndEvent = 'animationend';\\nif (hasTransition) {\\n  /* istanbul ignore if */\\n  if (window.ontransitionend === undefined &&\\n    window.onwebkittransitionend !== undefined) {\\n    transitionProp = 'WebkitTransition';\\n    transitionEndEvent = 'webkitTransitionEnd';\\n  }\\n  if (window.onanimationend === undefined &&\\n    window.onwebkitanimationend !== undefined) {\\n    animationProp = 'WebkitAnimation';\\n    animationEndEvent = 'webkitAnimationEnd';\\n  }\\n}\\n\\n// binding to window is necessary to make hot reload work in IE in strict mode\\nvar raf = inBrowser && window.requestAnimationFrame\\n  ? window.requestAnimationFrame.bind(window)\\n  : setTimeout;\\n\\nfunction nextFrame (fn) {\\n  raf(function () {\\n    raf(fn);\\n  });\\n}\\n\\nfunction addTransitionClass (el, cls) {\\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\\n  addClass(el, cls);\\n}\\n\\nfunction removeTransitionClass (el, cls) {\\n  if (el._transitionClasses) {\\n    remove(el._transitionClasses, cls);\\n  }\\n  removeClass(el, cls);\\n}\\n\\nfunction whenTransitionEnds (\\n  el,\\n  expectedType,\\n  cb\\n) {\\n  var ref = getTransitionInfo(el, expectedType);\\n  var type = ref.type;\\n  var timeout = ref.timeout;\\n  var propCount = ref.propCount;\\n  if (!type) { return cb() }\\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\\n  var ended = 0;\\n  var end = function () {\\n    el.removeEventListener(event, onEnd);\\n    cb();\\n  };\\n  var onEnd = function (e) {\\n    if (e.target === el) {\\n      if (++ended >= propCount) {\\n        end();\\n      }\\n    }\\n  };\\n  setTimeout(function () {\\n    if (ended < propCount) {\\n      end();\\n    }\\n  }, timeout + 1);\\n  el.addEventListener(event, onEnd);\\n}\\n\\nvar transformRE = /\\\\b(transform|all)(,|$)/;\\n\\nfunction getTransitionInfo (el, expectedType) {\\n  var styles = window.getComputedStyle(el);\\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\\n\\n  var type;\\n  var timeout = 0;\\n  var propCount = 0;\\n  /* istanbul ignore if */\\n  if (expectedType === TRANSITION) {\\n    if (transitionTimeout > 0) {\\n      type = TRANSITION;\\n      timeout = transitionTimeout;\\n      propCount = transitionDurations.length;\\n    }\\n  } else if (expectedType === ANIMATION) {\\n    if (animationTimeout > 0) {\\n      type = ANIMATION;\\n      timeout = animationTimeout;\\n      propCount = animationDurations.length;\\n    }\\n  } else {\\n    timeout = Math.max(transitionTimeout, animationTimeout);\\n    type = timeout > 0\\n      ? transitionTimeout > animationTimeout\\n        ? TRANSITION\\n        : ANIMATION\\n      : null;\\n    propCount = type\\n      ? type === TRANSITION\\n        ? transitionDurations.length\\n        : animationDurations.length\\n      : 0;\\n  }\\n  var hasTransform =\\n    type === TRANSITION &&\\n    transformRE.test(styles[transitionProp + 'Property']);\\n  return {\\n    type: type,\\n    timeout: timeout,\\n    propCount: propCount,\\n    hasTransform: hasTransform\\n  }\\n}\\n\\nfunction getTimeout (delays, durations) {\\n  /* istanbul ignore next */\\n  while (delays.length < durations.length) {\\n    delays = delays.concat(delays);\\n  }\\n\\n  return Math.max.apply(null, durations.map(function (d, i) {\\n    return toMs(d) + toMs(delays[i])\\n  }))\\n}\\n\\nfunction toMs (s) {\\n  return Number(s.slice(0, -1)) * 1000\\n}\\n\\n/*  */\\n\\nfunction enter (vnode, toggleDisplay) {\\n  var el = vnode.elm;\\n\\n  // call leave callback now\\n  if (el._leaveCb) {\\n    el._leaveCb.cancelled = true;\\n    el._leaveCb();\\n  }\\n\\n  var data = resolveTransition(vnode.data.transition);\\n  if (!data) {\\n    return\\n  }\\n\\n  /* istanbul ignore if */\\n  if (el._enterCb || el.nodeType !== 1) {\\n    return\\n  }\\n\\n  var css = data.css;\\n  var type = data.type;\\n  var enterClass = data.enterClass;\\n  var enterToClass = data.enterToClass;\\n  var enterActiveClass = data.enterActiveClass;\\n  var appearClass = data.appearClass;\\n  var appearToClass = data.appearToClass;\\n  var appearActiveClass = data.appearActiveClass;\\n  var beforeEnter = data.beforeEnter;\\n  var enter = data.enter;\\n  var afterEnter = data.afterEnter;\\n  var enterCancelled = data.enterCancelled;\\n  var beforeAppear = data.beforeAppear;\\n  var appear = data.appear;\\n  var afterAppear = data.afterAppear;\\n  var appearCancelled = data.appearCancelled;\\n  var duration = data.duration;\\n\\n  // activeInstance will always be the <transition> component managing this\\n  // transition. One edge case to check is when the <transition> is placed\\n  // as the root node of a child component. In that case we need to check\\n  // <transition>'s parent for appear check.\\n  var context = activeInstance;\\n  var transitionNode = activeInstance.$vnode;\\n  while (transitionNode && transitionNode.parent) {\\n    transitionNode = transitionNode.parent;\\n    context = transitionNode.context;\\n  }\\n\\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\\n\\n  if (isAppear && !appear && appear !== '') {\\n    return\\n  }\\n\\n  var startClass = isAppear && appearClass\\n    ? appearClass\\n    : enterClass;\\n  var activeClass = isAppear && appearActiveClass\\n    ? appearActiveClass\\n    : enterActiveClass;\\n  var toClass = isAppear && appearToClass\\n    ? appearToClass\\n    : enterToClass;\\n\\n  var beforeEnterHook = isAppear\\n    ? (beforeAppear || beforeEnter)\\n    : beforeEnter;\\n  var enterHook = isAppear\\n    ? (typeof appear === 'function' ? appear : enter)\\n    : enter;\\n  var afterEnterHook = isAppear\\n    ? (afterAppear || afterEnter)\\n    : afterEnter;\\n  var enterCancelledHook = isAppear\\n    ? (appearCancelled || enterCancelled)\\n    : enterCancelled;\\n\\n  var explicitEnterDuration = toNumber(\\n    isObject(duration)\\n      ? duration.enter\\n      : duration\\n  );\\n\\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\\n    checkDuration(explicitEnterDuration, 'enter', vnode);\\n  }\\n\\n  var expectsCSS = css !== false && !isIE9;\\n  var userWantsControl = getHookArgumentsLength(enterHook);\\n\\n  var cb = el._enterCb = once(function () {\\n    if (expectsCSS) {\\n      removeTransitionClass(el, toClass);\\n      removeTransitionClass(el, activeClass);\\n    }\\n    if (cb.cancelled) {\\n      if (expectsCSS) {\\n        removeTransitionClass(el, startClass);\\n      }\\n      enterCancelledHook && enterCancelledHook(el);\\n    } else {\\n      afterEnterHook && afterEnterHook(el);\\n    }\\n    el._enterCb = null;\\n  });\\n\\n  if (!vnode.data.show) {\\n    // remove pending leave element on enter by injecting an insert hook\\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\\n      var parent = el.parentNode;\\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\\n      if (pendingNode &&\\n          pendingNode.tag === vnode.tag &&\\n          pendingNode.elm._leaveCb) {\\n        pendingNode.elm._leaveCb();\\n      }\\n      enterHook && enterHook(el, cb);\\n    });\\n  }\\n\\n  // start enter transition\\n  beforeEnterHook && beforeEnterHook(el);\\n  if (expectsCSS) {\\n    addTransitionClass(el, startClass);\\n    addTransitionClass(el, activeClass);\\n    nextFrame(function () {\\n      addTransitionClass(el, toClass);\\n      removeTransitionClass(el, startClass);\\n      if (!cb.cancelled && !userWantsControl) {\\n        if (isValidDuration(explicitEnterDuration)) {\\n          setTimeout(cb, explicitEnterDuration);\\n        } else {\\n          whenTransitionEnds(el, type, cb);\\n        }\\n      }\\n    });\\n  }\\n\\n  if (vnode.data.show) {\\n    toggleDisplay && toggleDisplay();\\n    enterHook && enterHook(el, cb);\\n  }\\n\\n  if (!expectsCSS && !userWantsControl) {\\n    cb();\\n  }\\n}\\n\\nfunction leave (vnode, rm) {\\n  var el = vnode.elm;\\n\\n  // call enter callback now\\n  if (el._enterCb) {\\n    el._enterCb.cancelled = true;\\n    el._enterCb();\\n  }\\n\\n  var data = resolveTransition(vnode.data.transition);\\n  if (!data) {\\n    return rm()\\n  }\\n\\n  /* istanbul ignore if */\\n  if (el._leaveCb || el.nodeType !== 1) {\\n    return\\n  }\\n\\n  var css = data.css;\\n  var type = data.type;\\n  var leaveClass = data.leaveClass;\\n  var leaveToClass = data.leaveToClass;\\n  var leaveActiveClass = data.leaveActiveClass;\\n  var beforeLeave = data.beforeLeave;\\n  var leave = data.leave;\\n  var afterLeave = data.afterLeave;\\n  var leaveCancelled = data.leaveCancelled;\\n  var delayLeave = data.delayLeave;\\n  var duration = data.duration;\\n\\n  var expectsCSS = css !== false && !isIE9;\\n  var userWantsControl = getHookArgumentsLength(leave);\\n\\n  var explicitLeaveDuration = toNumber(\\n    isObject(duration)\\n      ? duration.leave\\n      : duration\\n  );\\n\\n  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {\\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\\n  }\\n\\n  var cb = el._leaveCb = once(function () {\\n    if (el.parentNode && el.parentNode._pending) {\\n      el.parentNode._pending[vnode.key] = null;\\n    }\\n    if (expectsCSS) {\\n      removeTransitionClass(el, leaveToClass);\\n      removeTransitionClass(el, leaveActiveClass);\\n    }\\n    if (cb.cancelled) {\\n      if (expectsCSS) {\\n        removeTransitionClass(el, leaveClass);\\n      }\\n      leaveCancelled && leaveCancelled(el);\\n    } else {\\n      rm();\\n      afterLeave && afterLeave(el);\\n    }\\n    el._leaveCb = null;\\n  });\\n\\n  if (delayLeave) {\\n    delayLeave(performLeave);\\n  } else {\\n    performLeave();\\n  }\\n\\n  function performLeave () {\\n    // the delayed leave may have already been cancelled\\n    if (cb.cancelled) {\\n      return\\n    }\\n    // record leaving element\\n    if (!vnode.data.show) {\\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\\n    }\\n    beforeLeave && beforeLeave(el);\\n    if (expectsCSS) {\\n      addTransitionClass(el, leaveClass);\\n      addTransitionClass(el, leaveActiveClass);\\n      nextFrame(function () {\\n        addTransitionClass(el, leaveToClass);\\n        removeTransitionClass(el, leaveClass);\\n        if (!cb.cancelled && !userWantsControl) {\\n          if (isValidDuration(explicitLeaveDuration)) {\\n            setTimeout(cb, explicitLeaveDuration);\\n          } else {\\n            whenTransitionEnds(el, type, cb);\\n          }\\n        }\\n      });\\n    }\\n    leave && leave(el, cb);\\n    if (!expectsCSS && !userWantsControl) {\\n      cb();\\n    }\\n  }\\n}\\n\\n// only used in dev mode\\nfunction checkDuration (val, name, vnode) {\\n  if (typeof val !== 'number') {\\n    warn(\\n      \\\"<transition> explicit \\\" + name + \\\" duration is not a valid number - \\\" +\\n      \\\"got \\\" + (JSON.stringify(val)) + \\\".\\\",\\n      vnode.context\\n    );\\n  } else if (isNaN(val)) {\\n    warn(\\n      \\\"<transition> explicit \\\" + name + \\\" duration is NaN - \\\" +\\n      'the duration expression might be incorrect.',\\n      vnode.context\\n    );\\n  }\\n}\\n\\nfunction isValidDuration (val) {\\n  return typeof val === 'number' && !isNaN(val)\\n}\\n\\n/**\\n * Normalize a transition hook's argument length. The hook may be:\\n * - a merged hook (invoker) with the original in .fns\\n * - a wrapped component method (check ._length)\\n * - a plain function (.length)\\n */\\nfunction getHookArgumentsLength (fn) {\\n  if (!fn) { return false }\\n  var invokerFns = fn.fns;\\n  if (invokerFns) {\\n    // invoker\\n    return getHookArgumentsLength(\\n      Array.isArray(invokerFns)\\n        ? invokerFns[0]\\n        : invokerFns\\n    )\\n  } else {\\n    return (fn._length || fn.length) > 1\\n  }\\n}\\n\\nfunction _enter (_, vnode) {\\n  if (!vnode.data.show) {\\n    enter(vnode);\\n  }\\n}\\n\\nvar transition = inBrowser ? {\\n  create: _enter,\\n  activate: _enter,\\n  remove: function remove$$1 (vnode, rm) {\\n    /* istanbul ignore else */\\n    if (!vnode.data.show) {\\n      leave(vnode, rm);\\n    } else {\\n      rm();\\n    }\\n  }\\n} : {};\\n\\nvar platformModules = [\\n  attrs,\\n  klass,\\n  events,\\n  domProps,\\n  style,\\n  transition\\n];\\n\\n/*  */\\n\\n// the directive module should be applied last, after all\\n// built-in modules have been applied.\\nvar modules = platformModules.concat(baseModules);\\n\\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\\n\\n/**\\n * Not type checking this file because flow doesn't like attaching\\n * properties to Elements.\\n */\\n\\n/* istanbul ignore if */\\nif (isIE9) {\\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\\n  document.addEventListener('selectionchange', function () {\\n    var el = document.activeElement;\\n    if (el && el.vmodel) {\\n      trigger(el, 'input');\\n    }\\n  });\\n}\\n\\nvar model$1 = {\\n  inserted: function inserted (el, binding, vnode) {\\n    if (vnode.tag === 'select') {\\n      var cb = function () {\\n        setSelected(el, binding, vnode.context);\\n      };\\n      cb();\\n      /* istanbul ignore if */\\n      if (isIE || isEdge) {\\n        setTimeout(cb, 0);\\n      }\\n    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {\\n      el._vModifiers = binding.modifiers;\\n      if (!binding.modifiers.lazy) {\\n        if (!isAndroid) {\\n          el.addEventListener('compositionstart', onCompositionStart);\\n          el.addEventListener('compositionend', onCompositionEnd);\\n        }\\n        /* istanbul ignore if */\\n        if (isIE9) {\\n          el.vmodel = true;\\n        }\\n      }\\n    }\\n  },\\n  componentUpdated: function componentUpdated (el, binding, vnode) {\\n    if (vnode.tag === 'select') {\\n      setSelected(el, binding, vnode.context);\\n      // in case the options rendered by v-for have changed,\\n      // it's possible that the value is out-of-sync with the rendered options.\\n      // detect such cases and filter out values that no longer has a matching\\n      // option in the DOM.\\n      var needReset = el.multiple\\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\\n      if (needReset) {\\n        trigger(el, 'change');\\n      }\\n    }\\n  }\\n};\\n\\nfunction setSelected (el, binding, vm) {\\n  var value = binding.value;\\n  var isMultiple = el.multiple;\\n  if (isMultiple && !Array.isArray(value)) {\\n    process.env.NODE_ENV !== 'production' && warn(\\n      \\\"<select multiple v-model=\\\\\\\"\\\" + (binding.expression) + \\\"\\\\\\\"> \\\" +\\n      \\\"expects an Array value for its binding, but got \\\" + (Object.prototype.toString.call(value).slice(8, -1)),\\n      vm\\n    );\\n    return\\n  }\\n  var selected, option;\\n  for (var i = 0, l = el.options.length; i < l; i++) {\\n    option = el.options[i];\\n    if (isMultiple) {\\n      selected = looseIndexOf(value, getValue(option)) > -1;\\n      if (option.selected !== selected) {\\n        option.selected = selected;\\n      }\\n    } else {\\n      if (looseEqual(getValue(option), value)) {\\n        if (el.selectedIndex !== i) {\\n          el.selectedIndex = i;\\n        }\\n        return\\n      }\\n    }\\n  }\\n  if (!isMultiple) {\\n    el.selectedIndex = -1;\\n  }\\n}\\n\\nfunction hasNoMatchingOption (value, options) {\\n  for (var i = 0, l = options.length; i < l; i++) {\\n    if (looseEqual(getValue(options[i]), value)) {\\n      return false\\n    }\\n  }\\n  return true\\n}\\n\\nfunction getValue (option) {\\n  return '_value' in option\\n    ? option._value\\n    : option.value\\n}\\n\\nfunction onCompositionStart (e) {\\n  e.target.composing = true;\\n}\\n\\nfunction onCompositionEnd (e) {\\n  e.target.composing = false;\\n  trigger(e.target, 'input');\\n}\\n\\nfunction trigger (el, type) {\\n  var e = document.createEvent('HTMLEvents');\\n  e.initEvent(type, true, true);\\n  el.dispatchEvent(e);\\n}\\n\\n/*  */\\n\\n// recursively search for possible transition defined inside the component root\\nfunction locateNode (vnode) {\\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\\n    ? locateNode(vnode.componentInstance._vnode)\\n    : vnode\\n}\\n\\nvar show = {\\n  bind: function bind (el, ref, vnode) {\\n    var value = ref.value;\\n\\n    vnode = locateNode(vnode);\\n    var transition = vnode.data && vnode.data.transition;\\n    var originalDisplay = el.__vOriginalDisplay =\\n      el.style.display === 'none' ? '' : el.style.display;\\n    if (value && transition && !isIE9) {\\n      vnode.data.show = true;\\n      enter(vnode, function () {\\n        el.style.display = originalDisplay;\\n      });\\n    } else {\\n      el.style.display = value ? originalDisplay : 'none';\\n    }\\n  },\\n\\n  update: function update (el, ref, vnode) {\\n    var value = ref.value;\\n    var oldValue = ref.oldValue;\\n\\n    /* istanbul ignore if */\\n    if (value === oldValue) { return }\\n    vnode = locateNode(vnode);\\n    var transition = vnode.data && vnode.data.transition;\\n    if (transition && !isIE9) {\\n      vnode.data.show = true;\\n      if (value) {\\n        enter(vnode, function () {\\n          el.style.display = el.__vOriginalDisplay;\\n        });\\n      } else {\\n        leave(vnode, function () {\\n          el.style.display = 'none';\\n        });\\n      }\\n    } else {\\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\\n    }\\n  },\\n\\n  unbind: function unbind (\\n    el,\\n    binding,\\n    vnode,\\n    oldVnode,\\n    isDestroy\\n  ) {\\n    if (!isDestroy) {\\n      el.style.display = el.__vOriginalDisplay;\\n    }\\n  }\\n};\\n\\nvar platformDirectives = {\\n  model: model$1,\\n  show: show\\n};\\n\\n/*  */\\n\\n// Provides transition support for a single element/component.\\n// supports transition mode (out-in / in-out)\\n\\nvar transitionProps = {\\n  name: String,\\n  appear: Boolean,\\n  css: Boolean,\\n  mode: String,\\n  type: String,\\n  enterClass: String,\\n  leaveClass: String,\\n  enterToClass: String,\\n  leaveToClass: String,\\n  enterActiveClass: String,\\n  leaveActiveClass: String,\\n  appearClass: String,\\n  appearActiveClass: String,\\n  appearToClass: String,\\n  duration: [Number, String, Object]\\n};\\n\\n// in case the child is also an abstract component, e.g. <keep-alive>\\n// we want to recursively retrieve the real component to be rendered\\nfunction getRealChild (vnode) {\\n  var compOptions = vnode && vnode.componentOptions;\\n  if (compOptions && compOptions.Ctor.options.abstract) {\\n    return getRealChild(getFirstComponentChild(compOptions.children))\\n  } else {\\n    return vnode\\n  }\\n}\\n\\nfunction extractTransitionData (comp) {\\n  var data = {};\\n  var options = comp.$options;\\n  // props\\n  for (var key in options.propsData) {\\n    data[key] = comp[key];\\n  }\\n  // events.\\n  // extract listeners and pass them directly to the transition methods\\n  var listeners = options._parentListeners;\\n  for (var key$1 in listeners) {\\n    data[camelize(key$1)] = listeners[key$1];\\n  }\\n  return data\\n}\\n\\nfunction placeholder (h, rawChild) {\\n  return /\\\\d-keep-alive$/.test(rawChild.tag)\\n    ? h('keep-alive')\\n    : null\\n}\\n\\nfunction hasParentTransition (vnode) {\\n  while ((vnode = vnode.parent)) {\\n    if (vnode.data.transition) {\\n      return true\\n    }\\n  }\\n}\\n\\nfunction isSameChild (child, oldChild) {\\n  return oldChild.key === child.key && oldChild.tag === child.tag\\n}\\n\\nvar Transition = {\\n  name: 'transition',\\n  props: transitionProps,\\n  abstract: true,\\n\\n  render: function render (h) {\\n    var this$1 = this;\\n\\n    var children = this.$slots.default;\\n    if (!children) {\\n      return\\n    }\\n\\n    // filter out text nodes (possible whitespaces)\\n    children = children.filter(function (c) { return c.tag; });\\n    /* istanbul ignore if */\\n    if (!children.length) {\\n      return\\n    }\\n\\n    // warn multiple elements\\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\\n      warn(\\n        '<transition> can only be used on a single element. Use ' +\\n        '<transition-group> for lists.',\\n        this.$parent\\n      );\\n    }\\n\\n    var mode = this.mode;\\n\\n    // warn invalid mode\\n    if (process.env.NODE_ENV !== 'production' &&\\n        mode && mode !== 'in-out' && mode !== 'out-in') {\\n      warn(\\n        'invalid <transition> mode: ' + mode,\\n        this.$parent\\n      );\\n    }\\n\\n    var rawChild = children[0];\\n\\n    // if this is a component root node and the component's\\n    // parent container node also has transition, skip.\\n    if (hasParentTransition(this.$vnode)) {\\n      return rawChild\\n    }\\n\\n    // apply transition data to child\\n    // use getRealChild() to ignore abstract components e.g. keep-alive\\n    var child = getRealChild(rawChild);\\n    /* istanbul ignore if */\\n    if (!child) {\\n      return rawChild\\n    }\\n\\n    if (this._leaving) {\\n      return placeholder(h, rawChild)\\n    }\\n\\n    // ensure a key that is unique to the vnode type and to this transition\\n    // component instance. This key will be used to remove pending leaving nodes\\n    // during entering.\\n    var id = \\\"__transition-\\\" + (this._uid) + \\\"-\\\";\\n    child.key = child.key == null\\n      ? id + child.tag\\n      : isPrimitive(child.key)\\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\\n        : child.key;\\n\\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\\n    var oldRawChild = this._vnode;\\n    var oldChild = getRealChild(oldRawChild);\\n\\n    // mark v-show\\n    // so that the transition module can hand over the control to the directive\\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\\n      child.data.show = true;\\n    }\\n\\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\\n      // replace old child transition data with fresh one\\n      // important for dynamic transitions!\\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\\n      // handle transition mode\\n      if (mode === 'out-in') {\\n        // return placeholder node and queue update when leave finishes\\n        this._leaving = true;\\n        mergeVNodeHook(oldData, 'afterLeave', function () {\\n          this$1._leaving = false;\\n          this$1.$forceUpdate();\\n        });\\n        return placeholder(h, rawChild)\\n      } else if (mode === 'in-out') {\\n        var delayedLeave;\\n        var performLeave = function () { delayedLeave(); };\\n        mergeVNodeHook(data, 'afterEnter', performLeave);\\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\\n      }\\n    }\\n\\n    return rawChild\\n  }\\n};\\n\\n/*  */\\n\\n// Provides transition support for list items.\\n// supports move transitions using the FLIP technique.\\n\\n// Because the vdom's children update algorithm is \\\"unstable\\\" - i.e.\\n// it doesn't guarantee the relative positioning of removed elements,\\n// we force transition-group to update its children into two passes:\\n// in the first pass, we remove all nodes that need to be removed,\\n// triggering their leaving transition; in the second pass, we insert/move\\n// into the final desired state. This way in the second pass removed\\n// nodes will remain where they should be.\\n\\nvar props = extend({\\n  tag: String,\\n  moveClass: String\\n}, transitionProps);\\n\\ndelete props.mode;\\n\\nvar TransitionGroup = {\\n  props: props,\\n\\n  render: function render (h) {\\n    var tag = this.tag || this.$vnode.data.tag || 'span';\\n    var map = Object.create(null);\\n    var prevChildren = this.prevChildren = this.children;\\n    var rawChildren = this.$slots.default || [];\\n    var children = this.children = [];\\n    var transitionData = extractTransitionData(this);\\n\\n    for (var i = 0; i < rawChildren.length; i++) {\\n      var c = rawChildren[i];\\n      if (c.tag) {\\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\\n          children.push(c);\\n          map[c.key] = c\\n          ;(c.data || (c.data = {})).transition = transitionData;\\n        } else if (process.env.NODE_ENV !== 'production') {\\n          var opts = c.componentOptions;\\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\\n          warn((\\\"<transition-group> children must be keyed: <\\\" + name + \\\">\\\"));\\n        }\\n      }\\n    }\\n\\n    if (prevChildren) {\\n      var kept = [];\\n      var removed = [];\\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\\n        var c$1 = prevChildren[i$1];\\n        c$1.data.transition = transitionData;\\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\\n        if (map[c$1.key]) {\\n          kept.push(c$1);\\n        } else {\\n          removed.push(c$1);\\n        }\\n      }\\n      this.kept = h(tag, null, kept);\\n      this.removed = removed;\\n    }\\n\\n    return h(tag, null, children)\\n  },\\n\\n  beforeUpdate: function beforeUpdate () {\\n    // force removing pass\\n    this.__patch__(\\n      this._vnode,\\n      this.kept,\\n      false, // hydrating\\n      true // removeOnly (!important, avoids unnecessary moves)\\n    );\\n    this._vnode = this.kept;\\n  },\\n\\n  updated: function updated () {\\n    var children = this.prevChildren;\\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\\n      return\\n    }\\n\\n    // we divide the work into three loops to avoid mixing DOM reads and writes\\n    // in each iteration - which helps prevent layout thrashing.\\n    children.forEach(callPendingCbs);\\n    children.forEach(recordPosition);\\n    children.forEach(applyTranslation);\\n\\n    // force reflow to put everything in position\\n    var body = document.body;\\n    var f = body.offsetHeight; // eslint-disable-line\\n\\n    children.forEach(function (c) {\\n      if (c.data.moved) {\\n        var el = c.elm;\\n        var s = el.style;\\n        addTransitionClass(el, moveClass);\\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\\n          if (!e || /transform$/.test(e.propertyName)) {\\n            el.removeEventListener(transitionEndEvent, cb);\\n            el._moveCb = null;\\n            removeTransitionClass(el, moveClass);\\n          }\\n        });\\n      }\\n    });\\n  },\\n\\n  methods: {\\n    hasMove: function hasMove (el, moveClass) {\\n      /* istanbul ignore if */\\n      if (!hasTransition) {\\n        return false\\n      }\\n      if (this._hasMove != null) {\\n        return this._hasMove\\n      }\\n      // Detect whether an element with the move class applied has\\n      // CSS transitions. Since the element may be inside an entering\\n      // transition at this very moment, we make a clone of it and remove\\n      // all other transition classes applied to ensure only the move class\\n      // is applied.\\n      var clone = el.cloneNode();\\n      if (el._transitionClasses) {\\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\\n      }\\n      addClass(clone, moveClass);\\n      clone.style.display = 'none';\\n      this.$el.appendChild(clone);\\n      var info = getTransitionInfo(clone);\\n      this.$el.removeChild(clone);\\n      return (this._hasMove = info.hasTransform)\\n    }\\n  }\\n};\\n\\nfunction callPendingCbs (c) {\\n  /* istanbul ignore if */\\n  if (c.elm._moveCb) {\\n    c.elm._moveCb();\\n  }\\n  /* istanbul ignore if */\\n  if (c.elm._enterCb) {\\n    c.elm._enterCb();\\n  }\\n}\\n\\nfunction recordPosition (c) {\\n  c.data.newPos = c.elm.getBoundingClientRect();\\n}\\n\\nfunction applyTranslation (c) {\\n  var oldPos = c.data.pos;\\n  var newPos = c.data.newPos;\\n  var dx = oldPos.left - newPos.left;\\n  var dy = oldPos.top - newPos.top;\\n  if (dx || dy) {\\n    c.data.moved = true;\\n    var s = c.elm.style;\\n    s.transform = s.WebkitTransform = \\\"translate(\\\" + dx + \\\"px,\\\" + dy + \\\"px)\\\";\\n    s.transitionDuration = '0s';\\n  }\\n}\\n\\nvar platformComponents = {\\n  Transition: Transition,\\n  TransitionGroup: TransitionGroup\\n};\\n\\n/*  */\\n\\n// install platform specific utils\\nVue$2.config.mustUseProp = mustUseProp;\\nVue$2.config.isReservedTag = isReservedTag;\\nVue$2.config.getTagNamespace = getTagNamespace;\\nVue$2.config.isUnknownElement = isUnknownElement;\\n\\n// install platform runtime directives & components\\nextend(Vue$2.options.directives, platformDirectives);\\nextend(Vue$2.options.components, platformComponents);\\n\\n// install platform patch function\\nVue$2.prototype.__patch__ = inBrowser ? patch : noop;\\n\\n// public mount method\\nVue$2.prototype.$mount = function (\\n  el,\\n  hydrating\\n) {\\n  el = el && inBrowser ? query(el) : undefined;\\n  return mountComponent(this, el, hydrating)\\n};\\n\\n// devtools global hook\\n/* istanbul ignore next */\\nsetTimeout(function () {\\n  if (config.devtools) {\\n    if (devtools) {\\n      devtools.emit('init', Vue$2);\\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\\n      console[console.info ? 'info' : 'log'](\\n        'Download the Vue Devtools extension for a better development experience:\\\\n' +\\n        'https://github.com/vuejs/vue-devtools'\\n      );\\n    }\\n  }\\n  if (process.env.NODE_ENV !== 'production' &&\\n      config.productionTip !== false &&\\n      inBrowser && typeof console !== 'undefined') {\\n    console[console.info ? 'info' : 'log'](\\n      \\\"You are running Vue in development mode.\\\\n\\\" +\\n      \\\"Make sure to turn on production mode when deploying for production.\\\\n\\\" +\\n      \\\"See more tips at https://vuejs.org/guide/deployment.html\\\"\\n    );\\n  }\\n}, 0);\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (Vue$2);\\n\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(18), __webpack_require__(1)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly5fdnVlQDIuMi42QHZ1ZS9kaXN0L3Z1ZS5ydW50aW1lLmVzbS5qcz8wZmE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlDQUFpQyxFQUFFO0FBQ3JGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7O0FBRXZDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0JBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IscUJBQXFCLGVBQWU7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLHVDQUF1Qyx3QkFBd0IsRUFBRTtBQUNqRSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLG9DQUFvQztBQUNwQztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixVQUFVOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1EQUFtRCxnQ0FBZ0MsRUFBRTtBQUNyRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0IsRUFBRTs7QUFFcEQ7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUMsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUI7QUFDekI7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZELG1CQUFtQiwyQkFBMkI7QUFDOUM7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBa0Q7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3Q0FBd0M7QUFDaEUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsK0JBQStCO0FBQy9GLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQ0FBc0M7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkNBQTZDO0FBQzlFO0FBQ0E7QUFDQSw2Q0FBNkMsNENBQTRDO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDhDQUE4QywyQkFBMkIsRUFBRTtBQUMzRSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEMsNEJBQTRCLEVBQUU7QUFDNUU7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hELDRCQUE0QixnQ0FBZ0M7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FLGlCQUFpQix3QkFBd0IsT0FBTyx1QkFBdUI7QUFDdkU7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPLGtEQUFrRDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0RBQWtEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG1DQUFtQyxnRUFBZ0U7QUFDbkc7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCLE9BQU8sZ0NBQWdDO0FBQy9FLHdEQUF3RCxvQkFBb0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdFQUFnRTtBQUMzRixPQUFPO0FBQ1AsbUNBQW1DLGlDQUFpQztBQUNwRTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxvQkFBb0I7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdDQUFnQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNELHFCQUFxQiw4QkFBOEI7QUFDbkQ7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RCxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDZDQUE2Qzs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0QkFBNEIsRUFBRTtBQUMzRSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywrQkFBK0IsRUFBRTtBQUM5RSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHFDQUFxQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDJDQUEyQyxFQUFFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsY0FBYyxFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRSwwQkFBMEIsRUFBRTtBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0IsRUFBRTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUIsRUFBRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuMi42XG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiBfdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gLyhbXi1dKShbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqL1xuZnVuY3Rpb24gYmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCBmbiBsZW5ndGhcbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBPQkpFQ1RfU1RSSU5HID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX1NUUklOR1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYilcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBwb3NzaWJsZSBjaXJjdWxhciByZWZlcmVuY2VcbiAgICAgIHJldHVybiBhID09PSBiXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuKCk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0ge1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFzc2V0IHR5cGVzIHRoYXQgYSBjb21wb25lbnQgY2FuIG93bi5cbiAgICovXG4gIF9hc3NldFR5cGVzOiBbXG4gICAgJ2NvbXBvbmVudCcsXG4gICAgJ2RpcmVjdGl2ZScsXG4gICAgJ2ZpbHRlcidcbiAgXSxcblxuICAvKipcbiAgICogTGlzdCBvZiBsaWZlY3ljbGUgaG9va3MuXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IFtcbiAgICAnYmVmb3JlQ3JlYXRlJyxcbiAgICAnY3JlYXRlZCcsXG4gICAgJ2JlZm9yZU1vdW50JyxcbiAgICAnbW91bnRlZCcsXG4gICAgJ2JlZm9yZVVwZGF0ZScsXG4gICAgJ3VwZGF0ZWQnLFxuICAgICdiZWZvcmVEZXN0cm95JyxcbiAgICAnZGVzdHJveWVkJyxcbiAgICAnYWN0aXZhdGVkJyxcbiAgICAnZGVhY3RpdmF0ZWQnXG4gIF0sXG5cbiAgLyoqXG4gICAqIE1heCBjaXJjdWxhciB1cGRhdGVzIGFsbG93ZWQgaW4gYSBzY2hlZHVsZXIgZmx1c2ggY3ljbGUuXG4gICAqL1xuICBfbWF4VXBkYXRlQ291bnQ6IDEwMFxufTtcblxuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG4vKiBnbG9iYWxzIE11dGF0aW9uT2JzZXJ2ZXIgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcbnZhciBpc0lPUyA9IFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSk7XG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXG4gKi9cbnZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIHRpbWVyRnVuYztcblxuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIgKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4gIC8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4gIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIGxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IH07XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgcC50aGVuKG5leHRUaWNrSGFuZGxlcikuY2F0Y2gobG9nRXJyb3IpO1xuICAgICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4gICkpIHtcbiAgICAvLyB1c2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTIElFMTEsIGlPUzcsIEFuZHJvaWQgNC40XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGZhbGxiYWNrIHRvIHNldFRpbWVvdXRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2tIYW5kbGVyLCAwKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHF1ZXVlTmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNiKSB7IGNiLmNhbGwoY3R4KTsgfVxuICAgICAgaWYgKF9yZXNvbHZlKSB7IF9yZXNvbHZlKGN0eCk7IH1cbiAgICB9KTtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgICAgdGltZXJGdW5jKCk7XG4gICAgfVxuICAgIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pKCk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxudmFyIHdhcm4gPSBub29wO1xudmFyIHRpcCA9IG5vb3A7XG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyBcIiBcIiArIChcbiAgICAgICAgdm0gPyBmb3JtYXRMb2NhdGlvbihmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIFwiIFwiICsgKFxuICAgICAgICB2bSA/IGZvcm1hdExvY2F0aW9uKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG5hbWUgPSB0eXBlb2Ygdm0gPT09ICdzdHJpbmcnXG4gICAgICA/IHZtXG4gICAgICA6IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5vcHRpb25zXG4gICAgICAgID8gdm0ub3B0aW9ucy5uYW1lXG4gICAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5uYW1lIHx8IHZtLiRvcHRpb25zLl9jb21wb25lbnRUYWdcbiAgICAgICAgICA6IHZtLm5hbWU7XG5cbiAgICB2YXIgZmlsZSA9IHZtLl9pc1Z1ZSAmJiB2bS4kb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciBmb3JtYXRMb2NhdGlvbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoc3RyID09PSBcIjxBbm9ueW1vdXM+XCIpIHtcbiAgICAgIHN0ciArPSBcIiAtIHVzZSB0aGUgXFxcIm5hbWVcXFwiIG9wdGlvbiBmb3IgYmV0dGVyIGRlYnVnZ2luZyBtZXNzYWdlcy5cIjtcbiAgICB9XG4gICAgcmV0dXJuIChcIlxcbihmb3VuZCBpbiBcIiArIHN0ciArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG52YXIgdWlkJDEgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQkMSsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0IChfdGFyZ2V0KSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7IHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7IH1cbiAgRGVwLnRhcmdldCA9IF90YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFjay5wb3AoKTtcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dXG4uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgLy8gYXZvaWQgbGVha2luZyBhcmd1bWVudHM6XG4gICAgLy8gaHR0cDovL2pzcGVyZi5jb20vY2xvc3VyZS13aXRoLWFyZ3VtZW50c1xuICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzJDFbaV07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIHdoZW4gcGFzc2luZyBkb3duIHByb3BzLFxuICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxuICogdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuIENvbnZlcnRpbmcgaXQgd291bGQgZGVmZWF0IHRoZSBvcHRpbWl6YXRpb24uXG4gKi9cbnZhciBvYnNlcnZlclN0YXRlID0ge1xuICBzaG91bGRDb252ZXJ0OiB0cnVlLFxuICBpc1NldHRpbmdQcm9wczogZmFsc2Vcbn07XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvXG4gICAgICA/IHByb3RvQXVnbWVudFxuICAgICAgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXJcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQgKS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgdHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCApLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIGNoaWxkVmFsLmNhbGwodGhpcyksXG4gICAgICAgIHBhcmVudFZhbC5jYWxsKHRoaXMpXG4gICAgICApXG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbFxufVxuXG5jb25maWcuX2xpZmVjeWNsZUhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgICA6IHJlc1xufVxuXG5jb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5XTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaXNCdWlsdEluVGFnKGxvd2VyKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhsb3dlcikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAnaWQ6ICcgKyBrZXlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQpO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gdHlwZW9mIGV4dGVuZHNGcm9tID09PSAnZnVuY3Rpb24nXG4gICAgICA/IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLm9wdGlvbnMsIHZtKVxuICAgICAgOiBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBtaXhpbiA9IGNoaWxkLm1peGluc1tpXTtcbiAgICAgIGlmIChtaXhpbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBWdWUkMikge1xuICAgICAgICBtaXhpbiA9IG1peGluLm9wdGlvbnM7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBtaXhpbiwgdm0pO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBoYW5kbGUgYm9vbGVhbiBwcm9wc1xuICBpZiAoaXNUeXBlKEJvb2xlYW4sIHByb3AudHlwZSkpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFpc1R5cGUoU3RyaW5nLCBwcm9wLnR5cGUpICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgdmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZENvbnZlcnQgPSBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQ7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBwcmV2U2hvdWxkQ29udmVydDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyArXG4gICAgICAnIEV4cGVjdGVkICcgKyBleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpICtcbiAgICAgICcsIGdvdCAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgKyAnLicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCB0aGUgdHlwZSBvZiBhIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChleHBlY3RlZFR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnc3RyaW5nJyk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnTnVtYmVyJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ251bWJlcicpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0Jvb2xlYW4nKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnYm9vbGVhbicpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0Z1bmN0aW9uJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ2Z1bmN0aW9uJyk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXVxufVxuXG5mdW5jdGlvbiBpc1R5cGUgKHR5cGUsIGZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSlcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZ2V0VHlwZShmbltpXSkgPT09IGdldFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjpcIiksIHZtKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbn1cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgXCJyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0byBkZWNsYXJlIHJlYWN0aXZlIGRhdGEgXCIgK1xuICAgICAgXCJwcm9wZXJ0aWVzIGluIHRoZSBkYXRhIG9wdGlvbi5cIixcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhJyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnNcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mdW5jdGlvbmFsQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7fSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gJyc7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIHZub2RlLmNoaWxkcmVuLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9uc1xuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuZnVuY3Rpb24gY2xvbmVWTm9kZXMgKHZub2Rlcykge1xuICB2YXIgbGVuID0gdm5vZGVzLmxlbmd0aDtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzW2ldID0gY2xvbmVWTm9kZSh2bm9kZXNbaV0pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm5zW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmICghY3VyKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFvbGQpIHtcbiAgICAgIGlmICghY3VyLmZucykge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoIW9uW25hbWVdKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoIW9sZEhvb2spIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAob2xkSG9vay5mbnMgJiYgb2xkSG9vay5tZXJnZWQpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdDtcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChjID09IG51bGwgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdCA9IHJlc1tyZXMubGVuZ3RoIC0gMV07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICByZXMucHVzaC5hcHBseShyZXMsIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKSk7XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGxhc3QgJiYgbGFzdC50ZXh0KSB7XG4gICAgICAgIGxhc3QudGV4dCArPSBTdHJpbmcoYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjLnRleHQgJiYgbGFzdCAmJiBsYXN0LnRleHQpIHtcbiAgICAgICAgcmVzW3Jlcy5sZW5ndGggLSAxXSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgaWYgKGMudGFnICYmIGMua2V5ID09IG51bGwgJiYgbmVzdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAmJiBjLmNvbXBvbmVudE9wdGlvbnM7IH0pWzBdXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UkJDEpIHtcbiAgaWYgKG9uY2UkJDEpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzJDEuJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkkMSA8IGw7IGkkMSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb2ZmKGV2ZW50W2kkMV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIHZhciBkZWZhdWx0U2xvdCA9IFtdO1xuICB2YXIgbmFtZSwgY2hpbGQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgICBjaGlsZC5kYXRhICYmIChuYW1lID0gY2hpbGQuZGF0YS5zbG90KSkge1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRTbG90LnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgd2hpdGVzcGFjZVxuICBpZiAoIWRlZmF1bHRTbG90LmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICBzbG90cy5kZWZhdWx0ID0gZGVmYXVsdFNsb3Q7XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zXG4pIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIHJlc1tmbnNbaV1bMF1dID0gZm5zW2ldWzFdO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18oXG4gICAgICAgIHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlZkVsbVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gRE9NIG5vZGVzIChwcmV2ZW50cyBsZWFrKVxuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0gPSB2bS4kb3B0aW9ucy5fcmVmRWxtID0gbnVsbDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgdm0uX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuICB9XG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChoYXNDaGlsZHJlbikge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlcnNbaV0uY2FsbCh2bSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoaG9vayArIFwiIGhvb2tcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgcXVldWUgPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBxdWV1ZS5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQsIHZtO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gY29uZmlnLl9tYXhVcGRhdGVDb3VudCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXNldCBzY2hlZHVsZXIgYmVmb3JlIHVwZGF0ZWQgaG9vayBjYWxsZWRcbiAgdmFyIG9sZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgdXBkYXRlZCBob29rc1xuICBpbmRleCA9IG9sZFF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB3YXRjaGVyID0gb2xkUXVldWVbaW5kZXhdO1xuICAgIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+PSAwICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoTWF0aC5tYXgoaSwgaW5kZXgpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9uc1xuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIGlmICh0aGlzLnVzZXIpIHtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9XG4gIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgaWYgKHRoaXMuZGVlcCkge1xuICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbiAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCkgeyBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpOyB9XG59XG5cbnZhciBpc1Jlc2VydmVkUHJvcCA9IHsga2V5OiAxLCByZWY6IDEsIHNsb3Q6IDEgfTtcblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wW2tleV0pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIW9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5c1tpXSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyAoa2V5c1tpXSkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5c1tpXSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleXNbaV0pO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk5vIGdldHRlciBmdW5jdGlvbiBoYXMgYmVlbiBkZWZpbmVkIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICAgIGdldHRlciA9IG5vb3A7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKHZtLCBnZXR0ZXIsIG5vb3AsIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMpO1xuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAodGFyZ2V0LCBrZXksIHVzZXJEZWYpIHtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSk7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IHVzZXJEZWYuZ2V0XG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XG4gICAgICA/IHVzZXJEZWYuc2V0XG4gICAgICA6IG5vb3A7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyICh2bSwga2V5LCBoYW5kbGVyKSB7XG4gIHZhciBvcHRpb25zO1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICB2bS4kd2F0Y2goa2V5LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG4vLyBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAoXG4gICAgdm5vZGUsXG4gICAgaHlkcmF0aW5nLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG1cbiAgKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLFxuICAgICAgICBwYXJlbnRFbG0sXG4gICAgICAgIHJlZkVsbVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKCFDdG9yKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICBpZiAoIUN0b3IuY2lkKSB7XG4gICAgaWYgKEN0b3IucmVzb2x2ZWQpIHtcbiAgICAgIEN0b3IgPSBDdG9yLnJlc29sdmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KEN0b3IsIGJhc2VDdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGl0J3Mgb2sgdG8gcXVldWUgdGhpcyBvbiBldmVyeSByZW5kZXIgYmVjYXVzZVxuICAgICAgICAvLyAkZm9yY2VVcGRhdGUgaXMgYnVmZmVyZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAgICAgICAgY29udGV4dC4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFDdG9yKSB7XG4gICAgICAgIC8vIHJldHVybiBub3RoaW5nIGlmIHRoaXMgaXMgaW5kZWVkIGFuIGFzeW5jIGNvbXBvbmVudFxuICAgICAgICAvLyB3YWl0IGZvciB0aGUgY2FsbGJhY2sgdG8gdHJpZ2dlciBwYXJlbnQgdXBkYXRlLlxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGRhdGEubW9kZWwpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnNcbiAgICBkYXRhID0ge307XG4gIH1cblxuICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIG1lcmdlSG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfVxuICApO1xuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW5cbikge1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAocHJvcE9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhKTtcbiAgICB9XG4gIH1cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBfY29udGV4dCA9IE9iamVjdC5jcmVhdGUoY29udGV4dCk7XG4gIHZhciBoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX2NvbnRleHQsIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuICB2YXIgdm5vZGUgPSBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgaCwge1xuICAgIHByb3BzOiBwcm9wcyxcbiAgICBkYXRhOiBkYXRhLFxuICAgIHBhcmVudDogY29udGV4dCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgc2xvdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCk7IH1cbiAgfSk7XG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgICh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50LCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbiAgcGFyZW50RWxtLFxuICByZWZFbG1cbikge1xuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIHByb3BzRGF0YTogdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YSxcbiAgICBfY29tcG9uZW50VGFnOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnLFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgX3BhcmVudExpc3RlbmVyczogdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycyxcbiAgICBfcmVuZGVyQ2hpbGRyZW46IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbixcbiAgICBfcGFyZW50RWxtOiBwYXJlbnRFbG0gfHwgbnVsbCxcbiAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlQ29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yLFxuICBjYlxuKSB7XG4gIGlmIChmYWN0b3J5LnJlcXVlc3RlZCkge1xuICAgIC8vIHBvb2wgY2FsbGJhY2tzXG4gICAgZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2IpO1xuICB9IGVsc2Uge1xuICAgIGZhY3RvcnkucmVxdWVzdGVkID0gdHJ1ZTtcbiAgICB2YXIgY2JzID0gZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzID0gW2NiXTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICAgIHJlcyA9IGJhc2VDdG9yLmV4dGVuZChyZXMpO1xuICAgICAgfVxuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSByZXM7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjYnNbaV0ocmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIC8vIGhhbmRsZSBwcm9taXNlXG4gICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicgJiYgIWZhY3RvcnkucmVzb2x2ZWQpIHtcbiAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wcyAoZGF0YSwgQ3RvciwgdGFnKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BPcHRpb25zKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICB2YXIgZG9tUHJvcHMgPSBkYXRhLmRvbVByb3BzO1xuICBpZiAoYXR0cnMgfHwgcHJvcHMgfHwgZG9tUHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGF0dHJzLmhhc093blByb3BlcnR5KGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXkpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBkb21Qcm9wcywga2V5LCBhbHRLZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGhhc2gpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2tzIChkYXRhKSB7XG4gIGlmICghZGF0YS5ob29rKSB7XG4gICAgZGF0YS5ob29rID0ge307XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIHZhciBmcm9tUGFyZW50ID0gZGF0YS5ob29rW2tleV07XG4gICAgdmFyIG91cnMgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgZGF0YS5ob29rW2tleV0gPSBmcm9tUGFyZW50ID8gbWVyZ2VIb29rJDEob3VycywgZnJvbVBhcmVudCkgOiBvdXJzO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICBvbmUoYSwgYiwgYywgZCk7XG4gICAgdHdvKGEsIGIsIGMsIGQpO1xuICB9XG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgaWYgKG9uW2V2ZW50XSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChhbHdheXNOb3JtYWxpemUpIHsgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFOyB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChkYXRhICYmIGRhdGEuX19vYl9fKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKChDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKHZub2RlKSB7XG4gICAgaWYgKG5zKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZub2RlLmNoaWxkcmVuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLnRhZyAmJiAhY2hpbGQubnMpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBleHRlbmQocHJvcHMsIGJpbmRPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFja1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2RlcyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkICYmIHdhcm4oXG4gICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNsb3ROb2RlcyB8fCBmYWxsYmFja1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluQWxpYXNcbikge1xuICB2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xuICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3Bcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUgYnkgZG9pbmcgYSBzaGFsbG93IGNsb25lLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRyZWUpXG4gICAgICA/IGNsb25lVk5vZGVzKHRyZWUpXG4gICAgICA6IGNsb25lVk5vZGUodHJlZSlcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF0gPVxuICAgIHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKHRoaXMuX3JlbmRlclByb3h5KTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS4kdm5vZGUgPSBudWxsOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIC8vIGNsb25lIHNsb3Qgbm9kZXMgb24gcmUtcmVuZGVyc1xuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHZtLiRzbG90c1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcblxuICAgIGlmIChzdGF0aWNSZW5kZXJGbnMgJiYgIXZtLl9zdGF0aWNUcmVlcykge1xuICAgICAgdm0uX3N0YXRpY1RyZWVzID0gW107XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyIGZ1bmN0aW9uXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3JcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSlcbiAgICAgICAgICA6IHZtLl92bm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG5cbiAgLy8gaW50ZXJuYWwgcmVuZGVyIGhlbHBlcnMuXG4gIC8vIHRoZXNlIGFyZSBleHBvc2VkIG9uIHRoZSBpbnN0YW5jZSBwcm90b3R5cGUgdG8gcmVkdWNlIGdlbmVyYXRlZCByZW5kZXJcbiAgLy8gY29kZSBzaXplLlxuICBWdWUucHJvdG90eXBlLl9vID0gbWFya09uY2U7XG4gIFZ1ZS5wcm90b3R5cGUuX24gPSB0b051bWJlcjtcbiAgVnVlLnByb3RvdHlwZS5fcyA9IF90b1N0cmluZztcbiAgVnVlLnByb3RvdHlwZS5fbCA9IHJlbmRlckxpc3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3QgPSByZW5kZXJTbG90O1xuICBWdWUucHJvdG90eXBlLl9xID0gbG9vc2VFcXVhbDtcbiAgVnVlLnByb3RvdHlwZS5faSA9IGxvb3NlSW5kZXhPZjtcbiAgVnVlLnByb3RvdHlwZS5fbSA9IHJlbmRlclN0YXRpYztcbiAgVnVlLnByb3RvdHlwZS5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX2sgPSBjaGVja0tleUNvZGVzO1xuICBWdWUucHJvdG90eXBlLl9iID0gYmluZE9iamVjdFByb3BzO1xuICBWdWUucHJvdG90eXBlLl92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICBWdWUucHJvdG90eXBlLl9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgaW5qZWN0ID0gdm0uJG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICAvLyBpc0FycmF5IGhlcmVcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoaW5qZWN0KTtcbiAgICB2YXIga2V5cyA9IGlzQXJyYXlcbiAgICAgID8gaW5qZWN0XG4gICAgICA6IGhhc1N5bWJvbFxuICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpXG4gICAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGlzQXJyYXkgPyBrZXkgOiBpbmplY3Rba2V5XTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIGxvb3AoIGkgKTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLWluaXQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKCgodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5wcm9wc0RhdGEgPSBvcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIHNlYWxlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBzZWFsZWQpIHtcbiAgLy8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcbiAgLy8gYmV0d2VlbiBtZXJnZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XG4gICAgICAgIHJlcy5wdXNoKGxhdGVzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGF0ZXN0XG4gIH1cbn1cblxuZnVuY3Rpb24gVnVlJDIgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUkMikpIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSQyKTtcbnN0YXRlTWl4aW4oVnVlJDIpO1xuZXZlbnRzTWl4aW4oVnVlJDIpO1xubGlmZWN5Y2xlTWl4aW4oVnVlJDIpO1xucmVuZGVyTWl4aW4oVnVlJDIpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgcGx1Z2luLmluc3RhbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBjb25maWcuaXNSZXNlcnZlZFRhZyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAgICAgICAnaWQ6ICcgKyBpZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwXTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChjYWNoZSwgZmlsdGVyKSB7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZWROb2RlKTtcbiAgICAgICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAodm5vZGUpIHtcbiAgaWYgKHZub2RlKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faW5hY3RpdmUpIHtcbiAgICAgIGNhbGxIb29rKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCAnZGVhY3RpdmF0ZWQnKTtcbiAgICB9XG4gICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxufVxuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlc1xuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGVba2V5XSk7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgaW5jbHVkZTogZnVuY3Rpb24gaW5jbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0sXG4gICAgZXhjbHVkZTogZnVuY3Rpb24gZXhjbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAoXG4gICAgICAgICh0aGlzLmluY2x1ZGUgJiYgIW1hdGNoZXModGhpcy5pbmNsdWRlLCBuYW1lKSkgfHxcbiAgICAgICAgKHRoaXMuZXhjbHVkZSAmJiBtYXRjaGVzKHRoaXMuZXhjbHVkZSwgbmFtZSkpXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKHRoaXMuY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgfVxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSQyKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQyLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cblZ1ZSQyLnZlcnNpb24gPSAnMi4yLjYnO1xuXG4vKiAgKi9cblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCcpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZW5DbGFzc0Zyb21EYXRhKGRhdGEpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogY2hpbGQuY2xhc3NcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkNsYXNzRnJvbURhdGEgKGRhdGEpIHtcbiAgdmFyIGR5bmFtaWNDbGFzcyA9IGRhdGEuY2xhc3M7XG4gIHZhciBzdGF0aWNDbGFzcyA9IGRhdGEuc3RhdGljQ2xhc3M7XG4gIGlmIChzdGF0aWNDbGFzcyB8fCBkeW5hbWljQ2xhc3MpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiByZXNcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBzdHJpbmdpZmllZDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHZhbHVlW2ldKSB7XG4gICAgICAgIGlmICgoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpKSB7XG4gICAgICAgICAgcmVzICs9IHN0cmluZ2lmaWVkICsgJyAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW2tleV0pIHsgcmVzICs9IGtleSArICcgJzsgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlJ1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cblxuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICgha2V5KSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSAmJiByZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmXG4gICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgKVxufVxuXG4vLyBTb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGR5bmFtaWNhbGx5IGNoYW5naW5nIHR5cGUgZm9yIDxpbnB1dD5cbi8vIHNvIHRoZXkgbmVlZCB0byBiZSB0cmVhdGVkIGFzIGRpZmZlcmVudCBub2Rlc1xuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQlxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpblByZSA9IDA7XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIG5lc3RlZCkge1xuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGluUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFpblByZSAmJlxuICAgICAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgICAgICEoY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiYgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5pbmRleE9mKHRhZykgPiAtMSkgJiZcbiAgICAgICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh0YWcpXG4gICAgICAgICkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBpblByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYpKSB7XG4gICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgfVxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldIDogbnVsbDtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhZWxtVG9Nb3ZlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnSXQgc2VlbXMgdGhlcmUgYXJlIGR1cGxpY2F0ZSBrZXlzIHRoYXQgaXMgY2F1c2luZyBhbiB1cGRhdGUgZXJyb3IuICcgK1xuICAgICAgICAgICAgICAnTWFrZSBzdXJlIGVhY2ggdi1mb3IgaXRlbSBoYXMgYSB1bmlxdWUga2V5LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzYW1lVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgbmV3U3RhcnRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsc3R5bGUsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWJhaWxlZCkge1xuICAgICAgICAgICAgICBiYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8XG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0kMSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5hdHRycyAmJiAhdm5vZGUuZGF0YS5hdHRycykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGF0dHJzLl9fb2JfXykge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUU5ICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoYXR0cnNba2V5XSA9PSBudWxsKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKCFkYXRhLnN0YXRpY0NsYXNzICYmICFkYXRhLmNsYXNzICYmXG4gICAgICAoIW9sZERhdGEgfHwgKCFvbGREYXRhLnN0YXRpY0NsYXNzICYmICFvbGREYXRhLmNsYXNzKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3MpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cblxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIsXCIgKyBhcmdzKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cblxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5cblxuLyoqXG4gKiBwYXJzZSBkaXJlY3RpdmUgbW9kZWwgdG8gZG8gdGhlIGFycmF5IHVwZGF0ZSB0cmFuc2Zvcm0uIGFbaWR4XSA9IHZhbCA9PiAkJGEuc3BsaWNlKCQkaWR4LCAxLCB2YWwpXG4gKlxuICogZm9yIGxvb3AgcG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3RbaWR4XVxuICogLSB0ZXN0W3Rlc3QxW2lkeF1dXG4gKiAtIHRlc3RbXCJhXCJdW2lkeF1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtpZHhdXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2lkeF1dXG4gKlxuICovXG5cbnZhciBzdHI7XG52YXIgaW5kZXgkMTtcblxuLyogICovXG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgdmFyIGV2ZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG9uW1JBTkdFX1RPS0VOXSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIGlmIChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pIHtcbiAgICAvLyBDaHJvbWUgZmlyZXMgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGNsaWNrL2NoYW5nZSwgbGVhZHMgdG8gIzQ1MjFcbiAgICBldmVudCA9IGlzQ2hyb21lID8gJ2NsaWNrJyA6ICdjaGFuZ2UnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UsXG4gIGNhcHR1cmVcbikge1xuICBpZiAob25jZSkge1xuICAgIHZhciBvbGRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICAgID8gb2xkSGFuZGxlcihldilcbiAgICAgICAgOiBvbGRIYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZSQyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEub24gJiYgIXZub2RlLmRhdGEub24pIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEuZG9tUHJvcHMgJiYgIXZub2RlLmRhdGEuZG9tUHJvcHMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAocHJvcHMuX19vYl9fKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChwcm9wc1trZXldID09IG51bGwpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBjdXIgPT0gbnVsbCA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCB2bm9kZSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoXG4gIGVsbSxcbiAgdm5vZGUsXG4gIGNoZWNrVmFsXG4pIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgdm5vZGUudGFnID09PSAnb3B0aW9uJyB8fFxuICAgIGlzRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0lucHV0Q2hhbmdlZChlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXMgbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG0gJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0lucHV0Q2hhbmdlZCAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcikgfHwgZWxtLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICB9XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnRyaW0pIHtcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoY2hpbGROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgZWwuc3R5bGVbbm9ybWFsaXplKG5hbWUpXSA9IHZhbDtcbiAgfVxufTtcblxudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciB0ZXN0RWw7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHRlc3RFbCA9IHRlc3RFbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gdGVzdEVsLnN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIHVwcGVyID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIHVwcGVyO1xuICAgIGlmIChwcmVmaXhlZCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZFxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKCFkYXRhLnN0YXRpY1N0eWxlICYmICFkYXRhLnN0eWxlICYmXG4gICAgICAhb2xkRGF0YS5zdGF0aWNTdHlsZSAmJiAhb2xkRGF0YS5zdHlsZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGRWbm9kZS5kYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkVm5vZGUuZGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIHZub2RlLmRhdGEuc3R5bGUgPSBzdHlsZS5fX29iX18gPyBleHRlbmQoe30sIHN0eWxlKSA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAobmV3U3R5bGVbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1ci50cmltKCkpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgOiBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICAoZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSkpLnB1c2goY2xzKTtcbiAgYWRkQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGVsLl9sZWF2ZUNiKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwuX2VudGVyQ2IgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IpIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGVsLl9lbnRlckNiKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbC5fbGVhdmVDYiB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdExlYXZlRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVt2bm9kZS5rZXldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmICghZm4pIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpbnZva2VyRm5zKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIGNiKCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBlbC50eXBlID09PSAndGV4dCcgfHwgZWwudHlwZSA9PT0gJ3Bhc3N3b3JkJykge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgZWwub3B0aW9ucyk7IH0pXG4gICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGVsLm9wdGlvbnMpO1xuICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbnNbaV0pLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBtb2RlbCQxLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgcmV0dXJuIC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKVxuICAgID8gaCgna2VlcC1hbGl2ZScpXG4gICAgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWc7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9sZENoaWxkICYmIG9sZENoaWxkLmRhdGEgJiYgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkpIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGYgPSBib2R5Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQyLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDIuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDIuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZSQyLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlJDIub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZSQyLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlJDIucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlJDIucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICk7XG4gIH1cbn0sIDApO1xuXG5leHBvcnQgZGVmYXVsdCBWdWUkMjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uX3Z1ZUAyLjIuNkB2dWUvZGlzdC92dWUucnVudGltZS5lc20uanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\");\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"Object.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__main_css__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__main_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__main_css__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vue_vue__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vue_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__vue_vue__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vue__ = __webpack_require__(4);\\nvar greeter = __webpack_require__(2);\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nnew __WEBPACK_IMPORTED_MODULE_2_vue__[\\\"a\\\" /* default */](__WEBPACK_IMPORTED_MODULE_1__vue_vue___default.a);\\r\\ndocument.getElementById('root').appendChild(greeter());\\r\\nconsole.log(\\\"ddddddddddddddddd-----ddd --sssssssssssss-----\\\");//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbWFpbi5qcz82YTRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ3JlZXRlciA9IHJlcXVpcmUoJy4vR3JlZXRlci5qcycpO1xyXG5cclxuaW1wb3J0ICcuL21haW4uY3NzJ1xyXG5cclxuaW1wb3J0IGFwcCBmcm9tICcuL3Z1ZS52dWUnXHJcbmltcG9ydCBWdWUgZnJvbSAndnVlJ1xyXG5uZXcgVnVlKGFwcCk7XHJcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290JykuYXBwZW5kQ2hpbGQoZ3JlZXRlcigpKTtcclxuY29uc29sZS5sb2coXCJkZGRkZGRkZGRkZGRkZGRkZC0tLS0tZGRkIC0tc3Nzc3Nzc3Nzc3Nzcy0tLS0tXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\");\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"Object.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = ({\\n    el: '#app',\\n    name: 'app',\\n    data() {\\n        return {\\n            msg: 'Welcome to Your Vue.js App'\\n        };\\n    }\\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdnVlLnZ1ZT9lOTdmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFTQTtRQUVBO1VBQ0E7V0FDQTs7aUJBR0E7QUFGQTtBQUdBO0FBUEEiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG48dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGlkPVwiYXBwXCI+XHJcbiAgICAgICAgPGgxPnt7IG1zZyB9fTwvaDE+XHJcblxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG4gICAgZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgICAgIGVsOiAnI2FwcCcsXHJcbiAgICAgICAgbmFtZTogJ2FwcCcsXHJcbiAgICAgICAgZGF0YSAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBtc2c6ICdXZWxjb21lIHRvIFlvdXIgVnVlLmpzIEFwcCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuPC9zY3JpcHQ+XHJcblxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gdnVlLnZ1ZT8yZDg0YTk4OCJdLCJzb3VyY2VSb290IjoiIn0=\");\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"exports = module.exports = __webpack_require__(8)(undefined);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \\\"html {\\\\r\\\\n  box-sizing: border-box;\\\\r\\\\n  -ms-text-size-adjust: 100%;\\\\r\\\\n  -webkit-text-size-adjust: 100%;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\n*, *:before, *:after {\\\\r\\\\n  box-sizing: inherit;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nbody {\\\\r\\\\n  margin: 0;\\\\r\\\\n  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nh1, h2, h3, h4, h5, h6, p, ul {\\\\r\\\\n  margin: 0;\\\\r\\\\n  padding: 0;\\\\r\\\\n}\\\", \\\"\\\"]);\\n\\n// exports\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbWFpbi5jc3M/ZGVmYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLCtCQUFnQyw2QkFBNkIsaUNBQWlDLHFDQUFxQyxLQUFLLDhCQUE4QiwwQkFBMEIsS0FBSyxjQUFjLGdCQUFnQixrRUFBa0UsS0FBSyx1Q0FBdUMsZ0JBQWdCLGlCQUFpQixLQUFLOztBQUV2WCIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy8uX2Nzcy1sb2FkZXJAMC4yOC4wQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJodG1sIHtcXHJcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuICAtbXMtdGV4dC1zaXplLWFkanVzdDogMTAwJTtcXHJcXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuKiwgKjpiZWZvcmUsICo6YWZ0ZXIge1xcclxcbiAgYm94LXNpemluZzogaW5oZXJpdDtcXHJcXG59XFxyXFxuXFxyXFxuYm9keSB7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxuICBmb250LWZhbWlseTogJ0hlbHZldGljYSBOZXVlJywgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcXHJcXG59XFxyXFxuXFxyXFxuaDEsIGgyLCBoMywgaDQsIGg1LCBoNiwgcCwgdWwge1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbiAgcGFkZGluZzogMDtcXHJcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly5fY3NzLWxvYWRlckAwLjI4LjBAY3NzLWxvYWRlcj9tb2R1bGVzIS4vYXBwL21haW4uY3NzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\");\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/* WEBPACK VAR INJECTION */(function(Buffer) {/*\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\n\\tAuthor Tobias Koppers @sokra\\n*/\\n// css base code, injected by the css-loader\\nmodule.exports = function(useSourceMap) {\\n\\tvar list = [];\\n\\n\\t// return the list of modules as css string\\n\\tlist.toString = function toString() {\\n\\t\\treturn this.map(function (item) {\\n\\t\\t\\tvar content = cssWithMappingToString(item, useSourceMap);\\n\\t\\t\\tif(item[2]) {\\n\\t\\t\\t\\treturn \\\"@media \\\" + item[2] + \\\"{\\\" + content + \\\"}\\\";\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn content;\\n\\t\\t\\t}\\n\\t\\t}).join(\\\"\\\");\\n\\t};\\n\\n\\t// import a list of modules into the list\\n\\tlist.i = function(modules, mediaQuery) {\\n\\t\\tif(typeof modules === \\\"string\\\")\\n\\t\\t\\tmodules = [[null, modules, \\\"\\\"]];\\n\\t\\tvar alreadyImportedModules = {};\\n\\t\\tfor(var i = 0; i < this.length; i++) {\\n\\t\\t\\tvar id = this[i][0];\\n\\t\\t\\tif(typeof id === \\\"number\\\")\\n\\t\\t\\t\\talreadyImportedModules[id] = true;\\n\\t\\t}\\n\\t\\tfor(i = 0; i < modules.length; i++) {\\n\\t\\t\\tvar item = modules[i];\\n\\t\\t\\t// skip already imported module\\n\\t\\t\\t// this implementation is not 100% perfect for weird media query combinations\\n\\t\\t\\t//  when a module is imported multiple times with different media queries.\\n\\t\\t\\t//  I hope this will never occur (Hey this way we have smaller bundles)\\n\\t\\t\\tif(typeof item[0] !== \\\"number\\\" || !alreadyImportedModules[item[0]]) {\\n\\t\\t\\t\\tif(mediaQuery && !item[2]) {\\n\\t\\t\\t\\t\\titem[2] = mediaQuery;\\n\\t\\t\\t\\t} else if(mediaQuery) {\\n\\t\\t\\t\\t\\titem[2] = \\\"(\\\" + item[2] + \\\") and (\\\" + mediaQuery + \\\")\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlist.push(item);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\treturn list;\\n};\\n\\nfunction cssWithMappingToString(item, useSourceMap) {\\n\\tvar content = item[1] || '';\\n\\tvar cssMapping = item[3];\\n\\tif (!cssMapping) {\\n\\t\\treturn content;\\n\\t}\\n\\n\\tif (useSourceMap) {\\n\\t\\tvar sourceMapping = toComment(cssMapping);\\n\\t\\tvar sourceURLs = cssMapping.sources.map(function (source) {\\n\\t\\t\\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\\n\\t\\t});\\n\\n\\t\\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\\\n');\\n\\t}\\n\\n\\treturn [content].join('\\\\n');\\n}\\n\\n// Adapted from convert-source-map (MIT)\\nfunction toComment(sourceMap) {\\n  var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');\\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\\n\\n  return '/*# ' + data + ' */';\\n}\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15).Buffer))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly5fY3NzLWxvYWRlckAwLjI4LjBAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/YjcwZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYzs7QUFFbkU7QUFDQSIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXApIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIHZhciBiYXNlNjQgPSBuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgdmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuICByZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly5fY3NzLWxvYWRlckAwLjI4LjBAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\");\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\neval(\"module.exports = {\\n\\t\\\"greetText\\\": \\\"Hi there and greetings from JSON!\\\"\\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvY29uZmlnLmpzb24/MzAyZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcImdyZWV0VGV4dFwiOiBcIkhpIHRoZXJlIGFuZCBncmVldGluZ3MgZnJvbSBKU09OIVwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL2NvbmZpZy5qc29uXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\");\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\n\\tAuthor Tobias Koppers @sokra\\n*/\\nvar stylesInDom = {},\\n\\tmemoize = function(fn) {\\n\\t\\tvar memo;\\n\\t\\treturn function () {\\n\\t\\t\\tif (typeof memo === \\\"undefined\\\") memo = fn.apply(this, arguments);\\n\\t\\t\\treturn memo;\\n\\t\\t};\\n\\t},\\n\\tisOldIE = memoize(function() {\\n\\t\\t// Test for IE <= 9 as proposed by Browserhacks\\n\\t\\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\\n\\t\\t// Tests for existence of standard globals is to allow style-loader \\n\\t\\t// to operate correctly into non-standard environments\\n\\t\\t// @see https://github.com/webpack-contrib/style-loader/issues/177\\n\\t\\treturn window && document && document.all && !window.atob;\\n\\t}),\\n\\tgetElement = (function(fn) {\\n\\t\\tvar memo = {};\\n\\t\\treturn function(selector) {\\n\\t\\t\\tif (typeof memo[selector] === \\\"undefined\\\") {\\n\\t\\t\\t\\tmemo[selector] = fn.call(this, selector);\\n\\t\\t\\t}\\n\\t\\t\\treturn memo[selector]\\n\\t\\t};\\n\\t})(function (styleTarget) {\\n\\t\\treturn document.querySelector(styleTarget)\\n\\t}),\\n\\tsingletonElement = null,\\n\\tsingletonCounter = 0,\\n\\tstyleElementsInsertedAtTop = [],\\n\\tfixUrls = __webpack_require__(11);\\n\\nmodule.exports = function(list, options) {\\n\\tif(typeof DEBUG !== \\\"undefined\\\" && DEBUG) {\\n\\t\\tif(typeof document !== \\\"object\\\") throw new Error(\\\"The style-loader cannot be used in a non-browser environment\\\");\\n\\t}\\n\\n\\toptions = options || {};\\n\\toptions.attrs = typeof options.attrs === \\\"object\\\" ? options.attrs : {};\\n\\n\\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\\n\\t// tags it will allow on a page\\n\\tif (typeof options.singleton === \\\"undefined\\\") options.singleton = isOldIE();\\n\\n\\t// By default, add <style> tags to the <head> element\\n\\tif (typeof options.insertInto === \\\"undefined\\\") options.insertInto = \\\"head\\\";\\n\\n\\t// By default, add <style> tags to the bottom of the target\\n\\tif (typeof options.insertAt === \\\"undefined\\\") options.insertAt = \\\"bottom\\\";\\n\\n\\tvar styles = listToStyles(list);\\n\\taddStylesToDom(styles, options);\\n\\n\\treturn function update(newList) {\\n\\t\\tvar mayRemove = [];\\n\\t\\tfor(var i = 0; i < styles.length; i++) {\\n\\t\\t\\tvar item = styles[i];\\n\\t\\t\\tvar domStyle = stylesInDom[item.id];\\n\\t\\t\\tdomStyle.refs--;\\n\\t\\t\\tmayRemove.push(domStyle);\\n\\t\\t}\\n\\t\\tif(newList) {\\n\\t\\t\\tvar newStyles = listToStyles(newList);\\n\\t\\t\\taddStylesToDom(newStyles, options);\\n\\t\\t}\\n\\t\\tfor(var i = 0; i < mayRemove.length; i++) {\\n\\t\\t\\tvar domStyle = mayRemove[i];\\n\\t\\t\\tif(domStyle.refs === 0) {\\n\\t\\t\\t\\tfor(var j = 0; j < domStyle.parts.length; j++)\\n\\t\\t\\t\\t\\tdomStyle.parts[j]();\\n\\t\\t\\t\\tdelete stylesInDom[domStyle.id];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n};\\n\\nfunction addStylesToDom(styles, options) {\\n\\tfor(var i = 0; i < styles.length; i++) {\\n\\t\\tvar item = styles[i];\\n\\t\\tvar domStyle = stylesInDom[item.id];\\n\\t\\tif(domStyle) {\\n\\t\\t\\tdomStyle.refs++;\\n\\t\\t\\tfor(var j = 0; j < domStyle.parts.length; j++) {\\n\\t\\t\\t\\tdomStyle.parts[j](item.parts[j]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(; j < item.parts.length; j++) {\\n\\t\\t\\t\\tdomStyle.parts.push(addStyle(item.parts[j], options));\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tvar parts = [];\\n\\t\\t\\tfor(var j = 0; j < item.parts.length; j++) {\\n\\t\\t\\t\\tparts.push(addStyle(item.parts[j], options));\\n\\t\\t\\t}\\n\\t\\t\\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction listToStyles(list) {\\n\\tvar styles = [];\\n\\tvar newStyles = {};\\n\\tfor(var i = 0; i < list.length; i++) {\\n\\t\\tvar item = list[i];\\n\\t\\tvar id = item[0];\\n\\t\\tvar css = item[1];\\n\\t\\tvar media = item[2];\\n\\t\\tvar sourceMap = item[3];\\n\\t\\tvar part = {css: css, media: media, sourceMap: sourceMap};\\n\\t\\tif(!newStyles[id])\\n\\t\\t\\tstyles.push(newStyles[id] = {id: id, parts: [part]});\\n\\t\\telse\\n\\t\\t\\tnewStyles[id].parts.push(part);\\n\\t}\\n\\treturn styles;\\n}\\n\\nfunction insertStyleElement(options, styleElement) {\\n\\tvar styleTarget = getElement(options.insertInto)\\n\\tif (!styleTarget) {\\n\\t\\tthrow new Error(\\\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\\\");\\n\\t}\\n\\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\\n\\tif (options.insertAt === \\\"top\\\") {\\n\\t\\tif(!lastStyleElementInsertedAtTop) {\\n\\t\\t\\tstyleTarget.insertBefore(styleElement, styleTarget.firstChild);\\n\\t\\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\\n\\t\\t\\tstyleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\\n\\t\\t} else {\\n\\t\\t\\tstyleTarget.appendChild(styleElement);\\n\\t\\t}\\n\\t\\tstyleElementsInsertedAtTop.push(styleElement);\\n\\t} else if (options.insertAt === \\\"bottom\\\") {\\n\\t\\tstyleTarget.appendChild(styleElement);\\n\\t} else {\\n\\t\\tthrow new Error(\\\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\\\");\\n\\t}\\n}\\n\\nfunction removeStyleElement(styleElement) {\\n\\tstyleElement.parentNode.removeChild(styleElement);\\n\\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\\n\\tif(idx >= 0) {\\n\\t\\tstyleElementsInsertedAtTop.splice(idx, 1);\\n\\t}\\n}\\n\\nfunction createStyleElement(options) {\\n\\tvar styleElement = document.createElement(\\\"style\\\");\\n\\toptions.attrs.type = \\\"text/css\\\";\\n\\n\\tattachTagAttrs(styleElement, options.attrs);\\n\\tinsertStyleElement(options, styleElement);\\n\\treturn styleElement;\\n}\\n\\nfunction createLinkElement(options) {\\n\\tvar linkElement = document.createElement(\\\"link\\\");\\n\\toptions.attrs.type = \\\"text/css\\\";\\n\\toptions.attrs.rel = \\\"stylesheet\\\";\\n\\n\\tattachTagAttrs(linkElement, options.attrs);\\n\\tinsertStyleElement(options, linkElement);\\n\\treturn linkElement;\\n}\\n\\nfunction attachTagAttrs(element, attrs) {\\n\\tObject.keys(attrs).forEach(function (key) {\\n\\t\\telement.setAttribute(key, attrs[key]);\\n\\t});\\n}\\n\\nfunction addStyle(obj, options) {\\n\\tvar styleElement, update, remove;\\n\\n\\tif (options.singleton) {\\n\\t\\tvar styleIndex = singletonCounter++;\\n\\t\\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\\n\\t\\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\\n\\t\\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\\n\\t} else if(obj.sourceMap &&\\n\\t\\ttypeof URL === \\\"function\\\" &&\\n\\t\\ttypeof URL.createObjectURL === \\\"function\\\" &&\\n\\t\\ttypeof URL.revokeObjectURL === \\\"function\\\" &&\\n\\t\\ttypeof Blob === \\\"function\\\" &&\\n\\t\\ttypeof btoa === \\\"function\\\") {\\n\\t\\tstyleElement = createLinkElement(options);\\n\\t\\tupdate = updateLink.bind(null, styleElement, options);\\n\\t\\tremove = function() {\\n\\t\\t\\tremoveStyleElement(styleElement);\\n\\t\\t\\tif(styleElement.href)\\n\\t\\t\\t\\tURL.revokeObjectURL(styleElement.href);\\n\\t\\t};\\n\\t} else {\\n\\t\\tstyleElement = createStyleElement(options);\\n\\t\\tupdate = applyToTag.bind(null, styleElement);\\n\\t\\tremove = function() {\\n\\t\\t\\tremoveStyleElement(styleElement);\\n\\t\\t};\\n\\t}\\n\\n\\tupdate(obj);\\n\\n\\treturn function updateStyle(newObj) {\\n\\t\\tif(newObj) {\\n\\t\\t\\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tupdate(obj = newObj);\\n\\t\\t} else {\\n\\t\\t\\tremove();\\n\\t\\t}\\n\\t};\\n}\\n\\nvar replaceText = (function () {\\n\\tvar textStore = [];\\n\\n\\treturn function (index, replacement) {\\n\\t\\ttextStore[index] = replacement;\\n\\t\\treturn textStore.filter(Boolean).join('\\\\n');\\n\\t};\\n})();\\n\\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\\n\\tvar css = remove ? \\\"\\\" : obj.css;\\n\\n\\tif (styleElement.styleSheet) {\\n\\t\\tstyleElement.styleSheet.cssText = replaceText(index, css);\\n\\t} else {\\n\\t\\tvar cssNode = document.createTextNode(css);\\n\\t\\tvar childNodes = styleElement.childNodes;\\n\\t\\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\\n\\t\\tif (childNodes.length) {\\n\\t\\t\\tstyleElement.insertBefore(cssNode, childNodes[index]);\\n\\t\\t} else {\\n\\t\\t\\tstyleElement.appendChild(cssNode);\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction applyToTag(styleElement, obj) {\\n\\tvar css = obj.css;\\n\\tvar media = obj.media;\\n\\n\\tif(media) {\\n\\t\\tstyleElement.setAttribute(\\\"media\\\", media)\\n\\t}\\n\\n\\tif(styleElement.styleSheet) {\\n\\t\\tstyleElement.styleSheet.cssText = css;\\n\\t} else {\\n\\t\\twhile(styleElement.firstChild) {\\n\\t\\t\\tstyleElement.removeChild(styleElement.firstChild);\\n\\t\\t}\\n\\t\\tstyleElement.appendChild(document.createTextNode(css));\\n\\t}\\n}\\n\\nfunction updateLink(linkElement, options, obj) {\\n\\tvar css = obj.css;\\n\\tvar sourceMap = obj.sourceMap;\\n\\n\\t/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\\n\\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\\n\\ton by default.  Otherwise default to the convertToAbsoluteUrls option\\n\\tdirectly\\n\\t*/\\n\\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\\n\\n\\tif (options.convertToAbsoluteUrls || autoFixUrls){\\n\\t\\tcss = fixUrls(css);\\n\\t}\\n\\n\\tif(sourceMap) {\\n\\t\\t// http://stackoverflow.com/a/26603875\\n\\t\\tcss += \\\"\\\\n/*# sourceMappingURL=data:application/json;base64,\\\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \\\" */\\\";\\n\\t}\\n\\n\\tvar blob = new Blob([css], { type: \\\"text/css\\\" });\\n\\n\\tvar oldSrc = linkElement.href;\\n\\n\\tlinkElement.href = URL.createObjectURL(blob);\\n\\n\\tif(oldSrc)\\n\\t\\tURL.revokeObjectURL(oldSrc);\\n}\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly5fc3R5bGUtbG9hZGVyQDAuMTYuMUBzdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzP2RiOGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xudmFyIHN0eWxlc0luRG9tID0ge30sXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xuXHRcdHZhciBtZW1vO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG1lbW87XG5cdFx0fTtcblx0fSxcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XG5cdFx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0XHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdFx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlciBcblx0XHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0XHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0XHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG5cdH0pLFxuXHRnZXRFbGVtZW50ID0gKGZ1bmN0aW9uKGZuKSB7XG5cdFx0dmFyIG1lbW8gPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBmbi5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxuXHRcdH07XG5cdH0pKGZ1bmN0aW9uIChzdHlsZVRhcmdldCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHN0eWxlVGFyZ2V0KVxuXHR9KSxcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdLFxuXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vZml4VXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0SW50byA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZVxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcblx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cdGlmICghc3R5bGVUYXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHN0eWxlVGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIHN0eWxlVGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0c3R5bGVUYXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZVRhcmdldC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHN0eWxlVGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YXR0YWNoVGFnQXR0cnMoc3R5bGVFbGVtZW50LCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhdHRhY2hUYWdBdHRycyhsaW5rRWxlbWVudCwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XG5cdHJldHVybiBsaW5rRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gYXR0YWNoVGFnQXR0cnMoZWxlbWVudCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcblx0XHRpZihuZXdPYmopIHtcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0LyogSWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpe1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmtFbGVtZW50LmhyZWY7XG5cblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKVxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uX3N0eWxlLWxvYWRlckAwLjE2LjFAc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\");\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\neval(\"\\n/**\\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\\n * embed the css on the page. This breaks all relative urls because now they are relative to a\\n * bundle instead of the current page.\\n *\\n * One solution is to only use full urls, but that may be impossible.\\n *\\n * Instead, this function \\\"fixes\\\" the relative urls to be absolute according to the current page location.\\n *\\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\\n *\\n */\\n\\nmodule.exports = function (css) {\\n  // get current location\\n  var location = typeof window !== \\\"undefined\\\" && window.location;\\n\\n  if (!location) {\\n    throw new Error(\\\"fixUrls requires window.location\\\");\\n  }\\n\\n\\t// blank or null?\\n\\tif (!css || typeof css !== \\\"string\\\") {\\n\\t  return css;\\n  }\\n\\n  var baseUrl = location.protocol + \\\"//\\\" + location.host;\\n  var currentDir = baseUrl + location.pathname.replace(/\\\\/[^\\\\/]*$/, \\\"/\\\");\\n\\n\\t// convert each url(...)\\n\\t/*\\n\\tThis regular expression is just a way to recursively match brackets within\\n\\ta string.\\n\\n\\t /url\\\\s*\\\\(  = Match on the word \\\"url\\\" with any whitespace after it and then a parens\\n\\t   (  = Start a capturing group\\n\\t     (?:  = Start a non-capturing group\\n\\t         [^)(]  = Match anything that isn't a parentheses\\n\\t         |  = OR\\n\\t         \\\\(  = Match a start parentheses\\n\\t             (?:  = Start another non-capturing groups\\n\\t                 [^)(]+  = Match anything that isn't a parentheses\\n\\t                 |  = OR\\n\\t                 \\\\(  = Match a start parentheses\\n\\t                     [^)(]*  = Match anything that isn't a parentheses\\n\\t                 \\\\)  = Match a end parentheses\\n\\t             )  = End Group\\n              *\\\\) = Match anything and then a close parens\\n          )  = Close non-capturing group\\n          *  = Match anything\\n       )  = Close capturing group\\n\\t \\\\)  = Match a close parens\\n\\n\\t /gi  = Get all matches, not the first.  Be case insensitive.\\n\\t */\\n\\tvar fixedCss = css.replace(/url\\\\s*\\\\(((?:[^)(]|\\\\((?:[^)(]+|\\\\([^)(]*\\\\))*\\\\))*)\\\\)/gi, function(fullMatch, origUrl) {\\n\\t\\t// strip quotes (if they exist)\\n\\t\\tvar unquotedOrigUrl = origUrl\\n\\t\\t\\t.trim()\\n\\t\\t\\t.replace(/^\\\"(.*)\\\"$/, function(o, $1){ return $1; })\\n\\t\\t\\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\\n\\n\\t\\t// already a full url? no change\\n\\t\\tif (/^(#|data:|http:\\\\/\\\\/|https:\\\\/\\\\/|file:\\\\/\\\\/\\\\/)/i.test(unquotedOrigUrl)) {\\n\\t\\t  return fullMatch;\\n\\t\\t}\\n\\n\\t\\t// convert the url to a full url\\n\\t\\tvar newUrl;\\n\\n\\t\\tif (unquotedOrigUrl.indexOf(\\\"//\\\") === 0) {\\n\\t\\t  \\t//TODO: should we add protocol?\\n\\t\\t\\tnewUrl = unquotedOrigUrl;\\n\\t\\t} else if (unquotedOrigUrl.indexOf(\\\"/\\\") === 0) {\\n\\t\\t\\t// path should be relative to the base url\\n\\t\\t\\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\\n\\t\\t} else {\\n\\t\\t\\t// path should be relative to current directory\\n\\t\\t\\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\\\.\\\\//, \\\"\\\"); // Strip leading './'\\n\\t\\t}\\n\\n\\t\\t// send back the fixed url(...)\\n\\t\\treturn \\\"url(\\\" + JSON.stringify(newUrl) + \\\")\\\";\\n\\t});\\n\\n\\t// send back the fixed css\\n\\treturn fixedCss;\\n};\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly5fc3R5bGUtbG9hZGVyQDAuMTYuMUBzdHlsZS1sb2FkZXIvZml4VXJscy5qcz9hNGM5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxFQUFFO0FBQ3JELHdDQUF3QyxXQUFXLEVBQUU7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDO0FBQ3RDLEdBQUc7QUFDSDtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uX3N0eWxlLWxvYWRlckAwLjE2LjFAc3R5bGUtbG9hZGVyL2ZpeFVybHMuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\");\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\neval(\"// this module is a runtime utility for cleaner component module output and will\\n// be included in the final webpack user bundle\\n\\nmodule.exports = function normalizeComponent (\\n  rawScriptExports,\\n  compiledTemplate,\\n  scopeId,\\n  cssModules\\n) {\\n  var esModule\\n  var scriptExports = rawScriptExports = rawScriptExports || {}\\n\\n  // ES6 modules interop\\n  var type = typeof rawScriptExports.default\\n  if (type === 'object' || type === 'function') {\\n    esModule = rawScriptExports\\n    scriptExports = rawScriptExports.default\\n  }\\n\\n  // Vue.extend constructor export interop\\n  var options = typeof scriptExports === 'function'\\n    ? scriptExports.options\\n    : scriptExports\\n\\n  // render functions\\n  if (compiledTemplate) {\\n    options.render = compiledTemplate.render\\n    options.staticRenderFns = compiledTemplate.staticRenderFns\\n  }\\n\\n  // scopedId\\n  if (scopeId) {\\n    options._scopeId = scopeId\\n  }\\n\\n  // inject cssModules\\n  if (cssModules) {\\n    var computed = Object.create(options.computed || null)\\n    Object.keys(cssModules).forEach(function (key) {\\n      var module = cssModules[key]\\n      computed[key] = function () { return module }\\n    })\\n    options.computed = computed\\n  }\\n\\n  return {\\n    esModule: esModule,\\n    exports: scriptExports,\\n    options: options\\n  }\\n}\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly5fdnVlLWxvYWRlckAxMS4zLjRAdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanM/NjIzOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0aGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICByYXdTY3JpcHRFeHBvcnRzLFxuICBjb21waWxlZFRlbXBsYXRlLFxuICBzY29wZUlkLFxuICBjc3NNb2R1bGVzXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICAvLyBpbmplY3QgY3NzTW9kdWxlc1xuICBpZiAoY3NzTW9kdWxlcykge1xuICAgIHZhciBjb21wdXRlZCA9IE9iamVjdC5jcmVhdGUob3B0aW9ucy5jb21wdXRlZCB8fCBudWxsKVxuICAgIE9iamVjdC5rZXlzKGNzc01vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG1vZHVsZSA9IGNzc01vZHVsZXNba2V5XVxuICAgICAgY29tcHV0ZWRba2V5XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZHVsZSB9XG4gICAgfSlcbiAgICBvcHRpb25zLmNvbXB1dGVkID0gY29tcHV0ZWRcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLl92dWUtbG9hZGVyQDExLjMuNEB2dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\");\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\\n  return _c('div', {\\n    attrs: {\\n      \\\"id\\\": \\\"app\\\"\\n    }\\n  }, [_c('h1', [_vm._v(_vm._s(_vm.msg))])])\\n},staticRenderFns: []}\\nmodule.exports.render._withStripped = true\\nif (false) {\\n  module.hot.accept()\\n  if (module.hot.data) {\\n     require(\\\"vue-loader/node_modules/vue-hot-reload-api\\\").rerender(\\\"data-v-7de3e7d8\\\", module.exports)\\n  }\\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvdnVlLnZ1ZT9kYTE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJhcHBcIlxuICAgIH1cbiAgfSwgW19jKCdoMScsIFtfdm0uX3YoX3ZtLl9zKF92bS5tc2cpKV0pXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtN2RlM2U3ZDhcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLl92dWUtbG9hZGVyQDExLjMuNEB2dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTdkZTNlN2Q4XCJ9IS4vfi8uX3Z1ZS1sb2FkZXJAMTEuMy40QHZ1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2FwcC92dWUudnVlXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\");\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nexports.byteLength = byteLength\\nexports.toByteArray = toByteArray\\nexports.fromByteArray = fromByteArray\\n\\nvar lookup = []\\nvar revLookup = []\\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\\n\\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\\nfor (var i = 0, len = code.length; i < len; ++i) {\\n  lookup[i] = code[i]\\n  revLookup[code.charCodeAt(i)] = i\\n}\\n\\nrevLookup['-'.charCodeAt(0)] = 62\\nrevLookup['_'.charCodeAt(0)] = 63\\n\\nfunction placeHoldersCount (b64) {\\n  var len = b64.length\\n  if (len % 4 > 0) {\\n    throw new Error('Invalid string. Length must be a multiple of 4')\\n  }\\n\\n  // the number of equal signs (place holders)\\n  // if there are two placeholders, than the two characters before it\\n  // represent one byte\\n  // if there is only one, then the three characters before it represent 2 bytes\\n  // this is just a cheap hack to not do indexOf twice\\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\\n}\\n\\nfunction byteLength (b64) {\\n  // base64 is 4/3 + up to two characters of the original data\\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\\n}\\n\\nfunction toByteArray (b64) {\\n  var i, j, l, tmp, placeHolders, arr\\n  var len = b64.length\\n  placeHolders = placeHoldersCount(b64)\\n\\n  arr = new Arr(len * 3 / 4 - placeHolders)\\n\\n  // if there are placeholders, only get up to the last complete 4 chars\\n  l = placeHolders > 0 ? len - 4 : len\\n\\n  var L = 0\\n\\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\\n    arr[L++] = (tmp >> 16) & 0xFF\\n    arr[L++] = (tmp >> 8) & 0xFF\\n    arr[L++] = tmp & 0xFF\\n  }\\n\\n  if (placeHolders === 2) {\\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\\n    arr[L++] = tmp & 0xFF\\n  } else if (placeHolders === 1) {\\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\\n    arr[L++] = (tmp >> 8) & 0xFF\\n    arr[L++] = tmp & 0xFF\\n  }\\n\\n  return arr\\n}\\n\\nfunction tripletToBase64 (num) {\\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\\n}\\n\\nfunction encodeChunk (uint8, start, end) {\\n  var tmp\\n  var output = []\\n  for (var i = start; i < end; i += 3) {\\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\\n    output.push(tripletToBase64(tmp))\\n  }\\n  return output.join('')\\n}\\n\\nfunction fromByteArray (uint8) {\\n  var tmp\\n  var len = uint8.length\\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\\n  var output = ''\\n  var parts = []\\n  var maxChunkLength = 16383 // must be multiple of 3\\n\\n  // go through the array every three bytes, we'll deal with trailing stuff later\\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\\n  }\\n\\n  // pad the end with zeros, but make sure to not forget the extra bytes\\n  if (extraBytes === 1) {\\n    tmp = uint8[len - 1]\\n    output += lookup[tmp >> 2]\\n    output += lookup[(tmp << 4) & 0x3F]\\n    output += '=='\\n  } else if (extraBytes === 2) {\\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\\n    output += lookup[tmp >> 10]\\n    output += lookup[(tmp >> 4) & 0x3F]\\n    output += lookup[(tmp << 2) & 0x3F]\\n    output += '='\\n  }\\n\\n  parts.push(output)\\n\\n  return parts.join('')\\n}\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Jhc2U2NC1qcy9pbmRleC5qcz8yYWRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jhc2U2NC1qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\");\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/* WEBPACK VAR INJECTION */(function(global) {/*!\\n * The buffer module from node.js, for the browser.\\n *\\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\\n * @license  MIT\\n */\\n/* eslint-disable no-proto */\\n\\n\\n\\nvar base64 = __webpack_require__(14)\\nvar ieee754 = __webpack_require__(16)\\nvar isArray = __webpack_require__(17)\\n\\nexports.Buffer = Buffer\\nexports.SlowBuffer = SlowBuffer\\nexports.INSPECT_MAX_BYTES = 50\\n\\n/**\\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\\n *   === true    Use Uint8Array implementation (fastest)\\n *   === false   Use Object implementation (most compatible, even IE6)\\n *\\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\\n * Opera 11.6+, iOS 4.2+.\\n *\\n * Due to various browser bugs, sometimes the Object implementation will be used even\\n * when the browser supports typed arrays.\\n *\\n * Note:\\n *\\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\\n *\\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\\n *\\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\\n *     incorrect length in some situations.\\n\\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\\n * get the Object implementation, which is slower but behaves correctly.\\n */\\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\\n  ? global.TYPED_ARRAY_SUPPORT\\n  : typedArraySupport()\\n\\n/*\\n * Export kMaxLength after typed array support is determined.\\n */\\nexports.kMaxLength = kMaxLength()\\n\\nfunction typedArraySupport () {\\n  try {\\n    var arr = new Uint8Array(1)\\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\\n    return arr.foo() === 42 && // typed array instances can be augmented\\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\\n  } catch (e) {\\n    return false\\n  }\\n}\\n\\nfunction kMaxLength () {\\n  return Buffer.TYPED_ARRAY_SUPPORT\\n    ? 0x7fffffff\\n    : 0x3fffffff\\n}\\n\\nfunction createBuffer (that, length) {\\n  if (kMaxLength() < length) {\\n    throw new RangeError('Invalid typed array length')\\n  }\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    // Return an augmented `Uint8Array` instance, for best performance\\n    that = new Uint8Array(length)\\n    that.__proto__ = Buffer.prototype\\n  } else {\\n    // Fallback: Return an object instance of the Buffer class\\n    if (that === null) {\\n      that = new Buffer(length)\\n    }\\n    that.length = length\\n  }\\n\\n  return that\\n}\\n\\n/**\\n * The Buffer constructor returns instances of `Uint8Array` that have their\\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\\n * returns a single octet.\\n *\\n * The `Uint8Array` prototype remains unmodified.\\n */\\n\\nfunction Buffer (arg, encodingOrOffset, length) {\\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\\n    return new Buffer(arg, encodingOrOffset, length)\\n  }\\n\\n  // Common case.\\n  if (typeof arg === 'number') {\\n    if (typeof encodingOrOffset === 'string') {\\n      throw new Error(\\n        'If encoding is specified then the first argument must be a string'\\n      )\\n    }\\n    return allocUnsafe(this, arg)\\n  }\\n  return from(this, arg, encodingOrOffset, length)\\n}\\n\\nBuffer.poolSize = 8192 // not used by this implementation\\n\\n// TODO: Legacy, not needed anymore. Remove in next major version.\\nBuffer._augment = function (arr) {\\n  arr.__proto__ = Buffer.prototype\\n  return arr\\n}\\n\\nfunction from (that, value, encodingOrOffset, length) {\\n  if (typeof value === 'number') {\\n    throw new TypeError('\\\"value\\\" argument must not be a number')\\n  }\\n\\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\\n  }\\n\\n  if (typeof value === 'string') {\\n    return fromString(that, value, encodingOrOffset)\\n  }\\n\\n  return fromObject(that, value)\\n}\\n\\n/**\\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\\n * if value is a number.\\n * Buffer.from(str[, encoding])\\n * Buffer.from(array)\\n * Buffer.from(buffer)\\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\\n **/\\nBuffer.from = function (value, encodingOrOffset, length) {\\n  return from(null, value, encodingOrOffset, length)\\n}\\n\\nif (Buffer.TYPED_ARRAY_SUPPORT) {\\n  Buffer.prototype.__proto__ = Uint8Array.prototype\\n  Buffer.__proto__ = Uint8Array\\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\\n      Buffer[Symbol.species] === Buffer) {\\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\\n    Object.defineProperty(Buffer, Symbol.species, {\\n      value: null,\\n      configurable: true\\n    })\\n  }\\n}\\n\\nfunction assertSize (size) {\\n  if (typeof size !== 'number') {\\n    throw new TypeError('\\\"size\\\" argument must be a number')\\n  } else if (size < 0) {\\n    throw new RangeError('\\\"size\\\" argument must not be negative')\\n  }\\n}\\n\\nfunction alloc (that, size, fill, encoding) {\\n  assertSize(size)\\n  if (size <= 0) {\\n    return createBuffer(that, size)\\n  }\\n  if (fill !== undefined) {\\n    // Only pay attention to encoding if it's a string. This\\n    // prevents accidentally sending in a number that would\\n    // be interpretted as a start offset.\\n    return typeof encoding === 'string'\\n      ? createBuffer(that, size).fill(fill, encoding)\\n      : createBuffer(that, size).fill(fill)\\n  }\\n  return createBuffer(that, size)\\n}\\n\\n/**\\n * Creates a new filled Buffer instance.\\n * alloc(size[, fill[, encoding]])\\n **/\\nBuffer.alloc = function (size, fill, encoding) {\\n  return alloc(null, size, fill, encoding)\\n}\\n\\nfunction allocUnsafe (that, size) {\\n  assertSize(size)\\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\\n    for (var i = 0; i < size; ++i) {\\n      that[i] = 0\\n    }\\n  }\\n  return that\\n}\\n\\n/**\\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\\n * */\\nBuffer.allocUnsafe = function (size) {\\n  return allocUnsafe(null, size)\\n}\\n/**\\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\\n */\\nBuffer.allocUnsafeSlow = function (size) {\\n  return allocUnsafe(null, size)\\n}\\n\\nfunction fromString (that, string, encoding) {\\n  if (typeof encoding !== 'string' || encoding === '') {\\n    encoding = 'utf8'\\n  }\\n\\n  if (!Buffer.isEncoding(encoding)) {\\n    throw new TypeError('\\\"encoding\\\" must be a valid string encoding')\\n  }\\n\\n  var length = byteLength(string, encoding) | 0\\n  that = createBuffer(that, length)\\n\\n  var actual = that.write(string, encoding)\\n\\n  if (actual !== length) {\\n    // Writing a hex string, for example, that contains invalid characters will\\n    // cause everything after the first invalid character to be ignored. (e.g.\\n    // 'abxxcd' will be treated as 'ab')\\n    that = that.slice(0, actual)\\n  }\\n\\n  return that\\n}\\n\\nfunction fromArrayLike (that, array) {\\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\\n  that = createBuffer(that, length)\\n  for (var i = 0; i < length; i += 1) {\\n    that[i] = array[i] & 255\\n  }\\n  return that\\n}\\n\\nfunction fromArrayBuffer (that, array, byteOffset, length) {\\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\\n\\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\\n    throw new RangeError('\\\\'offset\\\\' is out of bounds')\\n  }\\n\\n  if (array.byteLength < byteOffset + (length || 0)) {\\n    throw new RangeError('\\\\'length\\\\' is out of bounds')\\n  }\\n\\n  if (byteOffset === undefined && length === undefined) {\\n    array = new Uint8Array(array)\\n  } else if (length === undefined) {\\n    array = new Uint8Array(array, byteOffset)\\n  } else {\\n    array = new Uint8Array(array, byteOffset, length)\\n  }\\n\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    // Return an augmented `Uint8Array` instance, for best performance\\n    that = array\\n    that.__proto__ = Buffer.prototype\\n  } else {\\n    // Fallback: Return an object instance of the Buffer class\\n    that = fromArrayLike(that, array)\\n  }\\n  return that\\n}\\n\\nfunction fromObject (that, obj) {\\n  if (Buffer.isBuffer(obj)) {\\n    var len = checked(obj.length) | 0\\n    that = createBuffer(that, len)\\n\\n    if (that.length === 0) {\\n      return that\\n    }\\n\\n    obj.copy(that, 0, 0, len)\\n    return that\\n  }\\n\\n  if (obj) {\\n    if ((typeof ArrayBuffer !== 'undefined' &&\\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\\n        return createBuffer(that, 0)\\n      }\\n      return fromArrayLike(that, obj)\\n    }\\n\\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\\n      return fromArrayLike(that, obj.data)\\n    }\\n  }\\n\\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\\n}\\n\\nfunction checked (length) {\\n  // Note: cannot use `length < kMaxLength()` here because that fails when\\n  // length is NaN (which is otherwise coerced to zero.)\\n  if (length >= kMaxLength()) {\\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\\n  }\\n  return length | 0\\n}\\n\\nfunction SlowBuffer (length) {\\n  if (+length != length) { // eslint-disable-line eqeqeq\\n    length = 0\\n  }\\n  return Buffer.alloc(+length)\\n}\\n\\nBuffer.isBuffer = function isBuffer (b) {\\n  return !!(b != null && b._isBuffer)\\n}\\n\\nBuffer.compare = function compare (a, b) {\\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\\n    throw new TypeError('Arguments must be Buffers')\\n  }\\n\\n  if (a === b) return 0\\n\\n  var x = a.length\\n  var y = b.length\\n\\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\\n    if (a[i] !== b[i]) {\\n      x = a[i]\\n      y = b[i]\\n      break\\n    }\\n  }\\n\\n  if (x < y) return -1\\n  if (y < x) return 1\\n  return 0\\n}\\n\\nBuffer.isEncoding = function isEncoding (encoding) {\\n  switch (String(encoding).toLowerCase()) {\\n    case 'hex':\\n    case 'utf8':\\n    case 'utf-8':\\n    case 'ascii':\\n    case 'latin1':\\n    case 'binary':\\n    case 'base64':\\n    case 'ucs2':\\n    case 'ucs-2':\\n    case 'utf16le':\\n    case 'utf-16le':\\n      return true\\n    default:\\n      return false\\n  }\\n}\\n\\nBuffer.concat = function concat (list, length) {\\n  if (!isArray(list)) {\\n    throw new TypeError('\\\"list\\\" argument must be an Array of Buffers')\\n  }\\n\\n  if (list.length === 0) {\\n    return Buffer.alloc(0)\\n  }\\n\\n  var i\\n  if (length === undefined) {\\n    length = 0\\n    for (i = 0; i < list.length; ++i) {\\n      length += list[i].length\\n    }\\n  }\\n\\n  var buffer = Buffer.allocUnsafe(length)\\n  var pos = 0\\n  for (i = 0; i < list.length; ++i) {\\n    var buf = list[i]\\n    if (!Buffer.isBuffer(buf)) {\\n      throw new TypeError('\\\"list\\\" argument must be an Array of Buffers')\\n    }\\n    buf.copy(buffer, pos)\\n    pos += buf.length\\n  }\\n  return buffer\\n}\\n\\nfunction byteLength (string, encoding) {\\n  if (Buffer.isBuffer(string)) {\\n    return string.length\\n  }\\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\\n    return string.byteLength\\n  }\\n  if (typeof string !== 'string') {\\n    string = '' + string\\n  }\\n\\n  var len = string.length\\n  if (len === 0) return 0\\n\\n  // Use a for loop to avoid recursion\\n  var loweredCase = false\\n  for (;;) {\\n    switch (encoding) {\\n      case 'ascii':\\n      case 'latin1':\\n      case 'binary':\\n        return len\\n      case 'utf8':\\n      case 'utf-8':\\n      case undefined:\\n        return utf8ToBytes(string).length\\n      case 'ucs2':\\n      case 'ucs-2':\\n      case 'utf16le':\\n      case 'utf-16le':\\n        return len * 2\\n      case 'hex':\\n        return len >>> 1\\n      case 'base64':\\n        return base64ToBytes(string).length\\n      default:\\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\\n        encoding = ('' + encoding).toLowerCase()\\n        loweredCase = true\\n    }\\n  }\\n}\\nBuffer.byteLength = byteLength\\n\\nfunction slowToString (encoding, start, end) {\\n  var loweredCase = false\\n\\n  // No need to verify that \\\"this.length <= MAX_UINT32\\\" since it's a read-only\\n  // property of a typed array.\\n\\n  // This behaves neither like String nor Uint8Array in that we set start/end\\n  // to their upper/lower bounds if the value passed is out of range.\\n  // undefined is handled specially as per ECMA-262 6th Edition,\\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\\n  if (start === undefined || start < 0) {\\n    start = 0\\n  }\\n  // Return early if start > this.length. Done here to prevent potential uint32\\n  // coercion fail below.\\n  if (start > this.length) {\\n    return ''\\n  }\\n\\n  if (end === undefined || end > this.length) {\\n    end = this.length\\n  }\\n\\n  if (end <= 0) {\\n    return ''\\n  }\\n\\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\\n  end >>>= 0\\n  start >>>= 0\\n\\n  if (end <= start) {\\n    return ''\\n  }\\n\\n  if (!encoding) encoding = 'utf8'\\n\\n  while (true) {\\n    switch (encoding) {\\n      case 'hex':\\n        return hexSlice(this, start, end)\\n\\n      case 'utf8':\\n      case 'utf-8':\\n        return utf8Slice(this, start, end)\\n\\n      case 'ascii':\\n        return asciiSlice(this, start, end)\\n\\n      case 'latin1':\\n      case 'binary':\\n        return latin1Slice(this, start, end)\\n\\n      case 'base64':\\n        return base64Slice(this, start, end)\\n\\n      case 'ucs2':\\n      case 'ucs-2':\\n      case 'utf16le':\\n      case 'utf-16le':\\n        return utf16leSlice(this, start, end)\\n\\n      default:\\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\\n        encoding = (encoding + '').toLowerCase()\\n        loweredCase = true\\n    }\\n  }\\n}\\n\\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\\n// Buffer instances.\\nBuffer.prototype._isBuffer = true\\n\\nfunction swap (b, n, m) {\\n  var i = b[n]\\n  b[n] = b[m]\\n  b[m] = i\\n}\\n\\nBuffer.prototype.swap16 = function swap16 () {\\n  var len = this.length\\n  if (len % 2 !== 0) {\\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\\n  }\\n  for (var i = 0; i < len; i += 2) {\\n    swap(this, i, i + 1)\\n  }\\n  return this\\n}\\n\\nBuffer.prototype.swap32 = function swap32 () {\\n  var len = this.length\\n  if (len % 4 !== 0) {\\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\\n  }\\n  for (var i = 0; i < len; i += 4) {\\n    swap(this, i, i + 3)\\n    swap(this, i + 1, i + 2)\\n  }\\n  return this\\n}\\n\\nBuffer.prototype.swap64 = function swap64 () {\\n  var len = this.length\\n  if (len % 8 !== 0) {\\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\\n  }\\n  for (var i = 0; i < len; i += 8) {\\n    swap(this, i, i + 7)\\n    swap(this, i + 1, i + 6)\\n    swap(this, i + 2, i + 5)\\n    swap(this, i + 3, i + 4)\\n  }\\n  return this\\n}\\n\\nBuffer.prototype.toString = function toString () {\\n  var length = this.length | 0\\n  if (length === 0) return ''\\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\\n  return slowToString.apply(this, arguments)\\n}\\n\\nBuffer.prototype.equals = function equals (b) {\\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\\n  if (this === b) return true\\n  return Buffer.compare(this, b) === 0\\n}\\n\\nBuffer.prototype.inspect = function inspect () {\\n  var str = ''\\n  var max = exports.INSPECT_MAX_BYTES\\n  if (this.length > 0) {\\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\\n    if (this.length > max) str += ' ... '\\n  }\\n  return '<Buffer ' + str + '>'\\n}\\n\\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\\n  if (!Buffer.isBuffer(target)) {\\n    throw new TypeError('Argument must be a Buffer')\\n  }\\n\\n  if (start === undefined) {\\n    start = 0\\n  }\\n  if (end === undefined) {\\n    end = target ? target.length : 0\\n  }\\n  if (thisStart === undefined) {\\n    thisStart = 0\\n  }\\n  if (thisEnd === undefined) {\\n    thisEnd = this.length\\n  }\\n\\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\\n    throw new RangeError('out of range index')\\n  }\\n\\n  if (thisStart >= thisEnd && start >= end) {\\n    return 0\\n  }\\n  if (thisStart >= thisEnd) {\\n    return -1\\n  }\\n  if (start >= end) {\\n    return 1\\n  }\\n\\n  start >>>= 0\\n  end >>>= 0\\n  thisStart >>>= 0\\n  thisEnd >>>= 0\\n\\n  if (this === target) return 0\\n\\n  var x = thisEnd - thisStart\\n  var y = end - start\\n  var len = Math.min(x, y)\\n\\n  var thisCopy = this.slice(thisStart, thisEnd)\\n  var targetCopy = target.slice(start, end)\\n\\n  for (var i = 0; i < len; ++i) {\\n    if (thisCopy[i] !== targetCopy[i]) {\\n      x = thisCopy[i]\\n      y = targetCopy[i]\\n      break\\n    }\\n  }\\n\\n  if (x < y) return -1\\n  if (y < x) return 1\\n  return 0\\n}\\n\\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\\n//\\n// Arguments:\\n// - buffer - a Buffer to search\\n// - val - a string, Buffer, or number\\n// - byteOffset - an index into `buffer`; will be clamped to an int32\\n// - encoding - an optional encoding, relevant is val is a string\\n// - dir - true for indexOf, false for lastIndexOf\\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\\n  // Empty buffer means no match\\n  if (buffer.length === 0) return -1\\n\\n  // Normalize byteOffset\\n  if (typeof byteOffset === 'string') {\\n    encoding = byteOffset\\n    byteOffset = 0\\n  } else if (byteOffset > 0x7fffffff) {\\n    byteOffset = 0x7fffffff\\n  } else if (byteOffset < -0x80000000) {\\n    byteOffset = -0x80000000\\n  }\\n  byteOffset = +byteOffset  // Coerce to Number.\\n  if (isNaN(byteOffset)) {\\n    // byteOffset: it it's undefined, null, NaN, \\\"foo\\\", etc, search whole buffer\\n    byteOffset = dir ? 0 : (buffer.length - 1)\\n  }\\n\\n  // Normalize byteOffset: negative offsets start from the end of the buffer\\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\\n  if (byteOffset >= buffer.length) {\\n    if (dir) return -1\\n    else byteOffset = buffer.length - 1\\n  } else if (byteOffset < 0) {\\n    if (dir) byteOffset = 0\\n    else return -1\\n  }\\n\\n  // Normalize val\\n  if (typeof val === 'string') {\\n    val = Buffer.from(val, encoding)\\n  }\\n\\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\\n  if (Buffer.isBuffer(val)) {\\n    // Special case: looking for empty string/buffer always fails\\n    if (val.length === 0) {\\n      return -1\\n    }\\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\\n  } else if (typeof val === 'number') {\\n    val = val & 0xFF // Search for a byte value [0-255]\\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\\n        typeof Uint8Array.prototype.indexOf === 'function') {\\n      if (dir) {\\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\\n      } else {\\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\\n      }\\n    }\\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\\n  }\\n\\n  throw new TypeError('val must be string, number or Buffer')\\n}\\n\\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\\n  var indexSize = 1\\n  var arrLength = arr.length\\n  var valLength = val.length\\n\\n  if (encoding !== undefined) {\\n    encoding = String(encoding).toLowerCase()\\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\\n        encoding === 'utf16le' || encoding === 'utf-16le') {\\n      if (arr.length < 2 || val.length < 2) {\\n        return -1\\n      }\\n      indexSize = 2\\n      arrLength /= 2\\n      valLength /= 2\\n      byteOffset /= 2\\n    }\\n  }\\n\\n  function read (buf, i) {\\n    if (indexSize === 1) {\\n      return buf[i]\\n    } else {\\n      return buf.readUInt16BE(i * indexSize)\\n    }\\n  }\\n\\n  var i\\n  if (dir) {\\n    var foundIndex = -1\\n    for (i = byteOffset; i < arrLength; i++) {\\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\\n        if (foundIndex === -1) foundIndex = i\\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\\n      } else {\\n        if (foundIndex !== -1) i -= i - foundIndex\\n        foundIndex = -1\\n      }\\n    }\\n  } else {\\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\\n    for (i = byteOffset; i >= 0; i--) {\\n      var found = true\\n      for (var j = 0; j < valLength; j++) {\\n        if (read(arr, i + j) !== read(val, j)) {\\n          found = false\\n          break\\n        }\\n      }\\n      if (found) return i\\n    }\\n  }\\n\\n  return -1\\n}\\n\\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\\n  return this.indexOf(val, byteOffset, encoding) !== -1\\n}\\n\\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\\n}\\n\\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\\n}\\n\\nfunction hexWrite (buf, string, offset, length) {\\n  offset = Number(offset) || 0\\n  var remaining = buf.length - offset\\n  if (!length) {\\n    length = remaining\\n  } else {\\n    length = Number(length)\\n    if (length > remaining) {\\n      length = remaining\\n    }\\n  }\\n\\n  // must be an even number of digits\\n  var strLen = string.length\\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\\n\\n  if (length > strLen / 2) {\\n    length = strLen / 2\\n  }\\n  for (var i = 0; i < length; ++i) {\\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\\n    if (isNaN(parsed)) return i\\n    buf[offset + i] = parsed\\n  }\\n  return i\\n}\\n\\nfunction utf8Write (buf, string, offset, length) {\\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\\n}\\n\\nfunction asciiWrite (buf, string, offset, length) {\\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\\n}\\n\\nfunction latin1Write (buf, string, offset, length) {\\n  return asciiWrite(buf, string, offset, length)\\n}\\n\\nfunction base64Write (buf, string, offset, length) {\\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\\n}\\n\\nfunction ucs2Write (buf, string, offset, length) {\\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\\n}\\n\\nBuffer.prototype.write = function write (string, offset, length, encoding) {\\n  // Buffer#write(string)\\n  if (offset === undefined) {\\n    encoding = 'utf8'\\n    length = this.length\\n    offset = 0\\n  // Buffer#write(string, encoding)\\n  } else if (length === undefined && typeof offset === 'string') {\\n    encoding = offset\\n    length = this.length\\n    offset = 0\\n  // Buffer#write(string, offset[, length][, encoding])\\n  } else if (isFinite(offset)) {\\n    offset = offset | 0\\n    if (isFinite(length)) {\\n      length = length | 0\\n      if (encoding === undefined) encoding = 'utf8'\\n    } else {\\n      encoding = length\\n      length = undefined\\n    }\\n  // legacy write(string, encoding, offset, length) - remove in v0.13\\n  } else {\\n    throw new Error(\\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\\n    )\\n  }\\n\\n  var remaining = this.length - offset\\n  if (length === undefined || length > remaining) length = remaining\\n\\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\\n    throw new RangeError('Attempt to write outside buffer bounds')\\n  }\\n\\n  if (!encoding) encoding = 'utf8'\\n\\n  var loweredCase = false\\n  for (;;) {\\n    switch (encoding) {\\n      case 'hex':\\n        return hexWrite(this, string, offset, length)\\n\\n      case 'utf8':\\n      case 'utf-8':\\n        return utf8Write(this, string, offset, length)\\n\\n      case 'ascii':\\n        return asciiWrite(this, string, offset, length)\\n\\n      case 'latin1':\\n      case 'binary':\\n        return latin1Write(this, string, offset, length)\\n\\n      case 'base64':\\n        // Warning: maxLength not taken into account in base64Write\\n        return base64Write(this, string, offset, length)\\n\\n      case 'ucs2':\\n      case 'ucs-2':\\n      case 'utf16le':\\n      case 'utf-16le':\\n        return ucs2Write(this, string, offset, length)\\n\\n      default:\\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\\n        encoding = ('' + encoding).toLowerCase()\\n        loweredCase = true\\n    }\\n  }\\n}\\n\\nBuffer.prototype.toJSON = function toJSON () {\\n  return {\\n    type: 'Buffer',\\n    data: Array.prototype.slice.call(this._arr || this, 0)\\n  }\\n}\\n\\nfunction base64Slice (buf, start, end) {\\n  if (start === 0 && end === buf.length) {\\n    return base64.fromByteArray(buf)\\n  } else {\\n    return base64.fromByteArray(buf.slice(start, end))\\n  }\\n}\\n\\nfunction utf8Slice (buf, start, end) {\\n  end = Math.min(buf.length, end)\\n  var res = []\\n\\n  var i = start\\n  while (i < end) {\\n    var firstByte = buf[i]\\n    var codePoint = null\\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\\n      : (firstByte > 0xDF) ? 3\\n      : (firstByte > 0xBF) ? 2\\n      : 1\\n\\n    if (i + bytesPerSequence <= end) {\\n      var secondByte, thirdByte, fourthByte, tempCodePoint\\n\\n      switch (bytesPerSequence) {\\n        case 1:\\n          if (firstByte < 0x80) {\\n            codePoint = firstByte\\n          }\\n          break\\n        case 2:\\n          secondByte = buf[i + 1]\\n          if ((secondByte & 0xC0) === 0x80) {\\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\\n            if (tempCodePoint > 0x7F) {\\n              codePoint = tempCodePoint\\n            }\\n          }\\n          break\\n        case 3:\\n          secondByte = buf[i + 1]\\n          thirdByte = buf[i + 2]\\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\\n              codePoint = tempCodePoint\\n            }\\n          }\\n          break\\n        case 4:\\n          secondByte = buf[i + 1]\\n          thirdByte = buf[i + 2]\\n          fourthByte = buf[i + 3]\\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\\n              codePoint = tempCodePoint\\n            }\\n          }\\n      }\\n    }\\n\\n    if (codePoint === null) {\\n      // we did not generate a valid codePoint so insert a\\n      // replacement char (U+FFFD) and advance only 1 byte\\n      codePoint = 0xFFFD\\n      bytesPerSequence = 1\\n    } else if (codePoint > 0xFFFF) {\\n      // encode to utf16 (surrogate pair dance)\\n      codePoint -= 0x10000\\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\\n      codePoint = 0xDC00 | codePoint & 0x3FF\\n    }\\n\\n    res.push(codePoint)\\n    i += bytesPerSequence\\n  }\\n\\n  return decodeCodePointsArray(res)\\n}\\n\\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\\n// the lowest limit is Chrome, with 0x10000 args.\\n// We go 1 magnitude less, for safety\\nvar MAX_ARGUMENTS_LENGTH = 0x1000\\n\\nfunction decodeCodePointsArray (codePoints) {\\n  var len = codePoints.length\\n  if (len <= MAX_ARGUMENTS_LENGTH) {\\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\\n  }\\n\\n  // Decode in chunks to avoid \\\"call stack size exceeded\\\".\\n  var res = ''\\n  var i = 0\\n  while (i < len) {\\n    res += String.fromCharCode.apply(\\n      String,\\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\\n    )\\n  }\\n  return res\\n}\\n\\nfunction asciiSlice (buf, start, end) {\\n  var ret = ''\\n  end = Math.min(buf.length, end)\\n\\n  for (var i = start; i < end; ++i) {\\n    ret += String.fromCharCode(buf[i] & 0x7F)\\n  }\\n  return ret\\n}\\n\\nfunction latin1Slice (buf, start, end) {\\n  var ret = ''\\n  end = Math.min(buf.length, end)\\n\\n  for (var i = start; i < end; ++i) {\\n    ret += String.fromCharCode(buf[i])\\n  }\\n  return ret\\n}\\n\\nfunction hexSlice (buf, start, end) {\\n  var len = buf.length\\n\\n  if (!start || start < 0) start = 0\\n  if (!end || end < 0 || end > len) end = len\\n\\n  var out = ''\\n  for (var i = start; i < end; ++i) {\\n    out += toHex(buf[i])\\n  }\\n  return out\\n}\\n\\nfunction utf16leSlice (buf, start, end) {\\n  var bytes = buf.slice(start, end)\\n  var res = ''\\n  for (var i = 0; i < bytes.length; i += 2) {\\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\\n  }\\n  return res\\n}\\n\\nBuffer.prototype.slice = function slice (start, end) {\\n  var len = this.length\\n  start = ~~start\\n  end = end === undefined ? len : ~~end\\n\\n  if (start < 0) {\\n    start += len\\n    if (start < 0) start = 0\\n  } else if (start > len) {\\n    start = len\\n  }\\n\\n  if (end < 0) {\\n    end += len\\n    if (end < 0) end = 0\\n  } else if (end > len) {\\n    end = len\\n  }\\n\\n  if (end < start) end = start\\n\\n  var newBuf\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    newBuf = this.subarray(start, end)\\n    newBuf.__proto__ = Buffer.prototype\\n  } else {\\n    var sliceLen = end - start\\n    newBuf = new Buffer(sliceLen, undefined)\\n    for (var i = 0; i < sliceLen; ++i) {\\n      newBuf[i] = this[i + start]\\n    }\\n  }\\n\\n  return newBuf\\n}\\n\\n/*\\n * Need to make sure that buffer isn't trying to write out of bounds.\\n */\\nfunction checkOffset (offset, ext, length) {\\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\\n}\\n\\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\n\\n  var val = this[offset]\\n  var mul = 1\\n  var i = 0\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    val += this[offset + i] * mul\\n  }\\n\\n  return val\\n}\\n\\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) {\\n    checkOffset(offset, byteLength, this.length)\\n  }\\n\\n  var val = this[offset + --byteLength]\\n  var mul = 1\\n  while (byteLength > 0 && (mul *= 0x100)) {\\n    val += this[offset + --byteLength] * mul\\n  }\\n\\n  return val\\n}\\n\\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 1, this.length)\\n  return this[offset]\\n}\\n\\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  return this[offset] | (this[offset + 1] << 8)\\n}\\n\\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  return (this[offset] << 8) | this[offset + 1]\\n}\\n\\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return ((this[offset]) |\\n      (this[offset + 1] << 8) |\\n      (this[offset + 2] << 16)) +\\n      (this[offset + 3] * 0x1000000)\\n}\\n\\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return (this[offset] * 0x1000000) +\\n    ((this[offset + 1] << 16) |\\n    (this[offset + 2] << 8) |\\n    this[offset + 3])\\n}\\n\\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\n\\n  var val = this[offset]\\n  var mul = 1\\n  var i = 0\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    val += this[offset + i] * mul\\n  }\\n  mul *= 0x80\\n\\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\\n\\n  return val\\n}\\n\\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\n\\n  var i = byteLength\\n  var mul = 1\\n  var val = this[offset + --i]\\n  while (i > 0 && (mul *= 0x100)) {\\n    val += this[offset + --i] * mul\\n  }\\n  mul *= 0x80\\n\\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\\n\\n  return val\\n}\\n\\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 1, this.length)\\n  if (!(this[offset] & 0x80)) return (this[offset])\\n  return ((0xff - this[offset] + 1) * -1)\\n}\\n\\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  var val = this[offset] | (this[offset + 1] << 8)\\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\\n}\\n\\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  var val = this[offset + 1] | (this[offset] << 8)\\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\\n}\\n\\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return (this[offset]) |\\n    (this[offset + 1] << 8) |\\n    (this[offset + 2] << 16) |\\n    (this[offset + 3] << 24)\\n}\\n\\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return (this[offset] << 24) |\\n    (this[offset + 1] << 16) |\\n    (this[offset + 2] << 8) |\\n    (this[offset + 3])\\n}\\n\\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n  return ieee754.read(this, offset, true, 23, 4)\\n}\\n\\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n  return ieee754.read(this, offset, false, 23, 4)\\n}\\n\\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 8, this.length)\\n  return ieee754.read(this, offset, true, 52, 8)\\n}\\n\\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 8, this.length)\\n  return ieee754.read(this, offset, false, 52, 8)\\n}\\n\\nfunction checkInt (buf, value, offset, ext, max, min) {\\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\\\"buffer\\\" argument must be a Buffer instance')\\n  if (value > max || value < min) throw new RangeError('\\\"value\\\" argument is out of bounds')\\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\\n}\\n\\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) {\\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\\n  }\\n\\n  var mul = 1\\n  var i = 0\\n  this[offset] = value & 0xFF\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    this[offset + i] = (value / mul) & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) {\\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\\n  }\\n\\n  var i = byteLength - 1\\n  var mul = 1\\n  this[offset + i] = value & 0xFF\\n  while (--i >= 0 && (mul *= 0x100)) {\\n    this[offset + i] = (value / mul) & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\\n  this[offset] = (value & 0xff)\\n  return offset + 1\\n}\\n\\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\\n  if (value < 0) value = 0xffff + value + 1\\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\\n      (littleEndian ? i : 1 - i) * 8\\n  }\\n}\\n\\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value & 0xff)\\n    this[offset + 1] = (value >>> 8)\\n  } else {\\n    objectWriteUInt16(this, value, offset, true)\\n  }\\n  return offset + 2\\n}\\n\\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value >>> 8)\\n    this[offset + 1] = (value & 0xff)\\n  } else {\\n    objectWriteUInt16(this, value, offset, false)\\n  }\\n  return offset + 2\\n}\\n\\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\\n  if (value < 0) value = 0xffffffff + value + 1\\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\\n  }\\n}\\n\\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset + 3] = (value >>> 24)\\n    this[offset + 2] = (value >>> 16)\\n    this[offset + 1] = (value >>> 8)\\n    this[offset] = (value & 0xff)\\n  } else {\\n    objectWriteUInt32(this, value, offset, true)\\n  }\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value >>> 24)\\n    this[offset + 1] = (value >>> 16)\\n    this[offset + 2] = (value >>> 8)\\n    this[offset + 3] = (value & 0xff)\\n  } else {\\n    objectWriteUInt32(this, value, offset, false)\\n  }\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) {\\n    var limit = Math.pow(2, 8 * byteLength - 1)\\n\\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\\n  }\\n\\n  var i = 0\\n  var mul = 1\\n  var sub = 0\\n  this[offset] = value & 0xFF\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\\n      sub = 1\\n    }\\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) {\\n    var limit = Math.pow(2, 8 * byteLength - 1)\\n\\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\\n  }\\n\\n  var i = byteLength - 1\\n  var mul = 1\\n  var sub = 0\\n  this[offset + i] = value & 0xFF\\n  while (--i >= 0 && (mul *= 0x100)) {\\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\\n      sub = 1\\n    }\\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\\n  if (value < 0) value = 0xff + value + 1\\n  this[offset] = (value & 0xff)\\n  return offset + 1\\n}\\n\\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value & 0xff)\\n    this[offset + 1] = (value >>> 8)\\n  } else {\\n    objectWriteUInt16(this, value, offset, true)\\n  }\\n  return offset + 2\\n}\\n\\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value >>> 8)\\n    this[offset + 1] = (value & 0xff)\\n  } else {\\n    objectWriteUInt16(this, value, offset, false)\\n  }\\n  return offset + 2\\n}\\n\\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value & 0xff)\\n    this[offset + 1] = (value >>> 8)\\n    this[offset + 2] = (value >>> 16)\\n    this[offset + 3] = (value >>> 24)\\n  } else {\\n    objectWriteUInt32(this, value, offset, true)\\n  }\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\\n  if (value < 0) value = 0xffffffff + value + 1\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value >>> 24)\\n    this[offset + 1] = (value >>> 16)\\n    this[offset + 2] = (value >>> 8)\\n    this[offset + 3] = (value & 0xff)\\n  } else {\\n    objectWriteUInt32(this, value, offset, false)\\n  }\\n  return offset + 4\\n}\\n\\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\\n  if (offset < 0) throw new RangeError('Index out of range')\\n}\\n\\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\\n  if (!noAssert) {\\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\\n  }\\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\\n  return writeFloat(this, value, offset, true, noAssert)\\n}\\n\\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\\n  return writeFloat(this, value, offset, false, noAssert)\\n}\\n\\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\\n  if (!noAssert) {\\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\\n  }\\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\\n  return offset + 8\\n}\\n\\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\\n  return writeDouble(this, value, offset, true, noAssert)\\n}\\n\\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\\n  return writeDouble(this, value, offset, false, noAssert)\\n}\\n\\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\\n  if (!start) start = 0\\n  if (!end && end !== 0) end = this.length\\n  if (targetStart >= target.length) targetStart = target.length\\n  if (!targetStart) targetStart = 0\\n  if (end > 0 && end < start) end = start\\n\\n  // Copy 0 bytes; we're done\\n  if (end === start) return 0\\n  if (target.length === 0 || this.length === 0) return 0\\n\\n  // Fatal error conditions\\n  if (targetStart < 0) {\\n    throw new RangeError('targetStart out of bounds')\\n  }\\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\\n\\n  // Are we oob?\\n  if (end > this.length) end = this.length\\n  if (target.length - targetStart < end - start) {\\n    end = target.length - targetStart + start\\n  }\\n\\n  var len = end - start\\n  var i\\n\\n  if (this === target && start < targetStart && targetStart < end) {\\n    // descending copy from end\\n    for (i = len - 1; i >= 0; --i) {\\n      target[i + targetStart] = this[i + start]\\n    }\\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\\n    // ascending copy from start\\n    for (i = 0; i < len; ++i) {\\n      target[i + targetStart] = this[i + start]\\n    }\\n  } else {\\n    Uint8Array.prototype.set.call(\\n      target,\\n      this.subarray(start, start + len),\\n      targetStart\\n    )\\n  }\\n\\n  return len\\n}\\n\\n// Usage:\\n//    buffer.fill(number[, offset[, end]])\\n//    buffer.fill(buffer[, offset[, end]])\\n//    buffer.fill(string[, offset[, end]][, encoding])\\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\\n  // Handle string cases:\\n  if (typeof val === 'string') {\\n    if (typeof start === 'string') {\\n      encoding = start\\n      start = 0\\n      end = this.length\\n    } else if (typeof end === 'string') {\\n      encoding = end\\n      end = this.length\\n    }\\n    if (val.length === 1) {\\n      var code = val.charCodeAt(0)\\n      if (code < 256) {\\n        val = code\\n      }\\n    }\\n    if (encoding !== undefined && typeof encoding !== 'string') {\\n      throw new TypeError('encoding must be a string')\\n    }\\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\\n      throw new TypeError('Unknown encoding: ' + encoding)\\n    }\\n  } else if (typeof val === 'number') {\\n    val = val & 255\\n  }\\n\\n  // Invalid ranges are not set to a default, so can range check early.\\n  if (start < 0 || this.length < start || this.length < end) {\\n    throw new RangeError('Out of range index')\\n  }\\n\\n  if (end <= start) {\\n    return this\\n  }\\n\\n  start = start >>> 0\\n  end = end === undefined ? this.length : end >>> 0\\n\\n  if (!val) val = 0\\n\\n  var i\\n  if (typeof val === 'number') {\\n    for (i = start; i < end; ++i) {\\n      this[i] = val\\n    }\\n  } else {\\n    var bytes = Buffer.isBuffer(val)\\n      ? val\\n      : utf8ToBytes(new Buffer(val, encoding).toString())\\n    var len = bytes.length\\n    for (i = 0; i < end - start; ++i) {\\n      this[i + start] = bytes[i % len]\\n    }\\n  }\\n\\n  return this\\n}\\n\\n// HELPER FUNCTIONS\\n// ================\\n\\nvar INVALID_BASE64_RE = /[^+\\\\/0-9A-Za-z-_]/g\\n\\nfunction base64clean (str) {\\n  // Node strips out invalid characters like \\\\n and \\\\t from the string, base64-js does not\\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\\n  // Node converts strings with length < 2 to ''\\n  if (str.length < 2) return ''\\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\\n  while (str.length % 4 !== 0) {\\n    str = str + '='\\n  }\\n  return str\\n}\\n\\nfunction stringtrim (str) {\\n  if (str.trim) return str.trim()\\n  return str.replace(/^\\\\s+|\\\\s+$/g, '')\\n}\\n\\nfunction toHex (n) {\\n  if (n < 16) return '0' + n.toString(16)\\n  return n.toString(16)\\n}\\n\\nfunction utf8ToBytes (string, units) {\\n  units = units || Infinity\\n  var codePoint\\n  var length = string.length\\n  var leadSurrogate = null\\n  var bytes = []\\n\\n  for (var i = 0; i < length; ++i) {\\n    codePoint = string.charCodeAt(i)\\n\\n    // is surrogate component\\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\\n      // last char was a lead\\n      if (!leadSurrogate) {\\n        // no lead yet\\n        if (codePoint > 0xDBFF) {\\n          // unexpected trail\\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n          continue\\n        } else if (i + 1 === length) {\\n          // unpaired lead\\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n          continue\\n        }\\n\\n        // valid lead\\n        leadSurrogate = codePoint\\n\\n        continue\\n      }\\n\\n      // 2 leads in a row\\n      if (codePoint < 0xDC00) {\\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n        leadSurrogate = codePoint\\n        continue\\n      }\\n\\n      // valid surrogate pair\\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\\n    } else if (leadSurrogate) {\\n      // valid bmp char, but last char was a lead\\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n    }\\n\\n    leadSurrogate = null\\n\\n    // encode utf8\\n    if (codePoint < 0x80) {\\n      if ((units -= 1) < 0) break\\n      bytes.push(codePoint)\\n    } else if (codePoint < 0x800) {\\n      if ((units -= 2) < 0) break\\n      bytes.push(\\n        codePoint >> 0x6 | 0xC0,\\n        codePoint & 0x3F | 0x80\\n      )\\n    } else if (codePoint < 0x10000) {\\n      if ((units -= 3) < 0) break\\n      bytes.push(\\n        codePoint >> 0xC | 0xE0,\\n        codePoint >> 0x6 & 0x3F | 0x80,\\n        codePoint & 0x3F | 0x80\\n      )\\n    } else if (codePoint < 0x110000) {\\n      if ((units -= 4) < 0) break\\n      bytes.push(\\n        codePoint >> 0x12 | 0xF0,\\n        codePoint >> 0xC & 0x3F | 0x80,\\n        codePoint >> 0x6 & 0x3F | 0x80,\\n        codePoint & 0x3F | 0x80\\n      )\\n    } else {\\n      throw new Error('Invalid code point')\\n    }\\n  }\\n\\n  return bytes\\n}\\n\\nfunction asciiToBytes (str) {\\n  var byteArray = []\\n  for (var i = 0; i < str.length; ++i) {\\n    // Node's code seems to be doing this and not & 0x7F..\\n    byteArray.push(str.charCodeAt(i) & 0xFF)\\n  }\\n  return byteArray\\n}\\n\\nfunction utf16leToBytes (str, units) {\\n  var c, hi, lo\\n  var byteArray = []\\n  for (var i = 0; i < str.length; ++i) {\\n    if ((units -= 2) < 0) break\\n\\n    c = str.charCodeAt(i)\\n    hi = c >> 8\\n    lo = c % 256\\n    byteArray.push(lo)\\n    byteArray.push(hi)\\n  }\\n\\n  return byteArray\\n}\\n\\nfunction base64ToBytes (str) {\\n  return base64.toByteArray(base64clean(str))\\n}\\n\\nfunction blitBuffer (src, dst, offset, length) {\\n  for (var i = 0; i < length; ++i) {\\n    if ((i + offset >= dst.length) || (i >= src.length)) break\\n    dst[i + offset] = src[i]\\n  }\\n  return i\\n}\\n\\nfunction isnan (val) {\\n  return val !== val // eslint-disable-line no-self-compare\\n}\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2J1ZmZlci9pbmRleC5qcz8xYTU1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVmZmVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\");\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\neval(\"exports.read = function (buffer, offset, isLE, mLen, nBytes) {\\n  var e, m\\n  var eLen = nBytes * 8 - mLen - 1\\n  var eMax = (1 << eLen) - 1\\n  var eBias = eMax >> 1\\n  var nBits = -7\\n  var i = isLE ? (nBytes - 1) : 0\\n  var d = isLE ? -1 : 1\\n  var s = buffer[offset + i]\\n\\n  i += d\\n\\n  e = s & ((1 << (-nBits)) - 1)\\n  s >>= (-nBits)\\n  nBits += eLen\\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\\n\\n  m = e & ((1 << (-nBits)) - 1)\\n  e >>= (-nBits)\\n  nBits += mLen\\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\\n\\n  if (e === 0) {\\n    e = 1 - eBias\\n  } else if (e === eMax) {\\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\\n  } else {\\n    m = m + Math.pow(2, mLen)\\n    e = e - eBias\\n  }\\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\\n}\\n\\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\\n  var e, m, c\\n  var eLen = nBytes * 8 - mLen - 1\\n  var eMax = (1 << eLen) - 1\\n  var eBias = eMax >> 1\\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\\n  var i = isLE ? 0 : (nBytes - 1)\\n  var d = isLE ? 1 : -1\\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\\n\\n  value = Math.abs(value)\\n\\n  if (isNaN(value) || value === Infinity) {\\n    m = isNaN(value) ? 1 : 0\\n    e = eMax\\n  } else {\\n    e = Math.floor(Math.log(value) / Math.LN2)\\n    if (value * (c = Math.pow(2, -e)) < 1) {\\n      e--\\n      c *= 2\\n    }\\n    if (e + eBias >= 1) {\\n      value += rt / c\\n    } else {\\n      value += rt * Math.pow(2, 1 - eBias)\\n    }\\n    if (value * c >= 2) {\\n      e++\\n      c /= 2\\n    }\\n\\n    if (e + eBias >= eMax) {\\n      m = 0\\n      e = eMax\\n    } else if (e + eBias >= 1) {\\n      m = (value * c - 1) * Math.pow(2, mLen)\\n      e = e + eBias\\n    } else {\\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\\n      e = 0\\n    }\\n  }\\n\\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\\n\\n  e = (e << mLen) | m\\n  eLen += mLen\\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\\n\\n  buffer[offset + i - d] |= s * 128\\n}\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2llZWU3NTQvaW5kZXguanM/NzBmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxRQUFRLFVBQVU7O0FBRWxCO0FBQ0EiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pZWVlNzU0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\");\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\neval(\"var toString = {}.toString;\\n\\nmodule.exports = Array.isArray || function (arr) {\\n  return toString.call(arr) == '[object Array]';\\n};\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2lzYXJyYXkvaW5kZXguanM/ZWFiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\");\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\neval(\"// shim for using process in browser\\nvar process = module.exports = {};\\n\\n// cached from whatever global is present so that test runners that stub it\\n// don't break things.  But we need to wrap it in a try catch in case it is\\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\\n// function because try/catches deoptimize in certain engines.\\n\\nvar cachedSetTimeout;\\nvar cachedClearTimeout;\\n\\nfunction defaultSetTimout() {\\n    throw new Error('setTimeout has not been defined');\\n}\\nfunction defaultClearTimeout () {\\n    throw new Error('clearTimeout has not been defined');\\n}\\n(function () {\\n    try {\\n        if (typeof setTimeout === 'function') {\\n            cachedSetTimeout = setTimeout;\\n        } else {\\n            cachedSetTimeout = defaultSetTimout;\\n        }\\n    } catch (e) {\\n        cachedSetTimeout = defaultSetTimout;\\n    }\\n    try {\\n        if (typeof clearTimeout === 'function') {\\n            cachedClearTimeout = clearTimeout;\\n        } else {\\n            cachedClearTimeout = defaultClearTimeout;\\n        }\\n    } catch (e) {\\n        cachedClearTimeout = defaultClearTimeout;\\n    }\\n} ())\\nfunction runTimeout(fun) {\\n    if (cachedSetTimeout === setTimeout) {\\n        //normal enviroments in sane situations\\n        return setTimeout(fun, 0);\\n    }\\n    // if setTimeout wasn't available but was latter defined\\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\\n        cachedSetTimeout = setTimeout;\\n        return setTimeout(fun, 0);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedSetTimeout(fun, 0);\\n    } catch(e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\\n            return cachedSetTimeout.call(null, fun, 0);\\n        } catch(e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\\n            return cachedSetTimeout.call(this, fun, 0);\\n        }\\n    }\\n\\n\\n}\\nfunction runClearTimeout(marker) {\\n    if (cachedClearTimeout === clearTimeout) {\\n        //normal enviroments in sane situations\\n        return clearTimeout(marker);\\n    }\\n    // if clearTimeout wasn't available but was latter defined\\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\\n        cachedClearTimeout = clearTimeout;\\n        return clearTimeout(marker);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedClearTimeout(marker);\\n    } catch (e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\\n            return cachedClearTimeout.call(null, marker);\\n        } catch (e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\\n            return cachedClearTimeout.call(this, marker);\\n        }\\n    }\\n\\n\\n\\n}\\nvar queue = [];\\nvar draining = false;\\nvar currentQueue;\\nvar queueIndex = -1;\\n\\nfunction cleanUpNextTick() {\\n    if (!draining || !currentQueue) {\\n        return;\\n    }\\n    draining = false;\\n    if (currentQueue.length) {\\n        queue = currentQueue.concat(queue);\\n    } else {\\n        queueIndex = -1;\\n    }\\n    if (queue.length) {\\n        drainQueue();\\n    }\\n}\\n\\nfunction drainQueue() {\\n    if (draining) {\\n        return;\\n    }\\n    var timeout = runTimeout(cleanUpNextTick);\\n    draining = true;\\n\\n    var len = queue.length;\\n    while(len) {\\n        currentQueue = queue;\\n        queue = [];\\n        while (++queueIndex < len) {\\n            if (currentQueue) {\\n                currentQueue[queueIndex].run();\\n            }\\n        }\\n        queueIndex = -1;\\n        len = queue.length;\\n    }\\n    currentQueue = null;\\n    draining = false;\\n    runClearTimeout(timeout);\\n}\\n\\nprocess.nextTick = function (fun) {\\n    var args = new Array(arguments.length - 1);\\n    if (arguments.length > 1) {\\n        for (var i = 1; i < arguments.length; i++) {\\n            args[i - 1] = arguments[i];\\n        }\\n    }\\n    queue.push(new Item(fun, args));\\n    if (queue.length === 1 && !draining) {\\n        runTimeout(drainQueue);\\n    }\\n};\\n\\n// v8 likes predictible objects\\nfunction Item(fun, array) {\\n    this.fun = fun;\\n    this.array = array;\\n}\\nItem.prototype.run = function () {\\n    this.fun.apply(null, this.array);\\n};\\nprocess.title = 'browser';\\nprocess.browser = true;\\nprocess.env = {};\\nprocess.argv = [];\\nprocess.version = ''; // empty string to avoid regexp issues\\nprocess.versions = {};\\n\\nfunction noop() {}\\n\\nprocess.on = noop;\\nprocess.addListener = noop;\\nprocess.once = noop;\\nprocess.off = noop;\\nprocess.removeListener = noop;\\nprocess.removeAllListeners = noop;\\nprocess.emit = noop;\\n\\nprocess.binding = function (name) {\\n    throw new Error('process.binding is not supported');\\n};\\n\\nprocess.cwd = function () { return '/' };\\nprocess.chdir = function (dir) {\\n    throw new Error('process.chdir is not supported');\\n};\\nprocess.umask = function() { return 0; };\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\");\n\n/***/ })\n/******/ ]);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wdWJsaWMvYnVuZGxlLmpzP2ZiZDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEIsRUFBRTtBQUMvRCx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELCtEQUErRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNFdBQTRXLHFEQUFxRCxJQUFJLG1FQUFtRSxxQ0FBcUMsbUlBQW1JLGtDQUFrQyxjQUFjLHVNQUF1TSxzRUFBc0UsT0FBTyxnRUFBZ0UsR0FBRyxJQUFJLG1GQUFtRixjQUFjOztBQUU1bkMsT0FBTztBQUNQO0FBQ0E7O0FBRUEsWUFBWSw2REFBNkQsa0JBQWtCLEtBQUssSUFBSSxhQUFhLGlIQUFpSCxLQUFLLFdBQVcsaUhBQWlILEtBQUssOEtBQThLLEtBQUssMkJBQTJCLCtDQUErQyxjQUFjOztBQUVubkIsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMENBQTBDLHFDQUFxQyxpQ0FBaUMsZ0RBQWdELDhDQUE4QywyQ0FBMkMsbUJBQW1CLE1BQU0sMkNBQTJDLGNBQWM7O0FBRTNVLE9BQU87QUFDUDtBQUNBOztBQUVBLG9JQUFvSSxzRUFBc0UsZ0ZBQWdGLEVBQUUscURBQXFELHdDQUF3QywrRUFBK0Usc0hBQXNILG1IQUFtSCxzRkFBc0YsMkJBQTJCLE9BQU8sRUFBRSxLQUFLLDhGQUE4RixVQUFVLEVBQUUsRUFBRSxHQUFHLDJDQUEyQyxjQUFjOztBQUV4OUIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsb01BQW9NLDZIQUE2SCxtSkFBbUosNEJBQTRCLGdDQUFnQyxnSkFBZ0osa0NBQWtDLDhCQUE4QixtQkFBbUIsaUJBQWlCLE9BQU8sMEJBQTBCLEtBQUssbURBQW1ELCtCQUErQixFQUFFLHdCQUF3QixpQkFBaUIsRUFBRSxHQUFHLHVHQUF1Ryw0RUFBNEUscUJBQXFCLG9DQUFvQyx1QkFBdUIsMENBQTBDLEtBQUssR0FBRyxrSEFBa0gsOEJBQThCLDJDQUEyQyw0RUFBNEUsb0VBQW9FLG9GQUFvRixvQ0FBb0MscUNBQXFDLDJCQUEyQiwrQ0FBK0MsSUFBSSxpRkFBaUYsd0NBQXdDLG9EQUFvRCxpQ0FBaUMsRUFBRSxJQUFJLEVBQUUsK0VBQStFLHdEQUF3RCxFQUFFLG1GQUFtRix5Q0FBeUMsNkdBQTZHLEVBQUUsMkVBQTJFLDBCQUEwQiwrQkFBK0IsdUhBQXVILGdFQUFnRSxxQkFBcUIsZ0dBQWdHLHVCQUF1QixnQ0FBZ0MsMkJBQTJCLGlCQUFpQiwrQkFBK0IsS0FBSyxpQkFBaUIsa0ZBQWtGLDRCQUE0QiwyQkFBMkIsS0FBSyxnQkFBZ0Isc0xBQXNMLHFEQUFxRCx5SUFBeUksd0NBQXdDLGdDQUFnQyxrREFBa0QsMkZBQTJGLGlCQUFpQixtQkFBbUIsZ0JBQWdCLE9BQU8sbUJBQW1CLDRCQUE0QixPQUFPLEtBQUssaUJBQWlCLDJEQUEyRCw2REFBNkQsY0FBYyxHQUFHLGlFQUFpRSxVQUFVLEdBQUcsa09BQWtPLGdDQUFnQyxnQ0FBZ0MsaUNBQWlDLFdBQVcsNkRBQTZELFlBQVksbUVBQW1FLEtBQUsscUNBQXFDLHlDQUF5QyxPQUFPLHVCQUF1QixHQUFHLHNDQUFzQyxtQkFBbUIsZ0JBQWdCLE9BQU8sb0NBQW9DLFdBQVcsS0FBSyxnQkFBZ0IsNkVBQTZFLHVCQUF1Qix3QkFBd0Isb0JBQW9CLHNCQUFzQixhQUFhLE9BQU8sS0FBSyxHQUFHLDRCQUE0QixnekRBQWd6RCxnREFBZ0QsRUFBRSxrRkFBa0YscUNBQXFDLHNDQUFzQywrRUFBK0UscUNBQXFDLGtHQUFrRyxFQUFFLEdBQUcsNkRBQTZELDZCQUE2Qiw0QkFBNEIsaUJBQWlCLG1DQUFtQywyQkFBMkIscUJBQXFCLHFCQUFxQixPQUFPLG1CQUFtQixTQUFTLCtCQUErQixPQUFPLHFCQUFxQixHQUFHLHlHQUF5RyxtRkFBbUYsaUVBQWlFLDJDQUEyQywrQ0FBK0MsNkNBQTZDLGtEQUFrRCxvREFBb0QsMkRBQTJELDhIQUE4SCx1Q0FBdUMsa0NBQWtDLHNGQUFzRixpS0FBaUssT0FBTyxPQUFPLDBCQUEwQixPQUFPLEtBQUssd0JBQXdCLHdGQUF3RiwwREFBMEQsaURBQWlELDJJQUEySSwwRkFBMEYsdUJBQXVCLHdCQUF3QixrQkFBa0IsbUNBQW1DLHNCQUFzQixzQ0FBc0MsMkJBQTJCLHFCQUFxQixtQkFBbUIsT0FBTyxvQkFBb0IsT0FBTyxLQUFLLHVmQUF1ZixnQ0FBZ0MscUNBQXFDLG9CQUFvQixHQUFHLCtCQUErQixnREFBZ0QsZ2FBQWdhLGtCQUFrQixFQUFFLFFBQVEsS0FBSywyTUFBMk0seUlBQXlJLDJEQUEyRCw4REFBOEQsa0NBQWtDLGtDQUFrQyxFQUFFLCtCQUErQixvQ0FBb0Msd0NBQXdDLFFBQVEsS0FBSyxPQUFPLDhGQUE4Rix1Q0FBdUMsUUFBUSxLQUFLLCtDQUErQyxtQkFBbUIsa0NBQWtDLGlCQUFpQixjQUFjLEVBQUUsdUJBQXVCLGVBQWUsRUFBRSxPQUFPLEVBQUUscUJBQXFCLHVCQUF1QixvQkFBb0IsT0FBTyxrREFBa0QsK0NBQStDLDZCQUE2QixTQUFTLFFBQVEsS0FBSyxHQUFHLElBQUksYUFBYSw4RUFBOEUsb0RBQW9ELEdBQUcsT0FBTyxnR0FBZ0csdUJBQXVCLHVDQUF1QyxPQUFPLDhDQUE4Qyw2Q0FBNkMsOENBQThDLDZCQUE2QixRQUFRLCtDQUErQyx1Q0FBdUMsUUFBUSxtQkFBbUIsS0FBSyxJQUFJLEdBQUcsb0JBQW9CLGlCQUFpQiwwQkFBMEIsZ0RBQWdELG9EQUFvRCx3Q0FBd0MsbUNBQW1DLG9EQUFvRCx3QkFBd0IsRUFBRSw2QkFBNkIsR0FBRyxpQ0FBaUMsMkNBQTJDLDhIQUE4SCxPQUFPLE1BQU0sZ0NBQWdDLDJDQUEyQyw0SEFBNEgsT0FBTyxNQUFNLHdEQUF3RCw0QkFBNEIsOEJBQThCLG9PQUFvTyxtREFBbUQsMEJBQTBCLHFEQUFxRCxpQ0FBaUMsT0FBTyxvS0FBb0ssMkNBQTJDLG9DQUFvQyxpRkFBaUYsT0FBTyxvREFBb0QsR0FBRyw4QkFBOEIsNkhBQTZILHNCQUFzQixtQkFBbUIsSUFBSSxrREFBa0Qsd0JBQXdCLElBQUksd0RBQXdELDJCQUEyQixJQUFJLCtDQUErQyxxQkFBcUIsOEJBQThCLEtBQUssSUFBSSwrQ0FBK0MsMkVBQTJFLG9DQUFvQyxPQUFPLE9BQU8sdUJBQXVCLEtBQUssSUFBSSwyS0FBMkssdUJBQXVCLG1DQUFtQyxxQkFBcUIsOEJBQThCLEVBQUUseUJBQXlCLEdBQUcsMkJBQTJCLG1DQUFtQyxHQUFHLHlLQUF5SywrQ0FBK0Msc0hBQXNILGtFQUFrRSxtREFBbUQsa0NBQWtDLG1IQUFtSCw4QkFBOEIsbUJBQW1CLGlDQUFpQyxPQUFPLDhDQUE4QywyQkFBMkIsbUJBQW1CLHVCQUF1Qiw4Q0FBOEMsZ0VBQWdFLHdFQUF3RSxzQkFBc0IscUJBQXFCLDJCQUEyQixFQUFFLDRDQUE0Qyx3QkFBd0IsRUFBRSxHQUFHLEVBQUUsdUVBQXVFLDJVQUEyVSxxREFBcUQsMlFBQTJRLHVCQUF1Qix5QkFBeUIscUJBQXFCLCtCQUErQiwrQkFBK0Isd0VBQXdFLDhDQUE4QywrQkFBK0IsS0FBSyxPQUFPLHVCQUF1QixLQUFLLElBQUksdU1BQXVNLGdDQUFnQyxtQkFBbUIsaUJBQWlCLE9BQU8sb0RBQW9ELEtBQUssSUFBSSxrSEFBa0gscUNBQXFDLE9BQU8sT0FBTyx3QkFBd0IsS0FBSyxJQUFJLCtKQUErSiw0REFBNEQsbUNBQW1DLDZKQUE2SixvQ0FBb0MsT0FBTyxPQUFPLHdCQUF3QixpQ0FBaUMsS0FBSyxHQUFHLDhOQUE4TiwyQkFBMkIsaUJBQWlCLFdBQVcsc0VBQXNFLHdCQUF3QixLQUFLLCtMQUErTCwrQkFBK0IsS0FBSywyQkFBMkIsbUJBQW1CLEtBQUssZ0JBQWdCLG9JQUFvSSx3QkFBd0IsK0RBQStELHNEQUFzRCxpQkFBaUIsdUZBQXVGLDBDQUEwQyxpQ0FBaUMscUNBQXFDLHVGQUF1RixvREFBb0QseUJBQXlCLHVCQUF1Qix3QkFBd0IsaUNBQWlDLFdBQVcscUNBQXFDLCtCQUErQixXQUFXLFNBQVMsMkJBQTJCLDhDQUE4QyxvREFBb0QscUhBQXFILHlCQUF5QiwrR0FBK0cseUJBQXlCLFNBQVMscUJBQXFCLG1DQUFtQyxTQUFTLE9BQU8sdUJBQXVCLFNBQVMsa0NBQWtDLHFCQUFxQixPQUFPLEtBQUssRUFBRSxHQUFHLHNMQUFzTCwyREFBMkQsbURBQW1ELGlDQUFpQyxxQkFBcUIsOEJBQThCLHdCQUF3QixxQkFBcUIsOEJBQThCLDhDQUE4QywwTUFBME0scUJBQXFCLGNBQWMsd0JBQXdCLHFCQUFxQiwwQ0FBMEMsb0JBQW9CLGlCQUFpQixpR0FBaUcsMkRBQTJELDRCQUE0QixpQkFBaUIsOEJBQThCLDhDQUE4QyxzS0FBc0ssaUJBQWlCLCtCQUErQixpQkFBaUIsdUJBQXVCLGNBQWMsaUJBQWlCLG9CQUFvQixHQUFHLDRMQUE0TCxtREFBbUQsT0FBTyxPQUFPLG1CQUFtQiw2Q0FBNkMsNkJBQTZCLHVCQUF1QixPQUFPLEtBQUssR0FBRyx3TkFBd04sd0ZBQXdGLHNFQUFzRSxnQkFBZ0IsaUpBQWlKLE9BQU8sOENBQThDLEdBQUcsMkdBQTJHLGdCQUFnQixZQUFZLDRCQUE0QixpQ0FBaUMsbUJBQW1CLGlCQUFpQixPQUFPLG9CQUFvQixzQkFBc0IsMEJBQTBCLDZCQUE2Qiw4QkFBOEIsT0FBTywyREFBMkQsa0NBQWtDLE9BQU8sS0FBSyxnQkFBZ0IscUZBQXFGLGNBQWMsOEVBQThFLCtCQUErQiwyQ0FBMkMseU5BQXlOLCtCQUErQix1QkFBdUIsOEJBQThCLHNUQUFzVCxxR0FBcUcsS0FBSyxrQ0FBa0MsK0NBQStDLG9JQUFvSSw2R0FBNkcsMkJBQTJCLDhEQUE4RCxPQUFPLHFDQUFxQyxPQUFPLEtBQUssSUFBSSwyR0FBMkcsdUtBQXVLLG9EQUFvRCw2QkFBNkIsR0FBRyxFQUFFLGlPQUFpTywrQ0FBK0MsOERBQThELGdEQUFnRCxxQ0FBcUMsR0FBRyxFQUFFLHFLQUFxSyxnREFBZ0QsMENBQTBDLHFCQUFxQixrQkFBa0IsaUJBQWlCLDJCQUEyQiwrQkFBK0IsNEJBQTRCLGdDQUFnQyw2Q0FBNkMsMEJBQTBCLE9BQU8sdUVBQXVFLEtBQUssa0JBQWtCLDJIQUEySCxvQkFBb0IsMENBQTBDLHFCQUFxQixrQkFBa0Isa0NBQWtDLDJCQUEyQiwwQkFBMEIsa0JBQWtCLHVGQUF1RixzRUFBc0UsK0VBQStFLHlDQUF5QyxvQ0FBb0MsK0RBQStELHNIQUFzSCxPQUFPLEtBQUssR0FBRyxxSUFBcUksOEJBQThCLGlCQUFpQixTQUFTLGlCQUFpQixxQkFBcUIsK0JBQStCLHVCQUF1QixtQkFBbUIsdUJBQXVCLHNDQUFzQywrQkFBK0IsdUJBQXVCLGNBQWMsU0FBUyxrREFBa0QsaUVBQWlFLFNBQVMsT0FBTyxLQUFLLGlDQUFpQyw4QkFBOEIseUJBQXlCLDZCQUE2QixrRUFBa0UsYUFBYSxPQUFPLEtBQUssd0JBQXdCLEdBQUcsZ0hBQWdILGtDQUFrQyxlQUFlLDZCQUE2Qiw0QkFBNEIsd0NBQXdDLHVCQUF1QiwwQkFBMEIsU0FBUyxPQUFPLEtBQUssR0FBRywrS0FBK0ssZ0RBQWdELDZCQUE2QixLQUFLLDBCQUEwQiwrQkFBK0Isb0NBQW9DLHNCQUFzQix1SkFBdUosS0FBSyx1QkFBdUIsOENBQThDLE9BQU8sT0FBTyxvQ0FBb0MsK0NBQStDLGdDQUFnQyxTQUFTLGlEQUFpRCxPQUFPLEtBQUsscUJBQXFCLFlBQVkseUJBQXlCLHNCQUFzQixLQUFLLHdCQUF3QixpQ0FBaUMsd0JBQXdCLE9BQU8sS0FBSywrQkFBK0IsOENBQThDLDZEQUE2RCxLQUFLLHFCQUFxQixzTkFBc04sNkRBQTZELGlCQUFpQiwrQkFBK0IsNkVBQTZFLG9CQUFvQixtQ0FBbUMsc0NBQXNDLDZCQUE2QiwrQ0FBK0MsdUNBQXVDLDhCQUE4QiwwR0FBMEcsdUVBQXVFLCtGQUErRixLQUFLLGlCQUFpQixzRkFBc0YsZ0NBQWdDLHlDQUF5QywrQkFBK0IsZ0VBQWdFLCtDQUErQyxzQkFBc0IsT0FBTyxxRkFBcUYscUJBQXFCLE9BQU8sS0FBSyx3REFBd0QsaURBQWlELDRJQUE0SSx5Q0FBeUMscUJBQXFCLHNEQUFzRCxLQUFLLGdEQUFnRCwrQ0FBK0MsS0FBSyxtQkFBbUIsaUdBQWlHLHNFQUFzRSwyQkFBMkIsMkJBQTJCLDRIQUE0SCxxTUFBcU0sS0FBSyx1UUFBdVEsZ0NBQWdDLDZQQUE2UCx5SEFBeUgsa0NBQWtDLCtFQUErRSxpQkFBaUIsMENBQTBDLGlCQUFpQix5QkFBeUIsdUNBQXVDLDJCQUEyQixlQUFlLGlDQUFpQyxzQkFBc0IsT0FBTyxxQkFBcUIsMkJBQTJCLE9BQU8sc0RBQXNELDREQUE0RCxtQ0FBbUMsT0FBTyxLQUFLLGlCQUFpQixnUEFBZ1AsaUJBQWlCLG1DQUFtQyxvQkFBb0IsOEJBQThCLHNIQUFzSCxPQUFPLEtBQUssR0FBRyxnRkFBZ0YsY0FBYyxxQ0FBcUMsb0NBQW9DLHlEQUF5RCxLQUFLLHNDQUFzQyx5REFBeUQsS0FBSyx1Q0FBdUMsMERBQTBELEtBQUssd0NBQXdDLDJEQUEyRCxLQUFLLHNDQUFzQyxtQ0FBbUMsS0FBSyxxQ0FBcUMsbUNBQW1DLEtBQUssT0FBTyxvQ0FBb0MsS0FBSyxZQUFZLHdEQUF3RCxHQUFHLDBMQUEwTCxrRUFBa0UsK0JBQStCLGdDQUFnQyw2QkFBNkIsK0NBQStDLG9DQUFvQyxTQUFTLE9BQU8sNkNBQTZDLDBCQUEwQixLQUFLLGlEQUFpRCwwQ0FBMEMsOEJBQThCLG9EQUFvRCxLQUFLLE9BQU8sa0RBQWtELGlEQUFpRCxPQUFPLHdGQUF3RiwyQkFBMkIsT0FBTyxPQUFPLHdCQUF3QixLQUFLLEdBQUcsaUdBQWlHLGdEQUFnRCx3U0FBd1MsbURBQW1ELGlQQUFpUCxNQUFNLHFHQUFxRyxxQkFBcUIsK0VBQStFLG9EQUFvRCxnREFBZ0QsdUNBQXVDLHdGQUF3RixtQ0FBbUMsT0FBTyxnQ0FBZ0Msa0NBQWtDLFNBQVMsT0FBTyxFQUFFLEtBQUssd0JBQXdCLHVDQUF1QyxnQ0FBZ0MscUVBQXFFLGlDQUFpQyxzQ0FBc0MsU0FBUyx1Q0FBdUMsTUFBTSx3QkFBd0IsdUNBQXVDLDBEQUEwRCxzQ0FBc0MsU0FBUyxpQ0FBaUMsTUFBTSwyQ0FBMkMscUJBQXFCLGlGQUFpRixrSEFBa0gsa0RBQWtELE9BQU8sT0FBTyw2QkFBNkIsT0FBTyxNQUFNLEdBQUcsYUFBYSxjQUFjLGdEQUFnRCwrQ0FBK0MsK0lBQStJLDZCQUE2Qix1QkFBdUIsR0FBRyxtREFBbUQsNkNBQTZDLGtDQUFrQyxnQ0FBZ0MsaUNBQWlDLFFBQVEsS0FBSyxHQUFHLDhIQUE4SCxtQkFBbUIscUJBQXFCLDZCQUE2QixxQkFBcUIsbUJBQW1CLHdCQUF3QiwyQkFBMkIsdUNBQXVDLGdDQUFnQyw2Q0FBNkMsdUNBQXVDLDRCQUE0QixxQkFBcUIsMEJBQTBCLDZCQUE2QiwyQkFBMkIsMEJBQTBCLHdCQUF3QixJQUFJLDhCQUE4QixVQUFVLEdBQUcsOElBQThJLHFDQUFxQyxtRUFBbUUsd0NBQXdDLDJCQUEyQixtQkFBbUIsMEJBQTBCLG1CQUFtQixvQ0FBb0MscUVBQXFFLGlQQUFpUCx3S0FBd0sseUJBQXlCLHFDQUFxQywyQkFBMkIsMkJBQTJCLG9CQUFvQixtQ0FBbUMsNEJBQTRCLDZCQUE2QixtQkFBbUIsU0FBUyxPQUFPLHFDQUFxQyxLQUFLLGlCQUFpQiwyREFBMkQseUNBQXlDLDBFQUEwRSx5Q0FBeUMsMENBQTBDLFlBQVksZ0VBQWdFLEdBQUcsRUFBRSxvQ0FBb0MseUJBQXlCLGtDQUFrQyw4QkFBOEIsK0JBQStCLHVCQUF1QixnQkFBZ0IsT0FBTywwQ0FBMEMsU0FBUyxPQUFPLE9BQU8sMEdBQTBHLEtBQUssc0JBQXNCLHFCQUFxQixnRkFBZ0YsOEJBQThCLHNCQUFzQixxQkFBcUIsd0JBQXdCLG1DQUFtQyxpQkFBaUIsdUtBQXVLLE9BQU8saUJBQWlCLHVCQUF1QixnREFBZ0QsU0FBUyx3REFBd0QsT0FBTyx3QkFBd0Isc0JBQXNCLHVCQUF1QixPQUFPLEtBQUsseUJBQXlCLHNCQUFzQixxQ0FBcUMsMERBQTBELE9BQU8sS0FBSyxHQUFHLDREQUE0RCxnQkFBZ0IsK0JBQStCLCtCQUErQixrQ0FBa0MsNklBQTZJLEtBQUsscUJBQXFCLHdFQUF3RSxLQUFLLE9BQU8sd0VBQXdFLDZEQUE2RCxzQ0FBc0MsT0FBTyxPQUFPLHdGQUF3RixPQUFPLEtBQUssNEJBQTRCLDJCQUEyQixHQUFHLHN4QkFBc3hCLG1CQUFtQixxQkFBcUIsT0FBTyx1Q0FBdUMsZ0VBQWdFLEtBQUssc0JBQXNCLDRWQUE0VixrS0FBa0ssNkRBQTZELGlCQUFpQixtQkFBbUIsZUFBZSxxQkFBcUIsT0FBTyxzQkFBc0IsZ0RBQWdELFdBQVcsaUNBQWlDLDZDQUE2QywwRkFBMEYsT0FBTywyQkFBMkIsZ0NBQWdDLGlDQUFpQyxTQUFTLHFCQUFxQiw4RUFBOEUsU0FBUyxPQUFPLE9BQU8sMENBQTBDLG9FQUFvRSxTQUFTLE9BQU8sNElBQTRJLG1FQUFtRSxXQUFXLHNCQUFzQixTQUFTLE9BQU8sS0FBSyxpQkFBaUIsMERBQTBELHFEQUFxRCxnQ0FBZ0MsRUFBRSxPQUFPLHdDQUF3QyxxQ0FBcUMsNkJBQTZCLG1GQUFtRixvQkFBb0IsOENBQThDLEtBQUssR0FBRyxlQUFlLHVDQUF1QyxrQkFBa0IsOEJBQThCLEtBQUssT0FBTyw0QkFBNEIsS0FBSyxHQUFHLG1DQUFtQywyQkFBMkIsR0FBRyxpRkFBaUYsZ0JBQWdCLGlEQUFpRCxxQkFBcUIsR0FBRyxnQ0FBZ0MsMEJBQTBCLDhDQUE4Qyx3QkFBd0Isc0JBQXNCLGlDQUFpQyx5Q0FBeUMsT0FBTyxPQUFPLG1DQUFtQyxTQUFTLE9BQU8sT0FBTyxpRUFBaUUsc0pBQXNKLGtDQUFrQyxTQUFTLE9BQU8scUJBQXFCLGtEQUFrRCxvQkFBb0Isc0JBQXNCLDJCQUEyQixnQ0FBZ0MsT0FBTyxpQkFBaUIsd0JBQXdCLHFCQUFxQixpREFBaUQsd0JBQXdCLHNCQUFzQiwwQ0FBMEMseUNBQXlDLHdCQUF3Qix5REFBeUQsMkNBQTJDLFNBQVMsU0FBUyxzQ0FBc0MsU0FBUyx3QkFBd0IseURBQXlELGlCQUFpQix3QkFBd0IsbUNBQW1DLGlDQUFpQyx3QkFBd0Isc0NBQXNDLHlCQUF5QixtQkFBbUIsb0JBQW9CLHdDQUF3QywyQkFBMkIsd0JBQXdCLE9BQU8scUJBQXFCLDhDQUE4QyxvQkFBb0Isa0RBQWtELGlEQUFpRCxxRUFBcUUsMmVBQTJlLFNBQVMsT0FBTyxrQ0FBa0MsZ0JBQWdCLGtEQUFrRCx5Q0FBeUMsdUNBQXVDLE9BQU8sT0FBTyxpQ0FBaUMsU0FBUyxPQUFPLHFCQUFxQixHQUFHLHFKQUFxSixtQkFBbUIsb0JBQW9CLHVCQUF1Qix5QkFBeUIsb0JBQW9CLHdDQUF3QyxPQUFPLE9BQU8sMEJBQTBCLHNPQUFzTyx1REFBdUQsdUNBQXVDLGdEQUFnRCxTQUFTLE9BQU8sMkJBQTJCLFNBQVMsT0FBTyxPQUFPLGdDQUFnQyxPQUFPLEtBQUssbUVBQW1FLGtDQUFrQyxLQUFLLG1CQUFtQixrQ0FBa0MsaURBQWlELDZDQUE2QyxpQkFBaUIsbUJBQW1CLGdCQUFnQixPQUFPLGlDQUFpQyxLQUFLLGlCQUFpQix3Q0FBd0MsaUNBQWlDLDhCQUE4Qix5RUFBeUUsc0NBQXNDLDBEQUEwRCxnQ0FBZ0MsT0FBTyxnQ0FBZ0MsS0FBSywwQkFBMEIsMENBQTBDLHdCQUF3QixrQkFBa0IseUJBQXlCLHdCQUF3QiwrQkFBK0IsMEJBQTBCLDRCQUE0QixpQ0FBaUMsR0FBRyxtQ0FBbUMseURBQXlELG9CQUFvQiwwQkFBMEIscUNBQXFDLE9BQU8sMEJBQTBCLGdDQUFnQyw4Q0FBOEMsMEJBQTBCLHdCQUF3QixnSUFBZ0ksMExBQTBMLE9BQU8sT0FBTyxrRUFBa0UsT0FBTywwQ0FBMEMsb0RBQW9ELDhCQUE4QixPQUFPLG1CQUFtQiw0QkFBNEIsT0FBTywySEFBMkgsZ0NBQWdDLE9BQU8sOEhBQThILGdEQUFnRCxvQkFBb0Isd0JBQXdCLDZCQUE2QixPQUFPLE1BQU0sNENBQTRDLG9CQUFvQixpQ0FBaUMscUJBQXFCLG9DQUFvQyxrQ0FBa0MsOERBQThELHlFQUF5RSxxQ0FBcUMsT0FBTyxrREFBa0QsK0JBQStCLE9BQU8sa0NBQWtDLG1CQUFtQixtQ0FBbUMsT0FBTywrR0FBK0csa0NBQWtDLE9BQU8sMkRBQTJELDBGQUEwRiw0REFBNEQseURBQXlELG9EQUFvRCw4QkFBOEIsT0FBTyxnSEFBZ0gsTUFBTSxHQUFHLDZEQUE2RCxnQkFBZ0IsOEJBQThCLDRDQUE0QyxrREFBa0QsZ0pBQWdKLDZRQUE2USxTQUFTLE9BQU8sMkhBQTJILFNBQVMsT0FBTyxLQUFLLGdDQUFnQywwQkFBMEIsMEdBQTBHLHFDQUFxQyw0QkFBNEIseUJBQXlCLGdEQUFnRCw0Q0FBNEMseUJBQXlCLGlDQUFpQyxxQkFBcUIsd0RBQXdELHlCQUF5QixxQ0FBcUMscUJBQXFCLHVEQUF1RCxRQUFRLEtBQUssT0FBTyxxQ0FBcUMsNENBQTRDLFFBQVEsS0FBSywyREFBMkQsc0JBQXNCLHFLQUFxSywyQkFBMkIsOEJBQThCLEtBQUssZ0JBQWdCLDZHQUE2Ryw0WUFBNFksNkNBQTZDLDRCQUE0QixzRUFBc0UsbUVBQW1FLEtBQUssaURBQWlELDhEQUE4RCwwQ0FBMEMsa0RBQWtELDRDQUE0QyxPQUFPLDRCQUE0QixpREFBaUQscUJBQXFCLHFCQUFxQixPQUFPLDhCQUE4Qix5RUFBeUUsT0FBTyx5Q0FBeUMsa0RBQWtELDZDQUE2QyxPQUFPLDZFQUE2RSxLQUFLLDJDQUEyQyxzREFBc0QsK0NBQStDLDREQUE0RCxLQUFLLHlFQUF5RSxvRUFBb0Usd0JBQXdCLEtBQUssR0FBRyxvQ0FBb0MscUNBQXFDLHlCQUF5QixjQUFjLEtBQUssbUJBQW1CLGtEQUFrRCxpQkFBaUIsaUNBQWlDLGlDQUFpQyxxQkFBcUIsS0FBSywrQkFBK0IsaUJBQWlCLCtDQUErQywyQkFBMkIscUJBQXFCLHlCQUF5QixPQUFPLGdEQUFnRCxPQUFPLGdDQUFnQyxLQUFLLEdBQUcsb0RBQW9ELGlCQUFpQixnQ0FBZ0MsaUNBQWlDLHFCQUFxQixLQUFLLHdCQUF3QiwwQkFBMEIscUJBQXFCLHlCQUF5QixPQUFPLGtEQUFrRCxPQUFPLGtDQUFrQyxLQUFLLEdBQUcsa0NBQWtDLHFDQUFxQyxtQkFBbUIsMENBQTBDLE9BQU8sT0FBTyxhQUFhLCtCQUErQixTQUFTLFlBQVksaURBQWlELFNBQVMsT0FBTyxLQUFLLDJCQUEyQiwrQkFBK0IsS0FBSyxHQUFHLCtCQUErQixlQUFlLG9CQUFvQixzQkFBc0IsdUJBQXVCLGdCQUFnQixnRkFBZ0YscUJBQXFCLGFBQWEsZ0RBQWdELG9CQUFvQixLQUFLLCtCQUErQixHQUFHLDJGQUEyRixvQkFBb0Isd0JBQXdCLCtjQUErYyxvQkFBb0IsRUFBRSxFQUFFLHVIQUF1SCxzQkFBc0IsV0FBVyw2QkFBNkIsc0JBQXNCLHFCQUFxQixvQkFBb0IsNEhBQTRILCtDQUErQyxvREFBb0QsOFJBQThSLHdCQUF3QixPQUFPLEtBQUssb0ZBQW9GLDBCQUEwQix1REFBdUQscUJBQXFCLGdDQUFnQyxzQkFBc0IscURBQXFELGdDQUFnQyxPQUFPLEtBQUssdUZBQXVGLDZCQUE2QixLQUFLLEdBQUcsOExBQThMLHdCQUF3QiwwQkFBMEIscUJBQXFCLHNCQUFzQiw0QkFBNEIsT0FBTyxPQUFPLHNLQUFzSyxvREFBb0QsY0FBYyxTQUFTLHlEQUF5RCxPQUFPLDZDQUE2Qyx1QkFBdUIsc0NBQXNDLE9BQU8sS0FBSyxHQUFHLDRCQUE0Qix3UUFBd1EsaUJBQWlCLDRCQUE0QixnQ0FBZ0MsaUNBQWlDLGlDQUFpQyxpQ0FBaUMsaUNBQWlDLEtBQUssT0FBTyw0REFBNEQsS0FBSyxpQkFBaUIsc0JBQXNCLDJDQUEyQywyQkFBMkIsd0NBQXdDLHNCQUFzQiw2QkFBNkIsZ0NBQWdDLGdHQUFnRywwRUFBMEUsNEJBQTRCLEtBQUssT0FBTyx1Q0FBdUMseUJBQXlCLHFDQUFxQyxpUUFBaVEsT0FBTyxLQUFLLDhEQUE4RCxJQUFJLDZHQUE2RyxxQkFBcUIsY0FBYyxxQkFBcUIsb0JBQW9CLFdBQVcseUNBQXlDLE9BQU8sWUFBWSx5RkFBeUYsT0FBTyxLQUFLLE9BQU8sdUNBQXVDLEtBQUssbUhBQW1ILHNCQUFzQixLQUFLLGdCQUFnQix1QkFBdUIsb0JBQW9CLHdHQUF3RyxvQkFBb0Isa0NBQWtDLDZCQUE2Qiw2QkFBNkIsaUNBQWlDLHlCQUF5QixPQUFPLEtBQUssSUFBSSwrR0FBK0csd0JBQXdCLCtCQUErQixpQkFBaUIsK0JBQStCLDBDQUEwQyw4QkFBOEIsT0FBTyxLQUFLLDBCQUEwQixpQ0FBaUMseUJBQXlCLDJCQUEyQixvQkFBb0IsNkJBQTZCLHVCQUF1Qiw0QkFBNEIsSUFBSSxxSUFBcUksa0RBQWtELHdCQUF3QixLQUFLLHNCQUFzQixpQkFBaUIsS0FBSyxPQUFPLHlCQUF5QixLQUFLLElBQUkseUhBQXlILHNCQUFzQiw2QkFBNkIsd1BBQXdQLDBEQUEwRCwyQkFBMkIsd0JBQXdCLGVBQWUsbURBQW1ELFdBQVcsWUFBWSxvR0FBb0csV0FBVyxTQUFTLE9BQU8saURBQWlELFNBQVMsT0FBTyxLQUFLLElBQUkscUpBQXFKLDRCQUE0Qix1QkFBdUIsSUFBSSwrR0FBK0csd0JBQXdCLCtCQUErQixpQkFBaUIsOEJBQThCLEtBQUssSUFBSSx5SEFBeUgsd0JBQXdCLHdCQUF3QixxTEFBcUwsd0NBQXdDLE9BQU8sK0JBQStCLG1CQUFtQix5Q0FBeUMsT0FBTywwQkFBMEIsS0FBSyxJQUFJLDZNQUE2TSwyQkFBMkIsd0JBQXdCLGdDQUFnQyxHQUFHLG9DQUFvQyxnQkFBZ0IsaUNBQWlDLGdFQUFnRSxpQkFBaUIscUJBQXFCLG9DQUFvQyw0QkFBNEIscUJBQXFCLHNCQUFzQixLQUFLLGNBQWMscUJBQXFCLG1CQUFtQix5QkFBeUIsRUFBRSxLQUFLLE9BQU8sOEJBQThCLHNCQUFzQixtQkFBbUIsK0JBQStCLEVBQUUsS0FBSyxHQUFHLDhDQUE4QywyRUFBMkUsNkNBQTZDLDREQUE0RCx1Q0FBdUMsK0RBQStELGlDQUFpQyxNQUFNLGlFQUFpRSxHQUFHLDZCQUE2QixzQkFBc0IsMkJBQTJCLHFCQUFxQiwyQkFBMkIsRUFBRSx1QkFBdUIsK0JBQStCLEVBQUUsb0JBQW9CLG1CQUFtQixLQUFLLE9BQU8sMkJBQTJCLHlCQUF5QixLQUFLLHdCQUF3QixpQ0FBaUMsRUFBRSxxQkFBcUIsMkJBQTJCLEVBQUUsR0FBRywwQkFBMEIsMkJBQTJCLDJDQUEyQyxnREFBZ0QsK0JBQStCLHNLQUFzSyw2QkFBNkIsdUZBQXVGLGlDQUFpQyxxQkFBcUIsaUVBQWlFLGtGQUFrRixrQ0FBa0MsK0lBQStJLFNBQVMsMERBQTBELDREQUE0RCx3VkFBd1YsV0FBVyxTQUFTLEVBQUUsT0FBTyxPQUFPLDZDQUE2QyxPQUFPLCtMQUErTCxtQ0FBbUMsT0FBTyxNQUFNLGdEQUFnRCx1Q0FBdUMsR0FBRyw0QkFBNEIsZ0NBQWdDLDRGQUE0RiwrQkFBK0IsZ0JBQWdCLHlNQUF5TSxLQUFLLDhEQUE4RCxrQ0FBa0Msd0JBQXdCLGlCQUFpQiw0Q0FBNEMsdU5BQXVOLE9BQU8saUNBQWlDLHNDQUFzQyxPQUFPLEtBQUssNERBQTRELEdBQUcsaUNBQWlDLFNBQVMsK0JBQStCLFlBQVkscUNBQXFDLGVBQWUsS0FBSyxHQUFHLGtDQUFrQyxjQUFjLDBDQUEwQyw4REFBOEQsaUNBQWlDLGtDQUFrQyx5RUFBeUUsa0RBQWtELG1DQUFtQyw0SUFBNEksd0JBQXdCLFNBQVMsT0FBTyx1SUFBdUksbU5BQW1OLHlDQUF5QyxPQUFPLEtBQUssR0FBRyxvREFBb0Qsd0NBQXdDLCtEQUErRCwwQ0FBMEMsS0FBSyxPQUFPLDRKQUE0SixvRkFBb0YsS0FBSyxpRUFBaUUsR0FBRyx5Q0FBeUMsdUNBQXVDLDBFQUEwRSxvQkFBb0IsNEJBQTRCLDZCQUE2QixTQUFTLHlCQUF5QiwyQkFBMkIsU0FBUyxtQ0FBbUMsS0FBSyxHQUFHLHdDQUF3QyxrQ0FBa0MsOEJBQThCLHFFQUFxRSxrREFBa0QsbUNBQW1DLHNNQUFzTSxTQUFTLDBDQUEwQyw0SEFBNEgsU0FBUyxPQUFPLEtBQUssR0FBRyxvQ0FBb0MsNEJBQTRCLCtCQUErQixtQ0FBbUMsdUJBQXVCLG9CQUFvQixPQUFPLDZDQUE2QyxTQUFTLE9BQU8sT0FBTyx3Q0FBd0MsT0FBTyxLQUFLLEdBQUcsK0NBQStDLGdCQUFnQixpQ0FBaUMsd0JBQXdCLGdDQUFnQyxLQUFLLHNDQUFzQyw0QkFBNEIsS0FBSyxxQ0FBcUMsR0FBRywrQkFBK0IsaU1BQWlNLCtCQUErQixxQkFBcUIsc0JBQXNCLGdDQUFnQyxzQkFBc0IsZ0RBQWdELHdDQUF3Qyx3SUFBd0ksUUFBUSxrQ0FBa0MsNENBQTRDLFFBQVEsS0FBSywyREFBMkQsNkRBQTZELCtCQUErQixnQ0FBZ0Msa0ZBQWtGLG9CQUFvQiw4QkFBOEIsMEJBQTBCLDBEQUEwRCw4QkFBOEIsbUNBQW1DLE9BQU8sb0NBQW9DLDJCQUEyQixPQUFPLE1BQU0sR0FBRyxrR0FBa0csd0ZBQXdGLDZFQUE2RSxxS0FBcUssbUVBQW1FLE9BQU8saUNBQWlDLGtGQUFrRixtRkFBbUYsT0FBTyxLQUFLLHNEQUFzRCwyQ0FBMkMsdUVBQXVFLHFOQUFxTixLQUFLLHdDQUF3QyxnREFBZ0Qsa0RBQWtELHFEQUFxRCxPQUFPLGlDQUFpQywyRUFBMkUsT0FBTyxLQUFLLDBDQUEwQyxrREFBa0Qsb0NBQW9DLDZDQUE2QyxTQUFTLE9BQU8sK0VBQStFLFNBQVMsT0FBTyxLQUFLLElBQUksd0RBQXdELHFGQUFxRixnQkFBZ0IsaUJBQWlCLDRDQUE0Qyx5QkFBeUIsbUNBQW1DLEtBQUssdUNBQXVDLGtEQUFrRCw2RUFBNkUsT0FBTyxpQkFBaUIsNENBQTRDLDBCQUEwQiw2QkFBNkIsT0FBTyxPQUFPLGtFQUFrRSxrSkFBa0osU0FBUyxFQUFFLG9CQUFvQixxSkFBcUosT0FBTyxLQUFLLHFKQUFxSix3QkFBd0Isa0ZBQWtGLHlDQUF5QyxLQUFLLHdFQUF3RSwrREFBK0QscUZBQXFGLG1KQUFtSiwrRUFBK0Usa0NBQWtDLHNHQUFzRyxLQUFLLHdGQUF3RiwyRUFBMkUsNkpBQTZKLHVGQUF1RixNQUFNLG1CQUFtQixxR0FBcUcsbUJBQW1CLHlDQUF5QyxzQkFBc0Isb0NBQW9DLCtEQUErRCxPQUFPLEtBQUssd0xBQXdMLG1DQUFtQyxrREFBa0QsR0FBRyxtREFBbUQsNkdBQTZHLHdDQUF3QyxFQUFFLEtBQUssRUFBRSxpQ0FBaUMsd0NBQXdDLHNCQUFzQix1Q0FBdUMsb0JBQW9CLE9BQU8sS0FBSyxtQkFBbUIsNExBQTRMLHVEQUF1RCxtQkFBbUIsNlZBQTZWLGdHQUFnRyx5QkFBeUIsNkNBQTZDLCtEQUErRCxLQUFLLHFEQUFxRCx3RUFBd0UsNEJBQTRCLCtEQUErRCxLQUFLLE9BQU8sK0JBQStCLGdEQUFnRCxzQkFBc0Isc0NBQXNDLDRCQUE0QixxQ0FBcUMsU0FBUyx3REFBd0QsMEpBQTBKLHlDQUF5QyxPQUFPLE9BQU8sd0JBQXdCLFdBQVcsU0FBUyxRQUFRLHdDQUF3QywyTEFBMkwsUUFBUSwyQ0FBMkMsZ0dBQWdHLGtDQUFrQyxPQUFPLHFCQUFxQixnRkFBZ0YsR0FBRyw2Q0FBNkMsNEtBQTRLLHVCQUF1QixpQkFBaUIsaUJBQWlCLDJCQUEyQiwyQkFBMkIsaUNBQWlDLHFDQUFxQyxvQ0FBb0Msb0NBQW9DLG9EQUFvRCxpREFBaUQseUhBQXlILHlnQkFBeWdCLFdBQVcsU0FBUyw4SUFBOEksT0FBTyxLQUFLLGlCQUFpQiw2RUFBNkUsZUFBZSw4QkFBOEIsNkJBQTZCLHdCQUF3QiwyQkFBMkIsU0FBUywwQkFBMEIsaUNBQWlDLGdDQUFnQyx3QkFBd0IsOEJBQThCLFNBQVMsMEJBQTBCLEtBQUssbUJBQW1CLGdDQUFnQyxxQkFBcUIscUJBQXFCLEtBQUssbUJBQW1CLHlCQUF5QixPQUFPLGdDQUFnQyxzQ0FBc0MsMENBQTBDLHlFQUF5RSxLQUFLLEdBQUcscUNBQXFDLGtDQUFrQyxzQkFBc0Isc0JBQXNCLEtBQUssR0FBRyxxSkFBcUosZ0VBQWdFLGtFQUFrRSwrQkFBK0IsNEJBQTRCLHFDQUFxQyxFQUFFLG9CQUFvQiwwREFBMEQsS0FBSyxPQUFPLHNDQUFzQyxLQUFLLEdBQUcsdUNBQXVDLDJCQUEyQix1TkFBdU4sbURBQW1ELG1DQUFtQyxzQkFBc0IsdUJBQXVCLEtBQUssMEJBQTBCLHNDQUFzQyxFQUFFLDZFQUE2RSxpR0FBaUcsOEJBQThCLDZPQUE2TyxvQ0FBb0MsZUFBZSx3RkFBd0YsNElBQTRJLHdCQUF3QiwwQkFBMEIsd0JBQXdCLDBCQUEwQixLQUFLLGlEQUFpRCw2Q0FBNkMsS0FBSyxtREFBbUQsbURBQW1ELEtBQUssa0JBQWtCLGtDQUFrQyxlQUFlLHVDQUF1QyxzQ0FBc0MsMktBQTJLLE9BQU8sdUVBQXVFLHdGQUF3RixPQUFPLE9BQU8sNFFBQTRRLE9BQU8sS0FBSyxPQUFPLDJHQUEyRyxLQUFLLGdCQUFnQixlQUFlLG9CQUFvQixFQUFFLHVCQUF1QixPQUFPLG9DQUFvQyxHQUFHLGtDQUFrQyxrQkFBa0Isd0NBQXdDLG9FQUFvRSx5QkFBeUIsZ0RBQWdELE9BQU8sT0FBTyxzQ0FBc0MscUNBQXFDLDZCQUE2QixTQUFTLE9BQU8sS0FBSyxHQUFHLGtIQUFrSCw2QkFBNkIsd0RBQXdELGtDQUFrQyxpQ0FBaUMsT0FBTyxPQUFPLG1DQUFtQyxPQUFPLEtBQUssb0NBQW9DLDJCQUEyQixpQkFBaUIsU0FBUyxPQUFPLGtDQUFrQyxPQUFPLEtBQUssMEJBQTBCLDhCQUE4QixtQ0FBbUMsa0NBQWtDLE9BQU8sT0FBTyxzQkFBc0IsMENBQTBDLE9BQU8sS0FBSyxpQkFBaUIsd0lBQXdJLCtDQUErQyx1QkFBdUIseUNBQXlDLHVCQUF1QixrQ0FBa0MsT0FBTyxpREFBaUQsT0FBTyx3Q0FBd0MsaUdBQWlHLGtOQUFrTixtQ0FBbUMsT0FBTyx1Q0FBdUMsR0FBRyw4RkFBOEYsMEVBQTBFLG9KQUFvSix3REFBd0Qsa0NBQWtDLHVEQUF1RCxPQUFPLDJDQUEyQyxHQUFHLGtLQUFrSyxnQkFBZ0IsNkJBQTZCLG1KQUFtSixPQUFPLE9BQU8sbUNBQW1DLGtDQUFrQyxTQUFTLGlCQUFpQixnQ0FBZ0MsbURBQW1ELHdCQUF3QixXQUFXLE9BQU8scURBQXFELG1IQUFtSCwrQ0FBK0MsRUFBRSxXQUFXLCtCQUErQixtQ0FBbUMsV0FBVyxTQUFTLE9BQU8sS0FBSyxrQkFBa0Isd0hBQXdILHdDQUF3QyxzSkFBc0osMEZBQTBGLDhJQUE4SSxzREFBc0Qsa0JBQWtCLHNLQUFzSyxrRkFBa0Ysa0JBQWtCLHlEQUF5RCw4QkFBOEIscUJBQXFCLGlCQUFpQixPQUFPLHFEQUFxRCw2REFBNkQsU0FBUyxPQUFPLEtBQUssT0FBTyx3Q0FBd0MsS0FBSyxHQUFHLGlEQUFpRCx5QkFBeUIsbUJBQW1CLHlCQUF5QixHQUFHLHdDQUF3QyxxQkFBcUIsNERBQTRELHlEQUF5RCwrQ0FBK0MsMkRBQTJELHlFQUF5RSxrQ0FBa0MsK1JBQStSLDZDQUE2QyxHQUFHLDBKQUEwSiw0Q0FBNEMsR0FBRyxHQUFHLGdDQUFnQyw2Q0FBNkMscUNBQXFDLDJDQUEyQyxvQkFBb0IsNEJBQTRCLDhCQUE4QixnREFBZ0QsMENBQTBDLDRCQUE0Qiw2RUFBNkUsdURBQXVELFNBQVMsT0FBTyx5RkFBeUYsa0RBQWtELDZCQUE2QixPQUFPLGtKQUFrSixvQ0FBb0MsV0FBVyxnRUFBZ0UsT0FBTyxZQUFZLGdEQUFnRCx3TUFBd00sa0pBQWtKLFNBQVMsT0FBTyw0QkFBNEIsU0FBUyxPQUFPLHlHQUF5Ryw0RUFBNEUsNEtBQTRLLFNBQVMsbUNBQW1DLE9BQU8scURBQXFELHdCQUF3QiwrSkFBK0osZ0NBQWdDLGlDQUFpQyxrQ0FBa0Msa0NBQWtDLGtDQUFrQyxvQ0FBb0Msb0NBQW9DLHFDQUFxQyxxQ0FBcUMsdUNBQXVDLHVDQUF1Qyx3Q0FBd0MsMENBQTBDLEdBQUcseUNBQXlDLHNDQUFzQyxrQkFBa0IsOEZBQThGLEtBQUssR0FBRyxrQ0FBa0Msb0NBQW9DLGlCQUFpQiw0SUFBNEksOEhBQThILG1DQUFtQywwQkFBMEIscURBQXFELHdCQUF3Qix3QkFBd0IsbUVBQW1FLDhGQUE4RixvRkFBb0YsNFNBQTRTLGVBQWUsRUFBRSxhQUFhLE9BQU8sdUVBQXVFLGFBQWEsNEJBQTRCLGtDQUFrQyxTQUFTLFFBQVEsdUJBQXVCLGlCQUFpQixnQkFBZ0IsS0FBSyxHQUFHLDBCQUEwQiw4QkFBOEIsOENBQThDLG9CQUFvQixvQ0FBb0MsNkJBQTZCLDhHQUE4RyxrREFBa0QsK0NBQStDLHVCQUF1QixPQUFPLHFFQUFxRSxrRUFBa0UscU9BQXFPLE9BQU8sT0FBTyw4R0FBOEcsdUJBQXVCLE9BQU8sa0ZBQWtGLHNCQUFzQixPQUFPLE9BQU8sNkJBQTZCLE9BQU8sNkNBQTZDLHdCQUF3QixxQkFBcUIscUJBQXFCLG1DQUFtQyx5QkFBeUIsNERBQTRELHNCQUFzQixrRUFBa0UsZ0hBQWdILGtEQUFrRCxxQkFBcUIsNERBQTRELE9BQU8sNkJBQTZCLGtDQUFrQyxPQUFPLE1BQU0sR0FBRyxrREFBa0QsbUVBQW1FLGdHQUFnRyx1Q0FBdUMsNkNBQTZDLHFEQUFxRCxtREFBbUQsK0NBQStDLHlDQUF5QyxtQ0FBbUMseUJBQXlCLG1DQUFtQyxxREFBcUQsS0FBSyxHQUFHLCtDQUErQywrQkFBK0IscUJBQXFCLCtEQUErRCxpREFBaUQsZ0RBQWdELGdIQUFnSCxtSUFBbUksbUVBQW1FLHNEQUFzRCxTQUFTLGdGQUFnRiwyQkFBMkIsa0RBQWtELFNBQVMsT0FBTyxLQUFLLHFCQUFxQiw0Q0FBNEMsaUJBQWlCLDhCQUE4QixvQ0FBb0MsNkJBQTZCLHdDQUF3Qyx3QkFBd0IsZUFBZSxFQUFFLHlEQUF5RCxPQUFPLEtBQUssc0JBQXNCLHNDQUFzQyxtSUFBbUksbUJBQW1CLHlEQUF5RCxxQkFBcUIsbUJBQW1CLE9BQU8sNENBQTRDLDhCQUE4QixTQUFTLE9BQU8scUJBQXFCLE9BQU8sd0JBQXdCLEdBQUcsOEJBQThCLGlGQUFpRiwrRUFBK0UsS0FBSyx3QkFBd0IsR0FBRyxxQkFBcUIsb0JBQW9CLHFCQUFxQix3QkFBd0IscUJBQXFCLHNDQUFzQyxpQ0FBaUMsMkRBQTJELHFCQUFxQixxRUFBcUUseUJBQXlCLGlEQUFpRCwyQ0FBMkMsT0FBTyx5Q0FBeUMsaUNBQWlDLE9BQU8sOEJBQThCLHVCQUF1QixHQUFHLDBDQUEwQyxrQ0FBa0MsdURBQXVELE1BQU0sR0FBRyx5Q0FBeUMsZ05BQWdOLGdCQUFnQixtRkFBbUYsMENBQTBDLHVCQUF1Qiw4QkFBOEIsd0VBQXdFLEVBQUUsaUNBQWlDLDBDQUEwQyw0REFBNEQsa0RBQWtELDhDQUE4Qyx5TkFBeU4sU0FBUyxPQUFPLG1EQUFtRCw0QkFBNEIsUUFBUSxxREFBcUQsc0NBQXNDLHNCQUFzQixvRkFBb0YsMkJBQTJCLDZQQUE2UCx5QkFBeUIsT0FBTyxpQ0FBaUMsNEJBQTRCLE9BQU8scUZBQXFGLDhCQUE4QiwwQkFBMEIsbUpBQW1KLGdDQUFnQyxPQUFPLEVBQUUsc0RBQXNELDJDQUEyQyxPQUFPLG9NQUFvTSx3Q0FBd0MsbUNBQW1DLGVBQWUsNkRBQTZELHNCQUFzQixHQUFHLGlDQUFpQyxtQ0FBbUMsNEJBQTRCLDZDQUE2QyxLQUFLLEdBQUcsb0NBQW9DLHlDQUF5QywrQkFBK0IseURBQXlELEtBQUssR0FBRyxpREFBaUQsdUdBQXVHLGtFQUFrRSwwQkFBMEIsc0RBQXNELE9BQU8sd0ZBQXdGLG1FQUFtRSw2SUFBNkksYUFBYSxXQUFXLGtFQUFrRSxvREFBb0QsK0RBQStELFdBQVcseUVBQXlFLDBCQUEwQix3Q0FBd0MsV0FBVyxvREFBb0Qsb0NBQW9DLFFBQVEsS0FBSyxFQUFFLEdBQUcsa0RBQWtELHNDQUFzQywwREFBMEQsc0NBQXNDLHNDQUFzQyx1REFBdUQsc0NBQXNDLG9DQUFvQyxpREFBaUQseUNBQXlDLDRCQUE0QixrQ0FBa0MsdUJBQXVCLGlFQUFpRSxvQ0FBb0Msc0NBQXNDLDRCQUE0QixTQUFTLE9BQU8sS0FBSyxHQUFHLHNDQUFzQyxnQkFBZ0IsK0NBQStDLHlEQUF5RCxPQUFPLHlDQUF5QyxLQUFLLEdBQUcscUJBQXFCLHdEQUF3RCw0REFBNEQscUNBQXFDLHVDQUF1QyxLQUFLLHlDQUF5Qyx3QkFBd0IsdUNBQXVDLDJDQUEyQyxPQUFPLEtBQUssZUFBZSx1Q0FBdUMsZ0RBQWdELDJCQUEyQixFQUFFLEVBQUUsT0FBTyx3Q0FBd0MsZ0RBQWdELDRCQUE0QixFQUFFLEVBQUUsT0FBTyxLQUFLLG1DQUFtQyw4REFBOEQsNkRBQTZELDZCQUE2Qiw4RUFBOEUsbUpBQW1KLCtCQUErQiw2UkFBNlIsOEJBQThCLHNFQUFzRSxTQUFTLE9BQU8sa0NBQWtDLFNBQVMsb0NBQW9DLE9BQU8sdUJBQXVCLElBQUksNkJBQTZCLDRCQUE0Qiw0Q0FBNEMsb0NBQW9DLGlDQUFpQyxlQUFlLEdBQUcsZ0RBQWdELG1DQUFtQyx1R0FBdUcsUUFBUSxLQUFLLG9EQUFvRCwwS0FBMEssb0hBQW9ILG9CQUFvQixxQkFBcUIsNEJBQTRCLHdDQUF3QyxnREFBZ0Qsb0RBQW9ELEtBQUssRUFBRSwyS0FBMkssd0RBQXdELG1CQUFtQixxQkFBcUIsb0JBQW9CLDRCQUE0QixHQUFHLHlCQUF5Qix5REFBeUQsNkJBQTZCLEVBQUUsNEJBQTRCLDhIQUE4SCxnREFBZ0Qsc09BQXNPLDJFQUEyRSxzZEFBc2QsaURBQWlELG1DQUFtQyxxRUFBcUUsd0NBQXdDLDhEQUE4RCwyQ0FBMkMsMkNBQTJDLGlEQUFpRCwwQkFBMEIsMkJBQTJCLDBCQUEwQix5Q0FBeUMscURBQXFELDJCQUEyQixvREFBb0QsT0FBTyxLQUFLLDhDQUE4Qyw0QkFBNEIscURBQXFELE9BQU8sS0FBSyxvQ0FBb0MsNkNBQTZDLFlBQVkseUpBQXlKLEdBQUcsc0NBQXNDLGtDQUFrQyx1Q0FBdUMsc0NBQXNDLG1FQUFtRSw4Q0FBOEMsNEJBQTRCLG1EQUFtRCxxQ0FBcUMsaUJBQWlCLGlCQUFpQixxQkFBcUIsb0NBQW9DLHVCQUF1QiwrQkFBK0Isc0JBQXNCLHVDQUF1QyxPQUFPLE9BQU8sdUJBQXVCLHlEQUF5RCxxQ0FBcUMsV0FBVyxTQUFTLE9BQU8sa0NBQWtDLDBCQUEwQiw4QkFBOEIseUJBQXlCLGtCQUFrQixFQUFFLE9BQU8sa0NBQWtDLCtDQUErQyxrQ0FBa0Msd0ZBQXdGLHdzQkFBd3NCLGtYQUFrWCw0Q0FBNEMsMkNBQTJDLG9DQUFvQyxxQkFBcUIsdUJBQXVCLGtJQUFrSSx3QkFBd0IsR0FBRyxrREFBa0QsbUNBQW1DLGlEQUFpRCxzQkFBc0IsNkJBQTZCLHVCQUF1Qiw0QkFBNEIsdUVBQXVFLDBDQUEwQyx5Q0FBeUMsZ0NBQWdDLCtNQUErTSxPQUFPLHVGQUF1RixHQUFHLDJHQUEyRyxpQ0FBaUMsZ0RBQWdELHNCQUFzQixzR0FBc0csbURBQW1ELDBCQUEwQixPQUFPLG9CQUFvQixHQUFHLHlEQUF5RCw4Q0FBOEMsK0JBQStCLHFCQUFxQix5SkFBeUosK0NBQStDLEtBQUssaUJBQWlCLG1EQUFtRCx3RUFBd0Usb0NBQW9DLDJDQUEyQyxtQ0FBbUMsMENBQTBDLGdFQUFnRSxvREFBb0QsR0FBRyx3Q0FBd0MsNEJBQTRCLEdBQUcsd0NBQXdDLDRCQUE0QixHQUFHLGdDQUFnQyw2QkFBNkIsaUNBQWlDLDhCQUE4Qiw2QkFBNkIsMEJBQTBCLDBDQUEwQyw0QkFBNEIsR0FBRyw0Q0FBNEMsZ0NBQWdDLEdBQUcsbUNBQW1DLHNYQUFzWCxFQUFFLHlCQUF5Qix3Q0FBd0MseUJBQXlCLEtBQUssZ0RBQWdELGlEQUFpRCxvQ0FBb0MsMkJBQTJCLE9BQU8sS0FBSyx3Q0FBd0MsK0JBQStCLEtBQUssSUFBSSw2Q0FBNkMsNkJBQTZCLGVBQWUsU0FBUyw2QkFBNkIsbURBQW1ELHdCQUF3QixvQkFBb0IscUNBQXFDLCtCQUErQixPQUFPLDhCQUE4Qiw4QkFBOEIsT0FBTyxLQUFLLE9BQU8sZ0NBQWdDLHFFQUFxRSw4QkFBOEIsU0FBUyxPQUFPLDRCQUE0QixTQUFTLE9BQU8sT0FBTyx3QkFBd0IsT0FBTyxLQUFLLEdBQUcsOFpBQThaLE1BQU0sc0VBQXNFLDBCQUEwQiwyQ0FBMkMsd0JBQXdCLDJDQUEyQyx5QkFBeUIsd0JBQXdCLCtCQUErQix5S0FBeUssNEpBQTRKLDRCQUE0QixjQUFjLFVBQVUsa0VBQWtFLGtFQUFrRSw2QkFBNkIsNkRBQTZELGVBQWUsaUJBQWlCLHNCQUFzQixhQUFhLE9BQU8sNEJBQTRCLHVCQUF1QixjQUFjLEVBQUUsS0FBSyxpQkFBaUIsNENBQTRDLGFBQWEsaUJBQWlCLG9DQUFvQyxrQ0FBa0MsaUJBQWlCLGtCQUFrQixPQUFPLHlCQUF5QixpQkFBaUIsb0JBQW9CLE9BQU8sMENBQTBDLG1EQUFtRCxTQUFTLE9BQU8sS0FBSyxrQ0FBa0MsNkRBQTZELDBCQUEwQixpREFBaUQsNkJBQTZCLDBDQUEwQywrQkFBK0IsU0FBUyxPQUFPLHNDQUFzQywyQkFBMkIsZ0NBQWdDLDBDQUEwQywrRkFBK0Ysd0NBQXdDLE9BQU8sS0FBSyxvQkFBb0IsK0VBQStFLG1DQUFtQyx3R0FBd0cscUJBQXFCLDhCQUE4QixvQ0FBb0MsMEJBQTBCLHVCQUF1QixvREFBb0QsaUNBQWlDLG9CQUFvQixXQUFXLDJNQUEyTSxvUUFBb1EsV0FBVyxTQUFTLDRIQUE0SCx3QkFBd0IsMkNBQTJDLDhEQUE4RCw0QkFBNEIseURBQXlELFdBQVcsK0NBQStDLFNBQVMsMEVBQTBFLGtCQUFrQixTQUFTLE9BQU8sb0NBQW9DLHNEQUFzRCw2Q0FBNkMsT0FBTyxPQUFPLHVEQUF1RCw2Q0FBNkMsT0FBTyxLQUFLLCtFQUErRSx5QkFBeUIscUJBQXFCLDBFQUEwRSxxREFBcUQsNkRBQTZELFNBQVMsaVVBQWlVLG1EQUFtRCxzQ0FBc0MsOEVBQThFLFdBQVcsOEJBQThCLE9BQU8sS0FBSywwREFBMEQsNENBQTRDLG9GQUFvRixPQUFPLDhDQUE4QywrQkFBK0IscURBQXFELHdCQUF3QixPQUFPLE9BQU8sNkhBQTZILHFGQUFxRixPQUFPLEtBQUssbUZBQW1GLFlBQVksb1RBQW9ULDJDQUEyQyx1REFBdUQsbUVBQW1FLHFCQUFxQix5QkFBeUIsT0FBTyxrREFBa0QsV0FBVyw2Q0FBNkMsd0JBQXdCLE9BQU8sc0pBQXNKLEtBQUssMENBQTBDLDBCQUEwQix5QkFBeUIsaURBQWlELFNBQVMsT0FBTywyQ0FBMkMsU0FBUyxPQUFPLEtBQUsscUVBQXFFLG9DQUFvQyx1QkFBdUIscUJBQXFCLE9BQU8sNEVBQTRFLFNBQVMsT0FBTyxvQ0FBb0MsMkVBQTJFLE9BQU8sS0FBSyxvQ0FBb0MsdUNBQXVDLCtDQUErQyxPQUFPLGtDQUFrQyw4REFBOEQsdUJBQXVCLHlCQUF5QixTQUFTLDBDQUEwQyxPQUFPLDBCQUEwQix1Q0FBdUMsOEJBQThCLDRCQUE0QixFQUFFLDhCQUE4QixnQ0FBZ0MsRUFBRSxPQUFPLEtBQUssOE1BQThNLFlBQVksMkJBQTJCLHdCQUF3Qiw0RUFBNEUsaURBQWlELFNBQVMsbUNBQW1DLE9BQU8sbU1BQW1NLCtDQUErQyxPQUFPLEtBQUssNEZBQTRGLFlBQVksb0JBQW9CLGNBQWMsMkVBQTJFLE9BQU8sS0FBSywwQ0FBMEMsZUFBZSw0QkFBNEIsd0JBQXdCLDJEQUEyRCxVQUFVLEVBQUUsbUJBQW1CLHdCQUF3QixPQUFPLHVCQUF1QixFQUFFLE9BQU8sc0NBQXNDLG1CQUFtQiwyQkFBMkIsT0FBTywrQ0FBK0MsU0FBUyxPQUFPLEtBQUssbUVBQW1FLFlBQVksb0JBQW9CLGNBQWMsa0NBQWtDLHdCQUF3Qiw4QkFBOEIsMENBQTBDLGtDQUFrQyxXQUFXLE9BQU8sNENBQTRDLFdBQVcsU0FBUyxPQUFPLEtBQUssc0RBQXNELDJDQUEyQyw4Q0FBOEMsd0JBQXdCLHVJQUF1SSxTQUFTLE9BQU8sOEVBQThFLFNBQVMseUpBQXlKLDJDQUEyQyxTQUFTLG1CQUFtQix1QkFBdUIsT0FBTyxtQ0FBbUMsU0FBUyxnRUFBZ0UsdUJBQXVCLFNBQVMsT0FBTyxlQUFlLFNBQVMsT0FBTyxPQUFPLDhCQUE4QixPQUFPLEtBQUsseUZBQXlGLDBCQUEwQiwwQkFBMEIsdUNBQXVDLG1DQUFtQyx5Q0FBeUMsdUNBQXVDLG1DQUFtQyx5Q0FBeUMsbURBQW1ELGdOQUFnTixzRUFBc0UscUNBQXFDLCtDQUErQyxzQ0FBc0MsaUNBQWlDLDJDQUEyQyxTQUFTLG9EQUFvRCx1RUFBdUUsK0NBQStDLCtDQUErQyxTQUFTLGdEQUFnRCxtRUFBbUUsMkNBQTJDLDJDQUEyQyxTQUFTLGtEQUFrRCwwRkFBMEYsOEdBQThHLCtDQUErQywyQ0FBMkMsU0FBUyxrREFBa0QseUZBQXlGLHlGQUF5RiwyQ0FBMkMsK0NBQStDLFNBQVMsT0FBTyxxQ0FBcUMsZ0VBQWdFLEVBQUUsc0ZBQXNGLGtDQUFrQyxzR0FBc0csaURBQWlELFdBQVcsT0FBTyx3Q0FBd0MsMEdBQTBHLHVMQUF1TCxhQUFhLHNEQUFzRCx1RUFBdUUsMENBQTBDLCtGQUErRixtREFBbUQsYUFBYSxPQUFPLDhKQUE4SixtREFBbUQsYUFBYSxXQUFXLFNBQVMsT0FBTyxvQ0FBb0MsaUZBQWlGLHdGQUF3RixPQUFPLG9DQUFvQywrREFBK0QsT0FBTyxLQUFLLDZFQUE2RSwrQkFBK0IscUJBQXFCLG1hQUFtYSxpQ0FBaUMsNkRBQTZELHFCQUFxQixZQUFZLDRCQUE0Qix5RUFBeUUsMkJBQTJCLE9BQU8seUNBQXlDLG9DQUFvQyw4QkFBOEIsOENBQThDLG1CQUFtQix1QkFBdUIsT0FBTyxnQ0FBZ0MsRUFBRSwwREFBMEQsb0JBQW9CLEVBQUUsT0FBTyxnQ0FBZ0Msd0NBQXdDLDZCQUE2QixnRUFBZ0UsRUFBRSxTQUFTLHNCQUFzQixxQ0FBcUMsaUNBQWlDLEVBQUUseUVBQXlFLFNBQVMseUJBQXlCLHdEQUF3RCxTQUFTLGlDQUFpQywwQ0FBMEMsU0FBUyxPQUFPLHlDQUF5QyxnREFBZ0QsT0FBTyx3QkFBd0IsNkRBQTZELG9CQUFvQixFQUFFLE9BQU8sS0FBSyx5REFBeUQsaUtBQWlLLGdEQUFnRCxPQUFPLE9BQU8sdUJBQXVCLGtCQUFrQixPQUFPLDhDQUE4QyxTQUFTLE9BQU8sS0FBSyx5QkFBeUIsNk9BQTZPLDBJQUEwSSxrREFBa0QsMkNBQTJDLCtCQUErQixPQUFPLHNCQUFzQiwwQkFBMEIsNEJBQTRCLG9DQUFvQyx3QkFBd0Isd0RBQXdELGdDQUFnQyxFQUFFLGlEQUFpRCxzSEFBc0gsOEJBQThCLE9BQU8sdUJBQXVCLDhCQUE4Qiw4R0FBOEcsZ0VBQWdFLFdBQVcsT0FBTyxxQ0FBcUMsMkNBQTJDLDZCQUE2Qix1QkFBdUIsU0FBUyx5RkFBeUYsc0NBQXNDLG9DQUFvQyxnREFBZ0QsYUFBYSxrTEFBa0wseUlBQXlJLDhCQUE4Qiw4Q0FBOEMsOEZBQThGLGVBQWUsdUNBQXVDLFdBQVcsU0FBUywwQkFBMEIsaUNBQWlDLHlDQUF5QywyREFBMkQsZ0NBQWdDLFdBQVcsU0FBUyxPQUFPLG9DQUFvQyw4QkFBOEIsT0FBTyxzQkFBc0IsOENBQThDLDZCQUE2Qix1S0FBdUssT0FBTyxpRUFBaUUsS0FBSyx5RkFBeUYsMkJBQTJCLDhCQUE4Qiw2QkFBNkIsRUFBRSxxQkFBcUIsbUNBQW1DLGtDQUFrQyxnQ0FBZ0MsbUdBQW1HLGdFQUFnRSxPQUFPLE9BQU8scURBQXFELDJEQUEyRCwyR0FBMkcsU0FBUyxPQUFPLDhCQUE4QixrUEFBa1AsMERBQTBELCtCQUErQixhQUFhLG9DQUFvQyxpRUFBaUUsa0VBQWtFLDhDQUE4QyxrREFBa0Qsd1pBQXdaLGVBQWUsYUFBYSw4SkFBOEosV0FBVywyRUFBMkUsdURBQXVELDBXQUEwVyxzQ0FBc0MseUpBQXlKLDhCQUE4Qix1Q0FBdUMseUNBQXlDLGFBQWEscUNBQXFDLDZCQUE2Qix1QkFBdUIsT0FBTyx1REFBdUQsZUFBZSxhQUFhLFdBQVcscUNBQXFDLHdEQUF3RCxXQUFXLGdDQUFnQyx3Q0FBd0MsV0FBVyxTQUFTLE9BQU8sb0VBQW9FLDJCQUEyQixHQUFHLGdDQUFnQywwR0FBMEcseUNBQXlDLEtBQUssSUFBSSxpREFBaUQsNERBQTRELCtCQUErQixLQUFLLEdBQUcsd0NBQXdDLDBDQUEwQyx3Q0FBd0Msb0ZBQW9GLDhFQUE4RSw4QkFBOEIsK0JBQStCLDJCQUEyQiwwQkFBMEIsNEJBQTRCLHlCQUF5QixvQkFBb0IsK0VBQStFLDBDQUEwQyxtQ0FBbUMsU0FBUyxPQUFPLE9BQU8seUVBQXlFLG1EQUFtRCxrREFBa0Qsc0NBQXNDLFNBQVMsT0FBTyxLQUFLLGtDQUFrQyxvQ0FBb0MsdUJBQXVCLDJCQUEyQixPQUFPLHFFQUFxRSxTQUFTLFFBQVEscUJBQXFCLCtEQUErRCx5QkFBeUIsT0FBTyxPQUFPLHFCQUFxQixPQUFPLEtBQUsscUNBQXFDLDZEQUE2RCw2QkFBNkIsdUJBQXVCLDhCQUE4QixPQUFPLGdGQUFnRixTQUFTLE9BQU8sRUFBRSxLQUFLLHNCQUFzQiw0QkFBNEIsNEJBQTRCLGtIQUFrSCxTQUFTLE9BQU8sS0FBSyxHQUFHLDZDQUE2Qyx3REFBd0Qsa0NBQWtDLGdCQUFnQixxQkFBcUIsZUFBZSxlQUFlLGlCQUFpQixPQUFPLG9CQUFvQiwyQkFBMkIsdUNBQXVDLE9BQU8sb0NBQW9DLHdFQUF3RSxLQUFLLGlCQUFpQixrQ0FBa0MsZ0ZBQWdGLGdCQUFnQixpRUFBaUUsc0NBQXNDLGFBQWEscURBQXFELEtBQUssR0FBRyxpREFBaUQsc0RBQXNELG9EQUFvRCxpQkFBaUIsc0JBQXNCLHdCQUF3Qiw2Q0FBNkMsdUNBQXVDLDZGQUE2RiwwQ0FBMEMsU0FBUyxLQUFLLDBCQUEwQix1QkFBdUIsMEJBQTBCLHdCQUF3QiwrQkFBK0IsT0FBTyxLQUFLLHNKQUFzSix5Q0FBeUMsS0FBSywyQkFBMkIsK0JBQStCLDJCQUEyQiw0REFBNEQsU0FBUyxtQ0FBbUMsbUNBQW1DLFNBQVMsT0FBTyxLQUFLLEdBQUcsdUNBQXVDLDZCQUE2Qiw0SEFBNEgsZ0NBQWdDLE9BQU8sT0FBTyxrQ0FBa0MsT0FBTyxLQUFLLGtDQUFrQyw0RkFBNEYsS0FBSyx5QkFBeUIsb0NBQW9DLHlEQUF5RCxPQUFPLE9BQU8sK0NBQStDLE9BQU8sS0FBSyxPQUFPLG9DQUFvQyxnQ0FBZ0MsT0FBTyxPQUFPLG9DQUFvQyxPQUFPLEtBQUssR0FBRyxpQkFBaUIsbURBQW1ELHNEQUFzRCx1QkFBdUIsMEJBQTBCLGdDQUFnQyw0R0FBNEcsaUJBQWlCLHdDQUF3QyxrRkFBa0YsMEJBQTBCLHlEQUF5RCxLQUFLLHNEQUFzRCxvQ0FBb0MsMEJBQTBCLEtBQUssR0FBRyxpQkFBaUIsbURBQW1ELDJEQUEyRCwyQ0FBMkMsZ0NBQWdDLGdCQUFnQiw2RkFBNkYsT0FBTyxvQ0FBb0MscUNBQXFDLHdFQUF3RSxHQUFHLCtlQUErZSxjQUFjLDRKQUE0SixtQ0FBbUMsb1NBQW9TLGNBQWMsc0RBQXNELGtHQUFrRyw4REFBOEQsNkJBQTZCLEtBQUssbUNBQW1DLG9IQUFvSCx1RUFBdUUsc0NBQXNDLEtBQUssR0FBRyxpQkFBaUIsbUVBQW1FLGVBQWUsK0JBQStCLDZCQUE2Qix5RUFBeUUsZ0hBQWdILDJCQUEyQixxREFBcUQsU0FBUyxRQUFRLEtBQUssdURBQXVELEdBQUcseUVBQXlFLHVFQUF1RSxHQUFHLG1EQUFtRCw4Q0FBOEMsaUJBQWlCLGlDQUFpQyx1Q0FBdUMseUJBQXlCLHdCQUF3QiwrREFBK0QsR0FBRyxrQkFBa0IsaUVBQWlFLHlEQUF5RCwwREFBMEQsaUJBQWlCLGlCQUFpQix3QkFBd0IsZ0RBQWdELDBDQUEwQyw2RkFBNkYsNkNBQTZDLFNBQVMsS0FBSyw2QkFBNkIsK0JBQStCLHNCQUFzQixPQUFPLEtBQUssd0JBQXdCLHVCQUF1Qiw4T0FBOE8sNkJBQTZCLDJCQUEyQixFQUFFLG9DQUFvQyxXQUFXLE9BQU8sOEJBQThCLHVIQUF1SCxxSEFBcUgsb0RBQW9ELDZCQUE2QixTQUFTLE9BQU8sT0FBTyx1QkFBdUIsT0FBTyxLQUFLLEdBQUcseUhBQXlILHlJQUF5SSxzQ0FBc0MscUxBQXFMLDJDQUEyQywwQkFBMEIsb0NBQW9DLGtHQUFrRyxzREFBc0Qsc0NBQXNDLGdEQUFnRCw4QkFBOEIsb0JBQW9CLHlEQUF5RCw4REFBOEQsaUJBQWlCLDBCQUEwQixlQUFlLG9DQUFvQywwREFBMEQsaUJBQWlCLGdEQUFnRCwrREFBK0QsT0FBTyxLQUFLLEVBQUUsaUJBQWlCLEVBQUUsa0dBQWtHLGtEQUFrRCwwTkFBME4sNEdBQTRHLHNDQUFzQyx3Q0FBd0MsMkNBQTJDLDhDQUE4QywwQkFBMEIsK0pBQStKLGlCQUFpQixrQkFBa0IsdUJBQXVCLDRCQUE0QiwyQ0FBMkMsdURBQXVELGlGQUFpRixpQ0FBaUMsU0FBUyxPQUFPLEtBQUsseURBQXlELDZCQUE2QixLQUFLLDZCQUE2Qiw4Q0FBOEMsaUZBQWlGLCtCQUErQixPQUFPLEtBQUssaUJBQWlCLG1DQUFtQyxzQ0FBc0MsMENBQTBDLDBEQUEwRCxzQ0FBc0MsS0FBSyxrQ0FBa0MsNEVBQTRFLEtBQUssT0FBTyxzQ0FBc0MsS0FBSyxJQUFJLDJDQUEyQyxlQUFlLDBDQUEwQyxxREFBcUQsMEJBQTBCLHNEQUFzRCxzQkFBc0IsNkRBQTZELG1CQUFtQixxQkFBcUIsT0FBTyx5Q0FBeUMscUNBQXFDLDhCQUE4QixLQUFLLEdBQUcsRUFBRSw0Q0FBNEMsMEJBQTBCLGdDQUFnQyw4RkFBOEYsaUJBQWlCLG9CQUFvQix1QkFBdUIsbURBQW1ELG9EQUFvRCx1SkFBdUosZ0VBQWdFLGlEQUFpRCxpQkFBaUIsMkNBQTJDLDhCQUE4QixtQ0FBbUMsOEJBQThCLE9BQU8sS0FBSyw0QkFBNEIsMkJBQTJCLG1DQUFtQyxxSEFBcUgsT0FBTyxLQUFLLEdBQUcsaUJBQWlCLG1EQUFtRCx5SkFBeUosa0VBQWtFLGlCQUFpQix1REFBdUQsa0NBQWtDLGdEQUFnRCw0QkFBNEIsRUFBRSxFQUFFLE9BQU8sT0FBTyw4QkFBOEIsT0FBTyxLQUFLLE9BQU8saUVBQWlFLDZDQUE2QyxxREFBcUQsT0FBTyxLQUFLLEdBQUcscUpBQXFKLGtFQUFrRSxpQkFBaUIsdURBQXVELGtDQUFrQyxnREFBZ0QsK0JBQStCLEVBQUUsRUFBRSxPQUFPLE9BQU8saUNBQWlDLE9BQU8sS0FBSyxPQUFPLGlFQUFpRSxnQ0FBZ0MscUNBQXFDLG9DQUFvQyxPQUFPLDJDQUEyQyxLQUFLLEdBQUcsbURBQW1ELGtCQUFrQixpQkFBaUIsbUVBQW1FLG1CQUFtQixpQ0FBaUMsMkRBQTJELE9BQU8sMEJBQTBCLHFCQUFxQix1Q0FBdUMsMkNBQTJDLEdBQUcsb0RBQW9ELFlBQVksNFFBQTRRLEdBQUcsRUFBRSw0Q0FBNEMsZ0NBQWdDLDhCQUE4Qiw2RUFBNkUsMkNBQTJDLGtDQUFrQyx5Q0FBeUMsc0JBQXNCLDhIQUE4SCwwQ0FBMEMsaURBQWlELEtBQUssZ0dBQWdHLHdDQUF3QywrQ0FBK0MsS0FBSyxHQUFHLHVNQUF1TSw2QkFBNkIscUJBQXFCLGNBQWMsS0FBSyxFQUFFLEdBQUcsMkNBQTJDLHNFQUFzRSxzQkFBc0IsR0FBRyw4Q0FBOEMsZ0NBQWdDLHlDQUF5QyxLQUFLLHlCQUF5QixHQUFHLG9FQUFvRSxrREFBa0Qsd0JBQXdCLDhCQUE4QixrQ0FBa0MsZ0JBQWdCLGNBQWMsNkVBQTZFLGtCQUFrQiwyQkFBMkIsMkNBQTJDLFdBQVcsTUFBTSw4QkFBOEIsNEJBQTRCLG1DQUFtQyxnQkFBZ0IsU0FBUyxPQUFPLE1BQU0sNEJBQTRCLDhCQUE4QixjQUFjLE9BQU8sS0FBSyxlQUFlLHNDQUFzQyxHQUFHLGdEQUFnRCxtREFBbUQsNkNBQTZDLHdFQUF3RSw4RUFBOEUsOEVBQThFLHNFQUFzRSw0RUFBNEUsMkVBQTJFLGVBQWUsb0JBQW9CLHNCQUFzQixrRUFBa0Usa0NBQWtDLDBCQUEwQixvQ0FBb0MsK0NBQStDLE9BQU8sS0FBSyx1Q0FBdUMsaUNBQWlDLHlCQUF5QixtQ0FBbUMsOENBQThDLE9BQU8sS0FBSyxPQUFPLDhEQUE4RCxnSUFBZ0ksMElBQTBJLEtBQUssOEdBQThHLFlBQVksd0dBQXdHLEdBQUcsNkNBQTZDLDRFQUE0RSxxQ0FBcUMsS0FBSyxpRUFBaUUsMkNBQTJDLEtBQUssdUJBQXVCLDJDQUEyQyxxREFBcUQsdUJBQXVCLHNEQUFzRCxtQ0FBbUMsb0JBQW9CLEtBQUssMERBQTBELGdCQUFnQixpQkFBaUIseUVBQXlFLGlCQUFpQix5QkFBeUIseUJBQXlCLHFDQUFxQyx5Q0FBeUMsaURBQWlELHVDQUF1QywyQ0FBMkMsbURBQW1ELHVDQUF1QywyQkFBMkIscUNBQXFDLDZDQUE2Qyx5Q0FBeUMsNkJBQTZCLHVDQUF1QywrQ0FBK0MsaUNBQWlDLHFUQUFxVCwrQ0FBK0MscURBQXFELDZDQUE2Qyx1Q0FBdUMsS0FBSyxnRUFBZ0UsaURBQWlELGlCQUFpQixvRkFBb0YscUdBQXFHLHFGQUFxRiw2RkFBNkYsaUdBQWlHLHVGQUF1Rix1R0FBdUcsbUhBQW1ILG1GQUFtRiwyREFBMkQsS0FBSywrQ0FBK0MsNkRBQTZELCtDQUErQyx1QkFBdUIsMkNBQTJDLCtDQUErQyxPQUFPLHlCQUF5Qix5QkFBeUIsZ0RBQWdELFNBQVMscURBQXFELE9BQU8sT0FBTyw2Q0FBNkMsT0FBTyx5QkFBeUIsS0FBSyxFQUFFLDZCQUE2Qix1SUFBdUksMEJBQTBCLG1DQUFtQyxrRkFBa0YsNkdBQTZHLHFDQUFxQyxTQUFTLHVDQUF1QyxPQUFPLEVBQUUsS0FBSywwRUFBMEUscUJBQXFCLHlDQUF5QywwQ0FBMEMsNkJBQTZCLHdDQUF3Qyw4Q0FBOEMsaURBQWlELHVEQUF1RCxrREFBa0QsV0FBVyxPQUFPLDZDQUE2QyxXQUFXLFNBQVMsT0FBTyxFQUFFLEtBQUssNEJBQTRCLHVDQUF1QyxxQ0FBcUMsS0FBSyw2Q0FBNkMsV0FBVyxLQUFLLEdBQUcsZ0NBQWdDLHVCQUF1QixzREFBc0QsbUNBQW1DLG9CQUFvQixLQUFLLDBEQUEwRCxnQkFBZ0Isc0JBQXNCLHlFQUF5RSxpQkFBaUIseUJBQXlCLHlCQUF5QixxQ0FBcUMseUNBQXlDLGlEQUFpRCx1Q0FBdUMsMkJBQTJCLHFDQUFxQyw2Q0FBNkMscUNBQXFDLGlDQUFpQywrQ0FBK0MseURBQXlELG1IQUFtSCxtRkFBbUYsMkRBQTJELEtBQUssK0NBQStDLG9EQUFvRCxpREFBaUQsT0FBTyx1QkFBdUIsZ0RBQWdELG9EQUFvRCxPQUFPLHlCQUF5Qix5QkFBeUIsZ0RBQWdELFNBQVMsNkNBQTZDLE9BQU8sT0FBTyxhQUFhLHFDQUFxQyxPQUFPLHlCQUF5QixLQUFLLEVBQUUsdUJBQXVCLCtCQUErQixLQUFLLE9BQU8scUJBQXFCLEtBQUssZ0NBQWdDLG1GQUFtRixxQkFBcUIsNERBQTRELCtEQUErRCxzQkFBc0IsT0FBTyxxQ0FBcUMsdUJBQXVCLDJDQUEyQyxpREFBaUQsK0JBQStCLCtDQUErQyxnREFBZ0QsbURBQW1ELHlEQUF5RCxvREFBb0QsYUFBYSxPQUFPLCtDQUErQyxhQUFhLFdBQVcsU0FBUyxFQUFFLE9BQU8sNkJBQTZCLDZDQUE2QyxhQUFhLE9BQU8sS0FBSyxHQUFHLHlFQUF5RSxrQ0FBa0MsNktBQTZLLEtBQUssdUJBQXVCLG1LQUFtSyxLQUFLLEdBQUcsb0NBQW9DLG9EQUFvRCxtUUFBbVEsY0FBYyxlQUFlLDRCQUE0QixxQkFBcUIsZ0pBQWdKLE9BQU8sK0NBQStDLEdBQUcsZ0NBQWdDLDJCQUEyQixtQkFBbUIsS0FBSyxHQUFHLGtDQUFrQyxvRkFBb0YsNkRBQTZELHlCQUF5QixPQUFPLE9BQU8sYUFBYSxPQUFPLEtBQUssR0FBRyxNQUFNLG1HQUFtRyxtS0FBbUsscUNBQXFDLHFDQUFxQyxFQUFFLHNKQUFzSiw4SEFBOEgsc0NBQXNDLDRCQUE0Qiw2QkFBNkIsT0FBTyxLQUFLLEVBQUUsR0FBRyxtQkFBbUIsc0RBQXNELG1DQUFtQyw4QkFBOEIsa0RBQWtELFVBQVUsYUFBYSw2REFBNkQsNEJBQTRCLFNBQVMsT0FBTyxxRkFBcUYsMkNBQTJDLHNDQUFzQywyQkFBMkIsd0VBQXdFLG9FQUFvRSxXQUFXLHdEQUF3RCw2QkFBNkIsV0FBVyxTQUFTLE9BQU8sS0FBSyx1RUFBdUUsbUNBQW1DLGdEQUFnRCw0VUFBNFUsMkNBQTJDLEVBQUUsa0dBQWtHLHdCQUF3QixnQ0FBZ0MsU0FBUyxPQUFPLEtBQUssSUFBSSw0Q0FBNEMsOEJBQThCLGlDQUFpQyw4Q0FBOEMseVFBQXlRLGlCQUFpQix5QkFBeUIsMENBQTBDLE9BQU8sT0FBTyw2QkFBNkIsdUJBQXVCLDhEQUE4RCwyQ0FBMkMscUNBQXFDLFNBQVMsT0FBTyxPQUFPLGtEQUFrRCx1Q0FBdUMsaUNBQWlDLFdBQVcseUJBQXlCLE9BQU8sS0FBSyxzQkFBc0IsNEJBQTRCLEtBQUssR0FBRyxtREFBbUQsdUNBQXVDLE9BQU8sT0FBTyxvREFBb0QsMkJBQTJCLEtBQUssa0JBQWtCLGdDQUFnQyx5RUFBeUUscUNBQXFDLDhCQUE4QixHQUFHLG1DQUFtQywrQkFBK0IsK0JBQStCLEdBQUcsaUNBQWlDLCtDQUErQyxrQ0FBa0Msd0JBQXdCLEdBQUcsNEhBQTRILCtJQUErSSxnQkFBZ0IsMENBQTBDLDRCQUE0QixrQ0FBa0MsMkRBQTJELCtHQUErRywwQ0FBMEMsK0JBQStCLGtDQUFrQyw2Q0FBNkMsU0FBUyxFQUFFLE9BQU8sT0FBTyw0REFBNEQsT0FBTyxLQUFLLGlEQUFpRCw0QkFBNEIsa0NBQWtDLCtEQUErRCxTQUFTLGdDQUFnQywyREFBMkQsaUNBQWlDLCtCQUErQixvQkFBb0Isb0NBQW9DLHFEQUFxRCxXQUFXLEVBQUUsU0FBUyxPQUFPLG9DQUFvQyxzQ0FBc0MsV0FBVyxFQUFFLFNBQVMsT0FBTyxPQUFPLGtFQUFrRSxPQUFPLEtBQUssd0dBQXdHLHVCQUF1QixpREFBaUQsT0FBTyxLQUFLLElBQUksOEJBQThCLHFDQUFxQyxzSkFBc0osNFdBQTRXLGdMQUFnTCxzREFBc0QsMkRBQTJELDRFQUE0RSxPQUFPLHVCQUF1QixHQUFHLDJDQUEyQyxrQkFBa0IsZ0NBQWdDLG9EQUFvRCw0QkFBNEIsS0FBSyxvSUFBb0ksa0NBQWtDLCtDQUErQyxLQUFLLGtCQUFrQix3Q0FBd0MscUZBQXFGLDBDQUEwQyxvQ0FBb0Msa0NBQWtDLDBCQUEwQixLQUFLLEdBQUcsNENBQTRDLHNFQUFzRSxzQkFBc0Isd0dBQXdHLHdCQUF3QiwyQ0FBMkMsc0JBQXNCLHFCQUFxQixzR0FBc0csY0FBYyxFQUFFLEVBQUUsMkRBQTJELHFCQUFxQiwwR0FBMEcsNEpBQTRKLE9BQU8sNkJBQTZCLHlJQUF5SSw0RkFBNEYsT0FBTyxtQ0FBbUMscUtBQXFLLDhCQUE4QiwySkFBMkosaURBQWlELDhCQUE4Qiw0QkFBNEIsOENBQThDLGlQQUFpUCwrTEFBK0wsa0RBQWtELDRDQUE0QyxvQ0FBb0MsK0NBQStDLG1MQUFtTCwwQkFBMEIsRUFBRSxJQUFJLCtCQUErQixPQUFPLHlFQUF5RSwrS0FBK0ssU0FBUyxpRUFBaUUsd0dBQXdHLDZEQUE2RCxvQ0FBb0Msa0NBQWtDLFdBQVcsRUFBRSxrREFBa0QsOEJBQThCLDJCQUEyQiwwQ0FBMEMsZ0JBQWdCLEdBQUcsMkRBQTJELCtEQUErRCxrRUFBa0Usc0JBQXNCLEVBQUUsRUFBRSxTQUFTLE9BQU8sNEJBQTRCLElBQUksd2JBQXdiLDZLQUE2Syx3Q0FBd0MsbUJBQW1CLHNCQUFzQiwyQkFBMkIsb0RBQW9ELDJEQUEyRCxvQ0FBb0MsMkRBQTJELGtEQUFrRCx3Q0FBd0MsdURBQXVELHVCQUF1Qix3QkFBd0IsT0FBTywrQkFBK0Isb0JBQW9CLHdFQUF3RSw2QkFBNkIsdUNBQXVDLHVCQUF1QiwrQkFBK0IsV0FBVyxrREFBa0QsMENBQTBDLGlGQUFpRixvRkFBb0YsV0FBVyxTQUFTLE9BQU8sMkJBQTJCLHNCQUFzQix5QkFBeUIseUJBQXlCLDJCQUEyQixTQUFTLHNDQUFzQywrQ0FBK0MseURBQXlELDZCQUE2QiwyQkFBMkIsV0FBVyxPQUFPLDhCQUE4QixXQUFXLFNBQVMsdUNBQXVDLCtCQUErQixPQUFPLDBDQUEwQywrQ0FBK0MsMkxBQTJMLDhCQUE4QixLQUFLLHFDQUFxQyx1Q0FBdUMsdUVBQXVFLDBFQUEwRSxxQkFBcUIsNExBQTRMLHVDQUF1Qyx5Q0FBeUMsb0ZBQW9GLGdDQUFnQyw4REFBOEQsMkJBQTJCLHlCQUF5QiwyQkFBMkIsNENBQTRDLHNFQUFzRSxnRkFBZ0YsMERBQTBELDZEQUE2RCxnQ0FBZ0MsbURBQW1ELGFBQWEsV0FBVyxFQUFFLFNBQVMsT0FBTyxFQUFFLEtBQUssaUJBQWlCLGlEQUFpRCw2REFBNkQsK0JBQStCLG9DQUFvQyx1Q0FBdUMsNFZBQTRWLG9DQUFvQyx3REFBd0QseUJBQXlCLEVBQUUsRUFBRSxTQUFTLG1DQUFtQyxxQ0FBcUMsb0NBQW9DLDRDQUE0QyxvQ0FBb0MseURBQXlELEtBQUssSUFBSSxpQ0FBaUMsb0RBQW9ELHNCQUFzQixLQUFLLHFEQUFxRCx1QkFBdUIsS0FBSyxHQUFHLGlDQUFpQyxrREFBa0QsR0FBRyxtQ0FBbUMsNEJBQTRCLCtCQUErQix1Q0FBdUMscUNBQXFDLG1CQUFtQiwwQkFBMEIsMEJBQTBCLHFGQUFxRixrQ0FBa0MsS0FBSyxHQUFHLDhCQUE4QixtRUFBbUUseUZBQXlGLDZDQUE2QyxpREFBaUQsbURBQW1ELDhHQUE4Ryx1REFBdUQsNkZBQTZGLHdGQUF3RixpREFBaUQsa0RBQWtELGlGQUFpRiwwQkFBMEIscUJBQXFCLHFDQUFxQyxPQUFPLDhEQUE4RCxtTUFBbU0sT0FBTyxLQUFLLCtJQUErSSxzUUFBc1EsS0FBSyxHQUFHLEtBQUssc0VBQXNFLGdDQUFnQyx1SEFBdUgsY0FBYzs7QUFFLzNxTCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRSxjQUFjLEVBQUUsNEZBQTRGLDRJQUE0SSwyRkFBMkYsMElBQTBJLHNGQUFzRix1Q0FBdUMscUlBQXFJLDJEQUEyRCxvRUFBb0UsMkNBQTJDLGNBQWM7O0FBRXo5QixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRSxjQUFjLEVBQUUsc0dBQXNHLGlEQUFpRCxrQkFBa0IsMkRBQTJELE9BQU8sR0FBRyxFQUFFLDJDQUEyQyxjQUFjOztBQUUzWCxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxtRUFBbUUsNkRBQTZELCtCQUErQixtQ0FBbUMsdUNBQXVDLE9BQU8sa0NBQWtDLDRCQUE0QixPQUFPLGtCQUFrQixrQkFBa0Isb0VBQW9FLE9BQU8sMkNBQTJDLGtCQUFrQixtQkFBbUIsT0FBTyxXQUFXLDJEQUEyRCxjQUFjOztBQUUva0IsT0FBTztBQUNQO0FBQ0E7O0FBRUEsb0RBQW9ELGlNQUFpTSxrQkFBa0IsMEZBQTBGLHVDQUF1QyxpRUFBaUUscUJBQXFCLDRDQUE0QyxrQkFBa0IsR0FBRyxTQUFTLE9BQU8seUJBQXlCLFNBQVMsT0FBTyxhQUFhLE1BQU0sMkZBQTJGLGlGQUFpRixzQ0FBc0Msb0JBQW9CLGlCQUFpQixPQUFPLDRCQUE0QixnRkFBZ0YsT0FBTyxnQkFBZ0Isb0JBQW9CLE9BQU8sOEJBQThCLDRXQUE0VyxzQ0FBc0MsaUNBQWlDLFdBQVcsc0JBQXNCLHlFQUF5RSxXQUFXLDBCQUEwQixTQUFTLE9BQU8sTUFBTSxnQkFBZ0IsSUFBSSx5REFBeUQsZ0NBQWdDLDZCQUE2QixzQkFBc0IscUJBQXFCLEtBQUsseUJBQXlCLGdEQUFnRCxpRUFBaUUsK0VBQStFLEVBQUUsZ0ZBQWdGLEtBQUssbUNBQW1DLEdBQUcsNkVBQTZFLDBFQUEwRSx1REFBdUQsY0FBYyxrQkFBa0IsbUNBQW1DLEdBQUcsZ0NBQWdDLDBGQUEwRixjQUFjOztBQUV6aUYsT0FBTztBQUNQO0FBQ0E7O0FBRUEsd0JBQXdCLDREQUE0RCwyQ0FBMkMsY0FBYzs7QUFFN0ksT0FBTztBQUNQO0FBQ0E7O0FBRUEsb0lBQW9JLDZCQUE2QixlQUFlLDBCQUEwQiw0RUFBNEUsb0JBQW9CLFFBQVEsS0FBSyxtQ0FBbUMsK1lBQStZLEtBQUssa0NBQWtDLG9CQUFvQixpQ0FBaUMsc0RBQXNELG1EQUFtRCxTQUFTLHFDQUFxQyxLQUFLLDBCQUEwQixxREFBcUQsaUlBQWlJLDhDQUE4QyxpREFBaUQsMkhBQTJILEtBQUssOEJBQThCLDZFQUE2RSw0TUFBNE0sOElBQThJLGtKQUFrSixzQ0FBc0Msb0NBQW9DLHVDQUF1Qyx5QkFBeUIsb0JBQW9CLG1CQUFtQixPQUFPLDZCQUE2Qiw0Q0FBNEMsd0JBQXdCLGlDQUFpQyxPQUFPLG1CQUFtQiw4Q0FBOEMsMkNBQTJDLE9BQU8sb0JBQW9CLHNCQUFzQixPQUFPLG9DQUFvQyxpQ0FBaUMsd0JBQXdCLDJCQUEyQixxQ0FBcUMsMENBQTBDLFNBQVMsT0FBTyxNQUFNLElBQUksOENBQThDLGtCQUFrQixtQkFBbUIsT0FBTywyQkFBMkIsMENBQTBDLG9CQUFvQix3QkFBd0Isc0JBQXNCLDJCQUEyQixPQUFPLDJDQUEyQyxTQUFTLGFBQWEsdUJBQXVCLE9BQU8sZ0VBQWdFLFNBQVMsT0FBTyxPQUFPLHVCQUF1QixzQkFBc0IsdUJBQXVCLE9BQU8sdURBQXVELFNBQVMsZ0NBQWdDLG9DQUFvQyxPQUFPLEtBQUssR0FBRyxpQ0FBaUMsb0JBQW9CLHVCQUF1QixrQkFBa0IsaUJBQWlCLE9BQU8seUJBQXlCLHVCQUF1Qix3QkFBd0IsMEJBQTBCLDhCQUE4QixrQkFBa0IsOENBQThDLDZEQUE2RCxzQkFBc0IsRUFBRSxpREFBaUQsS0FBSyxrQkFBa0IsR0FBRyx3REFBd0QsMkVBQTJFLHVJQUF1SSxLQUFLLDBHQUEwRyx1Q0FBdUMsMENBQTBDLHVFQUF1RSxPQUFPLHFEQUFxRCwwRkFBMEYsT0FBTyxPQUFPLDhDQUE4QyxPQUFPLG9EQUFvRCxLQUFLLDRDQUE0Qyw0Q0FBNEMsS0FBSyxPQUFPLDhGQUE4RixLQUFLLEdBQUcsK0NBQStDLHNEQUFzRCwrREFBK0Qsa0JBQWtCLGdEQUFnRCxLQUFLLEdBQUcsMENBQTBDLHlEQUF5RCxzQ0FBc0Msa0RBQWtELDhDQUE4Qyx3QkFBd0IsR0FBRyx5Q0FBeUMsdURBQXVELHNDQUFzQyx1Q0FBdUMsaURBQWlELDZDQUE2Qyx1QkFBdUIsR0FBRyw2Q0FBNkMsK0NBQStDLDRDQUE0QyxLQUFLLEVBQUUsR0FBRyxxQ0FBcUMscUNBQXFDLDhCQUE4QiwwQ0FBMEMsMEZBQTBGLCtFQUErRSw4RUFBOEUsS0FBSywrT0FBK08sZ0RBQWdELDREQUE0RCwyQkFBMkIseUNBQXlDLDhFQUE4RSxRQUFRLEtBQUssT0FBTyxpREFBaUQsbURBQW1ELDJCQUEyQix5Q0FBeUMsUUFBUSxLQUFLLGtCQUFrQiwyQ0FBMkMsa0JBQWtCLHVIQUF1SCw2QkFBNkIsT0FBTyxPQUFPLGlCQUFpQixPQUFPLE1BQU0sR0FBRyxvQ0FBb0MsdUJBQXVCLDRDQUE0QyxxQ0FBcUMsbURBQW1ELE1BQU0sR0FBRyxJQUFJLG9FQUFvRSxzQ0FBc0Msb0NBQW9DLGdFQUFnRSxLQUFLLE9BQU8saURBQWlELCtDQUErQyx5RUFBeUUsOEJBQThCLDhEQUE4RCxPQUFPLE9BQU8sMENBQTBDLE9BQU8sS0FBSyxHQUFHLDRDQUE0QyxzQkFBc0IsMEJBQTBCLGlCQUFpQixzREFBc0QsbUNBQW1DLDRDQUE0QyxLQUFLLE9BQU8sc0NBQXNDLDBEQUEwRCxPQUFPLDZEQUE2RCxLQUFLLEdBQUcsb0RBQW9ELHNCQUFzQixrQ0FBa0MsZ1VBQWdVLHdEQUF3RCx5QkFBeUIsS0FBSyxxQkFBcUIseUdBQXlHLG9GQUFvRixLQUFLLGtDQUFrQyxxQkFBcUIsRUFBRSxvQ0FBb0MsbURBQW1ELGtEQUFrRCxHQUFHLDZDQUE2QyxjQUFjOztBQUUzblMsT0FBTztBQUNQO0FBQ0E7O0FBRUEsa2tCQUFra0IsaUdBQWlHLHNCQUFzQiw0REFBNEQsS0FBSyxtRUFBbUUsaUJBQWlCLEtBQUssK0RBQStELCtFQUErRSxvcUNBQW9xQyxzSUFBc0ksV0FBVyxFQUFFLDhDQUE4QyxXQUFXLEVBQUUsRUFBRSxnSUFBZ0kseUJBQXlCLE9BQU8seURBQXlELG9EQUFvRCwwRUFBMEUsT0FBTyxpREFBaUQsNkZBQTZGLGtDQUFrQyxPQUFPLDhIQUE4SCw2QkFBNkIsOEZBQThGLEtBQUssRUFBRSxvREFBb0QsSUFBSSw2Q0FBNkMsY0FBYzs7QUFFN3RHLE9BQU87QUFDUDtBQUNBOztBQUVBLGtRQUFrUSxpRkFBaUYsNkhBQTZILG9GQUFvRix5TUFBeU0sbUhBQW1ILG1DQUFtQyxxQ0FBcUMsK0NBQStDLGtIQUFrSCx5RUFBeUUsZ0JBQWdCLE9BQU8sdUNBQXVDLGNBQWMsaUZBQWlGLEdBQUcsNkNBQTZDLGNBQWM7O0FBRTcyQyxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQW1CLGFBQWEsMEJBQTBCLHdCQUF3QixzQkFBc0IsY0FBYyw4QkFBOEIsS0FBSywyQ0FBMkMscUJBQXFCLDBEQUEwRCxpREFBaUQsaUhBQWlILEdBQUcsMkNBQTJDLGNBQWM7O0FBRXZnQixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLGlWQUFpVixTQUFTLE9BQU8sK0RBQStELDhHQUE4Ryw4Q0FBOEMsNEVBQTRFLGlXQUFpVywrQkFBK0IseUhBQXlILGdDQUFnQyxrVEFBa1QsT0FBTyxrQkFBa0IsNlFBQTZRLCtCQUErQix5SEFBeUgsK0JBQStCLHNNQUFzTSxtQkFBbUIsb0NBQW9DLGdIQUFnSCw4Q0FBOEMscURBQXFELFNBQVMsVUFBVSwrR0FBK0csNkJBQTZCLG9DQUFvQyxxVUFBcVUsVUFBVSx1QkFBdUIsdUdBQXVHLHVHQUF1Ryw0SEFBNEgsNkJBQTZCLCtMQUErTCxzREFBc0QsNkNBQTZDLGNBQWM7O0FBRWhrSCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCxrb0RBQWtvRCxTQUFTLHdEQUF3RCxtREFBbUQsYUFBYSx3T0FBd08sWUFBWSx1QkFBdUIsR0FBRyw0QkFBNEIsNEVBQTRFLDBDQUEwQyxnQ0FBZ0MsNkRBQTZELHFDQUFxQyx1SkFBdUosT0FBTywwRkFBMEYsd0NBQXdDLCtCQUErQixvQkFBb0IsMmRBQTJkLG1FQUFtRSwyREFBMkQsdURBQXVELGlEQUFpRCxxSEFBcUgsd0NBQXdDLHVEQUF1RCx1S0FBdUsscURBQXFELDJEQUEyRCxvQ0FBb0MseUVBQXlFLCtFQUErRSx3RUFBd0Usc0NBQXNDLDJEQUEyRCx1Q0FBdUMsb1RBQW9ULHlEQUF5RCxxQ0FBcUMsNExBQTRMLHFJQUFxSSxxREFBcUQsTUFBTSxHQUFHLGdDQUFnQyxtQ0FBbUMsb0VBQW9FLHFCQUFxQix5RUFBeUUsR0FBRyxpREFBaUQsd0NBQXdDLDBDQUEwQyw2QkFBNkIsd1RBQXdULHNDQUFzQyw2SUFBNkksK0NBQStDLHVDQUF1Qyx5SEFBeUgscUJBQXFCLFVBQVUsT0FBTywwQkFBMEIsS0FBSyxrQkFBa0IsMklBQTJJLHFDQUFxQywrSUFBK0kscUNBQXFDLGtEQUFrRCwwREFBMEQsNEJBQTRCLHlDQUF5Qyw4RUFBOEUscUtBQXFLLGtQQUFrUCxvQkFBb0IsMENBQTBDLHlIQUF5SCxZQUFZLFVBQVUsbUNBQW1DLGtCQUFrQixnRUFBZ0UscUlBQXFJLGdFQUFnRSwwREFBMEQsZ0VBQWdFLDZEQUE2RCx3Q0FBd0MsaUNBQWlDLG9EQUFvRCxPQUFPLDREQUE0RCx1Q0FBdUMsc0lBQXNJLE9BQU8sNEdBQTRHLGtCQUFrQixxQ0FBcUMsK0JBQStCLDJHQUEyRywwQkFBMEIsdURBQXVELGdCQUFnQixrSEFBa0gsa0VBQWtFLCtDQUErQyw4Q0FBOEMseURBQXlELG1EQUFtRCxLQUFLLGtIQUFrSCwrQkFBK0IsdUtBQXVLLGdLQUFnSyx3QkFBd0Isa0NBQWtDLDRCQUE0QixtREFBbUQsbUNBQW1DLDZDQUE2QywwQ0FBMEMsOENBQThDLHFEQUFxRCwyREFBMkQsZ0hBQWdILFNBQVMsT0FBTywwQkFBMEIsb0RBQW9ELEtBQUssZ0VBQWdFLHdEQUF3RCw2Q0FBNkMsK1FBQStRLEdBQUcsb0RBQW9ELHlCQUF5QiwrRUFBK0UsOEJBQThCLGlDQUFpQywwQ0FBMEMsaUNBQWlDLGlCQUFpQixPQUFPLHVDQUF1QyxLQUFLLDJFQUEyRSxpQkFBaUIsT0FBTyx5REFBeUQsbUZBQW1GLHVEQUF1RCxvQkFBb0IsNENBQTRDLGtDQUFrQywrQkFBK0IsaUtBQWlLLG1DQUFtQyxxQ0FBcUMsK0JBQStCLHdJQUF3SSxHQUFHLHlCQUF5QixnbEJBQWdsQixLQUFLLEdBQUcsa0ZBQWtGLDJkQUEyZCxvQkFBb0IsMElBQTBJLG9CQUFvQixtREFBbUQsNEJBQTRCLHFCQUFxQixvQkFBb0IsdUlBQXVJLG9CQUFvQiwwREFBMEQseUJBQXlCLDByQkFBMHJCLEtBQUssR0FBRyxnTEFBZ0wsOENBQThDLGtEQUFrRCxpREFBaUQsNEVBQTRFLG1CQUFtQixTQUFTLFVBQVUsK0JBQStCLGtCQUFrQixrREFBa0QsaURBQWlELDRFQUE0RSxtQkFBbUIsU0FBUyxVQUFVLDZEQUE2RCxrQkFBa0Isa0RBQWtELGlEQUFpRCw0RUFBNEUsbUJBQW1CLFNBQVMsVUFBVSx5SEFBeUgsa0JBQWtCLHNEQUFzRCxpTEFBaUwsbURBQW1ELHVKQUF1SixvREFBb0QsaUZBQWlGLGtEQUFrRCxFQUFFLDZEQUE2RCxvQ0FBb0MsMEZBQTBGLG1DQUFtQywyREFBMkQsZ0NBQWdDLG9CQUFvQiw0QkFBNEIsMkNBQTJDLGtDQUFrQyx3QkFBd0IsZ0NBQWdDLGdDQUFnQyx1RkFBdUYscURBQXFELGlEQUFpRCxtQkFBbUIsK0JBQStCLG9CQUFvQix1QkFBdUIsbUJBQW1CLGtUQUFrVCxTQUFTLE9BQU8sMENBQTBDLG9FQUFvRSxLQUFLLGdFQUFnRSxpU0FBaVMsNk5BQTZOLDhJQUE4SSxvREFBb0Qsb0NBQW9DLGtDQUFrQyxxQ0FBcUMsbUNBQW1DLDhFQUE4RSx5SUFBeUkscUxBQXFMLHNFQUFzRSwyQkFBMkIsc0RBQXNELHdEQUF3RCwyQ0FBMkMsc0dBQXNHLGdHQUFnRyx3QkFBd0Isc0VBQXNFLG9DQUFvQywrSkFBK0osa0JBQWtCLG9GQUFvRixPQUFPLHdGQUF3RixPQUFPLDBFQUEwRSxvRUFBb0UsaUVBQWlFLG9IQUFvSCxxS0FBcUssK0NBQStDLDRCQUE0QiwrRkFBK0YsS0FBSyw4QkFBOEIsNEJBQTRCLDRCQUE0QixPQUFPLHFEQUFxRCxLQUFLLHlCQUF5QixtREFBbUQsZUFBZSxPQUFPLGlGQUFpRixxSUFBcUksT0FBTyxzRkFBc0YsT0FBTyxLQUFLLE9BQU8sMEdBQTBHLFFBQVEsT0FBTywrQ0FBK0MsZUFBZSxPQUFPLGtEQUFrRCxxREFBcUQsU0FBUyxrQ0FBa0MsS0FBSyxrQkFBa0IsK0VBQStFLDREQUE0RCw2RUFBNkUseUVBQXlFLHFGQUFxRiwwRUFBMEUscURBQXFELHlGQUF5Riw2QkFBNkIsT0FBTyw0REFBNEQsaUNBQWlDLEtBQUssMEtBQTBLLDhCQUE4QixtQkFBbUIsWUFBWSxPQUFPLDRIQUE0SCxlQUFlLHNEQUFzRCx1RkFBdUYsdURBQXVELG1FQUFtRSx3REFBd0QscURBQXFELHdEQUF3RCxvRUFBb0Usc0RBQXNELDBGQUEwRixnRkFBZ0YsMERBQTBELDJHQUEyRywrREFBK0QsK0hBQStILDZCQUE2QixzREFBc0QsdUZBQXVGLE9BQU8sMERBQTBELDRFQUE0RSxPQUFPLG1IQUFtSCxzTUFBc00seUVBQXlFLDhFQUE4RSxHQUFHLHlCQUF5QixvMEJBQW8wQixLQUFLLEdBQUcsa0RBQWtELFlBQVksc0ZBQXNGLEdBQUcsNENBQTRDLDRDQUE0QywyQ0FBMkMsT0FBTyw2REFBNkQsR0FBRywwQ0FBMEMsMkZBQTJGLDhOQUE4TixpR0FBaUcsb0RBQW9ELGdEQUFnRCxvSEFBb0gsc0hBQXNILHdEQUF3RCxhQUFhLHFMQUFxTCx3TUFBd00sd0RBQXdELGFBQWEsd1BBQXdQLDZNQUE2TSx3REFBd0QsYUFBYSxTQUFTLE9BQU8saUNBQWlDLHFMQUFxTCwrQkFBK0IscUxBQXFMLDJEQUEyRCwwQ0FBMEMsMFBBQTBQLHFFQUFxRSxzRkFBc0Ysa0hBQWtILHdIQUF3SCxpQkFBaUIsMkNBQTJDLDRFQUE0RSxTQUFTLE9BQU8sb0RBQW9ELGlCQUFpQiw0Q0FBNEMsNEVBQTRFLFNBQVMsT0FBTyw2Q0FBNkMsaUJBQWlCLHlDQUF5Qyx3SkFBd0osU0FBUyxPQUFPLCtCQUErQixpQkFBaUIsNkNBQTZDLHdFQUF3RSxrQkFBa0IsVUFBVSxvRUFBb0UsaUJBQWlCLDBEQUEwRCwyR0FBMkcscURBQXFELHdCQUF3QixzQkFBc0Isb0JBQW9CLCtDQUErQyxzQkFBc0Isb0JBQW9CLHVGQUF1RixzRkFBc0YsT0FBTyxtR0FBbUcsY0FBYyxPQUFPLDBDQUEwQyxLQUFLLHNCQUFzQixnSUFBZ0ksbUxBQW1MLHNGQUFzRiw2TkFBNk4sd0NBQXdDLG1CQUFtQixzRkFBc0YsMEVBQTBFLHVEQUF1RCx3R0FBd0csbURBQW1ELG1CQUFtQix3RUFBd0UsZ0ZBQWdGLDhFQUE4RSwwR0FBMEcsOEVBQThFLDBHQUEwRyw4RUFBOEUsaU1BQWlNLDhFQUE4RSx5TEFBeUwsb0ZBQW9GLDZOQUE2Tix3Q0FBd0MsMEZBQTBGLG9GQUFvRixpT0FBaU8sMENBQTBDLDBGQUEwRixzRUFBc0UseUpBQXlKLDRFQUE0RSwrSkFBK0osNEVBQTRFLCtKQUErSiw0RUFBNEUsbUxBQW1MLDRFQUE0RSxtTEFBbUwsNEVBQTRFLDJHQUEyRyw0RUFBNEUsNEdBQTRHLDhFQUE4RSwyR0FBMkcsOEVBQThFLDRHQUE0RywyREFBMkQsa1JBQWtSLCtGQUErRiw0RkFBNEYscUhBQXFILDZHQUE2RyxrREFBa0QsbUNBQW1DLCtGQUErRiw0RkFBNEYscUhBQXFILHNIQUFzSCxrREFBa0QsbUNBQW1DLGlGQUFpRiw0TkFBNE4sbUVBQW1FLHNHQUFzRyxPQUFPLE9BQU8sMkhBQTJILEdBQUcsdUZBQXVGLDRJQUE0SSw4RUFBOEUsT0FBTyx1REFBdUQsd0JBQXdCLHVGQUF1Riw0SUFBNEksOEVBQThFLE9BQU8sd0RBQXdELHdCQUF3QixtRUFBbUUsMEdBQTBHLE9BQU8sT0FBTyw4RUFBOEUsR0FBRyx1RkFBdUYsZ0pBQWdKLDRKQUE0SixPQUFPLHVEQUF1RCx3QkFBd0IsdUZBQXVGLGdKQUFnSiw0SkFBNEosT0FBTyx3REFBd0Qsd0JBQXdCLDZGQUE2Riw2REFBNkQsMEhBQTBILDRIQUE0SCxpRUFBaUUsc0JBQXNCLCtEQUErRCxtQ0FBbUMsNkZBQTZGLDZEQUE2RCwwSEFBMEgscUlBQXFJLGlFQUFpRSxzQkFBc0IsK0RBQStELG1DQUFtQywrRUFBK0UsMlFBQTJRLHFGQUFxRixrSkFBa0osOEVBQThFLE9BQU8sdURBQXVELHdCQUF3QixxRkFBcUYsa0pBQWtKLDhFQUE4RSxPQUFPLHdEQUF3RCx3QkFBd0IscUZBQXFGLDBKQUEwSiw0SkFBNEosT0FBTyx1REFBdUQsd0JBQXdCLHFGQUFxRiwyTUFBMk0sNEpBQTRKLE9BQU8sd0RBQXdELHdCQUF3QiwrREFBK0QsOElBQThJLHNFQUFzRSxvQkFBb0IsK0ZBQStGLGtGQUFrRixxRkFBcUYsNkRBQTZELHFGQUFxRiw4REFBOEQsdUVBQXVFLG9CQUFvQixpR0FBaUcsa0ZBQWtGLHVGQUF1Riw4REFBOEQsdUZBQXVGLCtEQUErRCwySkFBMkosNE9BQTRPLDZKQUE2Siw0REFBNEQsZ1JBQWdSLG9EQUFvRCw0R0FBNEcsd0RBQXdELFFBQVEsT0FBTyx3REFBd0QsS0FBSyxzREFBc0QsbURBQW1ELFNBQVMsT0FBTyx3REFBd0QsS0FBSyxPQUFPLDRIQUE0SCxtQkFBbUIsa09BQWtPLDZEQUE2RCxzQ0FBc0MseUVBQXlFLG9DQUFvQyxzREFBc0QsNkJBQTZCLDZEQUE2RCw2QkFBNkIsT0FBTyxtRUFBbUUsK0RBQStELHlFQUF5RSxtRUFBbUUsS0FBSyxvQ0FBb0MsMEJBQTBCLDJJQUEySSxxREFBcUQseUJBQXlCLHNCQUFzQixrSkFBa0oscUJBQXFCLFNBQVMsT0FBTyw0QkFBNEIsS0FBSyxPQUFPLDJKQUEySixpQkFBaUIsT0FBTywrQ0FBK0MsS0FBSyxvQkFBb0IsNkhBQTZILHNXQUFzVywwQkFBMEIsaUJBQWlCLCtCQUErQixnRkFBZ0Ysd0JBQXdCLHVFQUF1RSwwQ0FBMEMsK0lBQStJLFlBQVksT0FBTyw0SEFBNEgsNERBQTRELDJEQUEyRCw2SEFBNkgsNkJBQTZCLDBIQUEwSCx5RkFBeUYsOERBQThELDJIQUEySCx5SEFBeUgsMEJBQTBCLHFIQUFxSCwrRUFBK0UsdUVBQXVFLDhCQUE4Qix5SUFBeUksZ0NBQWdDLGtMQUFrTCxpQ0FBaUMsNE5BQTROLE9BQU8sb0RBQW9ELEtBQUsscUJBQXFCLGlDQUFpQyx5Q0FBeUMsZ0JBQWdCLE9BQU8sK0dBQStHLHVCQUF1QiwwQ0FBMEMsMERBQTBELGdCQUFnQixPQUFPLHNKQUFzSix5QkFBeUIsa0NBQWtDLGtEQUFrRCxvREFBb0QsbUJBQW1CLFlBQVksT0FBTyxtR0FBbUcsZUFBZSwwQkFBMEIsZ0VBQWdFLGdDQUFnQyxrRkFBa0YsY0FBYzs7QUFFajdpRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxvRUFBb0UsK1NBQStTLFdBQVcseURBQXlELGdGQUFnRixXQUFXLHlEQUF5RCxvQkFBb0Isd0JBQXdCLHVCQUF1QixxREFBcUQsT0FBTyx1REFBdUQsc0RBQXNELDBFQUEwRSxxWEFBcVgsaURBQWlELE9BQU8sOEZBQThGLGdDQUFnQywyQkFBMkIsOEJBQThCLE9BQU8sbURBQW1ELDJCQUEyQixnQ0FBZ0MsZ0NBQWdDLG9DQUFvQywyQkFBMkIsMkVBQTJFLE9BQU8sa0ZBQWtGLEtBQUssWUFBWSxXQUFXLCtEQUErRCxtREFBbUQsVUFBVSwrREFBK0QsMENBQTBDLDZDQUE2QyxjQUFjOztBQUV6cEUsT0FBTztBQUNQO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVUsc0RBQXNELGtEQUFrRCxJQUFJLDZDQUE2QyxjQUFjOztBQUV4TSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4RUFBOEUsc1VBQXNVLHlCQUF5QixpQ0FBaUMseURBQXlELEdBQUcsbUNBQW1DLDJEQUEyRCxHQUFHLGdCQUFnQixXQUFXLGlEQUFpRCw0Q0FBNEMsV0FBVyxPQUFPLGtEQUFrRCxXQUFXLE9BQU8sWUFBWSw4Q0FBOEMsT0FBTyxXQUFXLG1EQUFtRCxnREFBZ0QsV0FBVyxPQUFPLHVEQUF1RCxXQUFXLE9BQU8sWUFBWSxtREFBbUQsT0FBTyxHQUFHLGdDQUFnQyw0Q0FBNEMscUZBQXFGLE9BQU8scUpBQXFKLHdDQUF3QyxvQ0FBb0MsT0FBTyxXQUFXLDBIQUEwSCxPQUFPLFVBQVUsZUFBZSx5TEFBeUwsV0FBVyxVQUFVLHdPQUF3TyxXQUFXLE9BQU8sT0FBTyxvQ0FBb0MsZ0RBQWdELHVGQUF1RixPQUFPLGdLQUFnSyw0Q0FBNEMsc0NBQXNDLE9BQU8sV0FBVyw0SEFBNEgsT0FBTyxXQUFXLGVBQWUsNExBQTRMLFdBQVcsV0FBVyxxVUFBcVUsV0FBVyxPQUFPLFNBQVMsaUJBQWlCLHVCQUF1QixtQkFBbUIsc0JBQXNCLGdDQUFnQyx1Q0FBdUMsaUJBQWlCLE9BQU8sdUJBQXVCLGdDQUFnQyw2Q0FBNkMsT0FBTyxPQUFPLDBCQUEwQixPQUFPLHlCQUF5Qix1QkFBdUIsT0FBTyxHQUFHLDJCQUEyQixxQkFBcUIsaUJBQWlCLE9BQU8sZ0RBQWdELHNCQUFzQiwrQkFBK0Isa0JBQWtCLCtCQUErQixxQkFBcUIsc0NBQXNDLGlDQUFpQyxpREFBaUQsZUFBZSxXQUFXLDBCQUEwQiw2QkFBNkIsT0FBTywwQkFBMEIsdUJBQXVCLCtCQUErQixHQUFHLHVDQUF1QyxpREFBaUQsaUNBQWlDLHlCQUF5QixzQkFBc0IsT0FBTyx5Q0FBeUMsV0FBVyxPQUFPLHNDQUFzQyw0Q0FBNEMsaUNBQWlDLE9BQU8sSUFBSSxnRUFBZ0UscUJBQXFCLHlCQUF5QixHQUFHLG9DQUFvQyx1Q0FBdUMsSUFBSSw0QkFBNEIseUJBQXlCLG1CQUFtQixvQkFBb0IsdUJBQXVCLCtEQUErRCxzQkFBc0Isc0JBQXNCLDZCQUE2QixzQkFBc0IscUJBQXFCLGdDQUFnQyxvQ0FBb0Msc0JBQXNCLHVDQUF1QywwREFBMEQsSUFBSSwrQkFBK0IsY0FBYyxrQ0FBa0Msd0RBQXdELElBQUksOEJBQThCLFVBQVUsR0FBRyw2Q0FBNkMsY0FBYzs7QUFFdDZLLE9BQU87QUFDUCIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDUpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpKFxcbiAgLyogc2NyaXB0ICovXFxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLFxcbiAgLyogdGVtcGxhdGUgKi9cXG4gIF9fd2VicGFja19yZXF1aXJlX18oMTMpLFxcbiAgLyogc2NvcGVJZCAqL1xcbiAgbnVsbCxcXG4gIC8qIGNzc01vZHVsZXMgKi9cXG4gIG51bGxcXG4pXFxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXFxcIkM6XFxcXFxcXFzmnZDmlplcXFxcXFxcXOaWh+S7tlxcXFxcXFxcbm9kZVByb2plY3RcXFxcXFxcXHdlYnBhY2tcXFxcXFxcXGFwcFxcXFxcXFxcdnVlLnZ1ZVxcXCJcXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXFxcImRlZmF1bHRcXFwiICYmIGtleSAhPT0gXFxcIl9fZXNNb2R1bGVcXFwifSkpIHtjb25zb2xlLmVycm9yKFxcXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlxcXCIpfVxcbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcXFwiW3Z1ZS1sb2FkZXJdIHZ1ZS52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXFxcIil9XFxuXFxuLyogaG90IHJlbG9hZCAqL1xcbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XFxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcXFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXFxcIilcXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXFxcInZ1ZVxcXCIpLCBmYWxzZSlcXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcXG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcXFwiZGF0YS12LTdkZTNlN2Q4XFxcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXFxuICB9IGVsc2Uge1xcbiAgICBob3RBUEkucmVsb2FkKFxcXCJkYXRhLXYtN2RlM2U3ZDhcXFwiLCBDb21wb25lbnQub3B0aW9ucylcXG4gIH1cXG59KSgpfVxcblxcbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbmRsWW5CaFkyczZMeTh2TGk5aGNIQXZkblZsTG5aMVpUOHpZMlprSWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNkMEpCUVc5SU8wRkJRM0JJTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxDdEZRVUVyUlN4cFJFRkJhVVFzU1VGQlNUdEJRVU53U1N4dFEwRkJiVU03TzBGQlJXNURPMEZCUTBFc1dVRkJhVUk3UVVGRGFrSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVN4RFFVRkRPenRCUVVWRUlpd2labWxzWlNJNklqQXVhbk1pTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKMllYSWdRMjl0Y0c5dVpXNTBJRDBnY21WeGRXbHlaU2hjSWlFdUxpOXViMlJsWDIxdlpIVnNaWE12TGw5MmRXVXRiRzloWkdWeVFERXhMak11TkVCMmRXVXRiRzloWkdWeUwyeHBZaTlqYjIxd2IyNWxiblF0Ym05eWJXRnNhWHBsY2x3aUtTaGNiaUFnTHlvZ2MyTnlhWEIwSUNvdlhHNGdJSEpsY1hWcGNtVW9YQ0loSVdKaFltVnNMV3h2WVdSbGNpRXVMaTl1YjJSbFgyMXZaSFZzWlhNdkxsOTJkV1V0Ykc5aFpHVnlRREV4TGpNdU5FQjJkV1V0Ykc5aFpHVnlMMnhwWWk5elpXeGxZM1J2Y2o5MGVYQmxQWE5qY21sd2RDWnBibVJsZUQwd0lTNHZkblZsTG5aMVpWd2lLU3hjYmlBZ0x5b2dkR1Z0Y0d4aGRHVWdLaTljYmlBZ2NtVnhkV2x5WlNoY0lpRWhMaTR2Ym05a1pWOXRiMlIxYkdWekx5NWZkblZsTFd4dllXUmxja0F4TVM0ekxqUkFkblZsTFd4dllXUmxjaTlzYVdJdmRHVnRjR3hoZEdVdFkyOXRjR2xzWlhJdmFXNWtaWGcvZTF4Y1hDSnBaRnhjWENJNlhGeGNJbVJoZEdFdGRpMDNaR1V6WlRka09GeGNYQ0o5SVM0dUwyNXZaR1ZmYlc5a2RXeGxjeTh1WDNaMVpTMXNiMkZrWlhKQU1URXVNeTQwUUhaMVpTMXNiMkZrWlhJdmJHbGlMM05sYkdWamRHOXlQM1I1Y0dVOWRHVnRjR3hoZEdVbWFXNWtaWGc5TUNFdUwzWjFaUzUyZFdWY0lpa3NYRzRnSUM4cUlITmpiM0JsU1dRZ0tpOWNiaUFnYm5Wc2JDeGNiaUFnTHlvZ1kzTnpUVzlrZFd4bGN5QXFMMXh1SUNCdWRXeHNYRzRwWEc1RGIyMXdiMjVsYm5RdWIzQjBhVzl1Y3k1ZlgyWnBiR1VnUFNCY0lrTTZYRnhjWE9hZGtPYVdtVnhjWEZ6bWxvZmt1N1pjWEZ4Y2JtOWtaVkJ5YjJwbFkzUmNYRnhjZDJWaWNHRmphMXhjWEZ4aGNIQmNYRnhjZG5WbExuWjFaVndpWEc1cFppQW9RMjl0Y0c5dVpXNTBMbVZ6VFc5a2RXeGxJQ1ltSUU5aWFtVmpkQzVyWlhsektFTnZiWEJ2Ym1WdWRDNWxjMDF2WkhWc1pTa3VjMjl0WlNobWRXNWpkR2x2YmlBb2EyVjVLU0I3Y21WMGRYSnVJR3RsZVNBaFBUMGdYQ0prWldaaGRXeDBYQ0lnSmlZZ2EyVjVJQ0U5UFNCY0lsOWZaWE5OYjJSMWJHVmNJbjBwS1NCN1kyOXVjMjlzWlM1bGNuSnZjaWhjSW01aGJXVmtJR1Y0Y0c5eWRITWdZWEpsSUc1dmRDQnpkWEJ3YjNKMFpXUWdhVzRnS2k1MmRXVWdabWxzWlhNdVhDSXBmVnh1YVdZZ0tFTnZiWEJ2Ym1WdWRDNXZjSFJwYjI1ekxtWjFibU4wYVc5dVlXd3BJSHRqYjI1emIyeGxMbVZ5Y205eUtGd2lXM1oxWlMxc2IyRmtaWEpkSUhaMVpTNTJkV1U2SUdaMWJtTjBhVzl1WVd3Z1kyOXRjRzl1Wlc1MGN5QmhjbVVnYm05MElITjFjSEJ2Y25SbFpDQjNhWFJvSUhSbGJYQnNZWFJsY3l3Z2RHaGxlU0J6YUc5MWJHUWdkWE5sSUhKbGJtUmxjaUJtZFc1amRHbHZibk11WENJcGZWeHVYRzR2S2lCb2IzUWdjbVZzYjJGa0lDb3ZYRzVwWmlBb2JXOWtkV3hsTG1odmRDa2dleWhtZFc1amRHbHZiaUFvS1NCN1hHNGdJSFpoY2lCb2IzUkJVRWtnUFNCeVpYRjFhWEpsS0Z3aWRuVmxMV3h2WVdSbGNpOXViMlJsWDIxdlpIVnNaWE12ZG5WbExXaHZkQzF5Wld4dllXUXRZWEJwWENJcFhHNGdJR2h2ZEVGUVNTNXBibk4wWVd4c0tISmxjWFZwY21Vb1hDSjJkV1ZjSWlrc0lHWmhiSE5sS1Z4dUlDQnBaaUFvSVdodmRFRlFTUzVqYjIxd1lYUnBZbXhsS1NCeVpYUjFjbTVjYmlBZ2JXOWtkV3hsTG1odmRDNWhZMk5sY0hRb0tWeHVJQ0JwWmlBb0lXMXZaSFZzWlM1b2IzUXVaR0YwWVNrZ2UxeHVJQ0FnSUdodmRFRlFTUzVqY21WaGRHVlNaV052Y21Rb1hDSmtZWFJoTFhZdE4yUmxNMlUzWkRoY0lpd2dRMjl0Y0c5dVpXNTBMbTl3ZEdsdmJuTXBYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdhRzkwUVZCSkxuSmxiRzloWkNoY0ltUmhkR0V0ZGkwM1pHVXpaVGRrT0Z3aUxDQkRiMjF3YjI1bGJuUXViM0IwYVc5dWN5bGNiaUFnZlZ4dWZTa29LWDFjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCRGIyMXdiMjVsYm5RdVpYaHdiM0owYzF4dVhHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTloY0hBdmRuVmxMbloxWlZ4dUx5OGdiVzlrZFd4bElHbGtJRDBnTUZ4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlYU3dpYzI5MWNtTmxVbTl2ZENJNklpSjlcIik7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwidmFyIGc7XFxyXFxuXFxyXFxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcXHJcXG5nID0gKGZ1bmN0aW9uKCkge1xcclxcblxcdHJldHVybiB0aGlzO1xcclxcbn0pKCk7XFxyXFxuXFxyXFxudHJ5IHtcXHJcXG5cXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcXHJcXG5cXHRnID0gZyB8fCBGdW5jdGlvbihcXFwicmV0dXJuIHRoaXNcXFwiKSgpIHx8ICgxLGV2YWwpKFxcXCJ0aGlzXFxcIik7XFxyXFxufSBjYXRjaChlKSB7XFxyXFxuXFx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcXHJcXG5cXHRpZih0eXBlb2Ygd2luZG93ID09PSBcXFwib2JqZWN0XFxcIilcXHJcXG5cXHRcXHRnID0gd2luZG93O1xcclxcbn1cXHJcXG5cXHJcXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXFxyXFxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcXHJcXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XFxyXFxuXFxyXFxubW9kdWxlLmV4cG9ydHMgPSBnO1xcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluZGxZbkJoWTJzNkx5OHZLSGRsWW5CaFkyc3BMMkoxYVd4a2FXNHZaMnh2WW1Gc0xtcHpQek0yT1RnaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUTBGQlF6czdRVUZGUkR0QlFVTkJPMEZCUTBFN1FVRkRRU3hEUVVGRE8wRkJRMFE3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxEUkRRVUUwUXpzN1FVRkZOVU1pTENKbWFXeGxJam9pTVM1cWN5SXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJblpoY2lCbk8xeHlYRzVjY2x4dUx5OGdWR2hwY3lCM2IzSnJjeUJwYmlCdWIyNHRjM1J5YVdOMElHMXZaR1ZjY2x4dVp5QTlJQ2htZFc1amRHbHZiaWdwSUh0Y2NseHVYSFJ5WlhSMWNtNGdkR2hwY3p0Y2NseHVmU2tvS1R0Y2NseHVYSEpjYm5SeWVTQjdYSEpjYmx4MEx5OGdWR2hwY3lCM2IzSnJjeUJwWmlCbGRtRnNJR2x6SUdGc2JHOTNaV1FnS0hObFpTQkRVMUFwWEhKY2JseDBaeUE5SUdjZ2ZId2dSblZ1WTNScGIyNG9YQ0p5WlhSMWNtNGdkR2hwYzF3aUtTZ3BJSHg4SUNneExHVjJZV3dwS0Z3aWRHaHBjMXdpS1R0Y2NseHVmU0JqWVhSamFDaGxLU0I3WEhKY2JseDBMeThnVkdocGN5QjNiM0pyY3lCcFppQjBhR1VnZDJsdVpHOTNJSEpsWm1WeVpXNWpaU0JwY3lCaGRtRnBiR0ZpYkdWY2NseHVYSFJwWmloMGVYQmxiMllnZDJsdVpHOTNJRDA5UFNCY0ltOWlhbVZqZEZ3aUtWeHlYRzVjZEZ4MFp5QTlJSGRwYm1SdmR6dGNjbHh1ZlZ4eVhHNWNjbHh1THk4Z1p5QmpZVzRnYzNScGJHd2dZbVVnZFc1a1pXWnBibVZrTENCaWRYUWdibTkwYUdsdVp5QjBieUJrYnlCaFltOTFkQ0JwZEM0dUxseHlYRzR2THlCWFpTQnlaWFIxY200Z2RXNWtaV1pwYm1Wa0xDQnBibk4wWldGa0lHOW1JRzV2ZEdocGJtY2dhR1Z5WlN3Z2MyOGdhWFFuYzF4eVhHNHZMeUJsWVhOcFpYSWdkRzhnYUdGdVpHeGxJSFJvYVhNZ1kyRnpaUzRnYVdZb0lXZHNiMkpoYkNrZ2V5QXVMaTU5WEhKY2JseHlYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR2M3WEhKY2JseHVYRzVjYmk4dkx5OHZMeTh2THk4dkx5OHZMeTh2TDF4dUx5OGdWMFZDVUVGRFN5QkdUMDlVUlZKY2JpOHZJQ2gzWldKd1lXTnJLUzlpZFdsc1pHbHVMMmRzYjJKaGJDNXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdNVnh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaVhTd2ljMjkxY21ObFVtOXZkQ0k2SWlKOVwiKTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgY29uZmlnID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcXHJcXG52YXIgdnVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXHJcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xcclxcbiAgdmFyIGdyZWV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxyXFxuICB2YXIgVnVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxyXFxuICBncmVldC50ZXh0Q29udGVudCA9IGNvbmZpZy5ncmVldFRleHQ7XFxyXFxuICByZXR1cm4gZ3JlZXQ7XFxyXFxufTsvLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbmRsWW5CaFkyczZMeTh2TGk5aGNIQXZSM0psWlhSbGNpNXFjejlsWWpnMElsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRWlMQ0ptYVd4bElqb2lNaTVxY3lJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYkluWmhjaUJqYjI1bWFXY2dQU0J5WlhGMWFYSmxLQ2N1TDJOdmJtWnBaeTVxYzI5dUp5azdYSEpjYm5aaGNpQjJkV1VnUFNCeVpYRjFhWEpsS0NjdUwzWjFaUzUyZFdVbktUdGNjbHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaWdwSUh0Y2NseHVJQ0IyWVhJZ1ozSmxaWFFnUFNCa2IyTjFiV1Z1ZEM1amNtVmhkR1ZGYkdWdFpXNTBLQ2RrYVhZbktUdGNjbHh1SUNCMllYSWdWblZsSUQwZ1pHOWpkVzFsYm5RdVkzSmxZWFJsUld4bGJXVnVkQ2duWkdsMkp5azdYSEpjYmlBZ1ozSmxaWFF1ZEdWNGRFTnZiblJsYm5RZ1BTQmpiMjVtYVdjdVozSmxaWFJVWlhoME8xeHlYRzRnSUhKbGRIVnliaUJuY21WbGREdGNjbHh1ZlR0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMkZ3Y0M5SGNtVmxkR1Z5TG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBeVhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0pkTENKemIzVnlZMlZTYjI5MElqb2lJbjA9XCIpO1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXFxuXFxuLy8gbG9hZCB0aGUgc3R5bGVzXFxudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XFxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxcbnZhciB1cGRhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKShjb250ZW50LCB7fSk7XFxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XFxuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxcbmlmKGZhbHNlKSB7XFxuXFx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcXG5cXHRpZighY29udGVudC5sb2NhbHMpIHtcXG5cXHRcXHRtb2R1bGUuaG90LmFjY2VwdChcXFwiISEuLi9ub2RlX21vZHVsZXMvLl9jc3MtbG9hZGVyQDAuMjguMEBjc3MtbG9hZGVyL2luZGV4LmpzP21vZHVsZXMhLi9tYWluLmNzc1xcXCIsIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcXFwiISEuLi9ub2RlX21vZHVsZXMvLl9jc3MtbG9hZGVyQDAuMjguMEBjc3MtbG9hZGVyL2luZGV4LmpzP21vZHVsZXMhLi9tYWluLmNzc1xcXCIpO1xcblxcdFxcdFxcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xcblxcdFxcdFxcdHVwZGF0ZShuZXdDb250ZW50KTtcXG5cXHRcXHR9KTtcXG5cXHR9XFxuXFx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xcblxcdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xcbn0vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbmRsWW5CaFkyczZMeTh2TGk5aGNIQXZiV0ZwYmk1amMzTS9PREkzWWlKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHZEVRVUZ2Unp0QlFVTndSenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTEdkRFFVRm5ReXhWUVVGVkxFVkJRVVU3UVVGRE5VTWlMQ0ptYVd4bElqb2lNeTVxY3lJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpOHZJSE4wZVd4bExXeHZZV1JsY2pvZ1FXUmtjeUJ6YjIxbElHTnpjeUIwYnlCMGFHVWdSRTlOSUdKNUlHRmtaR2x1WnlCaElEeHpkSGxzWlQ0Z2RHRm5YRzVjYmk4dklHeHZZV1FnZEdobElITjBlV3hsYzF4dWRtRnlJR052Ym5SbGJuUWdQU0J5WlhGMWFYSmxLRndpSVNFdUxpOXViMlJsWDIxdlpIVnNaWE12TGw5amMzTXRiRzloWkdWeVFEQXVNamd1TUVCamMzTXRiRzloWkdWeUwybHVaR1Y0TG1welAyMXZaSFZzWlhNaExpOXRZV2x1TG1OemMxd2lLVHRjYm1sbUtIUjVjR1Z2WmlCamIyNTBaVzUwSUQwOVBTQW5jM1J5YVc1bkp5a2dZMjl1ZEdWdWRDQTlJRnRiYlc5a2RXeGxMbWxrTENCamIyNTBaVzUwTENBbkoxMWRPMXh1THk4Z1lXUmtJSFJvWlNCemRIbHNaWE1nZEc4Z2RHaGxJRVJQVFZ4dWRtRnlJSFZ3WkdGMFpTQTlJSEpsY1hWcGNtVW9YQ0loTGk0dmJtOWtaVjl0YjJSMWJHVnpMeTVmYzNSNWJHVXRiRzloWkdWeVFEQXVNVFl1TVVCemRIbHNaUzFzYjJGa1pYSXZZV1JrVTNSNWJHVnpMbXB6WENJcEtHTnZiblJsYm5Rc0lIdDlLVHRjYm1sbUtHTnZiblJsYm5RdWJHOWpZV3h6S1NCdGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdOdmJuUmxiblF1Ykc5allXeHpPMXh1THk4Z1NHOTBJRTF2WkhWc1pTQlNaWEJzWVdObGJXVnVkRnh1YVdZb2JXOWtkV3hsTG1odmRDa2dlMXh1WEhRdkx5QlhhR1Z1SUhSb1pTQnpkSGxzWlhNZ1kyaGhibWRsTENCMWNHUmhkR1VnZEdobElEeHpkSGxzWlQ0Z2RHRm5jMXh1WEhScFppZ2hZMjl1ZEdWdWRDNXNiMk5oYkhNcElIdGNibHgwWEhSdGIyUjFiR1V1YUc5MExtRmpZMlZ3ZENoY0lpRWhMaTR2Ym05a1pWOXRiMlIxYkdWekx5NWZZM056TFd4dllXUmxja0F3TGpJNExqQkFZM056TFd4dllXUmxjaTlwYm1SbGVDNXFjejl0YjJSMWJHVnpJUzR2YldGcGJpNWpjM05jSWl3Z1puVnVZM1JwYjI0b0tTQjdYRzVjZEZ4MFhIUjJZWElnYm1WM1EyOXVkR1Z1ZENBOUlISmxjWFZwY21Vb1hDSWhJUzR1TDI1dlpHVmZiVzlrZFd4bGN5OHVYMk56Y3kxc2IyRmtaWEpBTUM0eU9DNHdRR056Y3kxc2IyRmtaWEl2YVc1a1pYZ3Vhbk0vYlc5a2RXeGxjeUV1TDIxaGFXNHVZM056WENJcE8xeHVYSFJjZEZ4MGFXWW9kSGx3Wlc5bUlHNWxkME52Ym5SbGJuUWdQVDA5SUNkemRISnBibWNuS1NCdVpYZERiMjUwWlc1MElEMGdXMXR0YjJSMWJHVXVhV1FzSUc1bGQwTnZiblJsYm5Rc0lDY25YVjA3WEc1Y2RGeDBYSFIxY0dSaGRHVW9ibVYzUTI5dWRHVnVkQ2s3WEc1Y2RGeDBmU2s3WEc1Y2RIMWNibHgwTHk4Z1YyaGxiaUIwYUdVZ2JXOWtkV3hsSUdseklHUnBjM0J2YzJWa0xDQnlaVzF2ZG1VZ2RHaGxJRHh6ZEhsc1pUNGdkR0ZuYzF4dVhIUnRiMlIxYkdVdWFHOTBMbVJwYzNCdmMyVW9ablZ1WTNScGIyNG9LU0I3SUhWd1pHRjBaU2dwT3lCOUtUdGNibjFjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwyRndjQzl0WVdsdUxtTnpjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdNMXh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaVhTd2ljMjkxY21ObFVtOXZkQ0k2SWlKOVwiKTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzLCBnbG9iYWwpIHsvKiFcXG4gKiBWdWUuanMgdjIuMi42XFxuICogKGMpIDIwMTQtMjAxNyBFdmFuIFlvdVxcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cXG4gKi9cXG4vKiAgKi9cXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cXG4gKi9cXG5mdW5jdGlvbiBfdG9TdHJpbmcgKHZhbCkge1xcbiAgcmV0dXJuIHZhbCA9PSBudWxsXFxuICAgID8gJydcXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxcbiAgICAgIDogU3RyaW5nKHZhbClcXG59XFxuXFxuLyoqXFxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cXG4gKi9cXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XFxuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcXG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cXG59XFxuXFxuLyoqXFxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XFxuICogaXMgaW4gdGhhdCBtYXAuXFxuICovXFxuZnVuY3Rpb24gbWFrZU1hcCAoXFxuICBzdHIsXFxuICBleHBlY3RzTG93ZXJDYXNlXFxuKSB7XFxuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcXG4gIH1cXG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXFxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxcbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XFxufVxcblxcbi8qKlxcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxcbiAqL1xcbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xcblxcbi8qKlxcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcXG4gKi9cXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xcbiAgaWYgKGFyci5sZW5ndGgpIHtcXG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XFxuICAgIGlmIChpbmRleCA+IC0xKSB7XFxuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLyoqXFxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXFxuICovXFxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcXG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XFxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcXG59XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXFxuICovXFxuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XFxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXFxufVxcblxcbi8qKlxcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cXG4gKi9cXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XFxuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XFxuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcXG4gIH0pXFxufVxcblxcbi8qKlxcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXFxuICovXFxudmFyIGNhbWVsaXplUkUgPSAvLShcXFxcdykvZztcXG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXFxufSk7XFxuXFxuLyoqXFxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cXG4gKi9cXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XFxuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXFxufSk7XFxuXFxuLyoqXFxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cXG4gKi9cXG52YXIgaHlwaGVuYXRlUkUgPSAvKFteLV0pKFtBLVpdKS9nO1xcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xcbiAgcmV0dXJuIHN0clxcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXFxuICAgIC50b0xvd2VyQ2FzZSgpXFxufSk7XFxuXFxuLyoqXFxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxcbiAqL1xcbmZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcXG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcXG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xcbiAgICByZXR1cm4gbFxcbiAgICAgID8gbCA+IDFcXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXFxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxcbiAgICAgIDogZm4uY2FsbChjdHgpXFxuICB9XFxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XFxuICByZXR1cm4gYm91bmRGblxcbn1cXG5cXG4vKipcXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cXG4gKi9cXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcXG4gIHdoaWxlIChpLS0pIHtcXG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xcbiAgfVxcbiAgcmV0dXJuIHJldFxcbn1cXG5cXG4vKipcXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXFxuICovXFxuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcXG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcXG4gIH1cXG4gIHJldHVybiB0b1xcbn1cXG5cXG4vKipcXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXFxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxcbiAqL1xcbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcXG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcXG59XFxuXFxuLyoqXFxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXFxuICovXFxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcXG52YXIgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IE9iamVjdF0nO1xcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX1NUUklOR1xcbn1cXG5cXG4vKipcXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxcbiAqL1xcbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcXG4gIHZhciByZXMgPSB7fTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgIGlmIChhcnJbaV0pIHtcXG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzXFxufVxcblxcbi8qKlxcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxcbiAqL1xcbmZ1bmN0aW9uIG5vb3AgKCkge31cXG5cXG4vKipcXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxcbiAqL1xcbnZhciBubyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xcblxcbi8qKlxcbiAqIFJldHVybiBzYW1lIHZhbHVlXFxuICovXFxudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XFxuXFxuLyoqXFxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxcbiAqL1xcblxcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cXG4gKi9cXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XFxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XFxuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XFxuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xcbiAgICB0cnkge1xcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYilcXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgIC8vIHBvc3NpYmxlIGNpcmN1bGFyIHJlZmVyZW5jZVxcbiAgICAgIHJldHVybiBhID09PSBiXFxuICAgIH1cXG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XFxuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGZhbHNlXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XFxuICB9XFxuICByZXR1cm4gLTFcXG59XFxuXFxuLyoqXFxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cXG4gKi9cXG5mdW5jdGlvbiBvbmNlIChmbikge1xcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKCFjYWxsZWQpIHtcXG4gICAgICBjYWxsZWQgPSB0cnVlO1xcbiAgICAgIGZuKCk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxudmFyIGNvbmZpZyA9IHtcXG4gIC8qKlxcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXFxuICAgKi9cXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcXG5cXG4gIC8qKlxcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cXG4gICAqL1xcbiAgc2lsZW50OiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cXG4gICAqL1xcbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcXG5cXG4gIC8qKlxcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcXG4gICAqL1xcbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXFxuXFxuICAvKipcXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcXG4gICAqL1xcbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xcbiAgICovXFxuICBlcnJvckhhbmRsZXI6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xcbiAgICovXFxuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxcblxcbiAgLyoqXFxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxcbiAgICovXFxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcXG5cXG4gIC8qKlxcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXFxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXFxuICAgKi9cXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxcblxcbiAgLyoqXFxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXFxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXFxuICAgKi9cXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxcblxcbiAgLyoqXFxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XFxuICAgKi9cXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcXG5cXG4gIC8qKlxcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cXG4gICAqL1xcbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxcblxcbiAgLyoqXFxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxcbiAgICovXFxuICBtdXN0VXNlUHJvcDogbm8sXFxuXFxuICAvKipcXG4gICAqIExpc3Qgb2YgYXNzZXQgdHlwZXMgdGhhdCBhIGNvbXBvbmVudCBjYW4gb3duLlxcbiAgICovXFxuICBfYXNzZXRUeXBlczogW1xcbiAgICAnY29tcG9uZW50JyxcXG4gICAgJ2RpcmVjdGl2ZScsXFxuICAgICdmaWx0ZXInXFxuICBdLFxcblxcbiAgLyoqXFxuICAgKiBMaXN0IG9mIGxpZmVjeWNsZSBob29rcy5cXG4gICAqL1xcbiAgX2xpZmVjeWNsZUhvb2tzOiBbXFxuICAgICdiZWZvcmVDcmVhdGUnLFxcbiAgICAnY3JlYXRlZCcsXFxuICAgICdiZWZvcmVNb3VudCcsXFxuICAgICdtb3VudGVkJyxcXG4gICAgJ2JlZm9yZVVwZGF0ZScsXFxuICAgICd1cGRhdGVkJyxcXG4gICAgJ2JlZm9yZURlc3Ryb3knLFxcbiAgICAnZGVzdHJveWVkJyxcXG4gICAgJ2FjdGl2YXRlZCcsXFxuICAgICdkZWFjdGl2YXRlZCdcXG4gIF0sXFxuXFxuICAvKipcXG4gICAqIE1heCBjaXJjdWxhciB1cGRhdGVzIGFsbG93ZWQgaW4gYSBzY2hlZHVsZXIgZmx1c2ggY3ljbGUuXFxuICAgKi9cXG4gIF9tYXhVcGRhdGVDb3VudDogMTAwXFxufTtcXG5cXG4vKiAgKi9cXG5cXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cXG4gKi9cXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcXG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1Rlxcbn1cXG5cXG4vKipcXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cXG4gKi9cXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xcbiAgICB2YWx1ZTogdmFsLFxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXFxuICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICBjb25maWd1cmFibGU6IHRydWVcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cXG4gKi9cXG52YXIgYmFpbFJFID0gL1teXFxcXHcuJF0vO1xcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XFxuICAgIHJldHVyblxcbiAgfVxcbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XFxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcXG4gICAgfVxcbiAgICByZXR1cm4gb2JqXFxuICB9XFxufVxcblxcbi8qICAqL1xcbi8qIGdsb2JhbHMgTXV0YXRpb25PYnNlcnZlciAqL1xcblxcbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xcbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xcblxcbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XFxudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XFxudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcXG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcXG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XFxudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XFxudmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcXG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFxcXC9cXFxcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XFxuXFxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXFxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcXG52YXIgX2lzU2VydmVyO1xcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcXG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXFxuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gX2lzU2VydmVyXFxufTtcXG5cXG4vLyBkZXRlY3QgZGV2dG9vbHNcXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XFxuXFxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xcbiAgcmV0dXJuIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXFxufVxcblxcbnZhciBoYXNTeW1ib2wgPVxcbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XFxuXFxuLyoqXFxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXFxuICovXFxudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcXG4gIHZhciBjYWxsYmFja3MgPSBbXTtcXG4gIHZhciBwZW5kaW5nID0gZmFsc2U7XFxuICB2YXIgdGltZXJGdW5jO1xcblxcbiAgZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyICgpIHtcXG4gICAgcGVuZGluZyA9IGZhbHNlO1xcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xcbiAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBjb3BpZXNbaV0oKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gdGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcXG4gIC8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxcbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXFxuICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxcbiAgLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XFxuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XFxuICAgIHZhciBsb2dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB9O1xcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgcC50aGVuKG5leHRUaWNrSGFuZGxlcikuY2F0Y2gobG9nRXJyb3IpO1xcbiAgICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxcbiAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXFxuICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXFxuICAgICAgLy8gXFxcImZvcmNlXFxcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxcbiAgICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XFxuICAgIH07XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXFxuICAgIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XFxuICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxcbiAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXFxuICApKSB7XFxuICAgIC8vIHVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTIElFMTEsIGlPUzcsIEFuZHJvaWQgNC40XFxuICAgIHZhciBjb3VudGVyID0gMTtcXG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKTtcXG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcXG4gICAgfSk7XFxuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XFxuICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcXG4gICAgfTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIGZhbGxiYWNrIHRvIHNldFRpbWVvdXRcXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2tIYW5kbGVyLCAwKTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiBmdW5jdGlvbiBxdWV1ZU5leHRUaWNrIChjYiwgY3R4KSB7XFxuICAgIHZhciBfcmVzb2x2ZTtcXG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmIChjYikgeyBjYi5jYWxsKGN0eCk7IH1cXG4gICAgICBpZiAoX3Jlc29sdmUpIHsgX3Jlc29sdmUoY3R4KTsgfVxcbiAgICB9KTtcXG4gICAgaWYgKCFwZW5kaW5nKSB7XFxuICAgICAgcGVuZGluZyA9IHRydWU7XFxuICAgICAgdGltZXJGdW5jKCk7XFxuICAgIH1cXG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcXG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcXG4gICAgICB9KVxcbiAgICB9XFxuICB9XFxufSkoKTtcXG5cXG52YXIgX1NldDtcXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXFxuICBfU2V0ID0gU2V0O1xcbn0gZWxzZSB7XFxuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXFxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcXG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuICAgIH1cXG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXFxuICAgIH07XFxuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcXG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcXG4gICAgfTtcXG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcXG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuICAgIH07XFxuXFxuICAgIHJldHVybiBTZXQ7XFxuICB9KCkpO1xcbn1cXG5cXG52YXIgd2FybiA9IG5vb3A7XFxudmFyIHRpcCA9IG5vb3A7XFxudmFyIGZvcm1hdENvbXBvbmVudE5hbWU7XFxuXFxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcXG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXFxcdykvZztcXG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XFxuXFxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcXG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xcbiAgICAgIGNvbnNvbGUuZXJyb3IoXFxcIltWdWUgd2Fybl06IFxcXCIgKyBtc2cgKyBcXFwiIFxcXCIgKyAoXFxuICAgICAgICB2bSA/IGZvcm1hdExvY2F0aW9uKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSA6ICcnXFxuICAgICAgKSk7XFxuICAgIH1cXG4gIH07XFxuXFxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XFxuICAgICAgY29uc29sZS53YXJuKFxcXCJbVnVlIHRpcF06IFxcXCIgKyBtc2cgKyBcXFwiIFxcXCIgKyAoXFxuICAgICAgICB2bSA/IGZvcm1hdExvY2F0aW9uKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSA6ICcnXFxuICAgICAgKSk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XFxuICAgICAgcmV0dXJuICc8Um9vdD4nXFxuICAgIH1cXG4gICAgdmFyIG5hbWUgPSB0eXBlb2Ygdm0gPT09ICdzdHJpbmcnXFxuICAgICAgPyB2bVxcbiAgICAgIDogdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLm9wdGlvbnNcXG4gICAgICAgID8gdm0ub3B0aW9ucy5uYW1lXFxuICAgICAgICA6IHZtLl9pc1Z1ZVxcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLm5hbWUgfHwgdm0uJG9wdGlvbnMuX2NvbXBvbmVudFRhZ1xcbiAgICAgICAgICA6IHZtLm5hbWU7XFxuXFxuICAgIHZhciBmaWxlID0gdm0uX2lzVnVlICYmIHZtLiRvcHRpb25zLl9fZmlsZTtcXG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcXG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXFxcXFxdKylcXFxcLnZ1ZSQvKTtcXG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIChcXG4gICAgICAobmFtZSA/IChcXFwiPFxcXCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXFxcIj5cXFwiKSA6IFxcXCI8QW5vbnltb3VzPlxcXCIpICtcXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXFxcIiBhdCBcXFwiICsgZmlsZSkgOiAnJylcXG4gICAgKVxcbiAgfTtcXG5cXG4gIHZhciBmb3JtYXRMb2NhdGlvbiA9IGZ1bmN0aW9uIChzdHIpIHtcXG4gICAgaWYgKHN0ciA9PT0gXFxcIjxBbm9ueW1vdXM+XFxcIikge1xcbiAgICAgIHN0ciArPSBcXFwiIC0gdXNlIHRoZSBcXFxcXFxcIm5hbWVcXFxcXFxcIiBvcHRpb24gZm9yIGJldHRlciBkZWJ1Z2dpbmcgbWVzc2FnZXMuXFxcIjtcXG4gICAgfVxcbiAgICByZXR1cm4gKFxcXCJcXFxcbihmb3VuZCBpbiBcXFwiICsgc3RyICsgXFxcIilcXFwiKVxcbiAgfTtcXG59XFxuXFxuLyogICovXFxuXFxuXFxudmFyIHVpZCQxID0gMDtcXG5cXG4vKipcXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxcbiAqL1xcbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xcbiAgdGhpcy5pZCA9IHVpZCQxKys7XFxuICB0aGlzLnN1YnMgPSBbXTtcXG59O1xcblxcbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcXG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XFxufTtcXG5cXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XFxuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xcbn07XFxuXFxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xcbiAgaWYgKERlcC50YXJnZXQpIHtcXG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XFxuICB9XFxufTtcXG5cXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XFxuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgc3Vic1tpXS51cGRhdGUoKTtcXG4gIH1cXG59O1xcblxcbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXFxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXFxuRGVwLnRhcmdldCA9IG51bGw7XFxudmFyIHRhcmdldFN0YWNrID0gW107XFxuXFxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxcbiAgRGVwLnRhcmdldCA9IF90YXJnZXQ7XFxufVxcblxcbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XFxuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XFxufVxcblxcbi8qXFxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXFxuICovXFxuXFxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XFxudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xcbiAgJ3B1c2gnLFxcbiAgJ3BvcCcsXFxuICAnc2hpZnQnLFxcbiAgJ3Vuc2hpZnQnLFxcbiAgJ3NwbGljZScsXFxuICAnc29ydCcsXFxuICAncmV2ZXJzZSdcXG5dXFxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XFxuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XFxuXFxuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jbG9zdXJlLXdpdGgtYXJndW1lbnRzXFxuICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XFxuICAgIHdoaWxlIChpLS0pIHtcXG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzJDFbaV07XFxuICAgIH1cXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcXG4gICAgdmFyIGluc2VydGVkO1xcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xcbiAgICAgIGNhc2UgJ3B1c2gnOlxcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xcbiAgICAgICAgYnJlYWtcXG4gICAgICBjYXNlICd1bnNoaWZ0JzpcXG4gICAgICAgIGluc2VydGVkID0gYXJncztcXG4gICAgICAgIGJyZWFrXFxuICAgICAgY2FzZSAnc3BsaWNlJzpcXG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcXG4gICAgICAgIGJyZWFrXFxuICAgIH1cXG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cXG4gICAgLy8gbm90aWZ5IGNoYW5nZVxcbiAgICBvYi5kZXAubm90aWZ5KCk7XFxuICAgIHJldHVybiByZXN1bHRcXG4gIH0pO1xcbn0pO1xcblxcbi8qICAqL1xcblxcbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xcblxcbi8qKlxcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgd2hlbiBwYXNzaW5nIGRvd24gcHJvcHMsXFxuICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxcbiAqL1xcbnZhciBvYnNlcnZlclN0YXRlID0ge1xcbiAgc2hvdWxkQ29udmVydDogdHJ1ZSxcXG4gIGlzU2V0dGluZ1Byb3BzOiBmYWxzZVxcbn07XFxuXFxuLyoqXFxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cXG4gKi9cXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcXG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcXG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xcbiAgdGhpcy52bUNvdW50ID0gMDtcXG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cXG4gICAgICA/IHByb3RvQXVnbWVudFxcbiAgICAgIDogY29weUF1Z21lbnQ7XFxuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcXG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xcbiAgfSBlbHNlIHtcXG4gICAgdGhpcy53YWxrKHZhbHVlKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xcbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxcbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxcbiAqL1xcbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XFxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcXG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXFxuICovXFxuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xcbiAgfVxcbn07XFxuXFxuLy8gaGVscGVyc1xcblxcbi8qKlxcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xcbiAqL1xcbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXFxuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xcbn1cXG5cXG4vKipcXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cXG4gKi9cXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcXG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXFxuICovXFxuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcXG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XFxuICAgIHJldHVyblxcbiAgfVxcbiAgdmFyIG9iO1xcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XFxuICAgIG9iID0gdmFsdWUuX19vYl9fO1xcbiAgfSBlbHNlIGlmIChcXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXFxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXFxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcXG4gICAgIXZhbHVlLl9pc1Z1ZVxcbiAgKSB7XFxuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcXG4gIH1cXG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XFxuICAgIG9iLnZtQ291bnQrKztcXG4gIH1cXG4gIHJldHVybiBvYlxcbn1cXG5cXG4vKipcXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXFxuICovXFxuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxcbiAgb2JqLFxcbiAga2V5LFxcbiAgdmFsLFxcbiAgY3VzdG9tU2V0dGVyXFxuKSB7XFxuICB2YXIgZGVwID0gbmV3IERlcCgpO1xcblxcbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XFxuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xcbiAgICByZXR1cm5cXG4gIH1cXG5cXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcXG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XFxuXFxuICB2YXIgY2hpbGRPYiA9IG9ic2VydmUodmFsKTtcXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XFxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcXG4gICAgICAgIGRlcC5kZXBlbmQoKTtcXG4gICAgICAgIGlmIChjaGlsZE9iKSB7XFxuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHZhbHVlXFxuICAgIH0sXFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXFxuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcXG4gICAgICAgIHJldHVyblxcbiAgICAgIH1cXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XFxuICAgICAgfVxcbiAgICAgIGlmIChzZXR0ZXIpIHtcXG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFsID0gbmV3VmFsO1xcbiAgICAgIH1cXG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xcbiAgICAgIGRlcC5ub3RpZnkoKTtcXG4gICAgfVxcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcXG4gKiBhbHJlYWR5IGV4aXN0LlxcbiAqL1xcbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcXG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XFxuICAgIHJldHVybiB2YWxcXG4gIH1cXG4gIGlmIChoYXNPd24odGFyZ2V0LCBrZXkpKSB7XFxuICAgIHRhcmdldFtrZXldID0gdmFsO1xcbiAgICByZXR1cm4gdmFsXFxuICB9XFxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXFxuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcXG4gICAgKTtcXG4gICAgcmV0dXJuIHZhbFxcbiAgfVxcbiAgaWYgKCFvYikge1xcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcXG4gICAgcmV0dXJuIHZhbFxcbiAgfVxcbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcXG4gIG9iLmRlcC5ub3RpZnkoKTtcXG4gIHJldHVybiB2YWxcXG59XFxuXFxuLyoqXFxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cXG4gKi9cXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XFxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XFxuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcXG4gICAgcmV0dXJuXFxuICB9XFxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcXG4gICAgKTtcXG4gICAgcmV0dXJuXFxuICB9XFxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuICBkZWxldGUgdGFyZ2V0W2tleV07XFxuICBpZiAoIW9iKSB7XFxuICAgIHJldHVyblxcbiAgfVxcbiAgb2IuZGVwLm5vdGlmeSgpO1xcbn1cXG5cXG4vKipcXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxcbiAqL1xcbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBlID0gdmFsdWVbaV07XFxuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xcbiAgICB9XFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcbi8qKlxcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxcbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxcbiAqL1xcbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xcblxcbi8qKlxcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcXG4gKi9cXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XFxuICAgIGlmICghdm0pIHtcXG4gICAgICB3YXJuKFxcbiAgICAgICAgXFxcIm9wdGlvbiBcXFxcXFxcIlxcXCIgKyBrZXkgKyBcXFwiXFxcXFxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXFxcIiArXFxuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXFxuICAgICAgKTtcXG4gICAgfVxcbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXFxuICB9O1xcbn1cXG5cXG4vKipcXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cXG4gKi9cXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XFxuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cXG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xcbiAgICBrZXkgPSBrZXlzW2ldO1xcbiAgICB0b1ZhbCA9IHRvW2tleV07XFxuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XFxuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XFxuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcXG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gdG9cXG59XFxuXFxuLyoqXFxuICogRGF0YVxcbiAqL1xcbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxcbiAgcGFyZW50VmFsLFxcbiAgY2hpbGRWYWwsXFxuICB2bVxcbikge1xcbiAgaWYgKCF2bSkge1xcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xcbiAgICBpZiAoIWNoaWxkVmFsKSB7XFxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxcbiAgICB9XFxuICAgIGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXFxuICAgICAgICAnVGhlIFxcXCJkYXRhXFxcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXFxuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxcbiAgICAgICAgdm1cXG4gICAgICApO1xcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcXG4gICAgfVxcbiAgICBpZiAoIXBhcmVudFZhbCkge1xcbiAgICAgIHJldHVybiBjaGlsZFZhbFxcbiAgICB9XFxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXFxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xcbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXFxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXFxuICAgICAgICBjaGlsZFZhbC5jYWxsKHRoaXMpLFxcbiAgICAgICAgcGFyZW50VmFsLmNhbGwodGhpcylcXG4gICAgICApXFxuICAgIH1cXG4gIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XFxuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXFxuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0pXFxuICAgICAgICA6IGNoaWxkVmFsO1xcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0pXFxuICAgICAgICA6IHVuZGVmaW5lZDtcXG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XFxuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxcbiAqL1xcbmZ1bmN0aW9uIG1lcmdlSG9vayAoXFxuICBwYXJlbnRWYWwsXFxuICBjaGlsZFZhbFxcbikge1xcbiAgcmV0dXJuIGNoaWxkVmFsXFxuICAgID8gcGFyZW50VmFsXFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcXG4gICAgICAgID8gY2hpbGRWYWxcXG4gICAgICAgIDogW2NoaWxkVmFsXVxcbiAgICA6IHBhcmVudFZhbFxcbn1cXG5cXG5jb25maWcuX2xpZmVjeWNsZUhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcXG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcXG59KTtcXG5cXG4vKipcXG4gKiBBc3NldHNcXG4gKlxcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXFxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXFxuICovXFxuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcXG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcXG4gIHJldHVybiBjaGlsZFZhbFxcbiAgICA/IGV4dGVuZChyZXMsIGNoaWxkVmFsKVxcbiAgICA6IHJlc1xcbn1cXG5cXG5jb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XFxufSk7XFxuXFxuLyoqXFxuICogV2F0Y2hlcnMuXFxuICpcXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXFxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXFxuICovXFxuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxcbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cXG4gIHZhciByZXQgPSB7fTtcXG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XFxuICBmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcXG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcXG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcXG4gICAgfVxcbiAgICByZXRba2V5XSA9IHBhcmVudFxcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcXG4gICAgICA6IFtjaGlsZF07XFxuICB9XFxuICByZXR1cm4gcmV0XFxufTtcXG5cXG4vKipcXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxcbiAqL1xcbnN0cmF0cy5wcm9wcyA9XFxuc3RyYXRzLm1ldGhvZHMgPVxcbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XFxuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XFxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxcbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xcbiAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xcbiAgcmV0dXJuIHJldFxcbn07XFxuXFxuLyoqXFxuICogRGVmYXVsdCBzdHJhdGVneS5cXG4gKi9cXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcXG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXFxuICAgID8gcGFyZW50VmFsXFxuICAgIDogY2hpbGRWYWxcXG59O1xcblxcbi8qKlxcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xcbiAqL1xcbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xcbiAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcXG4gICAgaWYgKGlzQnVpbHRJblRhZyhsb3dlcikgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobG93ZXIpKSB7XFxuICAgICAgd2FybihcXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xcbiAgICAgICAgJ2lkOiAnICsga2V5XFxuICAgICAgKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxcbiAqL1xcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zKSB7XFxuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxcbiAgdmFyIHJlcyA9IHt9O1xcbiAgdmFyIGksIHZhbCwgbmFtZTtcXG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xcbiAgICB3aGlsZSAoaS0tKSB7XFxuICAgICAgdmFsID0gcHJvcHNbaV07XFxuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcXG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcXG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxcbiAgICAgICAgPyB2YWxcXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcXG4gICAgfVxcbiAgfVxcbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcXG59XFxuXFxuLyoqXFxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cXG4gKi9cXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XFxuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcXG4gIGlmIChkaXJzKSB7XFxuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XFxuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcXG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxcbiAqL1xcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXFxuICBwYXJlbnQsXFxuICBjaGlsZCxcXG4gIHZtXFxuKSB7XFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xcbiAgfVxcbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQpO1xcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XFxuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XFxuICAgIHBhcmVudCA9IHR5cGVvZiBleHRlbmRzRnJvbSA9PT0gJ2Z1bmN0aW9uJ1xcbiAgICAgID8gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20ub3B0aW9ucywgdm0pXFxuICAgICAgOiBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbSwgdm0pO1xcbiAgfVxcbiAgaWYgKGNoaWxkLm1peGlucykge1xcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICB2YXIgbWl4aW4gPSBjaGlsZC5taXhpbnNbaV07XFxuICAgICAgaWYgKG1peGluLnByb3RvdHlwZSBpbnN0YW5jZW9mIFZ1ZSQyKSB7XFxuICAgICAgICBtaXhpbiA9IG1peGluLm9wdGlvbnM7XFxuICAgICAgfVxcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIG1peGluLCB2bSk7XFxuICAgIH1cXG4gIH1cXG4gIHZhciBvcHRpb25zID0ge307XFxuICB2YXIga2V5O1xcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XFxuICAgIG1lcmdlRmllbGQoa2V5KTtcXG4gIH1cXG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XFxuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcXG4gICAgfVxcbiAgfVxcbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XFxuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcXG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xcbiAgfVxcbiAgcmV0dXJuIG9wdGlvbnNcXG59XFxuXFxuLyoqXFxuICogUmVzb2x2ZSBhbiBhc3NldC5cXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXFxuICovXFxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcXG4gIG9wdGlvbnMsXFxuICB0eXBlLFxcbiAgaWQsXFxuICB3YXJuTWlzc2luZ1xcbikge1xcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm5cXG4gIH1cXG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcXG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxcbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XFxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XFxuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxcbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXFxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xcbiAgICB3YXJuKFxcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXFxuICAgICAgb3B0aW9uc1xcbiAgICApO1xcbiAgfVxcbiAgcmV0dXJuIHJlc1xcbn1cXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxcbiAga2V5LFxcbiAgcHJvcE9wdGlvbnMsXFxuICBwcm9wc0RhdGEsXFxuICB2bVxcbikge1xcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XFxuICAvLyBoYW5kbGUgYm9vbGVhbiBwcm9wc1xcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XFxuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XFxuICAgICAgdmFsdWUgPSBmYWxzZTtcXG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcXG4gICAgICB2YWx1ZSA9IHRydWU7XFxuICAgIH1cXG4gIH1cXG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcXG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xcbiAgICBvYnNlcnZlKHZhbHVlKTtcXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XFxuICB9XFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xcbiAgfVxcbiAgcmV0dXJuIHZhbHVlXFxufVxcblxcbi8qKlxcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXFxuICovXFxuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xcbiAgICByZXR1cm4gdW5kZWZpbmVkXFxuICB9XFxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xcbiAgICB3YXJuKFxcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXFxcIicgKyBrZXkgKyAnXFxcIjogJyArXFxuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcXG4gICAgICB2bVxcbiAgICApO1xcbiAgfVxcbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXFxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWQpIHtcXG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXFxuICB9XFxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXFxuICAgID8gZGVmLmNhbGwodm0pXFxuICAgIDogZGVmXFxufVxcblxcbi8qKlxcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cXG4gKi9cXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcXG4gIHByb3AsXFxuICBuYW1lLFxcbiAgdmFsdWUsXFxuICB2bSxcXG4gIGFic2VudFxcbikge1xcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XFxuICAgIHdhcm4oXFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXFxcIicgKyBuYW1lICsgJ1xcXCInLFxcbiAgICAgIHZtXFxuICAgICk7XFxuICAgIHJldHVyblxcbiAgfVxcbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcXG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XFxuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xcbiAgaWYgKHR5cGUpIHtcXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XFxuICAgICAgdHlwZSA9IFt0eXBlXTtcXG4gICAgfVxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XFxuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcXG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcXG4gICAgfVxcbiAgfVxcbiAgaWYgKCF2YWxpZCkge1xcbiAgICB3YXJuKFxcbiAgICAgICdJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCInICsgbmFtZSArICdcXFwiLicgK1xcbiAgICAgICcgRXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykgK1xcbiAgICAgICcsIGdvdCAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgKyAnLicsXFxuICAgICAgdm1cXG4gICAgKTtcXG4gICAgcmV0dXJuXFxuICB9XFxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XFxuICBpZiAodmFsaWRhdG9yKSB7XFxuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xcbiAgICAgIHdhcm4oXFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiJyArIG5hbWUgKyAnXFxcIi4nLFxcbiAgICAgICAgdm1cXG4gICAgICApO1xcbiAgICB9XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIEFzc2VydCB0aGUgdHlwZSBvZiBhIHZhbHVlXFxuICovXFxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcXG4gIHZhciB2YWxpZDtcXG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ1N0cmluZycpIHtcXG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnc3RyaW5nJyk7XFxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ051bWJlcicpIHtcXG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnbnVtYmVyJyk7XFxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0Jvb2xlYW4nKSB7XFxuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ2Jvb2xlYW4nKTtcXG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnRnVuY3Rpb24nKSB7XFxuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ2Z1bmN0aW9uJyk7XFxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcXG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcXG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XFxuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XFxuICB9IGVsc2Uge1xcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcXG4gIH1cXG4gIHJldHVybiB7XFxuICAgIHZhbGlkOiB2YWxpZCxcXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cXG4gKi9cXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxcXFxzKmZ1bmN0aW9uIChcXFxcdyspLyk7XFxuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV1cXG59XFxuXFxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZuKSkge1xcbiAgICByZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSlcXG4gIH1cXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICBpZiAoZ2V0VHlwZShmbltpXSkgPT09IGdldFR5cGUodHlwZSkpIHtcXG4gICAgICByZXR1cm4gdHJ1ZVxcbiAgICB9XFxuICB9XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcbiAgcmV0dXJuIGZhbHNlXFxufVxcblxcbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XFxuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xcbiAgICBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbyk7XFxuICB9IGVsc2Uge1xcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgICAgIHdhcm4oKFxcXCJFcnJvciBpbiBcXFwiICsgaW5mbyArIFxcXCI6XFxcIiksIHZtKTtcXG4gICAgfVxcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xcbiAgICBpZiAoaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aHJvdyBlcnJcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cXG5cXG52YXIgaW5pdFByb3h5O1xcblxcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxcbiAgKTtcXG5cXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xcbiAgICB3YXJuKFxcbiAgICAgIFxcXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcXFxcXCJcXFwiICsga2V5ICsgXFxcIlxcXFxcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXFxcIiArXFxuICAgICAgXFxcInJlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRvIGRlY2xhcmUgcmVhY3RpdmUgZGF0YSBcXFwiICtcXG4gICAgICBcXFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXFxcIixcXG4gICAgICB0YXJnZXRcXG4gICAgKTtcXG4gIH07XFxuXFxuICB2YXIgaGFzUHJveHkgPVxcbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXFxuICAgIFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XFxuXFxuICBpZiAoaGFzUHJveHkpIHtcXG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YScpO1xcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcXG4gICAgICAgICAgd2FybigoXFxcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlxcXCIgKyBrZXkpKTtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxuICB2YXIgaGFzSGFuZGxlciA9IHtcXG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XFxuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XFxuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcXG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXFxuICAgIH1cXG4gIH07XFxuXFxuICB2YXIgZ2V0SGFuZGxlciA9IHtcXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XFxuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcXG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXFxuICAgIH1cXG4gIH07XFxuXFxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XFxuICAgIGlmIChoYXNQcm94eSkge1xcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XFxuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxcbiAgICAgICAgPyBnZXRIYW5kbGVyXFxuICAgICAgICA6IGhhc0hhbmRsZXI7XFxuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XFxuICAgIH1cXG4gIH07XFxufVxcblxcbnZhciBtYXJrO1xcbnZhciBtZWFzdXJlO1xcblxcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gIGlmIChcXG4gICAgcGVyZiAmJlxcbiAgICBwZXJmLm1hcmsgJiZcXG4gICAgcGVyZi5tZWFzdXJlICYmXFxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcXG4gICkge1xcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XFxuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcXG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcXG4gICAgfTtcXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxcbiAgdGFnLFxcbiAgZGF0YSxcXG4gIGNoaWxkcmVuLFxcbiAgdGV4dCxcXG4gIGVsbSxcXG4gIGNvbnRleHQsXFxuICBjb21wb25lbnRPcHRpb25zXFxuKSB7XFxuICB0aGlzLnRhZyA9IHRhZztcXG4gIHRoaXMuZGF0YSA9IGRhdGE7XFxuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XFxuICB0aGlzLnRleHQgPSB0ZXh0O1xcbiAgdGhpcy5lbG0gPSBlbG07XFxuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcXG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XFxuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XFxuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcXG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xcbiAgdGhpcy5yYXcgPSBmYWxzZTtcXG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcXG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcXG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XFxuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XFxuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xcbn07XFxuXFxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHt9IH07XFxuXFxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0Llxcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXFxucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXFxufTtcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcXG5cXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XFxuICBub2RlLnRleHQgPSAnJztcXG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcXG4gIHJldHVybiBub2RlXFxufTtcXG5cXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcXG59XFxuXFxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXFxuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XFxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcXG4gICAgdm5vZGUudGFnLFxcbiAgICB2bm9kZS5kYXRhLFxcbiAgICB2bm9kZS5jaGlsZHJlbixcXG4gICAgdm5vZGUudGV4dCxcXG4gICAgdm5vZGUuZWxtLFxcbiAgICB2bm9kZS5jb250ZXh0LFxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zXFxuICApO1xcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XFxuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcXG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XFxuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xcbiAgcmV0dXJuIGNsb25lZFxcbn1cXG5cXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzKSB7XFxuICB2YXIgbGVuID0gdm5vZGVzLmxlbmd0aDtcXG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgcmVzW2ldID0gY2xvbmVWTm9kZSh2bm9kZXNbaV0pO1xcbiAgfVxcbiAgcmV0dXJuIHJlc1xcbn1cXG5cXG4vKiAgKi9cXG5cXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcXG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcXG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcXG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XFxuICByZXR1cm4ge1xcbiAgICBuYW1lOiBuYW1lLFxcbiAgICBvbmNlOiBvbmNlJCQxLFxcbiAgICBjYXB0dXJlOiBjYXB0dXJlXFxuICB9XFxufSk7XFxuXFxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcXG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XFxuXFxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBmbnNbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxcbiAgICB9XFxuICB9XFxuICBpbnZva2VyLmZucyA9IGZucztcXG4gIHJldHVybiBpbnZva2VyXFxufVxcblxcbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXFxuICBvbixcXG4gIG9sZE9uLFxcbiAgYWRkLFxcbiAgcmVtb3ZlJCQxLFxcbiAgdm1cXG4pIHtcXG4gIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XFxuICBmb3IgKG5hbWUgaW4gb24pIHtcXG4gICAgY3VyID0gb25bbmFtZV07XFxuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xcbiAgICBpZiAoIWN1cikge1xcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcXG4gICAgICAgIFxcXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXFxcXFwiXFxcIiArIChldmVudC5uYW1lKSArIFxcXCJcXFxcXFxcIjogZ290IFxcXCIgKyBTdHJpbmcoY3VyKSxcXG4gICAgICAgIHZtXFxuICAgICAgKTtcXG4gICAgfSBlbHNlIGlmICghb2xkKSB7XFxuICAgICAgaWYgKCFjdXIuZm5zKSB7XFxuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xcbiAgICAgIH1cXG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlKTtcXG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xcbiAgICAgIG9sZC5mbnMgPSBjdXI7XFxuICAgICAgb25bbmFtZV0gPSBvbGQ7XFxuICAgIH1cXG4gIH1cXG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xcbiAgICBpZiAoIW9uW25hbWVdKSB7XFxuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcXG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xcbiAgICB9XFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcXG4gIHZhciBpbnZva2VyO1xcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XFxuXFxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XFxuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcXG4gIH1cXG5cXG4gIGlmICghb2xkSG9vaykge1xcbiAgICAvLyBubyBleGlzdGluZyBob29rXFxuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XFxuICB9IGVsc2Uge1xcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gICAgaWYgKG9sZEhvb2suZm5zICYmIG9sZEhvb2subWVyZ2VkKSB7XFxuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXFxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XFxuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcXG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XFxufVxcblxcbi8qICAqL1xcblxcbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXFxuLy9cXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XFxuXFxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXFxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XFxuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGNoaWxkcmVuXFxufVxcblxcbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXFxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxcbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxcbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXFxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxcbiAgICAgIDogdW5kZWZpbmVkXFxufVxcblxcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xcbiAgdmFyIHJlcyA9IFtdO1xcbiAgdmFyIGksIGMsIGxhc3Q7XFxuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcXG4gICAgYyA9IGNoaWxkcmVuW2ldO1xcbiAgICBpZiAoYyA9PSBudWxsIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxcbiAgICBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcXG4gICAgLy8gIG5lc3RlZFxcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xcbiAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFxcXCJfXFxcIiArIGkpKSk7XFxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcXG4gICAgICBpZiAobGFzdCAmJiBsYXN0LnRleHQpIHtcXG4gICAgICAgIGxhc3QudGV4dCArPSBTdHJpbmcoYyk7XFxuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmIChjLnRleHQgJiYgbGFzdCAmJiBsYXN0LnRleHQpIHtcXG4gICAgICAgIHJlc1tyZXMubGVuZ3RoIC0gMV0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcXG4gICAgICAgIGlmIChjLnRhZyAmJiBjLmtleSA9PSBudWxsICYmIG5lc3RlZEluZGV4ICE9IG51bGwpIHtcXG4gICAgICAgICAgYy5rZXkgPSBcXFwiX192bGlzdFxcXCIgKyBuZXN0ZWRJbmRleCArIFxcXCJfXFxcIiArIGkgKyBcXFwiX19cXFwiO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmVzLnB1c2goYyk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzXFxufVxcblxcbi8qICAqL1xcblxcbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XFxuICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjICYmIGMuY29tcG9uZW50T3B0aW9uczsgfSlbMF1cXG59XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcXG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXFxuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcXG4gIGlmIChsaXN0ZW5lcnMpIHtcXG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xcbiAgfVxcbn1cXG5cXG52YXIgdGFyZ2V0O1xcblxcbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlJCQxKSB7XFxuICBpZiAob25jZSQkMSkge1xcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcXG4gIH0gZWxzZSB7XFxuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcXG59XFxuXFxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcXG4gIHZtLFxcbiAgbGlzdGVuZXJzLFxcbiAgb2xkTGlzdGVuZXJzXFxuKSB7XFxuICB0YXJnZXQgPSB2bTtcXG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xcbn1cXG5cXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XFxuICB2YXIgaG9va1JFID0gL15ob29rOi87XFxuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIHZhciB2bSA9IHRoaXM7XFxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgICB0aGlzJDEuJG9uKGV2ZW50W2ldLCBmbik7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXFxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiB2bVxcbiAgfTtcXG5cXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XFxuICAgIHZhciB2bSA9IHRoaXM7XFxuICAgIGZ1bmN0aW9uIG9uICgpIHtcXG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XFxuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XFxuICAgIH1cXG4gICAgb24uZm4gPSBmbjtcXG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XFxuICAgIHJldHVybiB2bVxcbiAgfTtcXG5cXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIHZhciB2bSA9IHRoaXM7XFxuICAgIC8vIGFsbFxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG4gICAgICByZXR1cm4gdm1cXG4gICAgfVxcbiAgICAvLyBhcnJheSBvZiBldmVudHNcXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XFxuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcXG4gICAgICAgIHRoaXMkMS4kb2ZmKGV2ZW50W2kkMV0sIGZuKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHZtXFxuICAgIH1cXG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcXG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xcbiAgICBpZiAoIWNicykge1xcbiAgICAgIHJldHVybiB2bVxcbiAgICB9XFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XFxuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xcbiAgICAgIHJldHVybiB2bVxcbiAgICB9XFxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcXG4gICAgdmFyIGNiO1xcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XFxuICAgIHdoaWxlIChpLS0pIHtcXG4gICAgICBjYiA9IGNic1tpXTtcXG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcXG4gICAgICAgIGJyZWFrXFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiB2bVxcbiAgfTtcXG5cXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgdmFyIHZtID0gdGhpcztcXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcXG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcXG4gICAgICAgIHRpcChcXG4gICAgICAgICAgXFxcIkV2ZW50IFxcXFxcXFwiXFxcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXFxcIlxcXFxcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFxcXCIgK1xcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXFxcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcXFxcXCJcXFwiICsgZXZlbnQgKyBcXFwiXFxcXFxcXCIuIFxcXCIgK1xcbiAgICAgICAgICBcXFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXFxcIiArXFxuICAgICAgICAgIFxcXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXFxcIiArXFxuICAgICAgICAgIFxcXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFxcXFxcIlxcXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcXFwiXFxcXFxcXCIgaW5zdGVhZCBvZiBcXFxcXFxcIlxcXCIgKyBldmVudCArIFxcXCJcXFxcXFxcIi5cXFwiXFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XFxuICAgIGlmIChjYnMpIHtcXG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcXG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiB2bVxcbiAgfTtcXG59XFxuXFxuLyogICovXFxuXFxuLyoqXFxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cXG4gKi9cXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxcbiAgY2hpbGRyZW4sXFxuICBjb250ZXh0XFxuKSB7XFxuICB2YXIgc2xvdHMgPSB7fTtcXG4gIGlmICghY2hpbGRyZW4pIHtcXG4gICAgcmV0dXJuIHNsb3RzXFxuICB9XFxuICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcXG4gIHZhciBuYW1lLCBjaGlsZDtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIGNoaWxkID0gY2hpbGRyZW5baV07XFxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxcbiAgICAvLyBzYW1lIGNvbnRleHQuXFxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mdW5jdGlvbmFsQ29udGV4dCA9PT0gY29udGV4dCkgJiZcXG4gICAgICAgIGNoaWxkLmRhdGEgJiYgKG5hbWUgPSBjaGlsZC5kYXRhLnNsb3QpKSB7XFxuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcXG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XFxuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBkZWZhdWx0U2xvdC5wdXNoKGNoaWxkKTtcXG4gICAgfVxcbiAgfVxcbiAgLy8gaWdub3JlIHdoaXRlc3BhY2VcXG4gIGlmICghZGVmYXVsdFNsb3QuZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xcbiAgICBzbG90cy5kZWZhdWx0ID0gZGVmYXVsdFNsb3Q7XFxuICB9XFxuICByZXR1cm4gc2xvdHNcXG59XFxuXFxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XFxuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgfHwgbm9kZS50ZXh0ID09PSAnICdcXG59XFxuXFxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcXG4gIGZuc1xcbikge1xcbiAgdmFyIHJlcyA9IHt9O1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcXG4gICAgcmVzW2Zuc1tpXVswXV0gPSBmbnNbaV1bMV07XFxuICB9XFxuICByZXR1cm4gcmVzXFxufVxcblxcbi8qICAqL1xcblxcbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XFxuXFxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcXG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XFxuXFxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XFxuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XFxuICAgIH1cXG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcXG4gIH1cXG5cXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XFxuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xcblxcbiAgdm0uJGNoaWxkcmVuID0gW107XFxuICB2bS4kcmVmcyA9IHt9O1xcblxcbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcXG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XFxuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xcbn1cXG5cXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XFxuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xcbiAgICB2YXIgdm0gPSB0aGlzO1xcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XFxuICAgIH1cXG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcXG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcXG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcXG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXFxuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxcbiAgICBpZiAoIXByZXZWbm9kZSkge1xcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXFxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cXG4gICAgICApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIHVwZGF0ZXNcXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XFxuICAgIH1cXG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XFxuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxcbiAgICBpZiAocHJldkVsKSB7XFxuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xcbiAgICB9XFxuICAgIGlmICh2bS4kZWwpIHtcXG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xcbiAgICB9XFxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcXG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcXG4gICAgfVxcbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXFxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXFxuICB9O1xcblxcbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB2bSA9IHRoaXM7XFxuICAgIGlmICh2bS5fd2F0Y2hlcikge1xcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHZtID0gdGhpcztcXG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XFxuICAgICAgcmV0dXJuXFxuICAgIH1cXG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XFxuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcXG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcXG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XFxuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcXG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xcbiAgICB9XFxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXFxuICAgIGlmICh2bS5fd2F0Y2hlcikge1xcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XFxuICAgIH1cXG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xcbiAgICB3aGlsZSAoaS0tKSB7XFxuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XFxuICAgIH1cXG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXFxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcXG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xcbiAgICB9XFxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxcbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XFxuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcXG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cXG4gICAgdm0uJG9mZigpO1xcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcXG4gICAgaWYgKHZtLiRlbCkge1xcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcXG4gICAgfVxcbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIERPTSBub2RlcyAocHJldmVudHMgbGVhaylcXG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSA9IHZtLiRvcHRpb25zLl9yZWZFbG0gPSBudWxsO1xcbiAgfTtcXG59XFxuXFxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxcbiAgdm0sXFxuICBlbCxcXG4gIGh5ZHJhdGluZ1xcbikge1xcbiAgdm0uJGVsID0gZWw7XFxuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xcbiAgICAgICAgd2FybihcXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcXG4gICAgICAgICAgdm1cXG4gICAgICAgICk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHdhcm4oXFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcXG4gICAgICAgICAgdm1cXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XFxuXFxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcXG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xcbiAgICAgIHZhciBzdGFydFRhZyA9IFxcXCJ2dWUtcGVyZi1zdGFydDpcXFwiICsgaWQ7XFxuICAgICAgdmFyIGVuZFRhZyA9IFxcXCJ2dWUtcGVyZi1lbmQ6XFxcIiArIGlkO1xcblxcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcXG4gICAgICBtYXJrKGVuZFRhZyk7XFxuICAgICAgbWVhc3VyZSgobmFtZSArIFxcXCIgcmVuZGVyXFxcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xcblxcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XFxuICAgICAgbWFyayhlbmRUYWcpO1xcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcXFwiIHBhdGNoXFxcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xcbiAgICB9O1xcbiAgfSBlbHNlIHtcXG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xcbiAgICB9O1xcbiAgfVxcblxcbiAgdm0uX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wKTtcXG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xcblxcbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXFxuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcXG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XFxuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xcbiAgfVxcbiAgcmV0dXJuIHZtXFxufVxcblxcbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcXG4gIHZtLFxcbiAgcHJvcHNEYXRhLFxcbiAgbGlzdGVuZXJzLFxcbiAgcGFyZW50Vm5vZGUsXFxuICByZW5kZXJDaGlsZHJlblxcbikge1xcbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXFxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxcbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXFxuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcXG4gICk7XFxuXFxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcXG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXFxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcXG4gIH1cXG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xcblxcbiAgLy8gdXBkYXRlIHByb3BzXFxuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSB0cnVlO1xcbiAgICB9XFxuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcXG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XFxuICAgIH1cXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcXG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gZmFsc2U7XFxuICAgIH1cXG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XFxuICB9XFxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXFxuICBpZiAobGlzdGVuZXJzKSB7XFxuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcXG4gIH1cXG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXFxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcXG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcXG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XFxuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcXG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XFxuICB9XFxuICByZXR1cm4gZmFsc2VcXG59XFxuXFxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xcbiAgaWYgKGRpcmVjdCkge1xcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcXG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XFxuICAgICAgcmV0dXJuXFxuICAgIH1cXG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XFxuICAgIHJldHVyblxcbiAgfVxcbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT0gbnVsbCkge1xcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcXG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XFxuICAgIH1cXG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XFxuICBpZiAoZGlyZWN0KSB7XFxuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XFxuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xcbiAgICAgIHJldHVyblxcbiAgICB9XFxuICB9XFxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xcbiAgICB9XFxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XFxuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcXG4gIGlmIChoYW5kbGVycykge1xcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcXFwiIGhvb2tcXFwiKSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcblxcbnZhciBxdWV1ZSA9IFtdO1xcbnZhciBoYXMgPSB7fTtcXG52YXIgY2lyY3VsYXIgPSB7fTtcXG52YXIgd2FpdGluZyA9IGZhbHNlO1xcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xcbnZhciBpbmRleCA9IDA7XFxuXFxuLyoqXFxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxcbiAqL1xcbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xcbiAgcXVldWUubGVuZ3RoID0gMDtcXG4gIGhhcyA9IHt9O1xcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcXG4gICAgY2lyY3VsYXIgPSB7fTtcXG4gIH1cXG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xcbn1cXG5cXG4vKipcXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cXG4gKi9cXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcXG4gIGZsdXNoaW5nID0gdHJ1ZTtcXG4gIHZhciB3YXRjaGVyLCBpZCwgdm07XFxuXFxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcXG5cXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXFxuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcXG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcXG4gICAgaWQgPSB3YXRjaGVyLmlkO1xcbiAgICBoYXNbaWRdID0gbnVsbDtcXG4gICAgd2F0Y2hlci5ydW4oKTtcXG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcXG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcXG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gY29uZmlnLl9tYXhVcGRhdGVDb3VudCkge1xcbiAgICAgICAgd2FybihcXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxcbiAgICAgICAgICAgICAgPyAoXFxcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXFxcXFwiXFxcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXFxcIlxcXFxcXFwiXFxcIilcXG4gICAgICAgICAgICAgIDogXFxcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cXFwiXFxuICAgICAgICAgICksXFxuICAgICAgICAgIHdhdGNoZXIudm1cXG4gICAgICAgICk7XFxuICAgICAgICBicmVha1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gcmVzZXQgc2NoZWR1bGVyIGJlZm9yZSB1cGRhdGVkIGhvb2sgY2FsbGVkXFxuICB2YXIgb2xkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xcbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xcblxcbiAgLy8gY2FsbCB1cGRhdGVkIGhvb2tzXFxuICBpbmRleCA9IG9sZFF1ZXVlLmxlbmd0aDtcXG4gIHdoaWxlIChpbmRleC0tKSB7XFxuICAgIHdhdGNoZXIgPSBvbGRRdWV1ZVtpbmRleF07XFxuICAgIHZtID0gd2F0Y2hlci52bTtcXG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcXG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gZGV2dG9vbCBob29rXFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcXG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cXG4gKi9cXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcXG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XFxuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XFxuICAgIGhhc1tpZF0gPSB0cnVlO1xcbiAgICBpZiAoIWZsdXNoaW5nKSB7XFxuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XFxuICAgICAgd2hpbGUgKGkgPj0gMCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcXG4gICAgICAgIGktLTtcXG4gICAgICB9XFxuICAgICAgcXVldWUuc3BsaWNlKE1hdGgubWF4KGksIGluZGV4KSArIDEsIDAsIHdhdGNoZXIpO1xcbiAgICB9XFxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxcbiAgICBpZiAoIXdhaXRpbmcpIHtcXG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcXG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG52YXIgdWlkJDIgPSAwO1xcblxcbi8qKlxcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXFxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXFxuICovXFxudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcXG4gIHZtLFxcbiAgZXhwT3JGbixcXG4gIGNiLFxcbiAgb3B0aW9uc1xcbikge1xcbiAgdGhpcy52bSA9IHZtO1xcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XFxuICAvLyBvcHRpb25zXFxuICBpZiAob3B0aW9ucykge1xcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcXG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XFxuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xcbiAgfVxcbiAgdGhpcy5jYiA9IGNiO1xcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcXG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXFxuICB0aGlzLmRlcHMgPSBbXTtcXG4gIHRoaXMubmV3RGVwcyA9IFtdO1xcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxcbiAgICA6ICcnO1xcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXFxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xcbiAgfSBlbHNlIHtcXG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XFxuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcXG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcXG4gICAgICAgIFxcXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcXFxcXCJcXFwiICsgZXhwT3JGbiArIFxcXCJcXFxcXFxcIiBcXFwiICtcXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXFxuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxcbiAgICAgICAgdm1cXG4gICAgICApO1xcbiAgICB9XFxuICB9XFxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XFxuICAgID8gdW5kZWZpbmVkXFxuICAgIDogdGhpcy5nZXQoKTtcXG59O1xcblxcbi8qKlxcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cXG4gKi9cXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xcbiAgcHVzaFRhcmdldCh0aGlzKTtcXG4gIHZhciB2YWx1ZTtcXG4gIHZhciB2bSA9IHRoaXMudm07XFxuICBpZiAodGhpcy51c2VyKSB7XFxuICAgIHRyeSB7XFxuICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFxcXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcXFxcXCJcXFwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcXFwiXFxcXFxcXCJcXFwiKSk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xcbiAgfVxcbiAgLy8gXFxcInRvdWNoXFxcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xcbiAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXFxuICBpZiAodGhpcy5kZWVwKSB7XFxuICAgIHRyYXZlcnNlKHZhbHVlKTtcXG4gIH1cXG4gIHBvcFRhcmdldCgpO1xcbiAgdGhpcy5jbGVhbnVwRGVwcygpO1xcbiAgcmV0dXJuIHZhbHVlXFxufTtcXG5cXG4vKipcXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxcbiAqL1xcbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XFxuICB2YXIgaWQgPSBkZXAuaWQ7XFxuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcXG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcXG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcXG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XFxuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcXG4gICAgfVxcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cXG4gKi9cXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XFxuICB3aGlsZSAoaS0tKSB7XFxuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcXG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XFxuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xcbiAgICB9XFxuICB9XFxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XFxuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XFxuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xcbiAgdG1wID0gdGhpcy5kZXBzO1xcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XFxufTtcXG5cXG4vKipcXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxcbiAqL1xcbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xcbiAgaWYgKHRoaXMubGF6eSkge1xcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcXG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XFxuICAgIHRoaXMucnVuKCk7XFxuICB9IGVsc2Uge1xcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxcbiAqL1xcbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XFxuICBpZiAodGhpcy5hY3RpdmUpIHtcXG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcXG4gICAgaWYgKFxcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXFxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcXG4gICAgICB0aGlzLmRlZXBcXG4gICAgKSB7XFxuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XFxuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXFxcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXFxcXFwiXFxcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXFxcIlxcXFxcXFwiXFxcIikpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXFxuICovXFxuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XFxuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcXG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcXG59O1xcblxcbi8qKlxcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxcbiAqL1xcbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xcbiAgd2hpbGUgKGktLSkge1xcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxcbiAqL1xcbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcXG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XFxuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcXG4gICAgfVxcbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XFxuICAgIHdoaWxlIChpLS0pIHtcXG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcXG4gICAgfVxcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFxcXCJkZWVwXFxcIiBkZXBlbmRlbmN5LlxcbiAqL1xcbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XFxuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcXG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcXG59XFxuXFxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcXG4gIHZhciBpLCBrZXlzO1xcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcXG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xcbiAgICByZXR1cm5cXG4gIH1cXG4gIGlmICh2YWwuX19vYl9fKSB7XFxuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XFxuICAgICAgcmV0dXJuXFxuICAgIH1cXG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xcbiAgfVxcbiAgaWYgKGlzQSkge1xcbiAgICBpID0gdmFsLmxlbmd0aDtcXG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxcbiAgfSBlbHNlIHtcXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XFxuICAgIGkgPSBrZXlzLmxlbmd0aDtcXG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxcbiAgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xcbiAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gIGdldDogbm9vcCxcXG4gIHNldDogbm9vcFxcbn07XFxuXFxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcXG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XFxuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxcbiAgfTtcXG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XFxuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xcbiAgfTtcXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcXG59XFxuXFxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xcbiAgdm0uX3dhdGNoZXJzID0gW107XFxuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxcbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxcbiAgaWYgKG9wdHMuZGF0YSkge1xcbiAgICBpbml0RGF0YSh2bSk7XFxuICB9IGVsc2Uge1xcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XFxuICB9XFxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XFxuICBpZiAob3B0cy53YXRjaCkgeyBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpOyB9XFxufVxcblxcbnZhciBpc1Jlc2VydmVkUHJvcCA9IHsga2V5OiAxLCByZWY6IDEsIHNsb3Q6IDEgfTtcXG5cXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcXG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XFxuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcXG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XFxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XFxuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XFxuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcXG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGlzUm9vdDtcXG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XFxuICAgIGtleXMucHVzaChrZXkpO1xcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcFtrZXldKSB7XFxuICAgICAgICB3YXJuKFxcbiAgICAgICAgICAoXFxcIlxcXFxcXFwiXFxcIiArIGtleSArIFxcXCJcXFxcXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXFxcIiksXFxuICAgICAgICAgIHZtXFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIW9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMpIHtcXG4gICAgICAgICAgd2FybihcXG4gICAgICAgICAgICBcXFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFxcXCIgK1xcbiAgICAgICAgICAgIFxcXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcXFwiICtcXG4gICAgICAgICAgICBcXFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFxcXCIgK1xcbiAgICAgICAgICAgIFxcXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFxcXFxcIlxcXCIgKyBrZXkgKyBcXFwiXFxcXFxcXCJcXFwiLFxcbiAgICAgICAgICAgIHZtXFxuICAgICAgICAgICk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xcbiAgICB9XFxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcXG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxcbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XFxuICAgICAgcHJveHkodm0sIFxcXCJfcHJvcHNcXFwiLCBrZXkpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XFxuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xcbn1cXG5cXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcXG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcXG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXFxuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcXG4gICAgOiBkYXRhIHx8IHt9O1xcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XFxuICAgIGRhdGEgPSB7fTtcXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXFxcbicgK1xcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxcbiAgICAgIHZtXFxuICAgICk7XFxuICB9XFxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXFxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XFxuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xcbiAgd2hpbGUgKGktLSkge1xcbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXlzW2ldKSkge1xcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcXG4gICAgICAgIFxcXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFxcXFxcIlxcXCIgKyAoa2V5c1tpXSkgKyBcXFwiXFxcXFxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFxcXCIgK1xcbiAgICAgICAgXFxcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cXFwiLFxcbiAgICAgICAgdm1cXG4gICAgICApO1xcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleXNbaV0pKSB7XFxuICAgICAgcHJveHkodm0sIFxcXCJfZGF0YVxcXCIsIGtleXNbaV0pO1xcbiAgICB9XFxuICB9XFxuICAvLyBvYnNlcnZlIGRhdGFcXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiBkYXRhLmNhbGwodm0pXFxuICB9IGNhdGNoIChlKSB7XFxuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcXFwiZGF0YSgpXFxcIik7XFxuICAgIHJldHVybiB7fVxcbiAgfVxcbn1cXG5cXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xcblxcbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XFxuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuXFxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcXG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICAgICAgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICB3YXJuKFxcbiAgICAgICAgICAoXFxcIk5vIGdldHRlciBmdW5jdGlvbiBoYXMgYmVlbiBkZWZpbmVkIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFxcXFxcIlxcXCIgKyBrZXkgKyBcXFwiXFxcXFxcXCIuXFxcIiksXFxuICAgICAgICAgIHZtXFxuICAgICAgICApO1xcbiAgICAgICAgZ2V0dGVyID0gbm9vcDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cXG4gICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKHZtLCBnZXR0ZXIsIG5vb3AsIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMpO1xcblxcbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXFxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkICh0YXJnZXQsIGtleSwgdXNlckRlZikge1xcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpO1xcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcXG4gIH0gZWxzZSB7XFxuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxcbiAgICAgID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxcbiAgICAgICAgOiB1c2VyRGVmLmdldFxcbiAgICAgIDogbm9vcDtcXG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XFxuICAgICAgPyB1c2VyRGVmLnNldFxcbiAgICAgIDogbm9vcDtcXG4gIH1cXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcXG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcXG4gICAgaWYgKHdhdGNoZXIpIHtcXG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcXG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcXG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XFxuICAgICAgICB3YXJuKFxcbiAgICAgICAgICBcXFwibWV0aG9kIFxcXFxcXFwiXFxcIiArIGtleSArIFxcXCJcXFxcXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXFxcIiArXFxuICAgICAgICAgIFxcXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1xcXCIsXFxuICAgICAgICAgIHZtXFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XFxuICAgICAgICB3YXJuKFxcbiAgICAgICAgICAoXFxcIm1ldGhvZCBcXFxcXFxcIlxcXCIgKyBrZXkgKyBcXFwiXFxcXFxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cXFwiKSxcXG4gICAgICAgICAgdm1cXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XFxuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcXG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyICh2bSwga2V5LCBoYW5kbGVyKSB7XFxuICB2YXIgb3B0aW9ucztcXG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XFxuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XFxuICB9XFxuICB2bS4kd2F0Y2goa2V5LCBoYW5kbGVyLCBvcHRpb25zKTtcXG59XFxuXFxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XFxuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcXG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxcbiAgdmFyIGRhdGFEZWYgPSB7fTtcXG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xcbiAgdmFyIHByb3BzRGVmID0ge307XFxuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcXG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xcbiAgICAgIHdhcm4oXFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcXG4gICAgICAgIHRoaXNcXG4gICAgICApO1xcbiAgICB9O1xcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgd2FybihcXFwiJHByb3BzIGlzIHJlYWRvbmx5LlxcXCIsIHRoaXMpO1xcbiAgICB9O1xcbiAgfVxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XFxuXFxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XFxuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XFxuXFxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcXG4gICAgZXhwT3JGbixcXG4gICAgY2IsXFxuICAgIG9wdGlvbnNcXG4gICkge1xcbiAgICB2YXIgdm0gPSB0aGlzO1xcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcXG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcXG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcXG4gICAgfVxcbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcXG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XFxuICAgIH1cXG4gIH07XFxufVxcblxcbi8qICAqL1xcblxcbi8vIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxcbiAgICB2bm9kZSxcXG4gICAgaHlkcmF0aW5nLFxcbiAgICBwYXJlbnRFbG0sXFxuICAgIHJlZkVsbVxcbiAgKSB7XFxuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XFxuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxcbiAgICAgICAgdm5vZGUsXFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcXG4gICAgICAgIHBhcmVudEVsbSxcXG4gICAgICAgIHJlZkVsbVxcbiAgICAgICk7XFxuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcXG4gICAgfSBlbHNlIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XFxuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xcbiAgICB9XFxuICB9LFxcblxcbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcXG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcXG4gICAgICBjaGlsZCxcXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXFxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cXG4gICAgKTtcXG4gIH0sXFxuXFxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcXG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XFxuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XFxuICAgICAgY2FsbEhvb2sodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XFxuICAgIH1cXG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XFxuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xcbiAgICB9XFxuICB9LFxcblxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcXG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcXG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XFxuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcXG5cXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxcbiAgQ3RvcixcXG4gIGRhdGEsXFxuICBjb250ZXh0LFxcbiAgY2hpbGRyZW4sXFxuICB0YWdcXG4pIHtcXG4gIGlmICghQ3Rvcikge1xcbiAgICByZXR1cm5cXG4gIH1cXG5cXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XFxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcXG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcXG4gIH1cXG5cXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgICAgIHdhcm4oKFxcXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcXFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcXG4gICAgfVxcbiAgICByZXR1cm5cXG4gIH1cXG5cXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxcbiAgaWYgKCFDdG9yLmNpZCkge1xcbiAgICBpZiAoQ3Rvci5yZXNvbHZlZCkge1xcbiAgICAgIEN0b3IgPSBDdG9yLnJlc29sdmVkO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoQ3RvciwgYmFzZUN0b3IsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8vIGl0J3Mgb2sgdG8gcXVldWUgdGhpcyBvbiBldmVyeSByZW5kZXIgYmVjYXVzZVxcbiAgICAgICAgLy8gJGZvcmNlVXBkYXRlIGlzIGJ1ZmZlcmVkIGJ5IHRoZSBzY2hlZHVsZXIuXFxuICAgICAgICBjb250ZXh0LiRmb3JjZVVwZGF0ZSgpO1xcbiAgICAgIH0pO1xcbiAgICAgIGlmICghQ3Rvcikge1xcbiAgICAgICAgLy8gcmV0dXJuIG5vdGhpbmcgaWYgdGhpcyBpcyBpbmRlZWQgYW4gYXN5bmMgY29tcG9uZW50XFxuICAgICAgICAvLyB3YWl0IGZvciB0aGUgY2FsbGJhY2sgdG8gdHJpZ2dlciBwYXJlbnQgdXBkYXRlLlxcbiAgICAgICAgcmV0dXJuXFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXFxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XFxuXFxuICBkYXRhID0gZGF0YSB8fCB7fTtcXG5cXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcXG4gIGlmIChkYXRhLm1vZGVsKSB7XFxuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XFxuICB9XFxuXFxuICAvLyBleHRyYWN0IHByb3BzXFxuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzKGRhdGEsIEN0b3IsIHRhZyk7XFxuXFxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxcbiAgaWYgKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSB7XFxuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXFxuICB9XFxuXFxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xcblxcbiAgaWYgKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXFxuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnNcXG4gICAgZGF0YSA9IHt9O1xcbiAgfVxcblxcbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxcbiAgbWVyZ2VIb29rcyhkYXRhKTtcXG5cXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXFxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcXG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcXG4gICAgKFxcXCJ2dWUtY29tcG9uZW50LVxcXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXFxcIi1cXFwiICsgbmFtZSkgOiAnJykpLFxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9XFxuICApO1xcbiAgcmV0dXJuIHZub2RlXFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxcbiAgQ3RvcixcXG4gIHByb3BzRGF0YSxcXG4gIGRhdGEsXFxuICBjb250ZXh0LFxcbiAgY2hpbGRyZW5cXG4pIHtcXG4gIHZhciBwcm9wcyA9IHt9O1xcbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xcbiAgaWYgKHByb3BPcHRpb25zKSB7XFxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhKTtcXG4gICAgfVxcbiAgfVxcbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xcbiAgdmFyIF9jb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShjb250ZXh0KTtcXG4gIHZhciBoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX2NvbnRleHQsIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xcbiAgdmFyIHZub2RlID0gQ3Rvci5vcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIGgsIHtcXG4gICAgcHJvcHM6IHByb3BzLFxcbiAgICBkYXRhOiBkYXRhLFxcbiAgICBwYXJlbnQ6IGNvbnRleHQsXFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcXG4gICAgc2xvdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCk7IH1cXG4gIH0pO1xcbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcXG4gICAgdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xcbiAgICBpZiAoZGF0YS5zbG90KSB7XFxuICAgICAgKHZub2RlLmRhdGEgfHwgKHZub2RlLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB2bm9kZVxcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcXG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXFxuICBwYXJlbnRFbG0sXFxuICByZWZFbG1cXG4pIHtcXG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xcbiAgdmFyIG9wdGlvbnMgPSB7XFxuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcXG4gICAgcGFyZW50OiBwYXJlbnQsXFxuICAgIHByb3BzRGF0YTogdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YSxcXG4gICAgX2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcXG4gICAgX3BhcmVudExpc3RlbmVyczogdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycyxcXG4gICAgX3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sXFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxcbiAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxcbiAgfTtcXG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXFxuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xcbiAgaWYgKGlubGluZVRlbXBsYXRlKSB7XFxuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcXG4gIH1cXG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcXG59XFxuXFxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcXG4gIGZhY3RvcnksXFxuICBiYXNlQ3RvcixcXG4gIGNiXFxuKSB7XFxuICBpZiAoZmFjdG9yeS5yZXF1ZXN0ZWQpIHtcXG4gICAgLy8gcG9vbCBjYWxsYmFja3NcXG4gICAgZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2IpO1xcbiAgfSBlbHNlIHtcXG4gICAgZmFjdG9yeS5yZXF1ZXN0ZWQgPSB0cnVlO1xcbiAgICB2YXIgY2JzID0gZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzID0gW2NiXTtcXG4gICAgdmFyIHN5bmMgPSB0cnVlO1xcblxcbiAgICB2YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uIChyZXMpIHtcXG4gICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xcbiAgICAgICAgcmVzID0gYmFzZUN0b3IuZXh0ZW5kKHJlcyk7XFxuICAgICAgfVxcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IHJlcztcXG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXFxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXFxuICAgICAgaWYgKCFzeW5jKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgICAgY2JzW2ldKHJlcyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICB2YXIgcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcXG4gICAgICAgIFxcXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFxcXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXFxuICAgICAgICAocmVhc29uID8gKFxcXCJcXFxcblJlYXNvbjogXFxcIiArIHJlYXNvbikgOiAnJylcXG4gICAgICApO1xcbiAgICB9O1xcblxcbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xcblxcbiAgICAvLyBoYW5kbGUgcHJvbWlzZVxcbiAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiAhZmFjdG9yeS5yZXNvbHZlZCkge1xcbiAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XFxuICAgIH1cXG5cXG4gICAgc3luYyA9IGZhbHNlO1xcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XFxuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGV4dHJhY3RQcm9wcyAoZGF0YSwgQ3RvciwgdGFnKSB7XFxuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcXG4gIGlmICghcHJvcE9wdGlvbnMpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuICB2YXIgcmVzID0ge307XFxuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcXG4gIHZhciBkb21Qcm9wcyA9IGRhdGEuZG9tUHJvcHM7XFxuICBpZiAoYXR0cnMgfHwgcHJvcHMgfHwgZG9tUHJvcHMpIHtcXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XFxuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcXG4gICAgICAgIGlmIChcXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxcbiAgICAgICAgICBhdHRycyAmJiBhdHRycy5oYXNPd25Qcm9wZXJ0eShrZXlJbkxvd2VyQ2FzZSlcXG4gICAgICAgICkge1xcbiAgICAgICAgICB0aXAoXFxuICAgICAgICAgICAgXFxcIlByb3AgXFxcXFxcXCJcXFwiICsga2V5SW5Mb3dlckNhc2UgKyBcXFwiXFxcXFxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcXFwiICtcXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXFxcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcXFwiICtcXG4gICAgICAgICAgICBcXFwiIFxcXFxcXFwiXFxcIiArIGtleSArIFxcXCJcXFxcXFxcIi4gXFxcIiArXFxuICAgICAgICAgICAgXFxcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXFxcIiArXFxuICAgICAgICAgICAgXFxcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXFxcIiArXFxuICAgICAgICAgICAgXFxcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcXFxcXCJcXFwiICsgYWx0S2V5ICsgXFxcIlxcXFxcXFwiIGluc3RlYWQgb2YgXFxcXFxcXCJcXFwiICsga2V5ICsgXFxcIlxcXFxcXFwiLlxcXCJcXG4gICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSkgfHxcXG4gICAgICBjaGVja1Byb3AocmVzLCBkb21Qcm9wcywga2V5LCBhbHRLZXkpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzXFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXFxuICByZXMsXFxuICBoYXNoLFxcbiAga2V5LFxcbiAgYWx0S2V5LFxcbiAgcHJlc2VydmVcXG4pIHtcXG4gIGlmIChoYXNoKSB7XFxuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xcbiAgICAgIGlmICghcHJlc2VydmUpIHtcXG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0cnVlXFxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcXG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcXG4gICAgICBpZiAoIXByZXNlcnZlKSB7XFxuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdHJ1ZVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gZmFsc2VcXG59XFxuXFxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xcbiAgaWYgKCFkYXRhLmhvb2spIHtcXG4gICAgZGF0YS5ob29rID0ge307XFxuICB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcXG4gICAgZGF0YS5ob29rW2tleV0gPSBmcm9tUGFyZW50ID8gbWVyZ2VIb29rJDEob3VycywgZnJvbVBhcmVudCkgOiBvdXJzO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcXG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xcbiAgICBvbmUoYSwgYiwgYywgZCk7XFxuICAgIHR3byhhLCBiLCBjLCBkKTtcXG4gIH1cXG59XFxuXFxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xcbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxcbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XFxuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcXG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcXG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XFxuICBpZiAob25bZXZlbnRdKSB7XFxuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcXG4gIH0gZWxzZSB7XFxuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcXG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XFxuXFxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2VcXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcXG4gIGNvbnRleHQsXFxuICB0YWcsXFxuICBkYXRhLFxcbiAgY2hpbGRyZW4sXFxuICBub3JtYWxpemF0aW9uVHlwZSxcXG4gIGFsd2F5c05vcm1hbGl6ZVxcbikge1xcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcXG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcXG4gICAgY2hpbGRyZW4gPSBkYXRhO1xcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xcbiAgfVxcbiAgaWYgKGFsd2F5c05vcm1hbGl6ZSkgeyBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7IH1cXG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcXG59XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxcbiAgY29udGV4dCxcXG4gIHRhZyxcXG4gIGRhdGEsXFxuICBjaGlsZHJlbixcXG4gIG5vcm1hbGl6YXRpb25UeXBlXFxuKSB7XFxuICBpZiAoZGF0YSAmJiBkYXRhLl9fb2JfXykge1xcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXFxuICAgICAgXFxcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFxcXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXFxcIlxcXFxuXFxcIiArXFxuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXFxuICAgICAgY29udGV4dFxcbiAgICApO1xcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXFxuICB9XFxuICBpZiAoIXRhZykge1xcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXFxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcXG4gIH1cXG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxcbiAgICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcXG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcXG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcXG4gIH1cXG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcXG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcXG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XFxuICB9XFxuICB2YXIgdm5vZGUsIG5zO1xcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XFxuICAgIHZhciBDdG9yO1xcbiAgICBucyA9IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcXG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcXG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcXG4gICAgICApO1xcbiAgICB9IGVsc2UgaWYgKChDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcXG4gICAgICAvLyBjb21wb25lbnRcXG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXFxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcXG4gICAgICApO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcXG4gIH1cXG4gIGlmICh2bm9kZSkge1xcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XFxuICAgIHJldHVybiB2bm9kZVxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMpIHtcXG4gIHZub2RlLm5zID0gbnM7XFxuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcXG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XFxuICAgIHJldHVyblxcbiAgfVxcbiAgaWYgKHZub2RlLmNoaWxkcmVuKSB7XFxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XFxuICAgICAgaWYgKGNoaWxkLnRhZyAmJiAhY2hpbGQubnMpIHtcXG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxuLyoqXFxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cXG4gKi9cXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcXG4gIHZhbCxcXG4gIHJlbmRlclxcbikge1xcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XFxuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcXG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XFxuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcXG4gICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcXG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAga2V5ID0ga2V5c1tpXTtcXG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXRcXG59XFxuXFxuLyogICovXFxuXFxuLyoqXFxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cXG4gKi9cXG5mdW5jdGlvbiByZW5kZXJTbG90IChcXG4gIG5hbWUsXFxuICBmYWxsYmFjayxcXG4gIHByb3BzLFxcbiAgYmluZE9iamVjdFxcbikge1xcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xcbiAgICBpZiAoYmluZE9iamVjdCkge1xcbiAgICAgIGV4dGVuZChwcm9wcywgYmluZE9iamVjdCk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2tcXG4gIH0gZWxzZSB7XFxuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcXG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxcbiAgICBpZiAoc2xvdE5vZGVzICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcXG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkICYmIHdhcm4oXFxuICAgICAgICBcXFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcXFxcXCJcXFwiICsgbmFtZSArIFxcXCJcXFxcXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcXFwiICtcXG4gICAgICAgIFxcXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cXFwiLFxcbiAgICAgICAgdGhpc1xcbiAgICAgICk7XFxuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XFxuICAgIH1cXG4gICAgcmV0dXJuIHNsb3ROb2RlcyB8fCBmYWxsYmFja1xcbiAgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG4vKipcXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcXG4gKi9cXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxcbn1cXG5cXG4vKiAgKi9cXG5cXG4vKipcXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXFxuICovXFxuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXFxuICBldmVudEtleUNvZGUsXFxuICBrZXksXFxuICBidWlsdEluQWxpYXNcXG4pIHtcXG4gIHZhciBrZXlDb2RlcyA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5BbGlhcztcXG4gIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xcbiAgICByZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMVxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxuLyoqXFxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVxcXCJvYmplY3RcXFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXFxuICovXFxuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcXG4gIGRhdGEsXFxuICB0YWcsXFxuICB2YWx1ZSxcXG4gIGFzUHJvcFxcbikge1xcbiAgaWYgKHZhbHVlKSB7XFxuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcXG4gICAgICAgIHRoaXNcXG4gICAgICApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XFxuICAgICAgfVxcbiAgICAgIHZhciBoYXNoO1xcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScpIHtcXG4gICAgICAgICAgaGFzaCA9IGRhdGE7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkpIHtcXG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBkYXRhXFxufVxcblxcbi8qICAqL1xcblxcbi8qKlxcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxcbiAqL1xcbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXFxuICBpbmRleCxcXG4gIGlzSW5Gb3JcXG4pIHtcXG4gIHZhciB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdO1xcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZSBieSBkb2luZyBhIHNoYWxsb3cgY2xvbmUuXFxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxcbiAgICAgID8gY2xvbmVWTm9kZXModHJlZSlcXG4gICAgICA6IGNsb25lVk5vZGUodHJlZSlcXG4gIH1cXG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cXG4gIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF0gPVxcbiAgICB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XFxuICBtYXJrU3RhdGljKHRyZWUsIChcXFwiX19zdGF0aWNfX1xcXCIgKyBpbmRleCksIGZhbHNlKTtcXG4gIHJldHVybiB0cmVlXFxufVxcblxcbi8qKlxcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXFxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXFxuICovXFxuZnVuY3Rpb24gbWFya09uY2UgKFxcbiAgdHJlZSxcXG4gIGluZGV4LFxcbiAga2V5XFxuKSB7XFxuICBtYXJrU3RhdGljKHRyZWUsIChcXFwiX19vbmNlX19cXFwiICsgaW5kZXggKyAoa2V5ID8gKFxcXCJfXFxcIiArIGtleSkgOiBcXFwiXFxcIikpLCB0cnVlKTtcXG4gIHJldHVybiB0cmVlXFxufVxcblxcbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxcbiAgdHJlZSxcXG4gIGtleSxcXG4gIGlzT25jZVxcbikge1xcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXFxcIl9cXFwiICsgaSksIGlzT25jZSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XFxuICBub2RlLmtleSA9IGtleTtcXG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xcbn1cXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xcbiAgdm0uJHZub2RlID0gbnVsbDsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcXG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXFxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsO1xcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlO1xcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XFxuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcXG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXFxuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XFxuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxcbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XFxufVxcblxcbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XFxuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcXG4gIH07XFxuXFxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB2bSA9IHRoaXM7XFxuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcXG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XFxuICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcXG5cXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcXG4gICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdm0uJHNsb3RzKSB7XFxuICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHZtLiRzbG90c1trZXldKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XFxuXFxuICAgIGlmIChzdGF0aWNSZW5kZXJGbnMgJiYgIXZtLl9zdGF0aWNUcmVlcykge1xcbiAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xcbiAgICB9XFxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXFxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcXG4gICAgLy8gcmVuZGVyIHNlbGZcXG4gICAgdmFyIHZub2RlO1xcbiAgICB0cnkge1xcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXFxcInJlbmRlciBmdW5jdGlvblxcXCIpO1xcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvclxcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSlcXG4gICAgICAgICAgOiB2bS5fdm5vZGU7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XFxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcXG4gICAgICAgIHdhcm4oXFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXFxuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxcbiAgICAgICAgICB2bVxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XFxuICAgIH1cXG4gICAgLy8gc2V0IHBhcmVudFxcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XFxuICAgIHJldHVybiB2bm9kZVxcbiAgfTtcXG5cXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxcbiAgLy8gdGhlc2UgYXJlIGV4cG9zZWQgb24gdGhlIGluc3RhbmNlIHByb3RvdHlwZSB0byByZWR1Y2UgZ2VuZXJhdGVkIHJlbmRlclxcbiAgLy8gY29kZSBzaXplLlxcbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xcbiAgVnVlLnByb3RvdHlwZS5fbiA9IHRvTnVtYmVyO1xcbiAgVnVlLnByb3RvdHlwZS5fcyA9IF90b1N0cmluZztcXG4gIFZ1ZS5wcm90b3R5cGUuX2wgPSByZW5kZXJMaXN0O1xcbiAgVnVlLnByb3RvdHlwZS5fdCA9IHJlbmRlclNsb3Q7XFxuICBWdWUucHJvdG90eXBlLl9xID0gbG9vc2VFcXVhbDtcXG4gIFZ1ZS5wcm90b3R5cGUuX2kgPSBsb29zZUluZGV4T2Y7XFxuICBWdWUucHJvdG90eXBlLl9tID0gcmVuZGVyU3RhdGljO1xcbiAgVnVlLnByb3RvdHlwZS5fZiA9IHJlc29sdmVGaWx0ZXI7XFxuICBWdWUucHJvdG90eXBlLl9rID0gY2hlY2tLZXlDb2RlcztcXG4gIFZ1ZS5wcm90b3R5cGUuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XFxuICBWdWUucHJvdG90eXBlLl92ID0gY3JlYXRlVGV4dFZOb2RlO1xcbiAgVnVlLnByb3RvdHlwZS5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XFxuICBWdWUucHJvdG90eXBlLl91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xcbn1cXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcXG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcXG4gIGlmIChwcm92aWRlKSB7XFxuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXFxuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXFxuICAgICAgOiBwcm92aWRlO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcXG4gIHZhciBpbmplY3QgPSB2bS4kb3B0aW9ucy5pbmplY3Q7XFxuICBpZiAoaW5qZWN0KSB7XFxuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXFxuICAgIC8vIGlzQXJyYXkgaGVyZVxcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoaW5qZWN0KTtcXG4gICAgdmFyIGtleXMgPSBpc0FycmF5XFxuICAgICAgPyBpbmplY3RcXG4gICAgICA6IGhhc1N5bWJvbFxcbiAgICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xcblxcbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcXG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcXG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGlzQXJyYXkgPyBrZXkgOiBpbmplY3Rba2V5XTtcXG4gICAgICB2YXIgc291cmNlID0gdm07XFxuICAgICAgd2hpbGUgKHNvdXJjZSkge1xcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XFxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXFxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgd2FybihcXG4gICAgICAgICAgICAgICAgXFxcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXFxcIiArXFxuICAgICAgICAgICAgICAgIFxcXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFxcXCIgK1xcbiAgICAgICAgICAgICAgICBcXFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXFxcXFwiXFxcIiArIGtleSArIFxcXCJcXFxcXFxcIlxcXCIsXFxuICAgICAgICAgICAgICAgIHZtXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrXFxuICAgICAgICB9XFxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgbG9vcCggaSApO1xcbiAgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG52YXIgdWlkID0gMDtcXG5cXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XFxuICAgIHZhciB2bSA9IHRoaXM7XFxuICAgIC8vIGEgdWlkXFxuICAgIHZtLl91aWQgPSB1aWQrKztcXG5cXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xcbiAgICAgIHN0YXJ0VGFnID0gXFxcInZ1ZS1wZXJmLWluaXQ6XFxcIiArICh2bS5fdWlkKTtcXG4gICAgICBlbmRUYWcgPSBcXFwidnVlLXBlcmYtZW5kOlxcXCIgKyAodm0uX3VpZCk7XFxuICAgICAgbWFyayhzdGFydFRhZyk7XFxuICAgIH1cXG5cXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcXG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXFxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxcbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcXG4gICAgICAgIG9wdGlvbnMgfHwge30sXFxuICAgICAgICB2bVxcbiAgICAgICk7XFxuICAgIH1cXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcXG4gICAgICBpbml0UHJveHkodm0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xcbiAgICB9XFxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcXG4gICAgdm0uX3NlbGYgPSB2bTtcXG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XFxuICAgIGluaXRFdmVudHModm0pO1xcbiAgICBpbml0UmVuZGVyKHZtKTtcXG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcXG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcXG4gICAgaW5pdFN0YXRlKHZtKTtcXG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcXG5cXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XFxuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XFxuICAgICAgbWFyayhlbmRUYWcpO1xcbiAgICAgIG1lYXN1cmUoKCh2bS5fbmFtZSkgKyBcXFwiIGluaXRcXFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XFxuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcXG4gICAgfVxcbiAgfTtcXG59XFxuXFxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XFxuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcXG4gIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XFxuICBvcHRzLl9wYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcXG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcXG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcXG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XFxuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcXG4gIGlmIChDdG9yLnN1cGVyKSB7XFxuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XFxuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcXG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXFxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XFxuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XFxuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xcbiAgICAgIH1cXG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcXG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XFxuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gb3B0aW9uc1xcbn1cXG5cXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XFxuICB2YXIgbW9kaWZpZWQ7XFxuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcXG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcXG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxcbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIHNlYWxlZFtrZXldKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG1vZGlmaWVkXFxufVxcblxcbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBzZWFsZWQpIHtcXG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xcbiAgICB2YXIgcmVzID0gW107XFxuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xcbiAgICAgIGlmIChzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGxhdGVzdFxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBWdWUkMiAob3B0aW9ucykge1xcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDIpKSB7XFxuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcXG4gIH1cXG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XFxufVxcblxcbmluaXRNaXhpbihWdWUkMik7XFxuc3RhdGVNaXhpbihWdWUkMik7XFxuZXZlbnRzTWl4aW4oVnVlJDIpO1xcbmxpZmVjeWNsZU1peGluKFZ1ZSQyKTtcXG5yZW5kZXJNaXhpbihWdWUkMik7XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XFxuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcXG4gICAgICByZXR1cm5cXG4gICAgfVxcbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XFxuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcXG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcXG4gICAgfVxcbiAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcXG4gICAgcmV0dXJuIHRoaXNcXG4gIH07XFxufVxcblxcbi8qICAqL1xcblxcbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcXG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XFxuICB9O1xcbn1cXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcXG4gIC8qKlxcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXFxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcXFwiY2hpbGRcXG4gICAqIGNvbnN0cnVjdG9yc1xcXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXFxuICAgKi9cXG4gIFZ1ZS5jaWQgPSAwO1xcbiAgdmFyIGNpZCA9IDE7XFxuXFxuICAvKipcXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXFxuICAgKi9cXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcXG4gICAgdmFyIFN1cGVyID0gdGhpcztcXG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XFxuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XFxuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxcbiAgICB9XFxuXFxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcXG4gICAgICBpZiAoIS9eW2EtekEtWl1bXFxcXHctXSokLy50ZXN0KG5hbWUpKSB7XFxuICAgICAgICB3YXJuKFxcbiAgICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXFxcIicgKyBuYW1lICsgJ1xcXCIuIENvbXBvbmVudCBuYW1lcyAnICtcXG4gICAgICAgICAgJ2NhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYW5kIHRoZSBoeXBoZW4sICcgK1xcbiAgICAgICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XFxuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcXG4gICAgfTtcXG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcXG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcXG4gICAgU3ViLmNpZCA9IGNpZCsrO1xcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcXG4gICAgICBTdXBlci5vcHRpb25zLFxcbiAgICAgIGV4dGVuZE9wdGlvbnNcXG4gICAgKTtcXG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XFxuXFxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXFxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXFxuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XFxuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcXG4gICAgfVxcbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcXG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xcbiAgICB9XFxuXFxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcXG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcXG5cXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXFxuICAgIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XFxuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XFxuICAgIH0pO1xcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXFxuICAgIGlmIChuYW1lKSB7XFxuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcXG4gICAgfVxcblxcbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxcbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXFxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XFxuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XFxuXFxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXFxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xcbiAgICByZXR1cm4gU3ViXFxuICB9O1xcbn1cXG5cXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XFxuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcXFwiX3Byb3BzXFxcIiwga2V5KTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcXG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcXG4gIC8qKlxcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxcbiAgICovXFxuICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXFxuICAgICAgaWQsXFxuICAgICAgZGVmaW5pdGlvblxcbiAgICApIHtcXG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGNvbmZpZy5pc1Jlc2VydmVkVGFnKGlkKSkge1xcbiAgICAgICAgICAgIHdhcm4oXFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcXG4gICAgICAgICAgICAgICdpZDogJyArIGlkXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcXG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cXG4gICAgICB9XFxuICAgIH07XFxuICB9KTtcXG59XFxuXFxuLyogICovXFxuXFxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cF07XFxuXFxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXFxufVxcblxcbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcXG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcXG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcXG4gIH0gZWxzZSBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXFxuICB9XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcbiAgcmV0dXJuIGZhbHNlXFxufVxcblxcbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGNhY2hlLCBmaWx0ZXIpIHtcXG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XFxuICAgIGlmIChjYWNoZWROb2RlKSB7XFxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XFxuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlZE5vZGUpO1xcbiAgICAgICAgY2FjaGVba2V5XSA9IG51bGw7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAodm5vZGUpIHtcXG4gIGlmICh2bm9kZSkge1xcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pbmFjdGl2ZSkge1xcbiAgICAgIGNhbGxIb29rKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCAnZGVhY3RpdmF0ZWQnKTtcXG4gICAgfVxcbiAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xcbiAgfVxcbn1cXG5cXG52YXIgS2VlcEFsaXZlID0ge1xcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxcbiAgYWJzdHJhY3Q6IHRydWUsXFxuXFxuICBwcm9wczoge1xcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlc1xcbiAgfSxcXG5cXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG4gIH0sXFxuXFxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XFxuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZVtrZXldKTtcXG4gICAgfVxcbiAgfSxcXG5cXG4gIHdhdGNoOiB7XFxuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XFxuICAgIH0sXFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xcbiAgICB9XFxuICB9LFxcblxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XFxuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XFxuICAgICAgLy8gY2hlY2sgcGF0dGVyblxcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcXG4gICAgICBpZiAobmFtZSAmJiAoXFxuICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XFxuICAgICAgICAodGhpcy5leGNsdWRlICYmIG1hdGNoZXModGhpcy5leGNsdWRlLCBuYW1lKSlcXG4gICAgICApKSB7XFxuICAgICAgICByZXR1cm4gdm5vZGVcXG4gICAgICB9XFxuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFxcXCI6OlxcXCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxcbiAgICAgICAgOiB2bm9kZS5rZXk7XFxuICAgICAgaWYgKHRoaXMuY2FjaGVba2V5XSkge1xcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuY2FjaGVba2V5XSA9IHZub2RlO1xcbiAgICAgIH1cXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XFxuICAgIH1cXG4gICAgcmV0dXJuIHZub2RlXFxuICB9XFxufTtcXG5cXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XFxuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxcbn07XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XFxuICAvLyBjb25maWdcXG4gIHZhciBjb25maWdEZWYgPSB7fTtcXG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHdhcm4oXFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXFxuICAgICAgKTtcXG4gICAgfTtcXG4gIH1cXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xcblxcbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXFxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXFxuICBWdWUudXRpbCA9IHtcXG4gICAgd2Fybjogd2FybixcXG4gICAgZXh0ZW5kOiBleHRlbmQsXFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcXG4gIH07XFxuXFxuICBWdWUuc2V0ID0gc2V0O1xcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcXG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xcblxcbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcXG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgfSk7XFxuXFxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFxcXCJiYXNlXFxcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXFxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcXG5cXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XFxuXFxuICBpbml0VXNlKFZ1ZSk7XFxuICBpbml0TWl4aW4kMShWdWUpO1xcbiAgaW5pdEV4dGVuZChWdWUpO1xcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XFxufVxcblxcbmluaXRHbG9iYWxBUEkoVnVlJDIpO1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMi5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XFxuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXFxufSk7XFxuXFxuVnVlJDIudmVyc2lvbiA9ICcyLjIuNic7XFxuXFxuLyogICovXFxuXFxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QnKTtcXG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XFxuICByZXR1cm4gKFxcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcXG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxcbiAgKVxcbn07XFxuXFxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcXG5cXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXFxuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXFxuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcXG4pO1xcblxcbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xcblxcbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcXG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcXG59O1xcblxcbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXFxufTtcXG5cXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcXG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXFxufTtcXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcXG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcXG4gIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcXG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcXG4gICAgaWYgKGNoaWxkTm9kZS5kYXRhKSB7XFxuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcXG4gICAgfVxcbiAgfVxcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XFxuICAgIGlmIChwYXJlbnROb2RlLmRhdGEpIHtcXG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGdlbkNsYXNzRnJvbURhdGEoZGF0YSlcXG59XFxuXFxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcXG4gIHJldHVybiB7XFxuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXFxuICAgIGNsYXNzOiBjaGlsZC5jbGFzc1xcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXFxuICAgICAgOiBwYXJlbnQuY2xhc3NcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZ2VuQ2xhc3NGcm9tRGF0YSAoZGF0YSkge1xcbiAgdmFyIGR5bmFtaWNDbGFzcyA9IGRhdGEuY2xhc3M7XFxuICB2YXIgc3RhdGljQ2xhc3MgPSBkYXRhLnN0YXRpY0NsYXNzO1xcbiAgaWYgKHN0YXRpY0NsYXNzIHx8IGR5bmFtaWNDbGFzcykge1xcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxcbiAgfVxcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cXG4gIHJldHVybiAnJ1xcbn1cXG5cXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcXG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXFxufVxcblxcbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xcbiAgdmFyIHJlcyA9ICcnO1xcbiAgaWYgKCF2YWx1ZSkge1xcbiAgICByZXR1cm4gcmVzXFxuICB9XFxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gdmFsdWVcXG4gIH1cXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xcbiAgICB2YXIgc3RyaW5naWZpZWQ7XFxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgaWYgKHZhbHVlW2ldKSB7XFxuICAgICAgICBpZiAoKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSkge1xcbiAgICAgICAgICByZXMgKz0gc3RyaW5naWZpZWQgKyAnICc7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXFxuICB9XFxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XFxuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xcbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7IHJlcyArPSBrZXkgKyAnICc7IH1cXG4gICAgfVxcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxcbiAgfVxcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cXG4gIHJldHVybiByZXNcXG59XFxuXFxuLyogICovXFxuXFxudmFyIG5hbWVzcGFjZU1hcCA9IHtcXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xcbn07XFxuXFxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXFxuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXFxuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXFxuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXFxuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlJ1xcbik7XFxuXFxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XFxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcXG4gIHRydWVcXG4pO1xcblxcblxcblxcbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcXG59O1xcblxcbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XFxuICBpZiAoaXNTVkcodGFnKSkge1xcbiAgICByZXR1cm4gJ3N2ZydcXG4gIH1cXG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XFxuICAgIHJldHVybiAnbWF0aCdcXG4gIH1cXG59XFxuXFxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICBpZiAoIWluQnJvd3Nlcikge1xcbiAgICByZXR1cm4gdHJ1ZVxcbiAgfVxcbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xcbiAgICByZXR1cm4gZmFsc2VcXG4gIH1cXG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcXG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxcbiAgfVxcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxcbiAgICApKVxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxcbiAgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG4vKipcXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cXG4gKi9cXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcXG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XFxuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xcbiAgICBpZiAoIXNlbGVjdGVkKSB7XFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxcbiAgICAgICk7XFxuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXFxuICAgIH1cXG4gICAgcmV0dXJuIHNlbGVjdGVkXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gZWxcXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XFxuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcXG4gICAgcmV0dXJuIGVsbVxcbiAgfVxcbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcXG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XFxuICB9XFxuICByZXR1cm4gZWxtXFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XFxuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcXG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXFxufVxcblxcbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XFxufVxcblxcbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XFxufVxcblxcbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcXG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcXG59XFxuXFxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcXG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXFxufVxcblxcbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcXG4gIHJldHVybiBub2RlLnRhZ05hbWVcXG59XFxuXFxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcXG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xcbn1cXG5cXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XFxuICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XFxufVxcblxcblxcbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XFxuXFx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxcblxcdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxcblxcdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcXG5cXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxcblxcdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxcblxcdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcXG5cXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXFxuXFx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcXG5cXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXFxuXFx0dGFnTmFtZTogdGFnTmFtZSxcXG5cXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXFxuXFx0c2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcXG59KTtcXG5cXG4vKiAgKi9cXG5cXG52YXIgcmVmID0ge1xcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XFxuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcXG4gIH0sXFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XFxuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcXG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XFxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xcbiAgICB9XFxuICB9LFxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcXG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xcbiAgfVxcbn07XFxuXFxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcXG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcXG4gIGlmICgha2V5KSB7IHJldHVybiB9XFxuXFxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcXG4gIHZhciByZWZzID0gdm0uJHJlZnM7XFxuICBpZiAoaXNSZW1vdmFsKSB7XFxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcXG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XFxuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkgJiYgcmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICByZWZzW2tleV0gPSByZWY7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLyoqXFxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XFxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxcbiAqXFxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXFxuICpcXG5cXG4vKlxcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcXG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cXG4gKi9cXG5cXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xcblxcbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xcblxcbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcXG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxcbn1cXG5cXG5mdW5jdGlvbiBpc0RlZiAodikge1xcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXFxufVxcblxcbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xcbiAgcmV0dXJuIHYgPT09IHRydWVcXG59XFxuXFxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XFxuICByZXR1cm4gKFxcbiAgICBhLmtleSA9PT0gYi5rZXkgJiZcXG4gICAgYS50YWcgPT09IGIudGFnICYmXFxuICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxcbiAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXFxuICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcXG4gIClcXG59XFxuXFxuLy8gU29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBkeW5hbWljYWxseSBjaGFuZ2luZyB0eXBlIGZvciA8aW5wdXQ+XFxuLy8gc28gdGhleSBuZWVkIHRvIGJlIHRyZWF0ZWQgYXMgZGlmZmVyZW50IG5vZGVzXFxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cXG4gIHZhciBpO1xcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcXG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XFxuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCXFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xcbiAgdmFyIGksIGtleTtcXG4gIHZhciBtYXAgPSB7fTtcXG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XFxuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcXG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XFxuICB9XFxuICByZXR1cm4gbWFwXFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcXG4gIHZhciBpLCBqO1xcbiAgdmFyIGNicyA9IHt9O1xcblxcbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XFxuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcXG5cXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xcbiAgICBjYnNbaG9va3NbaV1dID0gW107XFxuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XFxuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcXG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcXG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xcbiAgICByZXR1cm4gcmVtb3ZlJCQxXFxuICB9XFxuXFxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcXG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XFxuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIGluUHJlID0gMDtcXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIG5lc3RlZCkge1xcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xcbiAgICAgIHJldHVyblxcbiAgICB9XFxuXFxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcXG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XFxuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XFxuICAgIGlmIChpc0RlZih0YWcpKSB7XFxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcXG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XFxuICAgICAgICAgIGluUHJlKys7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoXFxuICAgICAgICAgICFpblByZSAmJlxcbiAgICAgICAgICAhdm5vZGUubnMgJiZcXG4gICAgICAgICAgIShjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJiBjb25maWcuaWdub3JlZEVsZW1lbnRzLmluZGV4T2YodGFnKSA+IC0xKSAmJlxcbiAgICAgICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh0YWcpXFxuICAgICAgICApIHtcXG4gICAgICAgICAgd2FybihcXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXFxuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXFxcIm5hbWVcXFwiIG9wdGlvbi4nLFxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcXG4gICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcXG5cXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gICAgICB7XFxuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XFxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcXG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcXG4gICAgICAgIGluUHJlLS07XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XFxuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XFxuICAgIGlmIChpc0RlZihpKSkge1xcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovLCBwYXJlbnRFbG0sIHJlZkVsbSk7XFxuICAgICAgfVxcbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXFxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XFxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0cnVlXFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XFxuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XFxuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xcbiAgICB9XFxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcXG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXFxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXFxuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xcbiAgICB2YXIgaTtcXG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxcbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxcbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XFxuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcXG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XFxuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XFxuICAgICAgICB9XFxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xcbiAgICAgICAgYnJlYWtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXFxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZikge1xcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xcbiAgICAgIGlmIChpc0RlZihyZWYpKSB7XFxuICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSk7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XFxuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCkpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcXG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XFxuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XFxuICAgIH1cXG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XFxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcXG4gICAgfVxcbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxcbiAgICBpZiAoaXNEZWYoaSkpIHtcXG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XFxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXFxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcXG4gICAgdmFyIGk7XFxuICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcXG4gICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xcbiAgICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XFxuICAgICAgfVxcbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xcbiAgICB9XFxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcXG4gICAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcXG4gICAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XFxuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcXG4gICAgdmFyIGksIGo7XFxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcXG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XFxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XFxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxcbiAgICB9XFxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XFxuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XFxuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XFxuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcXG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcXG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XFxuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XFxuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XFxuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcXG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xcbiAgICAgIGlmIChpc0RlZihybSkpIHtcXG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XFxuICAgICAgfVxcbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXFxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XFxuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcXG4gICAgICB9XFxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcXG4gICAgICAgIGkodm5vZGUsIHJtKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcm0oKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcXG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcXG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcXG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XFxuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XFxuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XFxuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgcmVmRWxtO1xcblxcbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cXG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xcblxcbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XFxuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcXG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XFxuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcXG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcXG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XFxuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcXG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcXG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XFxuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XFxuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XFxuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcXG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcXG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcXG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cXG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldIDogbnVsbDtcXG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcXG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xcbiAgICAgICAgICAgIHdhcm4oXFxuICAgICAgICAgICAgICAnSXQgc2VlbXMgdGhlcmUgYXJlIGR1cGxpY2F0ZSBrZXlzIHRoYXQgaXMgY2F1c2luZyBhbiB1cGRhdGUgZXJyb3IuICcgK1xcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcXG4gICAgICAgICAgICBwYXRjaFZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcXG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XFxuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG5ld1N0YXJ0Vm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XFxuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcXG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcXG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XFxuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XFxuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcXG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XFxuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcXG4gICAgICByZXR1cm5cXG4gICAgfVxcbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXFxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxcbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcXG4gICAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcXG4gICAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXFxuICAgICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSkpIHtcXG4gICAgICB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XFxuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcXG4gICAgICByZXR1cm5cXG4gICAgfVxcbiAgICB2YXIgaTtcXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XFxuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xcbiAgICB9XFxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XFxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcXG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxcbiAgICB9XFxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XFxuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcXG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cXG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cXG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XFxuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XFxuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcXG4gICAgfVxcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcXG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XFxuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcXG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgYmFpbGVkID0gZmFsc2U7XFxuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsc3R5bGUsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XFxuXFxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxcbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSkpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICB2bm9kZS5lbG0gPSBlbG07XFxuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XFxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcXG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XFxuICAgIGlmIChpc0RlZihkYXRhKSkge1xcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXFxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xcbiAgICAgICAgcmV0dXJuIHRydWVcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGlzRGVmKHRhZykpIHtcXG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XFxuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XFxuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcXG4gICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xcbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xcbiAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcXG4gICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cXG4gICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXFxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxcbiAgICAgICAgICAgICAgICAhYmFpbGVkKSB7XFxuICAgICAgICAgICAgICBiYWlsZWQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XFxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xcbiAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcXG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRydWVcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUpIHtcXG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcXG4gICAgICByZXR1cm4gKFxcbiAgICAgICAgdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fFxcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXFxuICAgICAgKVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XFxuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XFxuICAgICAgcmV0dXJuXFxuICAgIH1cXG5cXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XFxuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcXG5cXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XFxuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcXG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXFxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcXG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcXG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZSgnc2VydmVyLXJlbmRlcmVkJykpIHtcXG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpO1xcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XFxuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XFxuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICAgICAgICAgICAgICB3YXJuKFxcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXFxuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXFxuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXFxuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcXG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcXG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xcbiAgICAgICAgY3JlYXRlRWxtKFxcbiAgICAgICAgICB2bm9kZSxcXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcXG4gICAgICAgICk7XFxuXFxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xcbiAgICAgICAgICAvLyBjb21wb25lbnQgcm9vdCBlbGVtZW50IHJlcGxhY2VkLlxcbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcXG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcXG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XFxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlLnBhcmVudCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XFxuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XFxuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcXG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcXG4gICAgcmV0dXJuIHZub2RlLmVsbVxcbiAgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG52YXIgZGlyZWN0aXZlcyA9IHtcXG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XFxuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcXG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XFxuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XFxuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XFxuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcXG5cXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XFxuXFxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcXG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcXG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XFxuICAgIGlmICghb2xkRGlyKSB7XFxuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XFxuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XFxuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XFxuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XFxuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICBpZiAoaXNDcmVhdGUpIHtcXG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNhbGxJbnNlcnQoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGlmICghaXNDcmVhdGUpIHtcXG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XFxuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG5cXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxcbiAgZGlycyxcXG4gIHZtXFxuKSB7XFxuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG4gIGlmICghZGlycykge1xcbiAgICByZXR1cm4gcmVzXFxuICB9XFxuICB2YXIgaSwgZGlyO1xcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcXG4gICAgZGlyID0gZGlyc1tpXTtcXG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XFxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xcbiAgICB9XFxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcXG4gIH1cXG4gIHJldHVybiByZXNcXG59XFxuXFxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XFxuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcXFwiLlxcXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcXG59XFxuXFxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xcbiAgaWYgKGZuKSB7XFxuICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XFxuICB9XFxufVxcblxcbnZhciBiYXNlTW9kdWxlcyA9IFtcXG4gIHJlZixcXG4gIGRpcmVjdGl2ZXNcXG5dO1xcblxcbi8qICAqL1xcblxcbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcXG4gIGlmICghb2xkVm5vZGUuZGF0YS5hdHRycyAmJiAhdm5vZGUuZGF0YS5hdHRycykge1xcbiAgICByZXR1cm5cXG4gIH1cXG4gIHZhciBrZXksIGN1ciwgb2xkO1xcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcXG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XFxuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XFxuICBpZiAoYXR0cnMuX19vYl9fKSB7XFxuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xcbiAgfVxcblxcbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcXG4gICAgY3VyID0gYXR0cnNba2V5XTtcXG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcXG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XFxuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcXG4gICAgfVxcbiAgfVxcbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKGlzSUU5ICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xcbiAgfVxcbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcXG4gICAgaWYgKGF0dHJzW2tleV0gPT0gbnVsbCkge1xcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcXG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XFxuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XFxuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XFxuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XFxuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXFxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XFxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGtleSk7XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XFxuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XFxuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG52YXIgYXR0cnMgPSB7XFxuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xcbn07XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xcbiAgaWYgKCFkYXRhLnN0YXRpY0NsYXNzICYmICFkYXRhLmNsYXNzICYmXFxuICAgICAgKCFvbGREYXRhIHx8ICghb2xkRGF0YS5zdGF0aWNDbGFzcyAmJiAhb2xkRGF0YS5jbGFzcykpKSB7XFxuICAgIHJldHVyblxcbiAgfVxcblxcbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xcblxcbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcXG4gIGlmICh0cmFuc2l0aW9uQ2xhc3MpIHtcXG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XFxuICB9XFxuXFxuICAvLyBzZXQgdGhlIGNsYXNzXFxuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XFxuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xcbiAgfVxcbn1cXG5cXG52YXIga2xhc3MgPSB7XFxuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xcbn07XFxuXFxuLyogICovXFxuXFxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcXFx3KS4rXFxcXC1fJFxcXFxdXS87XFxuXFxuXFxuXFxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcXG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcXG4gIGlmIChpIDwgMCkge1xcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxcbiAgICByZXR1cm4gKFxcXCJfZihcXFxcXFxcIlxcXCIgKyBmaWx0ZXIgKyBcXFwiXFxcXFxcXCIpKFxcXCIgKyBleHAgKyBcXFwiKVxcXCIpXFxuICB9IGVsc2Uge1xcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcXG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xcbiAgICByZXR1cm4gKFxcXCJfZihcXFxcXFxcIlxcXCIgKyBuYW1lICsgXFxcIlxcXFxcXFwiKShcXFwiICsgZXhwICsgXFxcIixcXFwiICsgYXJncylcXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxuLyogICovXFxuXFxuLyoqXFxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxcbiAqL1xcblxcblxcbi8qKlxcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxcbiAqL1xcblxcblxcbi8qKlxcbiAqIHBhcnNlIGRpcmVjdGl2ZSBtb2RlbCB0byBkbyB0aGUgYXJyYXkgdXBkYXRlIHRyYW5zZm9ybS4gYVtpZHhdID0gdmFsID0+ICQkYS5zcGxpY2UoJCRpZHgsIDEsIHZhbClcXG4gKlxcbiAqIGZvciBsb29wIHBvc3NpYmxlIGNhc2VzOlxcbiAqXFxuICogLSB0ZXN0XFxuICogLSB0ZXN0W2lkeF1cXG4gKiAtIHRlc3RbdGVzdDFbaWR4XV1cXG4gKiAtIHRlc3RbXFxcImFcXFwiXVtpZHhdXFxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2lkeF1dXFxuICogLSB0ZXN0Lnh4eC5hW1xcXCJhc2FcXFwiXVt0ZXN0MVtpZHhdXVxcbiAqXFxuICovXFxuXFxudmFyIHN0cjtcXG52YXIgaW5kZXgkMTtcXG5cXG4vKiAgKi9cXG5cXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXFxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcXG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcXG5cXG4vKiAgKi9cXG5cXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXFxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxcbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcXG4gIHZhciBldmVudDtcXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKG9uW1JBTkdFX1RPS0VOXSkge1xcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XFxuICAgIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcXG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcXG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcXG4gIH1cXG4gIGlmIChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pIHtcXG4gICAgLy8gQ2hyb21lIGZpcmVzIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBjbGljay9jaGFuZ2UsIGxlYWRzIHRvICM0NTIxXFxuICAgIGV2ZW50ID0gaXNDaHJvbWUgPyAnY2xpY2snIDogJ2NoYW5nZSc7XFxuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XFxuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XFxuICB9XFxufVxcblxcbnZhciB0YXJnZXQkMTtcXG5cXG5mdW5jdGlvbiBhZGQkMSAoXFxuICBldmVudCxcXG4gIGhhbmRsZXIsXFxuICBvbmNlLFxcbiAgY2FwdHVyZVxcbikge1xcbiAgaWYgKG9uY2UpIHtcXG4gICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xcbiAgICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxcbiAgICBoYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XFxuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcXG4gICAgICAgID8gb2xkSGFuZGxlcihldilcXG4gICAgICAgIDogb2xkSGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcXG4gICAgICAgIHJlbW92ZSQyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcXG59XFxuXFxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxcbiAgZXZlbnQsXFxuICBoYW5kbGVyLFxcbiAgY2FwdHVyZSxcXG4gIF90YXJnZXRcXG4pIHtcXG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcXG59XFxuXFxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcXG4gIGlmICghb2xkVm5vZGUuZGF0YS5vbiAmJiAhdm5vZGUuZGF0YS5vbikge1xcbiAgICByZXR1cm5cXG4gIH1cXG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XFxuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XFxuICBub3JtYWxpemVFdmVudHMob24pO1xcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcXG59XFxuXFxudmFyIGV2ZW50cyA9IHtcXG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcXG59O1xcblxcbi8qICAqL1xcblxcbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcXG4gIGlmICghb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyAmJiAhdm5vZGUuZGF0YS5kb21Qcm9wcykge1xcbiAgICByZXR1cm5cXG4gIH1cXG4gIHZhciBrZXksIGN1cjtcXG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XFxuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcXG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxcbiAgaWYgKHByb3BzLl9fb2JfXykge1xcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcXG4gIH1cXG5cXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XFxuICAgIGlmIChwcm9wc1trZXldID09IG51bGwpIHtcXG4gICAgICBlbG1ba2V5XSA9ICcnO1xcbiAgICB9XFxuICB9XFxuICBmb3IgKGtleSBpbiBwcm9wcykge1xcbiAgICBjdXIgPSBwcm9wc1trZXldO1xcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XFxuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cXG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cXG4gICAgfVxcblxcbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XFxuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcXG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcXG4gICAgICB2YXIgc3RyQ3VyID0gY3VyID09IG51bGwgPyAnJyA6IFN0cmluZyhjdXIpO1xcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHZub2RlLCBzdHJDdXIpKSB7XFxuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGVsbVtrZXldID0gY3VyO1xcbiAgICB9XFxuICB9XFxufVxcblxcbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxcblxcblxcbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChcXG4gIGVsbSxcXG4gIHZub2RlLFxcbiAgY2hlY2tWYWxcXG4pIHtcXG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxcbiAgICB2bm9kZS50YWcgPT09ICdvcHRpb24nIHx8XFxuICAgIGlzRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcXG4gICAgaXNJbnB1dENoYW5nZWQoZWxtLCBjaGVja1ZhbClcXG4gICkpXFxufVxcblxcbmZ1bmN0aW9uIGlzRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcXG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXMgbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXFxuICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcXG59XFxuXFxuZnVuY3Rpb24gaXNJbnB1dENoYW5nZWQgKGVsbSwgbmV3VmFsKSB7XFxuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XFxuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcXG4gIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXIpIHx8IGVsbS50eXBlID09PSAnbnVtYmVyJykge1xcbiAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXFxuICB9XFxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy50cmltKSB7XFxuICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcXG4gIH1cXG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXFxufVxcblxcbnZhciBkb21Qcm9wcyA9IHtcXG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXFxufTtcXG5cXG4vKiAgKi9cXG5cXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcXG4gIHZhciByZXMgPSB7fTtcXG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcXFwpKS9nO1xcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcXG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xcbiAgICBpZiAoaXRlbSkge1xcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcXG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgcmV0dXJuIHJlc1xcbn0pO1xcblxcbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XFxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XFxuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcXG4gICAgOiBzdHlsZVxcbn1cXG5cXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcXG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcXG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcXG4gIH1cXG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxcbiAgfVxcbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxcbn1cXG5cXG4vKipcXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXFxuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcXG4gKi9cXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcXG4gIHZhciByZXMgPSB7fTtcXG4gIHZhciBzdHlsZURhdGE7XFxuXFxuICBpZiAoY2hlY2tDaGlsZCkge1xcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XFxuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcXG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xcbiAgICAgIGlmIChjaGlsZE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSkpIHtcXG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcXG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcXG4gIH1cXG5cXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XFxuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcXG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XFxuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHJlc1xcbn1cXG5cXG4vKiAgKi9cXG5cXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcXG52YXIgaW1wb3J0YW50UkUgPSAvXFxcXHMqIWltcG9ydGFudCQvO1xcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcXG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcXG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XFxuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcXG4gIH0gZWxzZSB7XFxuICAgIGVsLnN0eWxlW25vcm1hbGl6ZShuYW1lKV0gPSB2YWw7XFxuICB9XFxufTtcXG5cXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcXG5cXG52YXIgdGVzdEVsO1xcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcXG4gIHRlc3RFbCA9IHRlc3RFbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcXG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiB0ZXN0RWwuc3R5bGUpKSB7XFxuICAgIHJldHVybiBwcm9wXFxuICB9XFxuICB2YXIgdXBwZXIgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyB1cHBlcjtcXG4gICAgaWYgKHByZWZpeGVkIGluIHRlc3RFbC5zdHlsZSkge1xcbiAgICAgIHJldHVybiBwcmVmaXhlZFxcbiAgICB9XFxuICB9XFxufSk7XFxuXFxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xcblxcbiAgaWYgKCFkYXRhLnN0YXRpY1N0eWxlICYmICFkYXRhLnN0eWxlICYmXFxuICAgICAgIW9sZERhdGEuc3RhdGljU3R5bGUgJiYgIW9sZERhdGEuc3R5bGUpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuXFxuICB2YXIgY3VyLCBuYW1lO1xcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkVm5vZGUuZGF0YS5zdGF0aWNTdHlsZTtcXG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGRWbm9kZS5kYXRhLnN0eWxlIHx8IHt9O1xcblxcbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcXG5cXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcXG5cXG4gIHZub2RlLmRhdGEuc3R5bGUgPSBzdHlsZS5fX29iX18gPyBleHRlbmQoe30sIHN0eWxlKSA6IHN0eWxlO1xcblxcbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xcblxcbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XFxuICAgIGlmIChuZXdTdHlsZVtuYW1lXSA9PSBudWxsKSB7XFxuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xcbiAgICB9XFxuICB9XFxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcXG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XFxuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XFxuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG52YXIgc3R5bGUgPSB7XFxuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxcbn07XFxuXFxuLyogICovXFxuXFxuLyoqXFxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXFxuICogU1ZHIGVsZW1lbnRzIGluIElFXFxuICovXFxuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xcbiAgICByZXR1cm5cXG4gIH1cXG5cXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXFxuICBpZiAoZWwuY2xhc3NMaXN0KSB7XFxuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcXG4gICAgICBjbHMuc3BsaXQoL1xcXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgdmFyIGN1ciA9IFxcXCIgXFxcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXFxcIiBcXFwiO1xcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcXG4gKi9cXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XFxuICAgIHJldHVyblxcbiAgfVxcblxcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcXG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xcbiAgICAgIGNscy5zcGxpdCgvXFxcXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICB2YXIgY3VyID0gXFxcIiBcXFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcXFwiIFxcXCI7XFxuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XFxuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcXG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XFxuICAgIH1cXG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1ci50cmltKCkpO1xcbiAgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XFxuICBpZiAoIWRlZiQkMSkge1xcbiAgICByZXR1cm5cXG4gIH1cXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXFxuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcXG4gICAgdmFyIHJlcyA9IHt9O1xcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcXG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcXG4gICAgfVxcbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xcbiAgICByZXR1cm4gcmVzXFxuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XFxuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXFxuICB9XFxufVxcblxcbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xcbiAgcmV0dXJuIHtcXG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcXFwiLWVudGVyXFxcIiksXFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcXFwiLWVudGVyLXRvXFxcIiksXFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXFxcIi1lbnRlci1hY3RpdmVcXFwiKSxcXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcXFwiLWxlYXZlXFxcIiksXFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcXFwiLWxlYXZlLXRvXFxcIiksXFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXFxcIi1sZWF2ZS1hY3RpdmVcXFwiKVxcbiAgfVxcbn0pO1xcblxcbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcXG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcXG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XFxuXFxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcXG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XFxudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XFxuaWYgKGhhc1RyYW5zaXRpb24pIHtcXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcXG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XFxuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcXG4gIH1cXG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XFxuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XFxuICB9XFxufVxcblxcbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxcbnZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxcbiAgOiBzZXRUaW1lb3V0O1xcblxcbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcXG4gIHJhZihmdW5jdGlvbiAoKSB7XFxuICAgIHJhZihmbik7XFxuICB9KTtcXG59XFxuXFxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XFxuICAoZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSkpLnB1c2goY2xzKTtcXG4gIGFkZENsYXNzKGVsLCBjbHMpO1xcbn1cXG5cXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcXG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcXG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcXG4gIH1cXG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xcbn1cXG5cXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxcbiAgZWwsXFxuICBleHBlY3RlZFR5cGUsXFxuICBjYlxcbikge1xcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcXG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XFxuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcXG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XFxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XFxuICB2YXIgZW5kZWQgPSAwO1xcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xcbiAgICBjYigpO1xcbiAgfTtcXG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XFxuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcXG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcXG4gICAgICAgIGVuZCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcXG4gICAgICBlbmQoKTtcXG4gICAgfVxcbiAgfSwgdGltZW91dCArIDEpO1xcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xcbn1cXG5cXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxcXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XFxuXFxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcXG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XFxuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcXG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XFxuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcXG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcXG5cXG4gIHZhciB0eXBlO1xcbiAgdmFyIHRpbWVvdXQgPSAwO1xcbiAgdmFyIHByb3BDb3VudCA9IDA7XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcXG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcXG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcXG4gICAgfVxcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcXG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XFxuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XFxuICAgICAgICA/IFRSQU5TSVRJT05cXG4gICAgICAgIDogQU5JTUFUSU9OXFxuICAgICAgOiBudWxsO1xcbiAgICBwcm9wQ291bnQgPSB0eXBlXFxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXFxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcXG4gICAgICA6IDA7XFxuICB9XFxuICB2YXIgaGFzVHJhbnNmb3JtID1cXG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcXG4gIHJldHVybiB7XFxuICAgIHR5cGU6IHR5cGUsXFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XFxuICB9XFxuXFxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxcbiAgfSkpXFxufVxcblxcbmZ1bmN0aW9uIHRvTXMgKHMpIHtcXG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxcbn1cXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcXG4gIHZhciBlbCA9IHZub2RlLmVsbTtcXG5cXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XFxuICBpZiAoZWwuX2xlYXZlQ2IpIHtcXG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcXG4gICAgZWwuX2xlYXZlQ2IoKTtcXG4gIH1cXG5cXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcXG4gIGlmICghZGF0YSkge1xcbiAgICByZXR1cm5cXG4gIH1cXG5cXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKGVsLl9lbnRlckNiIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XFxuICAgIHJldHVyblxcbiAgfVxcblxcbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XFxuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcXG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcXG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcXG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcXG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XFxuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XFxuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcXG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcXG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XFxuXFxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXFxuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXFxuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XFxuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XFxuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XFxuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcXG4gIH1cXG5cXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcXG5cXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuXFxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXFxuICAgID8gYXBwZWFyQ2xhc3NcXG4gICAgOiBlbnRlckNsYXNzO1xcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XFxuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcXG4gICAgPyBhcHBlYXJUb0NsYXNzXFxuICAgIDogZW50ZXJUb0NsYXNzO1xcblxcbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXFxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcXG4gICAgOiBiZWZvcmVFbnRlcjtcXG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXFxuICAgIDogZW50ZXI7XFxuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxcbiAgICA6IGFmdGVyRW50ZXI7XFxuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xcblxcbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxcbiAgICBpc09iamVjdChkdXJhdGlvbilcXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXFxuICAgICAgOiBkdXJhdGlvblxcbiAgKTtcXG5cXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XFxuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XFxuICB9XFxuXFxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XFxuXFxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoZXhwZWN0c0NTUykge1xcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XFxuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XFxuICAgIH1cXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XFxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xcbiAgICAgIH1cXG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XFxuICAgIH1cXG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xcbiAgfSk7XFxuXFxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcXG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxcbiAgICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxcbiAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IpIHtcXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xcbiAgICAgIH1cXG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxcbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XFxuICBpZiAoZXhwZWN0c0NTUykge1xcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcXG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcXG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XFxuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcXG4gICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcXG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XFxuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcXG4gIH1cXG5cXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xcbiAgICBjYigpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XFxuICB2YXIgZWwgPSB2bm9kZS5lbG07XFxuXFxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xcbiAgaWYgKGVsLl9lbnRlckNiKSB7XFxuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XFxuICAgIGVsLl9lbnRlckNiKCk7XFxuICB9XFxuXFxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XFxuICBpZiAoIWRhdGEpIHtcXG4gICAgcmV0dXJuIHJtKClcXG4gIH1cXG5cXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKGVsLl9sZWF2ZUNiIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XFxuICAgIHJldHVyblxcbiAgfVxcblxcbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XFxuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcXG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcXG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcXG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XFxuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcXG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XFxuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcXG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XFxuXFxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcXG5cXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXFxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxcbiAgICAgIDogZHVyYXRpb25cXG4gICk7XFxuXFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdExlYXZlRHVyYXRpb24gIT0gbnVsbCkge1xcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xcbiAgfVxcblxcbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XFxuICAgIH1cXG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcXG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XFxuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcXG4gICAgfVxcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XFxuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XFxuICAgICAgfVxcbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBybSgpO1xcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XFxuICAgIH1cXG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xcbiAgfSk7XFxuXFxuICBpZiAoZGVsYXlMZWF2ZSkge1xcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XFxuICB9IGVsc2Uge1xcbiAgICBwZXJmb3JtTGVhdmUoKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XFxuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xcbiAgICAgIHJldHVyblxcbiAgICB9XFxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcXG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcXG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbdm5vZGUua2V5XSA9IHZub2RlO1xcbiAgICB9XFxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcXG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcXG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XFxuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XFxuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcXG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XFxuICAgICAgY2IoKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XFxuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcXG4gICAgd2FybihcXG4gICAgICBcXFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFxcXCIgKyBuYW1lICsgXFxcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcXFwiICtcXG4gICAgICBcXFwiZ290IFxcXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcXFwiLlxcXCIsXFxuICAgICAgdm5vZGUuY29udGV4dFxcbiAgICApO1xcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XFxuICAgIHdhcm4oXFxuICAgICAgXFxcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcXFwiICsgbmFtZSArIFxcXCIgZHVyYXRpb24gaXMgTmFOIC0gXFxcIiArXFxuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxcbiAgICAgIHZub2RlLmNvbnRleHRcXG4gICAgKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcXG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxcbn1cXG5cXG4vKipcXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcXG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXFxuICovXFxuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcXG4gIGlmICghZm4pIHsgcmV0dXJuIGZhbHNlIH1cXG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xcbiAgaWYgKGludm9rZXJGbnMpIHtcXG4gICAgLy8gaW52b2tlclxcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXFxuICAgICAgICA/IGludm9rZXJGbnNbMF1cXG4gICAgICAgIDogaW52b2tlckZuc1xcbiAgICApXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xcbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcXG4gICAgZW50ZXIodm5vZGUpO1xcbiAgfVxcbn1cXG5cXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcXG4gIGNyZWF0ZTogX2VudGVyLFxcbiAgYWN0aXZhdGU6IF9lbnRlcixcXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcXG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJtKCk7XFxuICAgIH1cXG4gIH1cXG59IDoge307XFxuXFxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcXG4gIGF0dHJzLFxcbiAga2xhc3MsXFxuICBldmVudHMsXFxuICBkb21Qcm9wcyxcXG4gIHN0eWxlLFxcbiAgdHJhbnNpdGlvblxcbl07XFxuXFxuLyogICovXFxuXFxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xcblxcbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xcblxcbi8qKlxcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXFxuICovXFxuXFxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuaWYgKGlzSUU5KSB7XFxuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcXG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xcbiAgICB9XFxuICB9KTtcXG59XFxuXFxudmFyIG1vZGVsJDEgPSB7XFxuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xcbiAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcXG4gICAgICB9O1xcbiAgICAgIGNiKCk7XFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICAgICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XFxuICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGVsLnR5cGUgPT09ICd0ZXh0JyB8fCBlbC50eXBlID09PSAncGFzc3dvcmQnKSB7XFxuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcXG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcXG4gICAgICAgIGlmICghaXNBbmRyb2lkKSB7XFxuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICAgICAgICBpZiAoaXNJRTkpIHtcXG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH0sXFxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcXG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcXG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XFxuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxcbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxcbiAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxcbiAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgZWwub3B0aW9ucyk7IH0pXFxuICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBlbC5vcHRpb25zKTtcXG4gICAgICBpZiAobmVlZFJlc2V0KSB7XFxuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XFxuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcXG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXFxuICAgICAgXFxcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFxcXFxcIlxcXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFxcXCJcXFxcXFxcIj4gXFxcIiArXFxuICAgICAgXFxcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFxcXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxcbiAgICAgIHZtXFxuICAgICk7XFxuICAgIHJldHVyblxcbiAgfVxcbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XFxuICAgIGlmIChpc011bHRpcGxlKSB7XFxuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XFxuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcXG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcXG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XFxuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuXFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICBpZiAoIWlzTXVsdGlwbGUpIHtcXG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb25zW2ldKSwgdmFsdWUpKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB0cnVlXFxufVxcblxcbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcXG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cXG4gICAgPyBvcHRpb24uX3ZhbHVlXFxuICAgIDogb3B0aW9uLnZhbHVlXFxufVxcblxcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcXG59XFxuXFxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XFxuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcXG59XFxuXFxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcXG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcXG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcXG59XFxuXFxuLyogICovXFxuXFxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XFxuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXFxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXFxuICAgIDogdm5vZGVcXG59XFxuXFxudmFyIHNob3cgPSB7XFxuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XFxuXFxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XFxuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XFxuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcXG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XFxuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcXG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XFxuICAgIH1cXG4gIH0sXFxuXFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcXG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XFxuXFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlKSB7IHJldHVybiB9XFxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XFxuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XFxuICAgIGlmICh0cmFuc2l0aW9uICYmICFpc0lFOSkge1xcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XFxuICAgICAgaWYgKHZhbHVlKSB7XFxuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xcbiAgICB9XFxuICB9LFxcblxcbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxcbiAgICBlbCxcXG4gICAgYmluZGluZyxcXG4gICAgdm5vZGUsXFxuICAgIG9sZFZub2RlLFxcbiAgICBpc0Rlc3Ryb3lcXG4gICkge1xcbiAgICBpZiAoIWlzRGVzdHJveSkge1xcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XFxuICBtb2RlbDogbW9kZWwkMSxcXG4gIHNob3c6IHNob3dcXG59O1xcblxcbi8qICAqL1xcblxcbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXFxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXFxuXFxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcXG4gIG5hbWU6IFN0cmluZyxcXG4gIGFwcGVhcjogQm9vbGVhbixcXG4gIGNzczogQm9vbGVhbixcXG4gIG1vZGU6IFN0cmluZyxcXG4gIHR5cGU6IFN0cmluZyxcXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cXG59O1xcblxcbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxcbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcXG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcXG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiB2bm9kZVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcXG4gIHZhciBkYXRhID0ge307XFxuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XFxuICAvLyBwcm9wc1xcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XFxuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcXG4gIH1cXG4gIC8vIGV2ZW50cy5cXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcXG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xcbiAgfVxcbiAgcmV0dXJuIGRhdGFcXG59XFxuXFxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XFxuICByZXR1cm4gL1xcXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZylcXG4gICAgPyBoKCdrZWVwLWFsaXZlJylcXG4gICAgOiBudWxsXFxufVxcblxcbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XFxuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XFxuICAgICAgcmV0dXJuIHRydWVcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XFxuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcXG59XFxuXFxudmFyIFRyYW5zaXRpb24gPSB7XFxuICBuYW1lOiAndHJhbnNpdGlvbicsXFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxcbiAgYWJzdHJhY3Q6IHRydWUsXFxuXFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcXG4gICAgaWYgKCFjaGlsZHJlbikge1xcbiAgICAgIHJldHVyblxcbiAgICB9XFxuXFxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXFxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZzsgfSk7XFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xcbiAgICAgIHJldHVyblxcbiAgICB9XFxuXFxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xcbiAgICAgIHdhcm4oXFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcXG4gICAgICAgIHRoaXMuJHBhcmVudFxcbiAgICAgICk7XFxuICAgIH1cXG5cXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XFxuXFxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXFxuICAgICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nKSB7XFxuICAgICAgd2FybihcXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcXG4gICAgICAgIHRoaXMuJHBhcmVudFxcbiAgICAgICk7XFxuICAgIH1cXG5cXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XFxuXFxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXFxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xcbiAgICAgIHJldHVybiByYXdDaGlsZFxcbiAgICB9XFxuXFxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXFxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICBpZiAoIWNoaWxkKSB7XFxuICAgICAgcmV0dXJuIHJhd0NoaWxkXFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcXG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXFxuICAgIH1cXG5cXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXFxuICAgIHZhciBpZCA9IFxcXCJfX3RyYW5zaXRpb24tXFxcIiArICh0aGlzLl91aWQpICsgXFxcIi1cXFwiO1xcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxcbiAgICAgID8gaWQgKyBjaGlsZC50YWdcXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXFxuICAgICAgICA6IGNoaWxkLmtleTtcXG5cXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcXG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XFxuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XFxuXFxuICAgIC8vIG1hcmsgdi1zaG93XFxuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcXG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xcbiAgICB9XFxuXFxuICAgIGlmIChvbGRDaGlsZCAmJiBvbGRDaGlsZC5kYXRhICYmICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpKSB7XFxuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXFxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQgJiYgKG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSkpO1xcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcXG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XFxuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XFxuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcXG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XFxuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcXG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcXG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XFxuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiByYXdDaGlsZFxcbiAgfVxcbn07XFxuXFxuLyogICovXFxuXFxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxcbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxcblxcbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFxcXCJ1bnN0YWJsZVxcXCIgLSBpLmUuXFxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3NlczpcXG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXFxuXFxudmFyIHByb3BzID0gZXh0ZW5kKHtcXG4gIHRhZzogU3RyaW5nLFxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xcblxcbmRlbGV0ZSBwcm9wcy5tb2RlO1xcblxcbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XFxuICBwcm9wczogcHJvcHMsXFxuXFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcXG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xcbiAgICAgIGlmIChjLnRhZykge1xcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcXG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcXG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcXG4gICAgICAgICAgd2FybigoXFxcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XFxcIiArIG5hbWUgKyBcXFwiPlxcXCIpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xcbiAgICAgIHZhciBrZXB0ID0gW107XFxuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcXG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcXG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcXG4gIH0sXFxuXFxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XFxuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcXG4gICAgdGhpcy5fX3BhdGNoX18oXFxuICAgICAgdGhpcy5fdm5vZGUsXFxuICAgICAgdGhpcy5rZXB0LFxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcXG4gICAgKTtcXG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XFxuICB9LFxcblxcbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XFxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xcbiAgICAgIHJldHVyblxcbiAgICB9XFxuXFxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XFxuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xcblxcbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xcbiAgICB2YXIgZiA9IGJvZHkub2Zmc2V0SGVpZ2h0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXFxuXFxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcXG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XFxuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcXG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XFxuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XFxuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcXG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XFxuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XFxuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfSxcXG5cXG4gIG1ldGhvZHM6IHtcXG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlXFxuICAgICAgfVxcbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlICE9IG51bGwpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXFxuICAgICAgfVxcbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcXG4gICAgICAvLyBpcyBhcHBsaWVkLlxcbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcXG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xcbiAgICAgIH1cXG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcXG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcXG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcXG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XFxuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXFxuICAgIH1cXG4gIH1cXG59O1xcblxcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XFxuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcXG4gIH1cXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XFxuICAgIGMuZWxtLl9lbnRlckNiKCk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XFxuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxufVxcblxcbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcXG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XFxuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XFxuICBpZiAoZHggfHwgZHkpIHtcXG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcXG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcXG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFxcXCJ0cmFuc2xhdGUoXFxcIiArIGR4ICsgXFxcInB4LFxcXCIgKyBkeSArIFxcXCJweClcXFwiO1xcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XFxuICB9XFxufVxcblxcbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XFxuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcXG59O1xcblxcbi8qICAqL1xcblxcbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcXG5WdWUkMi5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcXG5WdWUkMi5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XFxuVnVlJDIuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcXG5WdWUkMi5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XFxuXFxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXFxuZXh0ZW5kKFZ1ZSQyLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcXG5leHRlbmQoVnVlJDIub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xcblxcbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cXG5WdWUkMi5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xcblxcbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcXG5WdWUkMi5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxcbiAgZWwsXFxuICBoeWRyYXRpbmdcXG4pIHtcXG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXFxufTtcXG5cXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXFxuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XFxuICAgIGlmIChkZXZ0b29scykge1xcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMik7XFxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0Nocm9tZSkge1xcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcXFxuJyArXFxuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcXG4gICAgICApO1xcbiAgICB9XFxuICB9XFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxcbiAgICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXFxuICAgICAgXFxcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXFxcblxcXCIgK1xcbiAgICAgIFxcXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxcXG5cXFwiICtcXG4gICAgICBcXFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcXFwiXFxuICAgICk7XFxuICB9XFxufSwgMCk7XFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1xcXCJhXFxcIl0gPSAoVnVlJDIpO1xcblxcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxKSkpLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5kbFluQmhZMnM2THk4dkxpOStMeTVmZG5WbFFESXVNaTQyUUhaMVpTOWthWE4wTDNaMVpTNXlkVzUwYVcxbExtVnpiUzVxY3o4d1ptRTRJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2FVSkJRV2xDTEdsQ1FVRnBRanRCUVVOc1F6dEJRVU5CTzBGQlEwRTdRVUZEUVN4elFrRkJjMElzSzBKQlFTdENPMEZCUTNKRUxITkNRVUZ6UWl4cFFrRkJhVUk3UVVGRGRrTTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2EwUkJRV3RFTEdsRFFVRnBReXhGUVVGRk8wRkJRM0pHTEVOQlFVTTdPMEZCUlVRN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVOQlFVTTdPMEZCUlVRN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1EwRkJRenM3UVVGRlJEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hwUWtGQmFVSXNaMEpCUVdkQ08wRkJRMnBETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHpRa0ZCYzBJc1kwRkJZenM3UVVGRmNFTTdRVUZEUVR0QlFVTkJPMEZCUTBFc05rSkJRVFpDTEZWQlFWVTdPMEZCUlhaRE8wRkJRMEU3UVVGRFFUczdPMEZCUjBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJMR2xDUVVGcFFpeG5Ra0ZCWjBJN1FVRkRha01zYTBOQlFXdERPMEZCUTJ4RE8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJMR3REUVVGclF6czdRVUZGYkVNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNiVUpCUVcxQ0xIRkNRVUZ4UWp0QlFVTjRReXhwUWtGQmFVSTdRVUZEYWtJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3h0UWtGQmJVSXNiVUpCUVcxQ08wRkJRM1JETzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3h0UTBGQmJVTXNiMEpCUVc5Q08wRkJRM1pFTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYTBKQlFXdENMR3RDUVVGclFqdEJRVU53UXp0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeGxRVUZsTEdOQlFXTTdRVUZETjBJc2NVSkJRWEZDTEdWQlFXVTdRVUZEY0VNc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1QwRkJUenRCUVVOUU8wRkJRMEU3UVVGRFFTeERRVUZET3p0QlFVVkVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeERRVUZETzBGQlEwUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTEVkQlFVYzdRVUZEU0RzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2FVTkJRV2xETzBGQlEycERMSFZEUVVGMVF5eDNRa0ZCZDBJc1JVRkJSVHRCUVVOcVJTd3dRa0ZCTUVJN08wRkJSVEZDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCT3pzN1FVRkhRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4clEwRkJhME1zVDBGQlR6dEJRVU42UXp0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQkxHMUNRVUZ0UWl3NFFrRkJPRUk3UVVGRGFrUTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFTdzJRMEZCTmtNN1FVRkROME03UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYlVKQlFXMUNMREpDUVVFeVFqdEJRVU01UXp0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGdzUTBGQlF6czdRVUZGUkRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHbENRVUZwUWl4cFFrRkJhVUk3UVVGRGJFTTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNiVU5CUVcxRExFOUJRVTg3UVVGRE1VTTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHJRMEZCYTBNc1QwRkJUenRCUVVONlF6dEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFOUJRVTg3UVVGRFVEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4cFJFRkJhVVFzVDBGQlR6dEJRVU40UkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHTkJRV003UVVGRFpEdEJRVU5CTzBGQlEwRXNhVUpCUVdsQ0xHbENRVUZwUWp0QlFVTnNRenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1QwRkJUenRCUVVOUU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hEUVVGRE96dEJRVVZFTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeERRVUZET3p0QlFVVkVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4clFrRkJhMEk3UVVGRGJFSXNiVUpCUVcxQ08wRkJRMjVDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2EwSkJRV3RDTzBGQlEyeENMRzFDUVVGdFFqdEJRVU51UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hsUVVGbE8wRkJRMlk3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxIRkNRVUZ4UWp0QlFVTnlRaXhQUVVGUE8wRkJRMUE3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFhRVUZYTzBGQlExZzdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzY1VKQlFYRkNPMEZCUTNKQ08wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxEUkRRVUUwUXl4UFFVRlBPMEZCUTI1RU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMREpDUVVFeVFqdEJRVU16UWp0QlFVTkJMRzlEUVVGdlF6dEJRVU53UXp0QlFVTkJMSEZEUVVGeFF6dEJRVU55UXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVSkJRVzFDTERKQ1FVRXlRanRCUVVNNVF6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4clEwRkJhME1zVTBGQlV6dEJRVU16UXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1UwRkJVenRCUVVOVU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc01rSkJRVEpDTEhWQ1FVRjFRanRCUVVOc1JEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQkxEQkNRVUV3UWl4VlFVRlZPenRCUVVWd1F6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4cFFrRkJhVUlzVTBGQlV6dEJRVU14UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJMSFZEUVVGMVF6dEJRVU4yUXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNRMEZCUXpzN1FVRkZSRHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJMSEZDUVVGeFFpeG5Ra0ZCWjBJN1FVRkRja003UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHbENRVUZwUWl4eFFrRkJjVUk3UVVGRGRFTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzWVVGQllTeHhRa0ZCY1VJN1FVRkRiRU03UVVGRFFTdzRRMEZCT0VNN1FVRkRPVU03UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQkxFOUJRVTg3UVVGRFVEdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQkxFOUJRVTg3UVVGRFVEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQkxHMUVRVUZ0UkN4blEwRkJaME1zUlVGQlJUdEJRVU55UmpzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzSzBOQlFTdERPMEZCUXk5RE96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeDFRMEZCZFVNc1QwRkJUenRCUVVNNVF6dEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4NVEwRkJlVU1zVTBGQlV6dEJRVU5zUkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4eFEwRkJjVU1zVDBGQlR6dEJRVU0xUXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHpRMEZCYzBNc1QwRkJUenRCUVVNM1F6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVDBGQlR6dEJRVU5RTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHbENRVUZwUWl4blFrRkJaMEk3UVVGRGFrTTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4UFFVRlBPMEZCUTFBN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJMREJDUVVFd1FqdEJRVU14UWl4clFrRkJhMEk3UVVGRGJFSTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3h0UWtGQmJVSXNjVUpCUVhGQ08wRkJRM2hETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeDFRa0ZCZFVJN1FVRkRka0k3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHMUNRVUZ0UWl4NVFrRkJlVUk3UVVGRE5VTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHRRa0ZCYlVJc2VVSkJRWGxDTzBGQlF6VkRPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2QwTkJRWGRETEU5QlFVODdRVUZETDBNN1FVRkRRVHRCUVVOQkxFOUJRVTg3UVVGRFVEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCT3pzN1FVRkhRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxEaENRVUU0UWl4dlFrRkJiMElzUlVGQlJUczdRVUZGY0VRN1FVRkRRVHRCUVVOQkxHbENRVUZwUWl4elFrRkJjMEk3UVVGRGRrTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFTeHZRa0ZCYjBJN1FVRkRjRUk3UVVGRFFTeDVRa0ZCZVVJN1FVRkRla0k3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZOQlFWTTdRVUZEVkR0QlFVTkJPMEZCUTBFc1QwRkJUenRCUVVOUU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHbENRVUZwUWl4NVFrRkJlVUk3UVVGRE1VTXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRU3hwUWtGQmFVSXNLMEpCUVN0Q08wRkJRMmhFTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4dFFrRkJiVUlzTWtKQlFUSkNPMEZCUXpsRExIRkNRVUZ4UWl3clFrRkJLMEk3UVVGRGNFUTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTQ3g1UWtGQmVVSTdRVUZEZWtJN1FVRkRRU3h6UWtGQmMwSXNhVU5CUVdsRE8wRkJRM1pFTEcxQ1FVRnRRaXd5UWtGQk1rSTdRVUZET1VNN08wRkJSVUVzYzBKQlFYTkNPenRCUVVWMFFqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4UFFVRlBPMEZCUTFBc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFc09FSkJRVGhDT3p0QlFVVTVRanRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzY1VKQlFYRkNMRzlDUVVGdlFqdEJRVU42UXp0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRFpDUVVFMlFqdEJRVU0zUWp0QlFVTkJMRGhDUVVFNFFqdEJRVU01UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTERoQ1FVRTRRanRCUVVNNVFqdEJRVU5CTzBGQlEwRXNSMEZCUnpzN1FVRkZTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3TzBGQlJVZzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdPMEZCUlVnN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFBRVUZQTzBGQlExQTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4UFFVRlBPMEZCUTFBN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMR2xEUVVGcFF5eHJSRUZCYTBRN1FVRkRia1k3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMSGRDUVVGM1FpeDNRMEZCZDBNN1FVRkRhRVVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVR0QlFVTkJMSEZEUVVGeFF6dEJRVU55UXp0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxIVkRRVUYxUXl4UFFVRlBPMEZCUXpsRE8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHBRa0ZCYVVJc2VVSkJRWGxDTzBGQlF6RkRPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3huUlVGQlowVXNLMEpCUVN0Q08wRkJReTlHTEcxRFFVRnRRenRCUVVOdVF6dEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMSGRDUVVGM1FpeHpRMEZCYzBNN1FVRkRPVVE3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzZDBKQlFYZENPMEZCUTNoQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeGhRVUZoTEc5Q1FVRnZRanRCUVVOcVF6dEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3c0UTBGQk9FTXNUMEZCVHp0QlFVTnlSRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEN0Q1FVRXJRaXhQUVVGUE8wRkJRM1JETzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRU3hsUVVGbExGTkJRVk03UVVGRGVFSTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEVzWjBOQlFXZERMRTlCUVU4N1FVRkRka003UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNjVUpCUVhGQ08wRkJRM0pDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZOQlFWTTdRVUZEVkR0QlFVTkJPMEZCUTBFc2EwUkJRV3RFTzBGQlEyeEVMRFJEUVVFMFF6dEJRVU0xUXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3h0UWtGQmJVSXNhVUpCUVdsQ08wRkJRM0JETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFc2JVSkJRVzFDTzBGQlEyNUNMRzFDUVVGdFFqdEJRVU51UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4cFEwRkJhVU1zTmtOQlFUWkRPMEZCUXpsRk8wRkJRMEU3UVVGRFFTdzJRMEZCTmtNc05FTkJRVFJETzBGQlEzcEdPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFOUJRVTg3UVVGRFVEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeGhRVUZoTzBGQlEySXNWMEZCVnp0QlFVTllPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJMRzFDUVVGdFFpeHBRa0ZCYVVJN1FVRkRjRU03UVVGRFFUczdRVUZGUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFUdEJRVU5CTEhGQ1FVRnhRanRCUVVOeVFqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxIVkNRVUYxUWp0QlFVTjJRanRCUVVOQkxHOUNRVUZ2UWp0QlFVTndRanM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEhOQ1FVRnpRaXhsUVVGbE8wRkJRM0pETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVSkJRVzFDTEcxQ1FVRnRRanRCUVVOMFF6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEhORlFVRnpSVHRCUVVOMFJUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEdsRFFVRnBRenM3UVVGRmFrTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4UFFVRlBPMEZCUTFBN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEhkQ1FVRjNRanRCUVVONFFqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU96dEJRVVZCT3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnpzN1FVRkZTRHRCUVVOQk8wRkJRMEVzUjBGQlJ6czdRVUZGU0R0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdPMEZCUlVnN1FVRkRRVHRCUVVOQkxEaERRVUU0UXl3eVFrRkJNa0lzUlVGQlJUdEJRVU16UlN4TFFVRkxPMEZCUTB3N1FVRkRRU3c0UTBGQk9FTXNORUpCUVRSQ0xFVkJRVVU3UVVGRE5VVTdRVUZEUVN4SFFVRkhPenRCUVVWSU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVDBGQlR6dEJRVU5RTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN3clFrRkJLMElzWlVGQlpUdEJRVU01UXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenM3UVVGRlNEdEJRVU5CTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRXNRMEZCUXpzN1FVRkZSRHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2NVTkJRWEZETEU5QlFVODdRVUZETlVNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3gxUWtGQmRVSXNhMEpCUVd0Q08wRkJRM3BETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenM3TzBGQlNVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN08wRkJSMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4RFFVRkRPenRCUVVWRU96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4aFFVRmhPenRCUVVWaU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVR0QlFVTkJMRTlCUVU4N1FVRkRVRHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFc1owTkJRV2RET3p0QlFVVm9RenM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNNRUpCUVRCQ08wRkJRekZDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNiMEpCUVc5Q0xHRkJRV0U3UVVGRGFrTTdRVUZEUVN4eFFrRkJjVUlzWTBGQll6dEJRVU51UXp0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUVzWVVGQllTeHJRa0ZCYTBJN1FVRkRMMEk3UVVGRFFTeGxRVUZsTEc5Q1FVRnZRanRCUVVOdVF6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEVzTWtSQlFUSkVPMEZCUXpORU96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFc2FVTkJRV2xETzBGQlEycERPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVSkJRVzFDTEhsQ1FVRjVRanRCUVVNMVF6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFOUJRVTg3UVVGRFVEdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzY1VKQlFYRkNMSEZDUVVGeFFqdEJRVU14UXp0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVN4eFFrRkJjVUlzZVVKQlFYbENPMEZCUXpsRE8wRkJRMEU3UVVGRFFTeDNRa0ZCZDBJN1FVRkRlRUk3UVVGRFFTdzBRa0ZCTkVJc05FSkJRVFJDTzBGQlEzaEVMRFJDUVVFMFFpeG5RMEZCWjBNN1FVRkROVVE3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQkxGVkJRVlVzYjBKQlFXOUNPMEZCUXpsQ08wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxIbEVRVUY1UkN4VlFVRlZPMEZCUTI1RkxHbENRVUZwUWl4M1FrRkJkMElzVDBGQlR5eDFRa0ZCZFVJN1FVRkRka1U3UVVGRFFUdEJRVU5CTEdsQ1FVRnBRaXd5UWtGQk1rSTdRVUZETlVNN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVN4VlFVRlZMRzlDUVVGdlFqdEJRVU01UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVTBGQlV5eFBRVUZQTzBGQlEyaENPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFBRVUZQTzBGQlExQTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHBRa0ZCYVVJc2RVSkJRWFZDTzBGQlEzaERPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVDBGQlR6dEJRVU5RTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN3MlEwRkJOa003UVVGRE4wTXNUMEZCVHp0QlFVTlFPMEZCUTBFc1QwRkJUenRCUVVOUU8wRkJRMEU3UVVGRFFUdEJRVU5CTEU5QlFVODdRVUZEVUR0QlFVTkJPMEZCUTBFN1FVRkRRU3hQUVVGUExHdEVRVUZyUkR0QlFVTjZSRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEU5QlFVOHNhMFJCUVd0RU8wRkJRM3BFTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1QwRkJUenRCUVVOUUxHMURRVUZ0UXl4blJVRkJaMFU3UVVGRGJrYzdRVUZEUVN4blEwRkJaME03UVVGRGFFTTdRVUZEUVR0QlFVTkJMRk5CUVZNN1FVRkRWRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZkQlFWYzdRVUZEV0R0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHBRa0ZCYVVJc2RVSkJRWFZDTEU5QlFVOHNaME5CUVdkRE8wRkJReTlGTEhkRVFVRjNSQ3h2UWtGQmIwSTdRVUZETlVVN1FVRkRRVHRCUVVOQk8wRkJRMEVzTWtKQlFUSkNMR2RGUVVGblJUdEJRVU16Uml4UFFVRlBPMEZCUTFBc2JVTkJRVzFETEdsRFFVRnBRenRCUVVOd1JUdEJRVU5CTEU5QlFVODdRVUZEVUR0QlFVTkJMRTlCUVU4N1FVRkRVRHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVR0QlFVTkJMREpFUVVFeVJDeHZRa0ZCYjBJN1FVRkRMMFU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTEhGQ1FVRnhRaXhyUWtGQmEwSTdRVUZEZGtNN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNjMFJCUVhORUxHZERRVUZuUXp0QlFVTjBSanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVTBGQlV6dEJRVU5VTzBGQlEwRTdRVUZEUVN3eVFrRkJNa0lzZFVKQlFYVkNPMEZCUTJ4RU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJMRFJDUVVFMFFpdzJRa0ZCTmtJN1FVRkRla1E3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVDBGQlR6dEJRVU5RTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMR0ZCUVdFN1FVRkRZanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3d5UWtGQk1rSXNkVUpCUVhWQ08wRkJRMnhFTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeFRRVUZUTzBGQlExUTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFc2NVSkJRWEZDTERKQ1FVRXlRanRCUVVOb1JEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRFpFUVVFMlJEdEJRVU0zUkN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRXNNa1JCUVRKRU8wRkJRek5FTEhGQ1FVRnhRaXc0UWtGQk9FSTdRVUZEYmtRN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzWVVGQllTeHBRa0ZCYVVJN1FVRkRPVUk3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRXNORVZCUVRSRk8wRkJRelZGT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMSGREUVVGM1F6dEJRVU40UXpzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRTlCUVU4N1FVRkRVRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdPenM3UVVGSlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenM3UVVGSFFUdEJRVU5CTzBGQlEwRTdPenRCUVVkQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzTWtKQlFUSkNPMEZCUXpOQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxESkRRVUV5UXp0QlFVTXpRenM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNNa0pCUVRKQ0xESkNRVUV5UWp0QlFVTjBSQ3hyUTBGQmEwTTdRVUZEYkVNN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96czdRVUZIUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hyUTBGQmEwTTdRVUZEYkVNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzZDBKQlFYZENPMEZCUTNoQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQkxFTkJRVU03TzBGQlJVUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHBRa0ZCYVVJc2NVSkJRWEZDTzBGQlEzUkRPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeERRVUZET3p0QlFVVkVPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTERaRFFVRTJRenM3UVVGRk4wTTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxEWkRRVUUyUXl3MFFrRkJORUlzUlVGQlJUdEJRVU16UlN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRFpEUVVFMlF5d3JRa0ZCSzBJc1JVRkJSVHRCUVVNNVJTeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNRMEZCUXpzN1FVRkZSRHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1kwRkJZenRCUVVOa08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdPMEZCUlVnN1FVRkRRVHRCUVVOQkxESkVRVUV5UkR0QlFVTXpSRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4VFFVRlRPMEZCUTFRN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE96dEJRVVZJTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxEWkVRVUUyUkR0QlFVTTNSRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVjBGQlZ6dEJRVU5ZTzBGQlEwRTdRVUZEUVR0QlFVTkJMRTlCUVU4N1FVRkRVRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZsQlFWazdRVUZEV2p0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CTEVOQlFVTTdPMEZCUlVRN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFc2FVTkJRV2xETEhGRFFVRnhRenM3UVVGRmRFVTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNNa05CUVRKRExESkRRVUV5UXl4RlFVRkZPMEZCUTNoR08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEhkRFFVRjNReXhQUVVGUE8wRkJReTlETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRU3h4UTBGQmNVTXNUMEZCVHp0QlFVTTFRenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFBRVUZQTzBGQlExQXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRU3hIUVVGSE96dEJRVVZJTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQkxEWkNRVUUyUWp0QlFVTTNRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRk5CUVZNN1FVRkRWQ3hQUVVGUE8wRkJRMUE3UVVGRFFUdEJRVU5CTEZOQlFWTTdRVUZEVkR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEVzUjBGQlJ6czdRVUZGU0R0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFTdzJRMEZCTmtNc1kwRkJZeXhGUVVGRk8wRkJRemRFTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRXNPRU5CUVRoRE8wRkJRemxETzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxEQkZRVUV3UlN3d1FrRkJNRUlzUlVGQlJUdEJRVU4wUnp0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEhGRlFVRnhSVHRCUVVOeVJUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGTkJRVk03UVVGRFZEdEJRVU5CTEU5QlFVODdRVUZEVUR0QlFVTkJMSGREUVVGM1F5eG5Ra0ZCWjBJN1FVRkRlRVE3UVVGRFFUdEJRVU5CTEdkRlFVRm5SU3h6UWtGQmMwSXNSVUZCUlR0QlFVTjRSanRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzZFVOQlFYVkRPMEZCUTNaRE8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1EwRkJRenM3UVVGRlJEczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQkxHMUNRVUZ0UWl4M1FrRkJkMEk3UVVGRE0wTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGZEJRVmNzZFVKQlFYVkNPMEZCUTJ4RExGTkJRVk03UVVGRFZEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNkVUpCUVhWQ0xESkNRVUV5UWp0QlFVTnNSRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNVMEZCVXp0QlFVTlVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJMRWRCUVVjN08wRkJSVWc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6czdRVUZGU0R0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRXNPRUpCUVRoQ096dEJRVVU1UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hUUVVGVE8wRkJRMVE3UVVGRFFTeExRVUZMTzBGQlEwd3NSMEZCUnpzN1FVRkZTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMSE5FUVVGelJDeDVRa0ZCZVVJc1JVRkJSVHRCUVVOcVJqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNRMEZCUXpzN1FVRkZSQ0lzSW1acGJHVWlPaUkwTG1weklpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lMeW9oWEc0Z0tpQldkV1V1YW5NZ2RqSXVNaTQyWEc0Z0tpQW9ZeWtnTWpBeE5DMHlNREUzSUVWMllXNGdXVzkxWEc0Z0tpQlNaV3hsWVhObFpDQjFibVJsY2lCMGFHVWdUVWxVSUV4cFkyVnVjMlV1WEc0Z0tpOWNiaThxSUNBcUwxeHVYRzR2S2lwY2JpQXFJRU52Ym5abGNuUWdZU0IyWVd4MVpTQjBieUJoSUhOMGNtbHVaeUIwYUdGMElHbHpJR0ZqZEhWaGJHeDVJSEpsYm1SbGNtVmtMbHh1SUNvdlhHNW1kVzVqZEdsdmJpQmZkRzlUZEhKcGJtY2dLSFpoYkNrZ2UxeHVJQ0J5WlhSMWNtNGdkbUZzSUQwOUlHNTFiR3hjYmlBZ0lDQS9JQ2NuWEc0Z0lDQWdPaUIwZVhCbGIyWWdkbUZzSUQwOVBTQW5iMkpxWldOMEoxeHVJQ0FnSUNBZ1B5QktVMDlPTG5OMGNtbHVaMmxtZVNoMllXd3NJRzUxYkd3c0lESXBYRzRnSUNBZ0lDQTZJRk4wY21sdVp5aDJZV3dwWEc1OVhHNWNiaThxS2x4dUlDb2dRMjl1ZG1WeWRDQmhJR2x1Y0hWMElIWmhiSFZsSUhSdklHRWdiblZ0WW1WeUlHWnZjaUJ3WlhKemFYTjBaVzVqWlM1Y2JpQXFJRWxtSUhSb1pTQmpiMjUyWlhKemFXOXVJR1poYVd4ekxDQnlaWFIxY200Z2IzSnBaMmx1WVd3Z2MzUnlhVzVuTGx4dUlDb3ZYRzVtZFc1amRHbHZiaUIwYjA1MWJXSmxjaUFvZG1Gc0tTQjdYRzRnSUhaaGNpQnVJRDBnY0dGeWMyVkdiRzloZENoMllXd3BPMXh1SUNCeVpYUjFjbTRnYVhOT1lVNG9iaWtnUHlCMllXd2dPaUJ1WEc1OVhHNWNiaThxS2x4dUlDb2dUV0ZyWlNCaElHMWhjQ0JoYm1RZ2NtVjBkWEp1SUdFZ1puVnVZM1JwYjI0Z1ptOXlJR05vWldOcmFXNW5JR2xtSUdFZ2EyVjVYRzRnS2lCcGN5QnBiaUIwYUdGMElHMWhjQzVjYmlBcUwxeHVablZ1WTNScGIyNGdiV0ZyWlUxaGNDQW9YRzRnSUhOMGNpeGNiaUFnWlhod1pXTjBjMHh2ZDJWeVEyRnpaVnh1S1NCN1hHNGdJSFpoY2lCdFlYQWdQU0JQWW1wbFkzUXVZM0psWVhSbEtHNTFiR3dwTzF4dUlDQjJZWElnYkdsemRDQTlJSE4wY2k1emNHeHBkQ2duTENjcE8xeHVJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUd4cGMzUXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0J0WVhCYmJHbHpkRnRwWFYwZ1BTQjBjblZsTzF4dUlDQjlYRzRnSUhKbGRIVnliaUJsZUhCbFkzUnpURzkzWlhKRFlYTmxYRzRnSUNBZ1B5Qm1kVzVqZEdsdmJpQW9kbUZzS1NCN0lISmxkSFZ5YmlCdFlYQmJkbUZzTG5SdlRHOTNaWEpEWVhObEtDbGRPeUI5WEc0Z0lDQWdPaUJtZFc1amRHbHZiaUFvZG1Gc0tTQjdJSEpsZEhWeWJpQnRZWEJiZG1Gc1hUc2dmVnh1ZlZ4dVhHNHZLaXBjYmlBcUlFTm9aV05ySUdsbUlHRWdkR0ZuSUdseklHRWdZblZwYkhRdGFXNGdkR0ZuTGx4dUlDb3ZYRzUyWVhJZ2FYTkNkV2xzZEVsdVZHRm5JRDBnYldGclpVMWhjQ2duYzJ4dmRDeGpiMjF3YjI1bGJuUW5MQ0IwY25WbEtUdGNibHh1THlvcVhHNGdLaUJTWlcxdmRtVWdZVzRnYVhSbGJTQm1jbTl0SUdGdUlHRnljbUY1WEc0Z0tpOWNibVoxYm1OMGFXOXVJSEpsYlc5MlpTQW9ZWEp5TENCcGRHVnRLU0I3WEc0Z0lHbG1JQ2hoY25JdWJHVnVaM1JvS1NCN1hHNGdJQ0FnZG1GeUlHbHVaR1Y0SUQwZ1lYSnlMbWx1WkdWNFQyWW9hWFJsYlNrN1hHNGdJQ0FnYVdZZ0tHbHVaR1Y0SUQ0Z0xURXBJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQmhjbkl1YzNCc2FXTmxLR2x1WkdWNExDQXhLVnh1SUNBZ0lIMWNiaUFnZlZ4dWZWeHVYRzR2S2lwY2JpQXFJRU5vWldOcklIZG9aWFJvWlhJZ2RHaGxJRzlpYW1WamRDQm9ZWE1nZEdobElIQnliM0JsY25SNUxseHVJQ292WEc1MllYSWdhR0Z6VDNkdVVISnZjR1Z5ZEhrZ1BTQlBZbXBsWTNRdWNISnZkRzkwZVhCbExtaGhjMDkzYmxCeWIzQmxjblI1TzF4dVpuVnVZM1JwYjI0Z2FHRnpUM2R1SUNodlltb3NJR3RsZVNrZ2UxeHVJQ0J5WlhSMWNtNGdhR0Z6VDNkdVVISnZjR1Z5ZEhrdVkyRnNiQ2h2WW1vc0lHdGxlU2xjYm4xY2JseHVMeW9xWEc0Z0tpQkRhR1ZqYXlCcFppQjJZV3gxWlNCcGN5QndjbWx0YVhScGRtVmNiaUFxTDF4dVpuVnVZM1JwYjI0Z2FYTlFjbWx0YVhScGRtVWdLSFpoYkhWbEtTQjdYRzRnSUhKbGRIVnliaUIwZVhCbGIyWWdkbUZzZFdVZ1BUMDlJQ2R6ZEhKcGJtY25JSHg4SUhSNWNHVnZaaUIyWVd4MVpTQTlQVDBnSjI1MWJXSmxjaWRjYm4xY2JseHVMeW9xWEc0Z0tpQkRjbVZoZEdVZ1lTQmpZV05vWldRZ2RtVnljMmx2YmlCdlppQmhJSEIxY21VZ1puVnVZM1JwYjI0dVhHNGdLaTljYm1aMWJtTjBhVzl1SUdOaFkyaGxaQ0FvWm00cElIdGNiaUFnZG1GeUlHTmhZMmhsSUQwZ1QySnFaV04wTG1OeVpXRjBaU2h1ZFd4c0tUdGNiaUFnY21WMGRYSnVJQ2htZFc1amRHbHZiaUJqWVdOb1pXUkdiaUFvYzNSeUtTQjdYRzRnSUNBZ2RtRnlJR2hwZENBOUlHTmhZMmhsVzNOMGNsMDdYRzRnSUNBZ2NtVjBkWEp1SUdocGRDQjhmQ0FvWTJGamFHVmJjM1J5WFNBOUlHWnVLSE4wY2lrcFhHNGdJSDBwWEc1OVhHNWNiaThxS2x4dUlDb2dRMkZ0Wld4cGVtVWdZU0JvZVhCb1pXNHRaR1ZzYVcxcGRHVmtJSE4wY21sdVp5NWNiaUFxTDF4dWRtRnlJR05oYldWc2FYcGxVa1VnUFNBdkxTaGNYSGNwTDJjN1hHNTJZWElnWTJGdFpXeHBlbVVnUFNCallXTm9aV1FvWm5WdVkzUnBiMjRnS0hOMGNpa2dlMXh1SUNCeVpYUjFjbTRnYzNSeUxuSmxjR3hoWTJVb1kyRnRaV3hwZW1WU1JTd2dablZ1WTNScGIyNGdLRjhzSUdNcElIc2djbVYwZFhKdUlHTWdQeUJqTG5SdlZYQndaWEpEWVhObEtDa2dPaUFuSnpzZ2ZTbGNibjBwTzF4dVhHNHZLaXBjYmlBcUlFTmhjR2wwWVd4cGVtVWdZU0J6ZEhKcGJtY3VYRzRnS2k5Y2JuWmhjaUJqWVhCcGRHRnNhWHBsSUQwZ1kyRmphR1ZrS0daMWJtTjBhVzl1SUNoemRISXBJSHRjYmlBZ2NtVjBkWEp1SUhOMGNpNWphR0Z5UVhRb01Da3VkRzlWY0hCbGNrTmhjMlVvS1NBcklITjBjaTV6YkdsalpTZ3hLVnh1ZlNrN1hHNWNiaThxS2x4dUlDb2dTSGx3YUdWdVlYUmxJR0VnWTJGdFpXeERZWE5sSUhOMGNtbHVaeTVjYmlBcUwxeHVkbUZ5SUdoNWNHaGxibUYwWlZKRklEMGdMeWhiWGkxZEtTaGJRUzFhWFNrdlp6dGNiblpoY2lCb2VYQm9aVzVoZEdVZ1BTQmpZV05vWldRb1puVnVZM1JwYjI0Z0tITjBjaWtnZTF4dUlDQnlaWFIxY200Z2MzUnlYRzRnSUNBZ0xuSmxjR3hoWTJVb2FIbHdhR1Z1WVhSbFVrVXNJQ2NrTVMwa01pY3BYRzRnSUNBZ0xuSmxjR3hoWTJVb2FIbHdhR1Z1WVhSbFVrVXNJQ2NrTVMwa01pY3BYRzRnSUNBZ0xuUnZURzkzWlhKRFlYTmxLQ2xjYm4wcE8xeHVYRzR2S2lwY2JpQXFJRk5wYlhCc1pTQmlhVzVrTENCbVlYTjBaWElnZEdoaGJpQnVZWFJwZG1WY2JpQXFMMXh1Wm5WdVkzUnBiMjRnWW1sdVpDQW9abTRzSUdOMGVDa2dlMXh1SUNCbWRXNWpkR2x2YmlCaWIzVnVaRVp1SUNoaEtTQjdYRzRnSUNBZ2RtRnlJR3dnUFNCaGNtZDFiV1Z1ZEhNdWJHVnVaM1JvTzF4dUlDQWdJSEpsZEhWeWJpQnNYRzRnSUNBZ0lDQS9JR3dnUGlBeFhHNGdJQ0FnSUNBZ0lEOGdabTR1WVhCd2JIa29ZM1I0TENCaGNtZDFiV1Z1ZEhNcFhHNGdJQ0FnSUNBZ0lEb2dabTR1WTJGc2JDaGpkSGdzSUdFcFhHNGdJQ0FnSUNBNklHWnVMbU5oYkd3b1kzUjRLVnh1SUNCOVhHNGdJQzh2SUhKbFkyOXlaQ0J2Y21sbmFXNWhiQ0JtYmlCc1pXNW5kR2hjYmlBZ1ltOTFibVJHYmk1ZmJHVnVaM1JvSUQwZ1ptNHViR1Z1WjNSb08xeHVJQ0J5WlhSMWNtNGdZbTkxYm1SR2JseHVmVnh1WEc0dktpcGNiaUFxSUVOdmJuWmxjblFnWVc0Z1FYSnlZWGt0YkdsclpTQnZZbXBsWTNRZ2RHOGdZU0J5WldGc0lFRnljbUY1TGx4dUlDb3ZYRzVtZFc1amRHbHZiaUIwYjBGeWNtRjVJQ2hzYVhOMExDQnpkR0Z5ZENrZ2UxeHVJQ0J6ZEdGeWRDQTlJSE4wWVhKMElIeDhJREE3WEc0Z0lIWmhjaUJwSUQwZ2JHbHpkQzVzWlc1bmRHZ2dMU0J6ZEdGeWREdGNiaUFnZG1GeUlISmxkQ0E5SUc1bGR5QkJjbkpoZVNocEtUdGNiaUFnZDJocGJHVWdLR2t0TFNrZ2UxeHVJQ0FnSUhKbGRGdHBYU0E5SUd4cGMzUmJhU0FySUhOMFlYSjBYVHRjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdjbVYwWEc1OVhHNWNiaThxS2x4dUlDb2dUV2w0SUhCeWIzQmxjblJwWlhNZ2FXNTBieUIwWVhKblpYUWdiMkpxWldOMExseHVJQ292WEc1bWRXNWpkR2x2YmlCbGVIUmxibVFnS0hSdkxDQmZabkp2YlNrZ2UxeHVJQ0JtYjNJZ0tIWmhjaUJyWlhrZ2FXNGdYMlp5YjIwcElIdGNiaUFnSUNCMGIxdHJaWGxkSUQwZ1gyWnliMjFiYTJWNVhUdGNiaUFnZlZ4dUlDQnlaWFIxY200Z2RHOWNibjFjYmx4dUx5b3FYRzRnS2lCUmRXbGpheUJ2WW1wbFkzUWdZMmhsWTJzZ0xTQjBhR2x6SUdseklIQnlhVzFoY21sc2VTQjFjMlZrSUhSdklIUmxiR3hjYmlBcUlFOWlhbVZqZEhNZ1puSnZiU0J3Y21sdGFYUnBkbVVnZG1Gc2RXVnpJSGRvWlc0Z2QyVWdhMjV2ZHlCMGFHVWdkbUZzZFdWY2JpQXFJR2x6SUdFZ1NsTlBUaTFqYjIxd2JHbGhiblFnZEhsd1pTNWNiaUFxTDF4dVpuVnVZM1JwYjI0Z2FYTlBZbXBsWTNRZ0tHOWlhaWtnZTF4dUlDQnlaWFIxY200Z2IySnFJQ0U5UFNCdWRXeHNJQ1ltSUhSNWNHVnZaaUJ2WW1vZ1BUMDlJQ2R2WW1wbFkzUW5YRzU5WEc1Y2JpOHFLbHh1SUNvZ1UzUnlhV04wSUc5aWFtVmpkQ0IwZVhCbElHTm9aV05yTGlCUGJteDVJSEpsZEhWeWJuTWdkSEoxWlZ4dUlDb2dabTl5SUhCc1lXbHVJRXBoZG1GVFkzSnBjSFFnYjJKcVpXTjBjeTVjYmlBcUwxeHVkbUZ5SUhSdlUzUnlhVzVuSUQwZ1QySnFaV04wTG5CeWIzUnZkSGx3WlM1MGIxTjBjbWx1Wnp0Y2JuWmhjaUJQUWtwRlExUmZVMVJTU1U1SElEMGdKMXR2WW1wbFkzUWdUMkpxWldOMFhTYzdYRzVtZFc1amRHbHZiaUJwYzFCc1lXbHVUMkpxWldOMElDaHZZbW9wSUh0Y2JpQWdjbVYwZFhKdUlIUnZVM1J5YVc1bkxtTmhiR3dvYjJKcUtTQTlQVDBnVDBKS1JVTlVYMU5VVWtsT1IxeHVmVnh1WEc0dktpcGNiaUFxSUUxbGNtZGxJR0Z1SUVGeWNtRjVJRzltSUU5aWFtVmpkSE1nYVc1MGJ5QmhJSE5wYm1kc1pTQlBZbXBsWTNRdVhHNGdLaTljYm1aMWJtTjBhVzl1SUhSdlQySnFaV04wSUNoaGNuSXBJSHRjYmlBZ2RtRnlJSEpsY3lBOUlIdDlPMXh1SUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHRnljaTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUdsbUlDaGhjbkpiYVYwcElIdGNiaUFnSUNBZ0lHVjRkR1Z1WkNoeVpYTXNJR0Z5Y2x0cFhTazdYRzRnSUNBZ2ZWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCeVpYTmNibjFjYmx4dUx5b3FYRzRnS2lCUVpYSm1iM0p0SUc1dklHOXdaWEpoZEdsdmJpNWNiaUFxTDF4dVpuVnVZM1JwYjI0Z2JtOXZjQ0FvS1NCN2ZWeHVYRzR2S2lwY2JpQXFJRUZzZDJGNWN5QnlaWFIxY200Z1ptRnNjMlV1WEc0Z0tpOWNiblpoY2lCdWJ5QTlJR1oxYm1OMGFXOXVJQ2dwSUhzZ2NtVjBkWEp1SUdaaGJITmxPeUI5TzF4dVhHNHZLaXBjYmlBcUlGSmxkSFZ5YmlCellXMWxJSFpoYkhWbFhHNGdLaTljYm5aaGNpQnBaR1Z1ZEdsMGVTQTlJR1oxYm1OMGFXOXVJQ2hmS1NCN0lISmxkSFZ5YmlCZk95QjlPMXh1WEc0dktpcGNiaUFxSUVkbGJtVnlZWFJsSUdFZ2MzUmhkR2xqSUd0bGVYTWdjM1J5YVc1bklHWnliMjBnWTI5dGNHbHNaWElnYlc5a2RXeGxjeTVjYmlBcUwxeHVYRzVjYmk4cUtseHVJQ29nUTJobFkyc2dhV1lnZEhkdklIWmhiSFZsY3lCaGNtVWdiRzl2YzJWc2VTQmxjWFZoYkNBdElIUm9ZWFFnYVhNc1hHNGdLaUJwWmlCMGFHVjVJR0Z5WlNCd2JHRnBiaUJ2WW1wbFkzUnpMQ0JrYnlCMGFHVjVJR2hoZG1VZ2RHaGxJSE5oYldVZ2MyaGhjR1UvWEc0Z0tpOWNibVoxYm1OMGFXOXVJR3h2YjNObFJYRjFZV3dnS0dFc0lHSXBJSHRjYmlBZ2RtRnlJR2x6VDJKcVpXTjBRU0E5SUdselQySnFaV04wS0dFcE8xeHVJQ0IyWVhJZ2FYTlBZbXBsWTNSQ0lEMGdhWE5QWW1wbFkzUW9ZaWs3WEc0Z0lHbG1JQ2hwYzA5aWFtVmpkRUVnSmlZZ2FYTlBZbXBsWTNSQ0tTQjdYRzRnSUNBZ2RISjVJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQktVMDlPTG5OMGNtbHVaMmxtZVNoaEtTQTlQVDBnU2xOUFRpNXpkSEpwYm1kcFpua29ZaWxjYmlBZ0lDQjlJR05oZEdOb0lDaGxLU0I3WEc0Z0lDQWdJQ0F2THlCd2IzTnphV0pzWlNCamFYSmpkV3hoY2lCeVpXWmxjbVZ1WTJWY2JpQWdJQ0FnSUhKbGRIVnliaUJoSUQwOVBTQmlYRzRnSUNBZ2ZWeHVJQ0I5SUdWc2MyVWdhV1lnS0NGcGMwOWlhbVZqZEVFZ0ppWWdJV2x6VDJKcVpXTjBRaWtnZTF4dUlDQWdJSEpsZEhWeWJpQlRkSEpwYm1jb1lTa2dQVDA5SUZOMGNtbHVaeWhpS1Z4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUhKbGRIVnliaUJtWVd4elpWeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJR3h2YjNObFNXNWtaWGhQWmlBb1lYSnlMQ0IyWVd3cElIdGNiaUFnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCaGNuSXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0JwWmlBb2JHOXZjMlZGY1hWaGJDaGhjbkpiYVYwc0lIWmhiQ2twSUhzZ2NtVjBkWEp1SUdrZ2ZWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlBdE1WeHVmVnh1WEc0dktpcGNiaUFxSUVWdWMzVnlaU0JoSUdaMWJtTjBhVzl1SUdseklHTmhiR3hsWkNCdmJteDVJRzl1WTJVdVhHNGdLaTljYm1aMWJtTjBhVzl1SUc5dVkyVWdLR1p1S1NCN1hHNGdJSFpoY2lCallXeHNaV1FnUFNCbVlXeHpaVHRjYmlBZ2NtVjBkWEp1SUdaMWJtTjBhVzl1SUNncElIdGNiaUFnSUNCcFppQW9JV05oYkd4bFpDa2dlMXh1SUNBZ0lDQWdZMkZzYkdWa0lEMGdkSEoxWlR0Y2JpQWdJQ0FnSUdadUtDazdYRzRnSUNBZ2ZWeHVJQ0I5WEc1OVhHNWNiaThxSUNBcUwxeHVYRzUyWVhJZ1kyOXVabWxuSUQwZ2UxeHVJQ0F2S2lwY2JpQWdJQ29nVDNCMGFXOXVJRzFsY21kbElITjBjbUYwWldkcFpYTWdLSFZ6WldRZ2FXNGdZMjl5WlM5MWRHbHNMMjl3ZEdsdmJuTXBYRzRnSUNBcUwxeHVJQ0J2Y0hScGIyNU5aWEpuWlZOMGNtRjBaV2RwWlhNNklFOWlhbVZqZEM1amNtVmhkR1VvYm5Wc2JDa3NYRzVjYmlBZ0x5b3FYRzRnSUNBcUlGZG9aWFJvWlhJZ2RHOGdjM1Z3Y0hKbGMzTWdkMkZ5Ym1sdVozTXVYRzRnSUNBcUwxeHVJQ0J6YVd4bGJuUTZJR1poYkhObExGeHVYRzRnSUM4cUtseHVJQ0FnS2lCVGFHOTNJSEJ5YjJSMVkzUnBiMjRnYlc5a1pTQjBhWEFnYldWemMyRm5aU0J2YmlCaWIyOTBQMXh1SUNBZ0tpOWNiaUFnY0hKdlpIVmpkR2x2YmxScGNEb2djSEp2WTJWemN5NWxibll1VGs5RVJWOUZUbFlnSVQwOUlDZHdjbTlrZFdOMGFXOXVKeXhjYmx4dUlDQXZLaXBjYmlBZ0lDb2dWMmhsZEdobGNpQjBieUJsYm1GaWJHVWdaR1YyZEc5dmJITmNiaUFnSUNvdlhHNGdJR1JsZG5SdmIyeHpPaUJ3Y205alpYTnpMbVZ1ZGk1T1QwUkZYMFZPVmlBaFBUMGdKM0J5YjJSMVkzUnBiMjRuTEZ4dVhHNGdJQzhxS2x4dUlDQWdLaUJYYUdWMGFHVnlJSFJ2SUhKbFkyOXlaQ0J3WlhKbVhHNGdJQ0FxTDF4dUlDQndaWEptYjNKdFlXNWpaVG9nWm1Gc2MyVXNYRzVjYmlBZ0x5b3FYRzRnSUNBcUlFVnljbTl5SUdoaGJtUnNaWElnWm05eUlIZGhkR05vWlhJZ1pYSnliM0p6WEc0Z0lDQXFMMXh1SUNCbGNuSnZja2hoYm1Sc1pYSTZJRzUxYkd3c1hHNWNiaUFnTHlvcVhHNGdJQ0FxSUVsbmJtOXlaU0JqWlhKMFlXbHVJR04xYzNSdmJTQmxiR1Z0Wlc1MGMxeHVJQ0FnS2k5Y2JpQWdhV2R1YjNKbFpFVnNaVzFsYm5Sek9pQmJYU3hjYmx4dUlDQXZLaXBjYmlBZ0lDb2dRM1Z6ZEc5dElIVnpaWElnYTJWNUlHRnNhV0Z6WlhNZ1ptOXlJSFl0YjI1Y2JpQWdJQ292WEc0Z0lHdGxlVU52WkdWek9pQlBZbXBsWTNRdVkzSmxZWFJsS0c1MWJHd3BMRnh1WEc0Z0lDOHFLbHh1SUNBZ0tpQkRhR1ZqYXlCcFppQmhJSFJoWnlCcGN5QnlaWE5sY25abFpDQnpieUIwYUdGMElHbDBJR05oYm01dmRDQmlaU0J5WldkcGMzUmxjbVZrSUdGeklHRmNiaUFnSUNvZ1kyOXRjRzl1Wlc1MExpQlVhR2x6SUdseklIQnNZWFJtYjNKdExXUmxjR1Z1WkdWdWRDQmhibVFnYldGNUlHSmxJRzkyWlhKM2NtbDBkR1Z1TGx4dUlDQWdLaTljYmlBZ2FYTlNaWE5sY25abFpGUmhaem9nYm04c1hHNWNiaUFnTHlvcVhHNGdJQ0FxSUVOb1pXTnJJR2xtSUdFZ2RHRm5JR2x6SUdGdUlIVnVhMjV2ZDI0Z1pXeGxiV1Z1ZEM1Y2JpQWdJQ29nVUd4aGRHWnZjbTB0WkdWd1pXNWtaVzUwTGx4dUlDQWdLaTljYmlBZ2FYTlZibXR1YjNkdVJXeGxiV1Z1ZERvZ2JtOHNYRzVjYmlBZ0x5b3FYRzRnSUNBcUlFZGxkQ0IwYUdVZ2JtRnRaWE53WVdObElHOW1JR0Z1SUdWc1pXMWxiblJjYmlBZ0lDb3ZYRzRnSUdkbGRGUmhaMDVoYldWemNHRmpaVG9nYm05dmNDeGNibHh1SUNBdktpcGNiaUFnSUNvZ1VHRnljMlVnZEdobElISmxZV3dnZEdGbklHNWhiV1VnWm05eUlIUm9aU0J6Y0dWamFXWnBZeUJ3YkdGMFptOXliUzVjYmlBZ0lDb3ZYRzRnSUhCaGNuTmxVR3hoZEdadmNtMVVZV2RPWVcxbE9pQnBaR1Z1ZEdsMGVTeGNibHh1SUNBdktpcGNiaUFnSUNvZ1EyaGxZMnNnYVdZZ1lXNGdZWFIwY21saWRYUmxJRzExYzNRZ1ltVWdZbTkxYm1RZ2RYTnBibWNnY0hKdmNHVnlkSGtzSUdVdVp5NGdkbUZzZFdWY2JpQWdJQ29nVUd4aGRHWnZjbTB0WkdWd1pXNWtaVzUwTGx4dUlDQWdLaTljYmlBZ2JYVnpkRlZ6WlZCeWIzQTZJRzV2TEZ4dVhHNGdJQzhxS2x4dUlDQWdLaUJNYVhOMElHOW1JR0Z6YzJWMElIUjVjR1Z6SUhSb1lYUWdZU0JqYjIxd2IyNWxiblFnWTJGdUlHOTNiaTVjYmlBZ0lDb3ZYRzRnSUY5aGMzTmxkRlI1Y0dWek9pQmJYRzRnSUNBZ0oyTnZiWEJ2Ym1WdWRDY3NYRzRnSUNBZ0oyUnBjbVZqZEdsMlpTY3NYRzRnSUNBZ0oyWnBiSFJsY2lkY2JpQWdYU3hjYmx4dUlDQXZLaXBjYmlBZ0lDb2dUR2x6ZENCdlppQnNhV1psWTNsamJHVWdhRzl2YTNNdVhHNGdJQ0FxTDF4dUlDQmZiR2xtWldONVkyeGxTRzl2YTNNNklGdGNiaUFnSUNBblltVm1iM0psUTNKbFlYUmxKeXhjYmlBZ0lDQW5ZM0psWVhSbFpDY3NYRzRnSUNBZ0oySmxabTl5WlUxdmRXNTBKeXhjYmlBZ0lDQW5iVzkxYm5SbFpDY3NYRzRnSUNBZ0oySmxabTl5WlZWd1pHRjBaU2NzWEc0Z0lDQWdKM1Z3WkdGMFpXUW5MRnh1SUNBZ0lDZGlaV1p2Y21WRVpYTjBjbTk1Snl4Y2JpQWdJQ0FuWkdWemRISnZlV1ZrSnl4Y2JpQWdJQ0FuWVdOMGFYWmhkR1ZrSnl4Y2JpQWdJQ0FuWkdWaFkzUnBkbUYwWldRblhHNGdJRjBzWEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRTFoZUNCamFYSmpkV3hoY2lCMWNHUmhkR1Z6SUdGc2JHOTNaV1FnYVc0Z1lTQnpZMmhsWkhWc1pYSWdabXgxYzJnZ1kzbGpiR1V1WEc0Z0lDQXFMMXh1SUNCZmJXRjRWWEJrWVhSbFEyOTFiblE2SURFd01GeHVmVHRjYmx4dUx5b2dJQ292WEc1Y2JuWmhjaUJsYlhCMGVVOWlhbVZqZENBOUlFOWlhbVZqZEM1bWNtVmxlbVVvZTMwcE8xeHVYRzR2S2lwY2JpQXFJRU5vWldOcklHbG1JR0VnYzNSeWFXNW5JSE4wWVhKMGN5QjNhWFJvSUNRZ2IzSWdYMXh1SUNvdlhHNW1kVzVqZEdsdmJpQnBjMUpsYzJWeWRtVmtJQ2h6ZEhJcElIdGNiaUFnZG1GeUlHTWdQU0FvYzNSeUlDc2dKeWNwTG1Ob1lYSkRiMlJsUVhRb01DazdYRzRnSUhKbGRIVnliaUJqSUQwOVBTQXdlREkwSUh4OElHTWdQVDA5SURCNE5VWmNibjFjYmx4dUx5b3FYRzRnS2lCRVpXWnBibVVnWVNCd2NtOXdaWEowZVM1Y2JpQXFMMXh1Wm5WdVkzUnBiMjRnWkdWbUlDaHZZbW9zSUd0bGVTd2dkbUZzTENCbGJuVnRaWEpoWW14bEtTQjdYRzRnSUU5aWFtVmpkQzVrWldacGJtVlFjbTl3WlhKMGVTaHZZbW9zSUd0bGVTd2dlMXh1SUNBZ0lIWmhiSFZsT2lCMllXd3NYRzRnSUNBZ1pXNTFiV1Z5WVdKc1pUb2dJU0ZsYm5WdFpYSmhZbXhsTEZ4dUlDQWdJSGR5YVhSaFlteGxPaUIwY25WbExGeHVJQ0FnSUdOdmJtWnBaM1Z5WVdKc1pUb2dkSEoxWlZ4dUlDQjlLVHRjYm4xY2JseHVMeW9xWEc0Z0tpQlFZWEp6WlNCemFXMXdiR1VnY0dGMGFDNWNiaUFxTDF4dWRtRnlJR0poYVd4U1JTQTlJQzliWGx4Y2R5NGtYUzg3WEc1bWRXNWpkR2x2YmlCd1lYSnpaVkJoZEdnZ0tIQmhkR2dwSUh0Y2JpQWdhV1lnS0dKaGFXeFNSUzUwWlhOMEtIQmhkR2dwS1NCN1hHNGdJQ0FnY21WMGRYSnVYRzRnSUgxY2JpQWdkbUZ5SUhObFoyMWxiblJ6SUQwZ2NHRjBhQzV6Y0d4cGRDZ25MaWNwTzF4dUlDQnlaWFIxY200Z1puVnVZM1JwYjI0Z0tHOWlhaWtnZTF4dUlDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnYzJWbmJXVnVkSE11YkdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNBZ0lHbG1JQ2doYjJKcUtTQjdJSEpsZEhWeWJpQjlYRzRnSUNBZ0lDQnZZbW9nUFNCdlltcGJjMlZuYldWdWRITmJhVjFkTzF4dUlDQWdJSDFjYmlBZ0lDQnlaWFIxY200Z2IySnFYRzRnSUgxY2JuMWNibHh1THlvZ0lDb3ZYRzR2S2lCbmJHOWlZV3h6SUUxMWRHRjBhVzl1VDJKelpYSjJaWElnS2k5Y2JseHVMeThnWTJGdUlIZGxJSFZ6WlNCZlgzQnliM1J2WDE4L1hHNTJZWElnYUdGelVISnZkRzhnUFNBblgxOXdjbTkwYjE5Zkp5QnBiaUI3ZlR0Y2JseHVMeThnUW5KdmQzTmxjaUJsYm5acGNtOXViV1Z1ZENCemJtbG1abWx1WjF4dWRtRnlJR2x1UW5KdmQzTmxjaUE5SUhSNWNHVnZaaUIzYVc1a2IzY2dJVDA5SUNkMWJtUmxabWx1WldRbk8xeHVkbUZ5SUZWQklEMGdhVzVDY205M2MyVnlJQ1ltSUhkcGJtUnZkeTV1WVhacFoyRjBiM0l1ZFhObGNrRm5aVzUwTG5SdlRHOTNaWEpEWVhObEtDazdYRzUyWVhJZ2FYTkpSU0E5SUZWQklDWW1JQzl0YzJsbGZIUnlhV1JsYm5RdkxuUmxjM1FvVlVFcE8xeHVkbUZ5SUdselNVVTVJRDBnVlVFZ0ppWWdWVUV1YVc1a1pYaFBaaWduYlhOcFpTQTVMakFuS1NBK0lEQTdYRzUyWVhJZ2FYTkZaR2RsSUQwZ1ZVRWdKaVlnVlVFdWFXNWtaWGhQWmlnblpXUm5aUzhuS1NBK0lEQTdYRzUyWVhJZ2FYTkJibVJ5YjJsa0lEMGdWVUVnSmlZZ1ZVRXVhVzVrWlhoUFppZ25ZVzVrY205cFpDY3BJRDRnTUR0Y2JuWmhjaUJwYzBsUFV5QTlJRlZCSUNZbUlDOXBjR2h2Ym1WOGFYQmhaSHhwY0c5a2ZHbHZjeTh1ZEdWemRDaFZRU2s3WEc1MllYSWdhWE5EYUhKdmJXVWdQU0JWUVNBbUppQXZZMmh5YjIxbFhGd3ZYRnhrS3k4dWRHVnpkQ2hWUVNrZ0ppWWdJV2x6UldSblpUdGNibHh1THk4Z2RHaHBjeUJ1WldWa2N5QjBieUJpWlNCc1lYcDVMV1YyWVd4bFpDQmlaV05oZFhObElIWjFaU0J0WVhrZ1ltVWdjbVZ4ZFdseVpXUWdZbVZtYjNKbFhHNHZMeUIyZFdVdGMyVnlkbVZ5TFhKbGJtUmxjbVZ5SUdOaGJpQnpaWFFnVmxWRlgwVk9WbHh1ZG1GeUlGOXBjMU5sY25abGNqdGNiblpoY2lCcGMxTmxjblpsY2xKbGJtUmxjbWx1WnlBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ2FXWWdLRjlwYzFObGNuWmxjaUE5UFQwZ2RXNWtaV1pwYm1Wa0tTQjdYRzRnSUNBZ0x5b2dhWE4wWVc1aWRXd2dhV2R1YjNKbElHbG1JQ292WEc0Z0lDQWdhV1lnS0NGcGJrSnliM2R6WlhJZ0ppWWdkSGx3Wlc5bUlHZHNiMkpoYkNBaFBUMGdKM1Z1WkdWbWFXNWxaQ2NwSUh0Y2JpQWdJQ0FnSUM4dklHUmxkR1ZqZENCd2NtVnpaVzVqWlNCdlppQjJkV1V0YzJWeWRtVnlMWEpsYm1SbGNtVnlJR0Z1WkNCaGRtOXBaRnh1SUNBZ0lDQWdMeThnVjJWaWNHRmpheUJ6YUdsdGJXbHVaeUIwYUdVZ2NISnZZMlZ6YzF4dUlDQWdJQ0FnWDJselUyVnlkbVZ5SUQwZ1oyeHZZbUZzV3lkd2NtOWpaWE56SjEwdVpXNTJMbFpWUlY5RlRsWWdQVDA5SUNkelpYSjJaWEluTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQmZhWE5UWlhKMlpYSWdQU0JtWVd4elpUdGNiaUFnSUNCOVhHNGdJSDFjYmlBZ2NtVjBkWEp1SUY5cGMxTmxjblpsY2x4dWZUdGNibHh1THk4Z1pHVjBaV04wSUdSbGRuUnZiMnh6WEc1MllYSWdaR1YyZEc5dmJITWdQU0JwYmtKeWIzZHpaWElnSmlZZ2QybHVaRzkzTGw5ZlZsVkZYMFJGVmxSUFQweFRYMGRNVDBKQlRGOUlUMDlMWDE4N1hHNWNiaThxSUdsemRHRnVZblZzSUdsbmJtOXlaU0J1WlhoMElDb3ZYRzVtZFc1amRHbHZiaUJwYzA1aGRHbDJaU0FvUTNSdmNpa2dlMXh1SUNCeVpYUjFjbTRnTDI1aGRHbDJaU0JqYjJSbEx5NTBaWE4wS0VOMGIzSXVkRzlUZEhKcGJtY29LU2xjYm4xY2JseHVkbUZ5SUdoaGMxTjViV0p2YkNBOVhHNGdJSFI1Y0dWdlppQlRlVzFpYjJ3Z0lUMDlJQ2QxYm1SbFptbHVaV1FuSUNZbUlHbHpUbUYwYVhabEtGTjViV0p2YkNrZ0ppWmNiaUFnZEhsd1pXOW1JRkpsWm14bFkzUWdJVDA5SUNkMWJtUmxabWx1WldRbklDWW1JR2x6VG1GMGFYWmxLRkpsWm14bFkzUXViM2R1UzJWNWN5azdYRzVjYmk4cUtseHVJQ29nUkdWbVpYSWdZU0IwWVhOcklIUnZJR1Y0WldOMWRHVWdhWFFnWVhONWJtTm9jbTl1YjNWemJIa3VYRzRnS2k5Y2JuWmhjaUJ1WlhoMFZHbGpheUE5SUNobWRXNWpkR2x2YmlBb0tTQjdYRzRnSUhaaGNpQmpZV3hzWW1GamEzTWdQU0JiWFR0Y2JpQWdkbUZ5SUhCbGJtUnBibWNnUFNCbVlXeHpaVHRjYmlBZ2RtRnlJSFJwYldWeVJuVnVZenRjYmx4dUlDQm1kVzVqZEdsdmJpQnVaWGgwVkdsamEwaGhibVJzWlhJZ0tDa2dlMXh1SUNBZ0lIQmxibVJwYm1jZ1BTQm1ZV3h6WlR0Y2JpQWdJQ0IyWVhJZ1kyOXdhV1Z6SUQwZ1kyRnNiR0poWTJ0ekxuTnNhV05sS0RBcE8xeHVJQ0FnSUdOaGJHeGlZV05yY3k1c1pXNW5kR2dnUFNBd08xeHVJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z1kyOXdhV1Z6TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQmpiM0JwWlhOYmFWMG9LVHRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0F2THlCMGFHVWdibVY0ZEZScFkyc2dZbVZvWVhacGIzSWdiR1YyWlhKaFoyVnpJSFJvWlNCdGFXTnliM1JoYzJzZ2NYVmxkV1VzSUhkb2FXTm9JR05oYmlCaVpTQmhZMk5sYzNObFpGeHVJQ0F2THlCMmFXRWdaV2wwYUdWeUlHNWhkR2wyWlNCUWNtOXRhWE5sTG5Sb1pXNGdiM0lnVFhWMFlYUnBiMjVQWW5ObGNuWmxjaTVjYmlBZ0x5OGdUWFYwWVhScGIyNVBZbk5sY25abGNpQm9ZWE1nZDJsa1pYSWdjM1Z3Y0c5eWRDd2dhRzkzWlhabGNpQnBkQ0JwY3lCelpYSnBiM1Z6YkhrZ1luVm5aMlZrSUdsdVhHNGdJQzh2SUZWSlYyVmlWbWxsZHlCcGJpQnBUMU1nUGowZ09TNHpMak1nZDJobGJpQjBjbWxuWjJWeVpXUWdhVzRnZEc5MVkyZ2daWFpsYm5RZ2FHRnVaR3hsY25NdUlFbDBYRzRnSUM4dklHTnZiWEJzWlhSbGJIa2djM1J2Y0hNZ2QyOXlhMmx1WnlCaFpuUmxjaUIwY21sbloyVnlhVzVuSUdFZ1ptVjNJSFJwYldWekxpNHVJSE52TENCcFppQnVZWFJwZG1WY2JpQWdMeThnVUhKdmJXbHpaU0JwY3lCaGRtRnBiR0ZpYkdVc0lIZGxJSGRwYkd3Z2RYTmxJR2wwT2x4dUlDQXZLaUJwYzNSaGJtSjFiQ0JwWjI1dmNtVWdhV1lnS2k5Y2JpQWdhV1lnS0hSNWNHVnZaaUJRY205dGFYTmxJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5QW1KaUJwYzA1aGRHbDJaU2hRY205dGFYTmxLU2tnZTF4dUlDQWdJSFpoY2lCd0lEMGdVSEp2YldselpTNXlaWE52YkhabEtDazdYRzRnSUNBZ2RtRnlJR3h2WjBWeWNtOXlJRDBnWm5WdVkzUnBiMjRnS0dWeWNpa2dleUJqYjI1emIyeGxMbVZ5Y205eUtHVnljaWs3SUgwN1hHNGdJQ0FnZEdsdFpYSkdkVzVqSUQwZ1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNBZ0lDQWdjQzUwYUdWdUtHNWxlSFJVYVdOclNHRnVaR3hsY2lrdVkyRjBZMmdvYkc5blJYSnliM0lwTzF4dUlDQWdJQ0FnTHk4Z2FXNGdjSEp2WW14bGJXRjBhV01nVlVsWFpXSldhV1YzY3l3Z1VISnZiV2x6WlM1MGFHVnVJR1J2WlhOdUozUWdZMjl0Y0d4bGRHVnNlU0JpY21WaGF5d2dZblYwWEc0Z0lDQWdJQ0F2THlCcGRDQmpZVzRnWjJWMElITjBkV05ySUdsdUlHRWdkMlZwY21RZ2MzUmhkR1VnZDJobGNtVWdZMkZzYkdKaFkydHpJR0Z5WlNCd2RYTm9aV1FnYVc1MGJ5QjBhR1ZjYmlBZ0lDQWdJQzh2SUcxcFkzSnZkR0Z6YXlCeGRXVjFaU0JpZFhRZ2RHaGxJSEYxWlhWbElHbHpiaWQwSUdKbGFXNW5JR1pzZFhOb1pXUXNJSFZ1ZEdsc0lIUm9aU0JpY205M2MyVnlYRzRnSUNBZ0lDQXZMeUJ1WldWa2N5QjBieUJrYnlCemIyMWxJRzkwYUdWeUlIZHZjbXNzSUdVdVp5NGdhR0Z1Wkd4bElHRWdkR2x0WlhJdUlGUm9aWEpsWm05eVpTQjNaU0JqWVc1Y2JpQWdJQ0FnSUM4dklGd2labTl5WTJWY0lpQjBhR1VnYldsamNtOTBZWE5ySUhGMVpYVmxJSFJ2SUdKbElHWnNkWE5vWldRZ1lua2dZV1JrYVc1bklHRnVJR1Z0Y0hSNUlIUnBiV1Z5TGx4dUlDQWdJQ0FnYVdZZ0tHbHpTVTlUS1NCN0lITmxkRlJwYldWdmRYUW9ibTl2Y0NrN0lIMWNiaUFnSUNCOU8xeHVJQ0I5SUdWc2MyVWdhV1lnS0hSNWNHVnZaaUJOZFhSaGRHbHZiazlpYzJWeWRtVnlJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5QW1KaUFvWEc0Z0lDQWdhWE5PWVhScGRtVW9UWFYwWVhScGIyNVBZbk5sY25abGNpa2dmSHhjYmlBZ0lDQXZMeUJRYUdGdWRHOXRTbE1nWVc1a0lHbFBVeUEzTG5oY2JpQWdJQ0JOZFhSaGRHbHZiazlpYzJWeWRtVnlMblJ2VTNSeWFXNW5LQ2tnUFQwOUlDZGJiMkpxWldOMElFMTFkR0YwYVc5dVQySnpaWEoyWlhKRGIyNXpkSEoxWTNSdmNsMG5YRzRnSUNrcElIdGNiaUFnSUNBdkx5QjFjMlVnVFhWMFlYUnBiMjVQWW5ObGNuWmxjaUIzYUdWeVpTQnVZWFJwZG1VZ1VISnZiV2x6WlNCcGN5QnViM1FnWVhaaGFXeGhZbXhsTEZ4dUlDQWdJQzh2SUdVdVp5NGdVR2hoYm5SdmJVcFRJRWxGTVRFc0lHbFBVemNzSUVGdVpISnZhV1FnTkM0MFhHNGdJQ0FnZG1GeUlHTnZkVzUwWlhJZ1BTQXhPMXh1SUNBZ0lIWmhjaUJ2WW5ObGNuWmxjaUE5SUc1bGR5Qk5kWFJoZEdsdmJrOWljMlZ5ZG1WeUtHNWxlSFJVYVdOclNHRnVaR3hsY2lrN1hHNGdJQ0FnZG1GeUlIUmxlSFJPYjJSbElEMGdaRzlqZFcxbGJuUXVZM0psWVhSbFZHVjRkRTV2WkdVb1UzUnlhVzVuS0dOdmRXNTBaWElwS1R0Y2JpQWdJQ0J2WW5ObGNuWmxjaTV2WW5ObGNuWmxLSFJsZUhST2IyUmxMQ0I3WEc0Z0lDQWdJQ0JqYUdGeVlXTjBaWEpFWVhSaE9pQjBjblZsWEc0Z0lDQWdmU2s3WEc0Z0lDQWdkR2x0WlhKR2RXNWpJRDBnWm5WdVkzUnBiMjRnS0NrZ2UxeHVJQ0FnSUNBZ1kyOTFiblJsY2lBOUlDaGpiM1Z1ZEdWeUlDc2dNU2tnSlNBeU8xeHVJQ0FnSUNBZ2RHVjRkRTV2WkdVdVpHRjBZU0E5SUZOMGNtbHVaeWhqYjNWdWRHVnlLVHRjYmlBZ0lDQjlPMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJQzh2SUdaaGJHeGlZV05ySUhSdklITmxkRlJwYldWdmRYUmNiaUFnSUNBdktpQnBjM1JoYm1KMWJDQnBaMjV2Y21VZ2JtVjRkQ0FxTDF4dUlDQWdJSFJwYldWeVJuVnVZeUE5SUdaMWJtTjBhVzl1SUNncElIdGNiaUFnSUNBZ0lITmxkRlJwYldWdmRYUW9ibVY0ZEZScFkydElZVzVrYkdWeUxDQXdLVHRjYmlBZ0lDQjlPMXh1SUNCOVhHNWNiaUFnY21WMGRYSnVJR1oxYm1OMGFXOXVJSEYxWlhWbFRtVjRkRlJwWTJzZ0tHTmlMQ0JqZEhncElIdGNiaUFnSUNCMllYSWdYM0psYzI5c2RtVTdYRzRnSUNBZ1kyRnNiR0poWTJ0ekxuQjFjMmdvWm5WdVkzUnBiMjRnS0NrZ2UxeHVJQ0FnSUNBZ2FXWWdLR05pS1NCN0lHTmlMbU5oYkd3b1kzUjRLVHNnZlZ4dUlDQWdJQ0FnYVdZZ0tGOXlaWE52YkhabEtTQjdJRjl5WlhOdmJIWmxLR04wZUNrN0lIMWNiaUFnSUNCOUtUdGNiaUFnSUNCcFppQW9JWEJsYm1ScGJtY3BJSHRjYmlBZ0lDQWdJSEJsYm1ScGJtY2dQU0IwY25WbE8xeHVJQ0FnSUNBZ2RHbHRaWEpHZFc1aktDazdYRzRnSUNBZ2ZWeHVJQ0FnSUdsbUlDZ2hZMklnSmlZZ2RIbHdaVzltSUZCeWIyMXBjMlVnSVQwOUlDZDFibVJsWm1sdVpXUW5LU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdibVYzSUZCeWIyMXBjMlVvWm5WdVkzUnBiMjRnS0hKbGMyOXNkbVVwSUh0Y2JpQWdJQ0FnSUNBZ1gzSmxjMjlzZG1VZ1BTQnlaWE52YkhabE8xeHVJQ0FnSUNBZ2ZTbGNiaUFnSUNCOVhHNGdJSDFjYm4wcEtDazdYRzVjYm5aaGNpQmZVMlYwTzF4dUx5b2dhWE4wWVc1aWRXd2dhV2R1YjNKbElHbG1JQ292WEc1cFppQW9kSGx3Wlc5bUlGTmxkQ0FoUFQwZ0ozVnVaR1ZtYVc1bFpDY2dKaVlnYVhOT1lYUnBkbVVvVTJWMEtTa2dlMXh1SUNBdkx5QjFjMlVnYm1GMGFYWmxJRk5sZENCM2FHVnVJR0YyWVdsc1lXSnNaUzVjYmlBZ1gxTmxkQ0E5SUZObGREdGNibjBnWld4elpTQjdYRzRnSUM4dklHRWdibTl1TFhOMFlXNWtZWEprSUZObGRDQndiMng1Wm1sc2JDQjBhR0YwSUc5dWJIa2dkMjl5YTNNZ2QybDBhQ0J3Y21sdGFYUnBkbVVnYTJWNWN5NWNiaUFnWDFObGRDQTlJQ2htZFc1amRHbHZiaUFvS1NCN1hHNGdJQ0FnWm5WdVkzUnBiMjRnVTJWMElDZ3BJSHRjYmlBZ0lDQWdJSFJvYVhNdWMyVjBJRDBnVDJKcVpXTjBMbU55WldGMFpTaHVkV3hzS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdVMlYwTG5CeWIzUnZkSGx3WlM1b1lYTWdQU0JtZFc1amRHbHZiaUJvWVhNZ0tHdGxlU2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdWMyVjBXMnRsZVYwZ1BUMDlJSFJ5ZFdWY2JpQWdJQ0I5TzF4dUlDQWdJRk5sZEM1d2NtOTBiM1I1Y0dVdVlXUmtJRDBnWm5WdVkzUnBiMjRnWVdSa0lDaHJaWGtwSUh0Y2JpQWdJQ0FnSUhSb2FYTXVjMlYwVzJ0bGVWMGdQU0IwY25WbE8xeHVJQ0FnSUgwN1hHNGdJQ0FnVTJWMExuQnliM1J2ZEhsd1pTNWpiR1ZoY2lBOUlHWjFibU4wYVc5dUlHTnNaV0Z5SUNncElIdGNiaUFnSUNBZ0lIUm9hWE11YzJWMElEMGdUMkpxWldOMExtTnlaV0YwWlNodWRXeHNLVHRjYmlBZ0lDQjlPMXh1WEc0Z0lDQWdjbVYwZFhKdUlGTmxkRHRjYmlBZ2ZTZ3BLVHRjYm4xY2JseHVkbUZ5SUhkaGNtNGdQU0J1YjI5d08xeHVkbUZ5SUhScGNDQTlJRzV2YjNBN1hHNTJZWElnWm05eWJXRjBRMjl0Y0c5dVpXNTBUbUZ0WlR0Y2JseHVhV1lnS0hCeWIyTmxjM011Wlc1MkxrNVBSRVZmUlU1V0lDRTlQU0FuY0hKdlpIVmpkR2x2YmljcElIdGNiaUFnZG1GeUlHaGhjME52Ym5OdmJHVWdQU0IwZVhCbGIyWWdZMjl1YzI5c1pTQWhQVDBnSjNWdVpHVm1hVzVsWkNjN1hHNGdJSFpoY2lCamJHRnpjMmxtZVZKRklEMGdMeWcvT2w1OFd5MWZYU2tvWEZ4M0tTOW5PMXh1SUNCMllYSWdZMnhoYzNOcFpua2dQU0JtZFc1amRHbHZiaUFvYzNSeUtTQjdJSEpsZEhWeWJpQnpkSEpjYmlBZ0lDQXVjbVZ3YkdGalpTaGpiR0Z6YzJsbWVWSkZMQ0JtZFc1amRHbHZiaUFvWXlrZ2V5QnlaWFIxY200Z1l5NTBiMVZ3Y0dWeVEyRnpaU2dwT3lCOUtWeHVJQ0FnSUM1eVpYQnNZV05sS0M5YkxWOWRMMmNzSUNjbktUc2dmVHRjYmx4dUlDQjNZWEp1SUQwZ1puVnVZM1JwYjI0Z0tHMXpaeXdnZG0wcElIdGNiaUFnSUNCcFppQW9hR0Z6UTI5dWMyOXNaU0FtSmlBb0lXTnZibVpwWnk1emFXeGxiblFwS1NCN1hHNGdJQ0FnSUNCamIyNXpiMnhsTG1WeWNtOXlLRndpVzFaMVpTQjNZWEp1WFRvZ1hDSWdLeUJ0YzJjZ0t5QmNJaUJjSWlBcklDaGNiaUFnSUNBZ0lDQWdkbTBnUHlCbWIzSnRZWFJNYjJOaGRHbHZiaWhtYjNKdFlYUkRiMjF3YjI1bGJuUk9ZVzFsS0hadEtTa2dPaUFuSjF4dUlDQWdJQ0FnS1NrN1hHNGdJQ0FnZlZ4dUlDQjlPMXh1WEc0Z0lIUnBjQ0E5SUdaMWJtTjBhVzl1SUNodGMyY3NJSFp0S1NCN1hHNGdJQ0FnYVdZZ0tHaGhjME52Ym5OdmJHVWdKaVlnS0NGamIyNW1hV2N1YzJsc1pXNTBLU2tnZTF4dUlDQWdJQ0FnWTI5dWMyOXNaUzUzWVhKdUtGd2lXMVoxWlNCMGFYQmRPaUJjSWlBcklHMXpaeUFySUZ3aUlGd2lJQ3NnS0Z4dUlDQWdJQ0FnSUNCMmJTQS9JR1p2Y20xaGRFeHZZMkYwYVc5dUtHWnZjbTFoZEVOdmJYQnZibVZ1ZEU1aGJXVW9kbTBwS1NBNklDY25YRzRnSUNBZ0lDQXBLVHRjYmlBZ0lDQjlYRzRnSUgwN1hHNWNiaUFnWm05eWJXRjBRMjl0Y0c5dVpXNTBUbUZ0WlNBOUlHWjFibU4wYVc5dUlDaDJiU3dnYVc1amJIVmtaVVpwYkdVcElIdGNiaUFnSUNCcFppQW9kbTB1SkhKdmIzUWdQVDA5SUhadEtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z0p6eFNiMjkwUGlkY2JpQWdJQ0I5WEc0Z0lDQWdkbUZ5SUc1aGJXVWdQU0IwZVhCbGIyWWdkbTBnUFQwOUlDZHpkSEpwYm1jblhHNGdJQ0FnSUNBL0lIWnRYRzRnSUNBZ0lDQTZJSFI1Y0dWdlppQjJiU0E5UFQwZ0oyWjFibU4wYVc5dUp5QW1KaUIyYlM1dmNIUnBiMjV6WEc0Z0lDQWdJQ0FnSUQ4Z2RtMHViM0IwYVc5dWN5NXVZVzFsWEc0Z0lDQWdJQ0FnSURvZ2RtMHVYMmx6Vm5WbFhHNGdJQ0FnSUNBZ0lDQWdQeUIyYlM0a2IzQjBhVzl1Y3k1dVlXMWxJSHg4SUhadExpUnZjSFJwYjI1ekxsOWpiMjF3YjI1bGJuUlVZV2RjYmlBZ0lDQWdJQ0FnSUNBNklIWnRMbTVoYldVN1hHNWNiaUFnSUNCMllYSWdabWxzWlNBOUlIWnRMbDlwYzFaMVpTQW1KaUIyYlM0a2IzQjBhVzl1Y3k1ZlgyWnBiR1U3WEc0Z0lDQWdhV1lnS0NGdVlXMWxJQ1ltSUdacGJHVXBJSHRjYmlBZ0lDQWdJSFpoY2lCdFlYUmphQ0E5SUdacGJHVXViV0YwWTJnb0x5aGJYaTljWEZ4Y1hTc3BYRnd1ZG5WbEpDOHBPMXh1SUNBZ0lDQWdibUZ0WlNBOUlHMWhkR05vSUNZbUlHMWhkR05vV3pGZE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhKbGRIVnliaUFvWEc0Z0lDQWdJQ0FvYm1GdFpTQS9JQ2hjSWp4Y0lpQXJJQ2hqYkdGemMybG1lU2h1WVcxbEtTa2dLeUJjSWo1Y0lpa2dPaUJjSWp4QmJtOXVlVzF2ZFhNK1hDSXBJQ3RjYmlBZ0lDQWdJQ2htYVd4bElDWW1JR2x1WTJ4MVpHVkdhV3hsSUNFOVBTQm1ZV3h6WlNBL0lDaGNJaUJoZENCY0lpQXJJR1pwYkdVcElEb2dKeWNwWEc0Z0lDQWdLVnh1SUNCOU8xeHVYRzRnSUhaaGNpQm1iM0p0WVhSTWIyTmhkR2x2YmlBOUlHWjFibU4wYVc5dUlDaHpkSElwSUh0Y2JpQWdJQ0JwWmlBb2MzUnlJRDA5UFNCY0lqeEJibTl1ZVcxdmRYTStYQ0lwSUh0Y2JpQWdJQ0FnSUhOMGNpQXJQU0JjSWlBdElIVnpaU0IwYUdVZ1hGeGNJbTVoYldWY1hGd2lJRzl3ZEdsdmJpQm1iM0lnWW1WMGRHVnlJR1JsWW5WbloybHVaeUJ0WlhOellXZGxjeTVjSWp0Y2JpQWdJQ0I5WEc0Z0lDQWdjbVYwZFhKdUlDaGNJbHhjYmlobWIzVnVaQ0JwYmlCY0lpQXJJSE4wY2lBcklGd2lLVndpS1Z4dUlDQjlPMXh1ZlZ4dVhHNHZLaUFnS2k5Y2JseHVYRzUyWVhJZ2RXbGtKREVnUFNBd08xeHVYRzR2S2lwY2JpQXFJRUVnWkdWd0lHbHpJR0Z1SUc5aWMyVnlkbUZpYkdVZ2RHaGhkQ0JqWVc0Z2FHRjJaU0J0ZFd4MGFYQnNaVnh1SUNvZ1pHbHlaV04wYVhabGN5QnpkV0p6WTNKcFltbHVaeUIwYnlCcGRDNWNiaUFxTDF4dWRtRnlJRVJsY0NBOUlHWjFibU4wYVc5dUlFUmxjQ0FvS1NCN1hHNGdJSFJvYVhNdWFXUWdQU0IxYVdRa01Tc3JPMXh1SUNCMGFHbHpMbk4xWW5NZ1BTQmJYVHRjYm4wN1hHNWNia1JsY0M1d2NtOTBiM1I1Y0dVdVlXUmtVM1ZpSUQwZ1puVnVZM1JwYjI0Z1lXUmtVM1ZpSUNoemRXSXBJSHRjYmlBZ2RHaHBjeTV6ZFdKekxuQjFjMmdvYzNWaUtUdGNibjA3WEc1Y2JrUmxjQzV3Y205MGIzUjVjR1V1Y21WdGIzWmxVM1ZpSUQwZ1puVnVZM1JwYjI0Z2NtVnRiM1psVTNWaUlDaHpkV0lwSUh0Y2JpQWdjbVZ0YjNabEtIUm9hWE11YzNWaWN5d2djM1ZpS1R0Y2JuMDdYRzVjYmtSbGNDNXdjbTkwYjNSNWNHVXVaR1Z3Wlc1a0lEMGdablZ1WTNScGIyNGdaR1Z3Wlc1a0lDZ3BJSHRjYmlBZ2FXWWdLRVJsY0M1MFlYSm5aWFFwSUh0Y2JpQWdJQ0JFWlhBdWRHRnlaMlYwTG1Ga1pFUmxjQ2gwYUdsektUdGNiaUFnZlZ4dWZUdGNibHh1UkdWd0xuQnliM1J2ZEhsd1pTNXViM1JwWm5rZ1BTQm1kVzVqZEdsdmJpQnViM1JwWm5rZ0tDa2dlMXh1SUNBdkx5QnpkR0ZpYVd4cGVtVWdkR2hsSUhOMVluTmpjbWxpWlhJZ2JHbHpkQ0JtYVhKemRGeHVJQ0IyWVhJZ2MzVmljeUE5SUhSb2FYTXVjM1ZpY3k1emJHbGpaU2dwTzF4dUlDQm1iM0lnS0haaGNpQnBJRDBnTUN3Z2JDQTlJSE4xWW5NdWJHVnVaM1JvT3lCcElEd2diRHNnYVNzcktTQjdYRzRnSUNBZ2MzVmljMXRwWFM1MWNHUmhkR1VvS1R0Y2JpQWdmVnh1ZlR0Y2JseHVMeThnZEdobElHTjFjbkpsYm5RZ2RHRnlaMlYwSUhkaGRHTm9aWElnWW1WcGJtY2daWFpoYkhWaGRHVmtMbHh1THk4Z2RHaHBjeUJwY3lCbmJHOWlZV3hzZVNCMWJtbHhkV1VnWW1WallYVnpaU0IwYUdWeVpTQmpiM1ZzWkNCaVpTQnZibXg1SUc5dVpWeHVMeThnZDJGMFkyaGxjaUJpWldsdVp5QmxkbUZzZFdGMFpXUWdZWFFnWVc1NUlIUnBiV1V1WEc1RVpYQXVkR0Z5WjJWMElEMGdiblZzYkR0Y2JuWmhjaUIwWVhKblpYUlRkR0ZqYXlBOUlGdGRPMXh1WEc1bWRXNWpkR2x2YmlCd2RYTm9WR0Z5WjJWMElDaGZkR0Z5WjJWMEtTQjdYRzRnSUdsbUlDaEVaWEF1ZEdGeVoyVjBLU0I3SUhSaGNtZGxkRk4wWVdOckxuQjFjMmdvUkdWd0xuUmhjbWRsZENrN0lIMWNiaUFnUkdWd0xuUmhjbWRsZENBOUlGOTBZWEpuWlhRN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUhCdmNGUmhjbWRsZENBb0tTQjdYRzRnSUVSbGNDNTBZWEpuWlhRZ1BTQjBZWEpuWlhSVGRHRmpheTV3YjNBb0tUdGNibjFjYmx4dUx5cGNiaUFxSUc1dmRDQjBlWEJsSUdOb1pXTnJhVzVuSUhSb2FYTWdabWxzWlNCaVpXTmhkWE5sSUdac2IzY2daRzlsYzI0bmRDQndiR0Y1SUhkbGJHd2dkMmwwYUZ4dUlDb2daSGx1WVcxcFkyRnNiSGtnWVdOalpYTnphVzVuSUcxbGRHaHZaSE1nYjI0Z1FYSnlZWGtnY0hKdmRHOTBlWEJsWEc0Z0tpOWNibHh1ZG1GeUlHRnljbUY1VUhKdmRHOGdQU0JCY25KaGVTNXdjbTkwYjNSNWNHVTdYRzUyWVhJZ1lYSnlZWGxOWlhSb2IyUnpJRDBnVDJKcVpXTjBMbU55WldGMFpTaGhjbkpoZVZCeWIzUnZLVHRiWEc0Z0lDZHdkWE5vSnl4Y2JpQWdKM0J2Y0Njc1hHNGdJQ2R6YUdsbWRDY3NYRzRnSUNkMWJuTm9hV1owSnl4Y2JpQWdKM053YkdsalpTY3NYRzRnSUNkemIzSjBKeXhjYmlBZ0ozSmxkbVZ5YzJVblhHNWRYRzR1Wm05eVJXRmphQ2htZFc1amRHbHZiaUFvYldWMGFHOWtLU0I3WEc0Z0lDOHZJR05oWTJobElHOXlhV2RwYm1Gc0lHMWxkR2h2WkZ4dUlDQjJZWElnYjNKcFoybHVZV3dnUFNCaGNuSmhlVkJ5YjNSdlcyMWxkR2h2WkYwN1hHNGdJR1JsWmloaGNuSmhlVTFsZEdodlpITXNJRzFsZEdodlpDd2dablZ1WTNScGIyNGdiWFYwWVhSdmNpQW9LU0I3WEc0Z0lDQWdkbUZ5SUdGeVozVnRaVzUwY3lReElEMGdZWEpuZFcxbGJuUnpPMXh1WEc0Z0lDQWdMeThnWVhadmFXUWdiR1ZoYTJsdVp5QmhjbWQxYldWdWRITTZYRzRnSUNBZ0x5OGdhSFIwY0RvdkwycHpjR1Z5Wmk1amIyMHZZMnh2YzNWeVpTMTNhWFJvTFdGeVozVnRaVzUwYzF4dUlDQWdJSFpoY2lCcElEMGdZWEpuZFcxbGJuUnpMbXhsYm1kMGFEdGNiaUFnSUNCMllYSWdZWEpuY3lBOUlHNWxkeUJCY25KaGVTaHBLVHRjYmlBZ0lDQjNhR2xzWlNBb2FTMHRLU0I3WEc0Z0lDQWdJQ0JoY21kelcybGRJRDBnWVhKbmRXMWxiblJ6SkRGYmFWMDdYRzRnSUNBZ2ZWeHVJQ0FnSUhaaGNpQnlaWE4xYkhRZ1BTQnZjbWxuYVc1aGJDNWhjSEJzZVNoMGFHbHpMQ0JoY21kektUdGNiaUFnSUNCMllYSWdiMklnUFNCMGFHbHpMbDlmYjJKZlh6dGNiaUFnSUNCMllYSWdhVzV6WlhKMFpXUTdYRzRnSUNBZ2MzZHBkR05vSUNodFpYUm9iMlFwSUh0Y2JpQWdJQ0FnSUdOaGMyVWdKM0IxYzJnbk9seHVJQ0FnSUNBZ0lDQnBibk5sY25SbFpDQTlJR0Z5WjNNN1hHNGdJQ0FnSUNBZ0lHSnlaV0ZyWEc0Z0lDQWdJQ0JqWVhObElDZDFibk5vYVdaMEp6cGNiaUFnSUNBZ0lDQWdhVzV6WlhKMFpXUWdQU0JoY21kek8xeHVJQ0FnSUNBZ0lDQmljbVZoYTF4dUlDQWdJQ0FnWTJGelpTQW5jM0JzYVdObEp6cGNiaUFnSUNBZ0lDQWdhVzV6WlhKMFpXUWdQU0JoY21kekxuTnNhV05sS0RJcE8xeHVJQ0FnSUNBZ0lDQmljbVZoYTF4dUlDQWdJSDFjYmlBZ0lDQnBaaUFvYVc1elpYSjBaV1FwSUhzZ2IySXViMkp6WlhKMlpVRnljbUY1S0dsdWMyVnlkR1ZrS1RzZ2ZWeHVJQ0FnSUM4dklHNXZkR2xtZVNCamFHRnVaMlZjYmlBZ0lDQnZZaTVrWlhBdWJtOTBhV1o1S0NrN1hHNGdJQ0FnY21WMGRYSnVJSEpsYzNWc2RGeHVJQ0I5S1R0Y2JuMHBPMXh1WEc0dktpQWdLaTljYmx4dWRtRnlJR0Z5Y21GNVMyVjVjeUE5SUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVVNWhiV1Z6S0dGeWNtRjVUV1YwYUc5a2N5azdYRzVjYmk4cUtseHVJQ29nUW5rZ1pHVm1ZWFZzZEN3Z2QyaGxiaUJoSUhKbFlXTjBhWFpsSUhCeWIzQmxjblI1SUdseklITmxkQ3dnZEdobElHNWxkeUIyWVd4MVpTQnBjMXh1SUNvZ1lXeHpieUJqYjI1MlpYSjBaV1FnZEc4Z1ltVmpiMjFsSUhKbFlXTjBhWFpsTGlCSWIzZGxkbVZ5SUhkb1pXNGdjR0Z6YzJsdVp5QmtiM2R1SUhCeWIzQnpMRnh1SUNvZ2QyVWdaRzl1SjNRZ2QyRnVkQ0IwYnlCbWIzSmpaU0JqYjI1MlpYSnphVzl1SUdKbFkyRjFjMlVnZEdobElIWmhiSFZsSUcxaGVTQmlaU0JoSUc1bGMzUmxaQ0IyWVd4MVpWeHVJQ29nZFc1a1pYSWdZU0JtY205NlpXNGdaR0YwWVNCemRISjFZM1IxY21VdUlFTnZiblpsY25ScGJtY2dhWFFnZDI5MWJHUWdaR1ZtWldGMElIUm9aU0J2Y0hScGJXbDZZWFJwYjI0dVhHNGdLaTljYm5aaGNpQnZZbk5sY25abGNsTjBZWFJsSUQwZ2UxeHVJQ0J6YUc5MWJHUkRiMjUyWlhKME9pQjBjblZsTEZ4dUlDQnBjMU5sZEhScGJtZFFjbTl3Y3pvZ1ptRnNjMlZjYm4wN1hHNWNiaThxS2x4dUlDb2dUMkp6WlhKMlpYSWdZMnhoYzNNZ2RHaGhkQ0JoY21VZ1lYUjBZV05vWldRZ2RHOGdaV0ZqYUNCdlluTmxjblpsWkZ4dUlDb2diMkpxWldOMExpQlBibU5sSUdGMGRHRmphR1ZrTENCMGFHVWdiMkp6WlhKMlpYSWdZMjl1ZG1WeWRITWdkR0Z5WjJWMFhHNGdLaUJ2WW1wbFkzUW5jeUJ3Y205d1pYSjBlU0JyWlhseklHbHVkRzhnWjJWMGRHVnlMM05sZEhSbGNuTWdkR2hoZEZ4dUlDb2dZMjlzYkdWamRDQmtaWEJsYm1SbGJtTnBaWE1nWVc1a0lHUnBjM0JoZEdOb1pYTWdkWEJrWVhSbGN5NWNiaUFxTDF4dWRtRnlJRTlpYzJWeWRtVnlJRDBnWm5WdVkzUnBiMjRnVDJKelpYSjJaWElnS0haaGJIVmxLU0I3WEc0Z0lIUm9hWE11ZG1Gc2RXVWdQU0IyWVd4MVpUdGNiaUFnZEdocGN5NWtaWEFnUFNCdVpYY2dSR1Z3S0NrN1hHNGdJSFJvYVhNdWRtMURiM1Z1ZENBOUlEQTdYRzRnSUdSbFppaDJZV3gxWlN3Z0oxOWZiMkpmWHljc0lIUm9hWE1wTzF4dUlDQnBaaUFvUVhKeVlYa3VhWE5CY25KaGVTaDJZV3gxWlNrcElIdGNiaUFnSUNCMllYSWdZWFZuYldWdWRDQTlJR2hoYzFCeWIzUnZYRzRnSUNBZ0lDQS9JSEJ5YjNSdlFYVm5iV1Z1ZEZ4dUlDQWdJQ0FnT2lCamIzQjVRWFZuYldWdWREdGNiaUFnSUNCaGRXZHRaVzUwS0haaGJIVmxMQ0JoY25KaGVVMWxkR2h2WkhNc0lHRnljbUY1UzJWNWN5azdYRzRnSUNBZ2RHaHBjeTV2WW5ObGNuWmxRWEp5WVhrb2RtRnNkV1VwTzF4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUhSb2FYTXVkMkZzYXloMllXeDFaU2s3WEc0Z0lIMWNibjA3WEc1Y2JpOHFLbHh1SUNvZ1YyRnNheUIwYUhKdmRXZG9JR1ZoWTJnZ2NISnZjR1Z5ZEhrZ1lXNWtJR052Ym5abGNuUWdkR2hsYlNCcGJuUnZYRzRnS2lCblpYUjBaWEl2YzJWMGRHVnljeTRnVkdocGN5QnRaWFJvYjJRZ2MyaHZkV3hrSUc5dWJIa2dZbVVnWTJGc2JHVmtJSGRvWlc1Y2JpQXFJSFpoYkhWbElIUjVjR1VnYVhNZ1QySnFaV04wTGx4dUlDb3ZYRzVQWW5ObGNuWmxjaTV3Y205MGIzUjVjR1V1ZDJGc2F5QTlJR1oxYm1OMGFXOXVJSGRoYkdzZ0tHOWlhaWtnZTF4dUlDQjJZWElnYTJWNWN5QTlJRTlpYW1WamRDNXJaWGx6S0c5aWFpazdYRzRnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2EyVjVjeTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUdSbFptbHVaVkpsWVdOMGFYWmxKQ1F4S0c5aWFpd2dhMlY1YzF0cFhTd2diMkpxVzJ0bGVYTmJhVjFkS1R0Y2JpQWdmVnh1ZlR0Y2JseHVMeW9xWEc0Z0tpQlBZbk5sY25abElHRWdiR2x6ZENCdlppQkJjbkpoZVNCcGRHVnRjeTVjYmlBcUwxeHVUMkp6WlhKMlpYSXVjSEp2ZEc5MGVYQmxMbTlpYzJWeWRtVkJjbkpoZVNBOUlHWjFibU4wYVc5dUlHOWljMlZ5ZG1WQmNuSmhlU0FvYVhSbGJYTXBJSHRjYmlBZ1ptOXlJQ2gyWVhJZ2FTQTlJREFzSUd3Z1BTQnBkR1Z0Y3k1c1pXNW5kR2c3SUdrZ1BDQnNPeUJwS3lzcElIdGNiaUFnSUNCdlluTmxjblpsS0dsMFpXMXpXMmxkS1R0Y2JpQWdmVnh1ZlR0Y2JseHVMeThnYUdWc2NHVnljMXh1WEc0dktpcGNiaUFxSUVGMVoyMWxiblFnWVc0Z2RHRnlaMlYwSUU5aWFtVmpkQ0J2Y2lCQmNuSmhlU0JpZVNCcGJuUmxjbU5sY0hScGJtZGNiaUFxSUhSb1pTQndjbTkwYjNSNWNHVWdZMmhoYVc0Z2RYTnBibWNnWDE5d2NtOTBiMTlmWEc0Z0tpOWNibVoxYm1OMGFXOXVJSEJ5YjNSdlFYVm5iV1Z1ZENBb2RHRnlaMlYwTENCemNtTXBJSHRjYmlBZ0x5b2daWE5zYVc1MExXUnBjMkZpYkdVZ2JtOHRjSEp2ZEc4Z0tpOWNiaUFnZEdGeVoyVjBMbDlmY0hKdmRHOWZYeUE5SUhOeVl6dGNiaUFnTHlvZ1pYTnNhVzUwTFdWdVlXSnNaU0J1Ynkxd2NtOTBieUFxTDF4dWZWeHVYRzR2S2lwY2JpQXFJRUYxWjIxbGJuUWdZVzRnZEdGeVoyVjBJRTlpYW1WamRDQnZjaUJCY25KaGVTQmllU0JrWldacGJtbHVaMXh1SUNvZ2FHbGtaR1Z1SUhCeWIzQmxjblJwWlhNdVhHNGdLaTljYmk4cUlHbHpkR0Z1WW5Wc0lHbG5ibTl5WlNCdVpYaDBJQ292WEc1bWRXNWpkR2x2YmlCamIzQjVRWFZuYldWdWRDQW9kR0Z5WjJWMExDQnpjbU1zSUd0bGVYTXBJSHRjYmlBZ1ptOXlJQ2gyWVhJZ2FTQTlJREFzSUd3Z1BTQnJaWGx6TG14bGJtZDBhRHNnYVNBOElHdzdJR2tyS3lrZ2UxeHVJQ0FnSUhaaGNpQnJaWGtnUFNCclpYbHpXMmxkTzF4dUlDQWdJR1JsWmloMFlYSm5aWFFzSUd0bGVTd2djM0pqVzJ0bGVWMHBPMXh1SUNCOVhHNTlYRzVjYmk4cUtseHVJQ29nUVhSMFpXMXdkQ0IwYnlCamNtVmhkR1VnWVc0Z2IySnpaWEoyWlhJZ2FXNXpkR0Z1WTJVZ1ptOXlJR0VnZG1Gc2RXVXNYRzRnS2lCeVpYUjFjbTV6SUhSb1pTQnVaWGNnYjJKelpYSjJaWElnYVdZZ2MzVmpZMlZ6YzJaMWJHeDVJRzlpYzJWeWRtVmtMRnh1SUNvZ2IzSWdkR2hsSUdWNGFYTjBhVzVuSUc5aWMyVnlkbVZ5SUdsbUlIUm9aU0IyWVd4MVpTQmhiSEpsWVdSNUlHaGhjeUJ2Ym1VdVhHNGdLaTljYm1aMWJtTjBhVzl1SUc5aWMyVnlkbVVnS0haaGJIVmxMQ0JoYzFKdmIzUkVZWFJoS1NCN1hHNGdJR2xtSUNnaGFYTlBZbXBsWTNRb2RtRnNkV1VwS1NCN1hHNGdJQ0FnY21WMGRYSnVYRzRnSUgxY2JpQWdkbUZ5SUc5aU8xeHVJQ0JwWmlBb2FHRnpUM2R1S0haaGJIVmxMQ0FuWDE5dllsOWZKeWtnSmlZZ2RtRnNkV1V1WDE5dllsOWZJR2x1YzNSaGJtTmxiMllnVDJKelpYSjJaWElwSUh0Y2JpQWdJQ0J2WWlBOUlIWmhiSFZsTGw5ZmIySmZYenRjYmlBZ2ZTQmxiSE5sSUdsbUlDaGNiaUFnSUNCdlluTmxjblpsY2xOMFlYUmxMbk5vYjNWc1pFTnZiblpsY25RZ0ppWmNiaUFnSUNBaGFYTlRaWEoyWlhKU1pXNWtaWEpwYm1jb0tTQW1KbHh1SUNBZ0lDaEJjbkpoZVM1cGMwRnljbUY1S0haaGJIVmxLU0I4ZkNCcGMxQnNZV2x1VDJKcVpXTjBLSFpoYkhWbEtTa2dKaVpjYmlBZ0lDQlBZbXBsWTNRdWFYTkZlSFJsYm5OcFlteGxLSFpoYkhWbEtTQW1KbHh1SUNBZ0lDRjJZV3gxWlM1ZmFYTldkV1ZjYmlBZ0tTQjdYRzRnSUNBZ2IySWdQU0J1WlhjZ1QySnpaWEoyWlhJb2RtRnNkV1VwTzF4dUlDQjlYRzRnSUdsbUlDaGhjMUp2YjNSRVlYUmhJQ1ltSUc5aUtTQjdYRzRnSUNBZ2IySXVkbTFEYjNWdWRDc3JPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQnZZbHh1ZlZ4dVhHNHZLaXBjYmlBcUlFUmxabWx1WlNCaElISmxZV04wYVhabElIQnliM0JsY25SNUlHOXVJR0Z1SUU5aWFtVmpkQzVjYmlBcUwxeHVablZ1WTNScGIyNGdaR1ZtYVc1bFVtVmhZM1JwZG1Va0pERWdLRnh1SUNCdlltb3NYRzRnSUd0bGVTeGNiaUFnZG1Gc0xGeHVJQ0JqZFhOMGIyMVRaWFIwWlhKY2Jpa2dlMXh1SUNCMllYSWdaR1Z3SUQwZ2JtVjNJRVJsY0NncE8xeHVYRzRnSUhaaGNpQndjbTl3WlhKMGVTQTlJRTlpYW1WamRDNW5aWFJQZDI1UWNtOXdaWEowZVVSbGMyTnlhWEIwYjNJb2IySnFMQ0JyWlhrcE8xeHVJQ0JwWmlBb2NISnZjR1Z5ZEhrZ0ppWWdjSEp2Y0dWeWRIa3VZMjl1Wm1sbmRYSmhZbXhsSUQwOVBTQm1ZV3h6WlNrZ2UxeHVJQ0FnSUhKbGRIVnlibHh1SUNCOVhHNWNiaUFnTHk4Z1kyRjBaWElnWm05eUlIQnlaUzFrWldacGJtVmtJR2RsZEhSbGNpOXpaWFIwWlhKelhHNGdJSFpoY2lCblpYUjBaWElnUFNCd2NtOXdaWEowZVNBbUppQndjbTl3WlhKMGVTNW5aWFE3WEc0Z0lIWmhjaUJ6WlhSMFpYSWdQU0J3Y205d1pYSjBlU0FtSmlCd2NtOXdaWEowZVM1elpYUTdYRzVjYmlBZ2RtRnlJR05vYVd4a1QySWdQU0J2WW5ObGNuWmxLSFpoYkNrN1hHNGdJRTlpYW1WamRDNWtaV1pwYm1WUWNtOXdaWEowZVNodlltb3NJR3RsZVN3Z2UxeHVJQ0FnSUdWdWRXMWxjbUZpYkdVNklIUnlkV1VzWEc0Z0lDQWdZMjl1Wm1sbmRYSmhZbXhsT2lCMGNuVmxMRnh1SUNBZ0lHZGxkRG9nWm5WdVkzUnBiMjRnY21WaFkzUnBkbVZIWlhSMFpYSWdLQ2tnZTF4dUlDQWdJQ0FnZG1GeUlIWmhiSFZsSUQwZ1oyVjBkR1Z5SUQ4Z1oyVjBkR1Z5TG1OaGJHd29iMkpxS1NBNklIWmhiRHRjYmlBZ0lDQWdJR2xtSUNoRVpYQXVkR0Z5WjJWMEtTQjdYRzRnSUNBZ0lDQWdJR1JsY0M1a1pYQmxibVFvS1R0Y2JpQWdJQ0FnSUNBZ2FXWWdLR05vYVd4a1QySXBJSHRjYmlBZ0lDQWdJQ0FnSUNCamFHbHNaRTlpTG1SbGNDNWtaWEJsYm1Rb0tUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0JwWmlBb1FYSnlZWGt1YVhOQmNuSmhlU2gyWVd4MVpTa3BJSHRjYmlBZ0lDQWdJQ0FnSUNCa1pYQmxibVJCY25KaGVTaDJZV3gxWlNrN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lISmxkSFZ5YmlCMllXeDFaVnh1SUNBZ0lIMHNYRzRnSUNBZ2MyVjBPaUJtZFc1amRHbHZiaUJ5WldGamRHbDJaVk5sZEhSbGNpQW9ibVYzVm1Gc0tTQjdYRzRnSUNBZ0lDQjJZWElnZG1Gc2RXVWdQU0JuWlhSMFpYSWdQeUJuWlhSMFpYSXVZMkZzYkNodlltb3BJRG9nZG1Gc08xeHVJQ0FnSUNBZ0x5b2daWE5zYVc1MExXUnBjMkZpYkdVZ2JtOHRjMlZzWmkxamIyMXdZWEpsSUNvdlhHNGdJQ0FnSUNCcFppQW9ibVYzVm1Gc0lEMDlQU0IyWVd4MVpTQjhmQ0FvYm1WM1ZtRnNJQ0U5UFNCdVpYZFdZV3dnSmlZZ2RtRnNkV1VnSVQwOUlIWmhiSFZsS1NrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY201Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUM4cUlHVnpiR2x1ZEMxbGJtRmliR1VnYm04dGMyVnNaaTFqYjIxd1lYSmxJQ292WEc0Z0lDQWdJQ0JwWmlBb2NISnZZMlZ6Y3k1bGJuWXVUazlFUlY5RlRsWWdJVDA5SUNkd2NtOWtkV04wYVc5dUp5QW1KaUJqZFhOMGIyMVRaWFIwWlhJcElIdGNiaUFnSUNBZ0lDQWdZM1Z6ZEc5dFUyVjBkR1Z5S0NrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNCcFppQW9jMlYwZEdWeUtTQjdYRzRnSUNBZ0lDQWdJSE5sZEhSbGNpNWpZV3hzS0c5aWFpd2dibVYzVm1Gc0tUdGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lIWmhiQ0E5SUc1bGQxWmhiRHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJR05vYVd4a1QySWdQU0J2WW5ObGNuWmxLRzVsZDFaaGJDazdYRzRnSUNBZ0lDQmtaWEF1Ym05MGFXWjVLQ2s3WEc0Z0lDQWdmVnh1SUNCOUtUdGNibjFjYmx4dUx5b3FYRzRnS2lCVFpYUWdZU0J3Y205d1pYSjBlU0J2YmlCaGJpQnZZbXBsWTNRdUlFRmtaSE1nZEdobElHNWxkeUJ3Y205d1pYSjBlU0JoYm1SY2JpQXFJSFJ5YVdkblpYSnpJR05vWVc1blpTQnViM1JwWm1sallYUnBiMjRnYVdZZ2RHaGxJSEJ5YjNCbGNuUjVJR1J2WlhOdUozUmNiaUFxSUdGc2NtVmhaSGtnWlhocGMzUXVYRzRnS2k5Y2JtWjFibU4wYVc5dUlITmxkQ0FvZEdGeVoyVjBMQ0JyWlhrc0lIWmhiQ2tnZTF4dUlDQnBaaUFvUVhKeVlYa3VhWE5CY25KaGVTaDBZWEpuWlhRcElDWW1JSFI1Y0dWdlppQnJaWGtnUFQwOUlDZHVkVzFpWlhJbktTQjdYRzRnSUNBZ2RHRnlaMlYwTG14bGJtZDBhQ0E5SUUxaGRHZ3ViV0Y0S0hSaGNtZGxkQzVzWlc1bmRHZ3NJR3RsZVNrN1hHNGdJQ0FnZEdGeVoyVjBMbk53YkdsalpTaHJaWGtzSURFc0lIWmhiQ2s3WEc0Z0lDQWdjbVYwZFhKdUlIWmhiRnh1SUNCOVhHNGdJR2xtSUNob1lYTlBkMjRvZEdGeVoyVjBMQ0JyWlhrcEtTQjdYRzRnSUNBZ2RHRnlaMlYwVzJ0bGVWMGdQU0IyWVd3N1hHNGdJQ0FnY21WMGRYSnVJSFpoYkZ4dUlDQjlYRzRnSUhaaGNpQnZZaUE5SUNoMFlYSm5aWFFnS1M1ZlgyOWlYMTg3WEc0Z0lHbG1JQ2gwWVhKblpYUXVYMmx6Vm5WbElIeDhJQ2h2WWlBbUppQnZZaTUyYlVOdmRXNTBLU2tnZTF4dUlDQWdJSEJ5YjJObGMzTXVaVzUyTGs1UFJFVmZSVTVXSUNFOVBTQW5jSEp2WkhWamRHbHZiaWNnSmlZZ2QyRnliaWhjYmlBZ0lDQWdJQ2RCZG05cFpDQmhaR1JwYm1jZ2NtVmhZM1JwZG1VZ2NISnZjR1Z5ZEdsbGN5QjBieUJoSUZaMVpTQnBibk4wWVc1alpTQnZjaUJwZEhNZ2NtOXZkQ0FrWkdGMFlTQW5JQ3RjYmlBZ0lDQWdJQ2RoZENCeWRXNTBhVzFsSUMwZ1pHVmpiR0Z5WlNCcGRDQjFjR1p5YjI1MElHbHVJSFJvWlNCa1lYUmhJRzl3ZEdsdmJpNG5YRzRnSUNBZ0tUdGNiaUFnSUNCeVpYUjFjbTRnZG1Gc1hHNGdJSDFjYmlBZ2FXWWdLQ0Z2WWlrZ2UxeHVJQ0FnSUhSaGNtZGxkRnRyWlhsZElEMGdkbUZzTzF4dUlDQWdJSEpsZEhWeWJpQjJZV3hjYmlBZ2ZWeHVJQ0JrWldacGJtVlNaV0ZqZEdsMlpTUWtNU2h2WWk1MllXeDFaU3dnYTJWNUxDQjJZV3dwTzF4dUlDQnZZaTVrWlhBdWJtOTBhV1o1S0NrN1hHNGdJSEpsZEhWeWJpQjJZV3hjYm4xY2JseHVMeW9xWEc0Z0tpQkVaV3hsZEdVZ1lTQndjbTl3WlhKMGVTQmhibVFnZEhKcFoyZGxjaUJqYUdGdVoyVWdhV1lnYm1WalpYTnpZWEo1TGx4dUlDb3ZYRzVtZFc1amRHbHZiaUJrWld3Z0tIUmhjbWRsZEN3Z2EyVjVLU0I3WEc0Z0lHbG1JQ2hCY25KaGVTNXBjMEZ5Y21GNUtIUmhjbWRsZENrZ0ppWWdkSGx3Wlc5bUlHdGxlU0E5UFQwZ0oyNTFiV0psY2ljcElIdGNiaUFnSUNCMFlYSm5aWFF1YzNCc2FXTmxLR3RsZVN3Z01TazdYRzRnSUNBZ2NtVjBkWEp1WEc0Z0lIMWNiaUFnZG1GeUlHOWlJRDBnS0hSaGNtZGxkQ0FwTGw5ZmIySmZYenRjYmlBZ2FXWWdLSFJoY21kbGRDNWZhWE5XZFdVZ2ZId2dLRzlpSUNZbUlHOWlMblp0UTI5MWJuUXBLU0I3WEc0Z0lDQWdjSEp2WTJWemN5NWxibll1VGs5RVJWOUZUbFlnSVQwOUlDZHdjbTlrZFdOMGFXOXVKeUFtSmlCM1lYSnVLRnh1SUNBZ0lDQWdKMEYyYjJsa0lHUmxiR1YwYVc1bklIQnliM0JsY25ScFpYTWdiMjRnWVNCV2RXVWdhVzV6ZEdGdVkyVWdiM0lnYVhSeklISnZiM1FnSkdSaGRHRWdKeUFyWEc0Z0lDQWdJQ0FuTFNCcWRYTjBJSE5sZENCcGRDQjBieUJ1ZFd4c0xpZGNiaUFnSUNBcE8xeHVJQ0FnSUhKbGRIVnlibHh1SUNCOVhHNGdJR2xtSUNnaGFHRnpUM2R1S0hSaGNtZGxkQ3dnYTJWNUtTa2dlMXh1SUNBZ0lISmxkSFZ5Ymx4dUlDQjlYRzRnSUdSbGJHVjBaU0IwWVhKblpYUmJhMlY1WFR0Y2JpQWdhV1lnS0NGdllpa2dlMXh1SUNBZ0lISmxkSFZ5Ymx4dUlDQjlYRzRnSUc5aUxtUmxjQzV1YjNScFpua29LVHRjYm4xY2JseHVMeW9xWEc0Z0tpQkRiMnhzWldOMElHUmxjR1Z1WkdWdVkybGxjeUJ2YmlCaGNuSmhlU0JsYkdWdFpXNTBjeUIzYUdWdUlIUm9aU0JoY25KaGVTQnBjeUIwYjNWamFHVmtMQ0J6YVc1alpWeHVJQ29nZDJVZ1kyRnVibTkwSUdsdWRHVnlZMlZ3ZENCaGNuSmhlU0JsYkdWdFpXNTBJR0ZqWTJWemN5QnNhV3RsSUhCeWIzQmxjblI1SUdkbGRIUmxjbk11WEc0Z0tpOWNibVoxYm1OMGFXOXVJR1JsY0dWdVpFRnljbUY1SUNoMllXeDFaU2tnZTF4dUlDQm1iM0lnS0haaGNpQmxJRDBnS0hadmFXUWdNQ2tzSUdrZ1BTQXdMQ0JzSUQwZ2RtRnNkV1V1YkdWdVozUm9PeUJwSUR3Z2JEc2dhU3NyS1NCN1hHNGdJQ0FnWlNBOUlIWmhiSFZsVzJsZE8xeHVJQ0FnSUdVZ0ppWWdaUzVmWDI5aVgxOGdKaVlnWlM1ZlgyOWlYMTh1WkdWd0xtUmxjR1Z1WkNncE8xeHVJQ0FnSUdsbUlDaEJjbkpoZVM1cGMwRnljbUY1S0dVcEtTQjdYRzRnSUNBZ0lDQmtaWEJsYm1SQmNuSmhlU2hsS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNibjFjYmx4dUx5b2dJQ292WEc1Y2JpOHFLbHh1SUNvZ1QzQjBhVzl1SUc5MlpYSjNjbWwwYVc1bklITjBjbUYwWldkcFpYTWdZWEpsSUdaMWJtTjBhVzl1Y3lCMGFHRjBJR2hoYm1Sc1pWeHVJQ29nYUc5M0lIUnZJRzFsY21kbElHRWdjR0Z5Wlc1MElHOXdkR2x2YmlCMllXeDFaU0JoYm1RZ1lTQmphR2xzWkNCdmNIUnBiMjVjYmlBcUlIWmhiSFZsSUdsdWRHOGdkR2hsSUdacGJtRnNJSFpoYkhWbExseHVJQ292WEc1MllYSWdjM1J5WVhSeklEMGdZMjl1Wm1sbkxtOXdkR2x2YmsxbGNtZGxVM1J5WVhSbFoybGxjenRjYmx4dUx5b3FYRzRnS2lCUGNIUnBiMjV6SUhkcGRHZ2djbVZ6ZEhKcFkzUnBiMjV6WEc0Z0tpOWNibWxtSUNod2NtOWpaWE56TG1WdWRpNU9UMFJGWDBWT1ZpQWhQVDBnSjNCeWIyUjFZM1JwYjI0bktTQjdYRzRnSUhOMGNtRjBjeTVsYkNBOUlITjBjbUYwY3k1d2NtOXdjMFJoZEdFZ1BTQm1kVzVqZEdsdmJpQW9jR0Z5Wlc1MExDQmphR2xzWkN3Z2RtMHNJR3RsZVNrZ2UxeHVJQ0FnSUdsbUlDZ2hkbTBwSUh0Y2JpQWdJQ0FnSUhkaGNtNG9YRzRnSUNBZ0lDQWdJRndpYjNCMGFXOXVJRnhjWENKY0lpQXJJR3RsZVNBcklGd2lYRnhjSWlCallXNGdiMjVzZVNCaVpTQjFjMlZrSUdSMWNtbHVaeUJwYm5OMFlXNWpaU0JjSWlBclhHNGdJQ0FnSUNBZ0lDZGpjbVZoZEdsdmJpQjNhWFJvSUhSb1pTQmdibVYzWUNCclpYbDNiM0prTGlkY2JpQWdJQ0FnSUNrN1hHNGdJQ0FnZlZ4dUlDQWdJSEpsZEhWeWJpQmtaV1poZFd4MFUzUnlZWFFvY0dGeVpXNTBMQ0JqYUdsc1pDbGNiaUFnZlR0Y2JuMWNibHh1THlvcVhHNGdLaUJJWld4d1pYSWdkR2hoZENCeVpXTjFjbk5wZG1Wc2VTQnRaWEpuWlhNZ2RIZHZJR1JoZEdFZ2IySnFaV04wY3lCMGIyZGxkR2hsY2k1Y2JpQXFMMXh1Wm5WdVkzUnBiMjRnYldWeVoyVkVZWFJoSUNoMGJ5d2dabkp2YlNrZ2UxeHVJQ0JwWmlBb0lXWnliMjBwSUhzZ2NtVjBkWEp1SUhSdklIMWNiaUFnZG1GeUlHdGxlU3dnZEc5V1lXd3NJR1p5YjIxV1lXdzdYRzRnSUhaaGNpQnJaWGx6SUQwZ1QySnFaV04wTG10bGVYTW9abkp2YlNrN1hHNGdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnYTJWNWN5NXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJR3RsZVNBOUlHdGxlWE5iYVYwN1hHNGdJQ0FnZEc5V1lXd2dQU0IwYjF0clpYbGRPMXh1SUNBZ0lHWnliMjFXWVd3Z1BTQm1jbTl0VzJ0bGVWMDdYRzRnSUNBZ2FXWWdLQ0ZvWVhOUGQyNG9kRzhzSUd0bGVTa3BJSHRjYmlBZ0lDQWdJSE5sZENoMGJ5d2dhMlY1TENCbWNtOXRWbUZzS1R0Y2JpQWdJQ0I5SUdWc2MyVWdhV1lnS0dselVHeGhhVzVQWW1wbFkzUW9kRzlXWVd3cElDWW1JR2x6VUd4aGFXNVBZbXBsWTNRb1puSnZiVlpoYkNrcElIdGNiaUFnSUNBZ0lHMWxjbWRsUkdGMFlTaDBiMVpoYkN3Z1puSnZiVlpoYkNrN1hHNGdJQ0FnZlZ4dUlDQjlYRzRnSUhKbGRIVnliaUIwYjF4dWZWeHVYRzR2S2lwY2JpQXFJRVJoZEdGY2JpQXFMMXh1YzNSeVlYUnpMbVJoZEdFZ1BTQm1kVzVqZEdsdmJpQW9YRzRnSUhCaGNtVnVkRlpoYkN4Y2JpQWdZMmhwYkdSV1lXd3NYRzRnSUhadFhHNHBJSHRjYmlBZ2FXWWdLQ0YyYlNrZ2UxeHVJQ0FnSUM4dklHbHVJR0VnVm5WbExtVjRkR1Z1WkNCdFpYSm5aU3dnWW05MGFDQnphRzkxYkdRZ1ltVWdablZ1WTNScGIyNXpYRzRnSUNBZ2FXWWdLQ0ZqYUdsc1pGWmhiQ2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJSEJoY21WdWRGWmhiRnh1SUNBZ0lIMWNiaUFnSUNCcFppQW9kSGx3Wlc5bUlHTm9hV3hrVm1Gc0lDRTlQU0FuWm5WdVkzUnBiMjRuS1NCN1hHNGdJQ0FnSUNCd2NtOWpaWE56TG1WdWRpNU9UMFJGWDBWT1ZpQWhQVDBnSjNCeWIyUjFZM1JwYjI0bklDWW1JSGRoY200b1hHNGdJQ0FnSUNBZ0lDZFVhR1VnWENKa1lYUmhYQ0lnYjNCMGFXOXVJSE5vYjNWc1pDQmlaU0JoSUdaMWJtTjBhVzl1SUNjZ0sxeHVJQ0FnSUNBZ0lDQW5kR2hoZENCeVpYUjFjbTV6SUdFZ2NHVnlMV2x1YzNSaGJtTmxJSFpoYkhWbElHbHVJR052YlhCdmJtVnVkQ0FuSUN0Y2JpQWdJQ0FnSUNBZ0oyUmxabWx1YVhScGIyNXpMaWNzWEc0Z0lDQWdJQ0FnSUhadFhHNGdJQ0FnSUNBcE8xeHVJQ0FnSUNBZ2NtVjBkWEp1SUhCaGNtVnVkRlpoYkZ4dUlDQWdJSDFjYmlBZ0lDQnBaaUFvSVhCaGNtVnVkRlpoYkNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUdOb2FXeGtWbUZzWEc0Z0lDQWdmVnh1SUNBZ0lDOHZJSGRvWlc0Z2NHRnlaVzUwVm1Gc0lDWWdZMmhwYkdSV1lXd2dZWEpsSUdKdmRHZ2djSEpsYzJWdWRDeGNiaUFnSUNBdkx5QjNaU0J1WldWa0lIUnZJSEpsZEhWeWJpQmhJR1oxYm1OMGFXOXVJSFJvWVhRZ2NtVjBkWEp1Y3lCMGFHVmNiaUFnSUNBdkx5QnRaWEpuWldRZ2NtVnpkV3gwSUc5bUlHSnZkR2dnWm5WdVkzUnBiMjV6TGk0dUlHNXZJRzVsWldRZ2RHOWNiaUFnSUNBdkx5QmphR1ZqYXlCcFppQndZWEpsYm5SV1lXd2dhWE1nWVNCbWRXNWpkR2x2YmlCb1pYSmxJR0psWTJGMWMyVmNiaUFnSUNBdkx5QnBkQ0JvWVhNZ2RHOGdZbVVnWVNCbWRXNWpkR2x2YmlCMGJ5QndZWE56SUhCeVpYWnBiM1Z6SUcxbGNtZGxjeTVjYmlBZ0lDQnlaWFIxY200Z1puVnVZM1JwYjI0Z2JXVnlaMlZrUkdGMFlVWnVJQ2dwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJ0WlhKblpVUmhkR0VvWEc0Z0lDQWdJQ0FnSUdOb2FXeGtWbUZzTG1OaGJHd29kR2hwY3lrc1hHNGdJQ0FnSUNBZ0lIQmhjbVZ1ZEZaaGJDNWpZV3hzS0hSb2FYTXBYRzRnSUNBZ0lDQXBYRzRnSUNBZ2ZWeHVJQ0I5SUdWc2MyVWdhV1lnS0hCaGNtVnVkRlpoYkNCOGZDQmphR2xzWkZaaGJDa2dlMXh1SUNBZ0lISmxkSFZ5YmlCbWRXNWpkR2x2YmlCdFpYSm5aV1JKYm5OMFlXNWpaVVJoZEdGR2JpQW9LU0I3WEc0Z0lDQWdJQ0F2THlCcGJuTjBZVzVqWlNCdFpYSm5aVnh1SUNBZ0lDQWdkbUZ5SUdsdWMzUmhibU5sUkdGMFlTQTlJSFI1Y0dWdlppQmphR2xzWkZaaGJDQTlQVDBnSjJaMWJtTjBhVzl1SjF4dUlDQWdJQ0FnSUNBL0lHTm9hV3hrVm1Gc0xtTmhiR3dvZG0wcFhHNGdJQ0FnSUNBZ0lEb2dZMmhwYkdSV1lXdzdYRzRnSUNBZ0lDQjJZWElnWkdWbVlYVnNkRVJoZEdFZ1BTQjBlWEJsYjJZZ2NHRnlaVzUwVm1Gc0lEMDlQU0FuWm5WdVkzUnBiMjRuWEc0Z0lDQWdJQ0FnSUQ4Z2NHRnlaVzUwVm1Gc0xtTmhiR3dvZG0wcFhHNGdJQ0FnSUNBZ0lEb2dkVzVrWldacGJtVmtPMXh1SUNBZ0lDQWdhV1lnS0dsdWMzUmhibU5sUkdGMFlTa2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdiV1Z5WjJWRVlYUmhLR2x1YzNSaGJtTmxSR0YwWVN3Z1pHVm1ZWFZzZEVSaGRHRXBYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1pHVm1ZWFZzZEVSaGRHRmNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNGdJSDFjYm4wN1hHNWNiaThxS2x4dUlDb2dTRzl2YTNNZ1lXNWtJSEJ5YjNCeklHRnlaU0J0WlhKblpXUWdZWE1nWVhKeVlYbHpMbHh1SUNvdlhHNW1kVzVqZEdsdmJpQnRaWEpuWlVodmIyc2dLRnh1SUNCd1lYSmxiblJXWVd3c1hHNGdJR05vYVd4a1ZtRnNYRzRwSUh0Y2JpQWdjbVYwZFhKdUlHTm9hV3hrVm1Gc1hHNGdJQ0FnUHlCd1lYSmxiblJXWVd4Y2JpQWdJQ0FnSUQ4Z2NHRnlaVzUwVm1Gc0xtTnZibU5oZENoamFHbHNaRlpoYkNsY2JpQWdJQ0FnSURvZ1FYSnlZWGt1YVhOQmNuSmhlU2hqYUdsc1pGWmhiQ2xjYmlBZ0lDQWdJQ0FnUHlCamFHbHNaRlpoYkZ4dUlDQWdJQ0FnSUNBNklGdGphR2xzWkZaaGJGMWNiaUFnSUNBNklIQmhjbVZ1ZEZaaGJGeHVmVnh1WEc1amIyNW1hV2N1WDJ4cFptVmplV05zWlVodmIydHpMbVp2Y2tWaFkyZ29ablZ1WTNScGIyNGdLR2h2YjJzcElIdGNiaUFnYzNSeVlYUnpXMmh2YjJ0ZElEMGdiV1Z5WjJWSWIyOXJPMXh1ZlNrN1hHNWNiaThxS2x4dUlDb2dRWE56WlhSelhHNGdLbHh1SUNvZ1YyaGxiaUJoSUhadElHbHpJSEJ5WlhObGJuUWdLR2x1YzNSaGJtTmxJR055WldGMGFXOXVLU3dnZDJVZ2JtVmxaQ0IwYnlCa2IxeHVJQ29nWVNCMGFISmxaUzEzWVhrZ2JXVnlaMlVnWW1WMGQyVmxiaUJqYjI1emRISjFZM1J2Y2lCdmNIUnBiMjV6TENCcGJuTjBZVzVqWlZ4dUlDb2diM0IwYVc5dWN5QmhibVFnY0dGeVpXNTBJRzl3ZEdsdmJuTXVYRzRnS2k5Y2JtWjFibU4wYVc5dUlHMWxjbWRsUVhOelpYUnpJQ2h3WVhKbGJuUldZV3dzSUdOb2FXeGtWbUZzS1NCN1hHNGdJSFpoY2lCeVpYTWdQU0JQWW1wbFkzUXVZM0psWVhSbEtIQmhjbVZ1ZEZaaGJDQjhmQ0J1ZFd4c0tUdGNiaUFnY21WMGRYSnVJR05vYVd4a1ZtRnNYRzRnSUNBZ1B5QmxlSFJsYm1Rb2NtVnpMQ0JqYUdsc1pGWmhiQ2xjYmlBZ0lDQTZJSEpsYzF4dWZWeHVYRzVqYjI1bWFXY3VYMkZ6YzJWMFZIbHdaWE11Wm05eVJXRmphQ2htZFc1amRHbHZiaUFvZEhsd1pTa2dlMXh1SUNCemRISmhkSE5iZEhsd1pTQXJJQ2R6SjEwZ1BTQnRaWEpuWlVGemMyVjBjenRjYm4wcE8xeHVYRzR2S2lwY2JpQXFJRmRoZEdOb1pYSnpMbHh1SUNwY2JpQXFJRmRoZEdOb1pYSnpJR2hoYzJobGN5QnphRzkxYkdRZ2JtOTBJRzkyWlhKM2NtbDBaU0J2Ym1WY2JpQXFJR0Z1YjNSb1pYSXNJSE52SUhkbElHMWxjbWRsSUhSb1pXMGdZWE1nWVhKeVlYbHpMbHh1SUNvdlhHNXpkSEpoZEhNdWQyRjBZMmdnUFNCbWRXNWpkR2x2YmlBb2NHRnlaVzUwVm1Gc0xDQmphR2xzWkZaaGJDa2dlMXh1SUNBdktpQnBjM1JoYm1KMWJDQnBaMjV2Y21VZ2FXWWdLaTljYmlBZ2FXWWdLQ0ZqYUdsc1pGWmhiQ2tnZXlCeVpYUjFjbTRnVDJKcVpXTjBMbU55WldGMFpTaHdZWEpsYm5SV1lXd2dmSHdnYm5Wc2JDa2dmVnh1SUNCcFppQW9JWEJoY21WdWRGWmhiQ2tnZXlCeVpYUjFjbTRnWTJocGJHUldZV3dnZlZ4dUlDQjJZWElnY21WMElEMGdlMzA3WEc0Z0lHVjRkR1Z1WkNoeVpYUXNJSEJoY21WdWRGWmhiQ2s3WEc0Z0lHWnZjaUFvZG1GeUlHdGxlU0JwYmlCamFHbHNaRlpoYkNrZ2UxeHVJQ0FnSUhaaGNpQndZWEpsYm5RZ1BTQnlaWFJiYTJWNVhUdGNiaUFnSUNCMllYSWdZMmhwYkdRZ1BTQmphR2xzWkZaaGJGdHJaWGxkTzF4dUlDQWdJR2xtSUNod1lYSmxiblFnSmlZZ0lVRnljbUY1TG1selFYSnlZWGtvY0dGeVpXNTBLU2tnZTF4dUlDQWdJQ0FnY0dGeVpXNTBJRDBnVzNCaGNtVnVkRjA3WEc0Z0lDQWdmVnh1SUNBZ0lISmxkRnRyWlhsZElEMGdjR0Z5Wlc1MFhHNGdJQ0FnSUNBL0lIQmhjbVZ1ZEM1amIyNWpZWFFvWTJocGJHUXBYRzRnSUNBZ0lDQTZJRnRqYUdsc1pGMDdYRzRnSUgxY2JpQWdjbVYwZFhKdUlISmxkRnh1ZlR0Y2JseHVMeW9xWEc0Z0tpQlBkR2hsY2lCdlltcGxZM1FnYUdGemFHVnpMbHh1SUNvdlhHNXpkSEpoZEhNdWNISnZjSE1nUFZ4dWMzUnlZWFJ6TG0xbGRHaHZaSE1nUFZ4dWMzUnlZWFJ6TG1OdmJYQjFkR1ZrSUQwZ1puVnVZM1JwYjI0Z0tIQmhjbVZ1ZEZaaGJDd2dZMmhwYkdSV1lXd3BJSHRjYmlBZ2FXWWdLQ0ZqYUdsc1pGWmhiQ2tnZXlCeVpYUjFjbTRnVDJKcVpXTjBMbU55WldGMFpTaHdZWEpsYm5SV1lXd2dmSHdnYm5Wc2JDa2dmVnh1SUNCcFppQW9JWEJoY21WdWRGWmhiQ2tnZXlCeVpYUjFjbTRnWTJocGJHUldZV3dnZlZ4dUlDQjJZWElnY21WMElEMGdUMkpxWldOMExtTnlaV0YwWlNodWRXeHNLVHRjYmlBZ1pYaDBaVzVrS0hKbGRDd2djR0Z5Wlc1MFZtRnNLVHRjYmlBZ1pYaDBaVzVrS0hKbGRDd2dZMmhwYkdSV1lXd3BPMXh1SUNCeVpYUjFjbTRnY21WMFhHNTlPMXh1WEc0dktpcGNiaUFxSUVSbFptRjFiSFFnYzNSeVlYUmxaM2t1WEc0Z0tpOWNiblpoY2lCa1pXWmhkV3gwVTNSeVlYUWdQU0JtZFc1amRHbHZiaUFvY0dGeVpXNTBWbUZzTENCamFHbHNaRlpoYkNrZ2UxeHVJQ0J5WlhSMWNtNGdZMmhwYkdSV1lXd2dQVDA5SUhWdVpHVm1hVzVsWkZ4dUlDQWdJRDhnY0dGeVpXNTBWbUZzWEc0Z0lDQWdPaUJqYUdsc1pGWmhiRnh1ZlR0Y2JseHVMeW9xWEc0Z0tpQldZV3hwWkdGMFpTQmpiMjF3YjI1bGJuUWdibUZ0WlhOY2JpQXFMMXh1Wm5WdVkzUnBiMjRnWTJobFkydERiMjF3YjI1bGJuUnpJQ2h2Y0hScGIyNXpLU0I3WEc0Z0lHWnZjaUFvZG1GeUlHdGxlU0JwYmlCdmNIUnBiMjV6TG1OdmJYQnZibVZ1ZEhNcElIdGNiaUFnSUNCMllYSWdiRzkzWlhJZ1BTQnJaWGt1ZEc5TWIzZGxja05oYzJVb0tUdGNiaUFnSUNCcFppQW9hWE5DZFdsc2RFbHVWR0ZuS0d4dmQyVnlLU0I4ZkNCamIyNW1hV2N1YVhOU1pYTmxjblpsWkZSaFp5aHNiM2RsY2lrcElIdGNiaUFnSUNBZ0lIZGhjbTRvWEc0Z0lDQWdJQ0FnSUNkRWJ5QnViM1FnZFhObElHSjFhV3gwTFdsdUlHOXlJSEpsYzJWeWRtVmtJRWhVVFV3Z1pXeGxiV1Z1ZEhNZ1lYTWdZMjl0Y0c5dVpXNTBJQ2NnSzF4dUlDQWdJQ0FnSUNBbmFXUTZJQ2NnS3lCclpYbGNiaUFnSUNBZ0lDazdYRzRnSUNBZ2ZWeHVJQ0I5WEc1OVhHNWNiaThxS2x4dUlDb2dSVzV6ZFhKbElHRnNiQ0J3Y205d2N5QnZjSFJwYjI0Z2MzbHVkR0Y0SUdGeVpTQnViM0p0WVd4cGVtVmtJR2x1ZEc4Z2RHaGxYRzRnS2lCUFltcGxZM1F0WW1GelpXUWdabTl5YldGMExseHVJQ292WEc1bWRXNWpkR2x2YmlCdWIzSnRZV3hwZW1WUWNtOXdjeUFvYjNCMGFXOXVjeWtnZTF4dUlDQjJZWElnY0hKdmNITWdQU0J2Y0hScGIyNXpMbkJ5YjNCek8xeHVJQ0JwWmlBb0lYQnliM0J6S1NCN0lISmxkSFZ5YmlCOVhHNGdJSFpoY2lCeVpYTWdQU0I3ZlR0Y2JpQWdkbUZ5SUdrc0lIWmhiQ3dnYm1GdFpUdGNiaUFnYVdZZ0tFRnljbUY1TG1selFYSnlZWGtvY0hKdmNITXBLU0I3WEc0Z0lDQWdhU0E5SUhCeWIzQnpMbXhsYm1kMGFEdGNiaUFnSUNCM2FHbHNaU0FvYVMwdEtTQjdYRzRnSUNBZ0lDQjJZV3dnUFNCd2NtOXdjMXRwWFR0Y2JpQWdJQ0FnSUdsbUlDaDBlWEJsYjJZZ2RtRnNJRDA5UFNBbmMzUnlhVzVuSnlrZ2UxeHVJQ0FnSUNBZ0lDQnVZVzFsSUQwZ1kyRnRaV3hwZW1Vb2RtRnNLVHRjYmlBZ0lDQWdJQ0FnY21WelcyNWhiV1ZkSUQwZ2V5QjBlWEJsT2lCdWRXeHNJSDA3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0hCeWIyTmxjM011Wlc1MkxrNVBSRVZmUlU1V0lDRTlQU0FuY0hKdlpIVmpkR2x2YmljcElIdGNiaUFnSUNBZ0lDQWdkMkZ5YmlnbmNISnZjSE1nYlhWemRDQmlaU0J6ZEhKcGJtZHpJSGRvWlc0Z2RYTnBibWNnWVhKeVlYa2djM2x1ZEdGNExpY3BPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNiaUFnZlNCbGJITmxJR2xtSUNocGMxQnNZV2x1VDJKcVpXTjBLSEJ5YjNCektTa2dlMXh1SUNBZ0lHWnZjaUFvZG1GeUlHdGxlU0JwYmlCd2NtOXdjeWtnZTF4dUlDQWdJQ0FnZG1Gc0lEMGdjSEp2Y0hOYmEyVjVYVHRjYmlBZ0lDQWdJRzVoYldVZ1BTQmpZVzFsYkdsNlpTaHJaWGtwTzF4dUlDQWdJQ0FnY21WelcyNWhiV1ZkSUQwZ2FYTlFiR0ZwYms5aWFtVmpkQ2gyWVd3cFhHNGdJQ0FnSUNBZ0lEOGdkbUZzWEc0Z0lDQWdJQ0FnSURvZ2V5QjBlWEJsT2lCMllXd2dmVHRjYmlBZ0lDQjlYRzRnSUgxY2JpQWdiM0IwYVc5dWN5NXdjbTl3Y3lBOUlISmxjenRjYm4xY2JseHVMeW9xWEc0Z0tpQk9iM0p0WVd4cGVtVWdjbUYzSUdaMWJtTjBhVzl1SUdScGNtVmpkR2wyWlhNZ2FXNTBieUJ2WW1wbFkzUWdabTl5YldGMExseHVJQ292WEc1bWRXNWpkR2x2YmlCdWIzSnRZV3hwZW1WRWFYSmxZM1JwZG1WeklDaHZjSFJwYjI1ektTQjdYRzRnSUhaaGNpQmthWEp6SUQwZ2IzQjBhVzl1Y3k1a2FYSmxZM1JwZG1Wek8xeHVJQ0JwWmlBb1pHbHljeWtnZTF4dUlDQWdJR1p2Y2lBb2RtRnlJR3RsZVNCcGJpQmthWEp6S1NCN1hHNGdJQ0FnSUNCMllYSWdaR1ZtSUQwZ1pHbHljMXRyWlhsZE8xeHVJQ0FnSUNBZ2FXWWdLSFI1Y0dWdlppQmtaV1lnUFQwOUlDZG1kVzVqZEdsdmJpY3BJSHRjYmlBZ0lDQWdJQ0FnWkdseWMxdHJaWGxkSUQwZ2V5QmlhVzVrT2lCa1pXWXNJSFZ3WkdGMFpUb2daR1ZtSUgwN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dUlDQjlYRzU5WEc1Y2JpOHFLbHh1SUNvZ1RXVnlaMlVnZEhkdklHOXdkR2x2YmlCdlltcGxZM1J6SUdsdWRHOGdZU0J1WlhjZ2IyNWxMbHh1SUNvZ1EyOXlaU0IxZEdsc2FYUjVJSFZ6WldRZ2FXNGdZbTkwYUNCcGJuTjBZVzUwYVdGMGFXOXVJR0Z1WkNCcGJtaGxjbWwwWVc1alpTNWNiaUFxTDF4dVpuVnVZM1JwYjI0Z2JXVnlaMlZQY0hScGIyNXpJQ2hjYmlBZ2NHRnlaVzUwTEZ4dUlDQmphR2xzWkN4Y2JpQWdkbTFjYmlrZ2UxeHVJQ0JwWmlBb2NISnZZMlZ6Y3k1bGJuWXVUazlFUlY5RlRsWWdJVDA5SUNkd2NtOWtkV04wYVc5dUp5a2dlMXh1SUNBZ0lHTm9aV05yUTI5dGNHOXVaVzUwY3loamFHbHNaQ2s3WEc0Z0lIMWNiaUFnYm05eWJXRnNhWHBsVUhKdmNITW9ZMmhwYkdRcE8xeHVJQ0J1YjNKdFlXeHBlbVZFYVhKbFkzUnBkbVZ6S0dOb2FXeGtLVHRjYmlBZ2RtRnlJR1Y0ZEdWdVpITkdjbTl0SUQwZ1kyaHBiR1F1WlhoMFpXNWtjenRjYmlBZ2FXWWdLR1Y0ZEdWdVpITkdjbTl0S1NCN1hHNGdJQ0FnY0dGeVpXNTBJRDBnZEhsd1pXOW1JR1Y0ZEdWdVpITkdjbTl0SUQwOVBTQW5ablZ1WTNScGIyNG5YRzRnSUNBZ0lDQS9JRzFsY21kbFQzQjBhVzl1Y3lod1lYSmxiblFzSUdWNGRHVnVaSE5HY205dExtOXdkR2x2Ym5Nc0lIWnRLVnh1SUNBZ0lDQWdPaUJ0WlhKblpVOXdkR2x2Ym5Nb2NHRnlaVzUwTENCbGVIUmxibVJ6Um5KdmJTd2dkbTBwTzF4dUlDQjlYRzRnSUdsbUlDaGphR2xzWkM1dGFYaHBibk1wSUh0Y2JpQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Dd2diQ0E5SUdOb2FXeGtMbTFwZUdsdWN5NXNaVzVuZEdnN0lHa2dQQ0JzT3lCcEt5c3BJSHRjYmlBZ0lDQWdJSFpoY2lCdGFYaHBiaUE5SUdOb2FXeGtMbTFwZUdsdWMxdHBYVHRjYmlBZ0lDQWdJR2xtSUNodGFYaHBiaTV3Y205MGIzUjVjR1VnYVc1emRHRnVZMlZ2WmlCV2RXVWtNaWtnZTF4dUlDQWdJQ0FnSUNCdGFYaHBiaUE5SUcxcGVHbHVMbTl3ZEdsdmJuTTdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQndZWEpsYm5RZ1BTQnRaWEpuWlU5d2RHbHZibk1vY0dGeVpXNTBMQ0J0YVhocGJpd2dkbTBwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVJQ0IyWVhJZ2IzQjBhVzl1Y3lBOUlIdDlPMXh1SUNCMllYSWdhMlY1TzF4dUlDQm1iM0lnS0d0bGVTQnBiaUJ3WVhKbGJuUXBJSHRjYmlBZ0lDQnRaWEpuWlVacFpXeGtLR3RsZVNrN1hHNGdJSDFjYmlBZ1ptOXlJQ2hyWlhrZ2FXNGdZMmhwYkdRcElIdGNiaUFnSUNCcFppQW9JV2hoYzA5M2JpaHdZWEpsYm5Rc0lHdGxlU2twSUh0Y2JpQWdJQ0FnSUcxbGNtZGxSbWxsYkdRb2EyVjVLVHRjYmlBZ0lDQjlYRzRnSUgxY2JpQWdablZ1WTNScGIyNGdiV1Z5WjJWR2FXVnNaQ0FvYTJWNUtTQjdYRzRnSUNBZ2RtRnlJSE4wY21GMElEMGdjM1J5WVhSelcydGxlVjBnZkh3Z1pHVm1ZWFZzZEZOMGNtRjBPMXh1SUNBZ0lHOXdkR2x2Ym5OYmEyVjVYU0E5SUhOMGNtRjBLSEJoY21WdWRGdHJaWGxkTENCamFHbHNaRnRyWlhsZExDQjJiU3dnYTJWNUtUdGNiaUFnZlZ4dUlDQnlaWFIxY200Z2IzQjBhVzl1YzF4dWZWeHVYRzR2S2lwY2JpQXFJRkpsYzI5c2RtVWdZVzRnWVhOelpYUXVYRzRnS2lCVWFHbHpJR1oxYm1OMGFXOXVJR2x6SUhWelpXUWdZbVZqWVhWelpTQmphR2xzWkNCcGJuTjBZVzVqWlhNZ2JtVmxaQ0JoWTJObGMzTmNiaUFxSUhSdklHRnpjMlYwY3lCa1pXWnBibVZrSUdsdUlHbDBjeUJoYm1ObGMzUnZjaUJqYUdGcGJpNWNiaUFxTDF4dVpuVnVZM1JwYjI0Z2NtVnpiMngyWlVGemMyVjBJQ2hjYmlBZ2IzQjBhVzl1Y3l4Y2JpQWdkSGx3WlN4Y2JpQWdhV1FzWEc0Z0lIZGhjbTVOYVhOemFXNW5YRzRwSUh0Y2JpQWdMeW9nYVhOMFlXNWlkV3dnYVdkdWIzSmxJR2xtSUNvdlhHNGdJR2xtSUNoMGVYQmxiMllnYVdRZ0lUMDlJQ2R6ZEhKcGJtY25LU0I3WEc0Z0lDQWdjbVYwZFhKdVhHNGdJSDFjYmlBZ2RtRnlJR0Z6YzJWMGN5QTlJRzl3ZEdsdmJuTmJkSGx3WlYwN1hHNGdJQzh2SUdOb1pXTnJJR3h2WTJGc0lISmxaMmx6ZEhKaGRHbHZiaUIyWVhKcFlYUnBiMjV6SUdacGNuTjBYRzRnSUdsbUlDaG9ZWE5QZDI0b1lYTnpaWFJ6TENCcFpDa3BJSHNnY21WMGRYSnVJR0Z6YzJWMGMxdHBaRjBnZlZ4dUlDQjJZWElnWTJGdFpXeHBlbVZrU1dRZ1BTQmpZVzFsYkdsNlpTaHBaQ2s3WEc0Z0lHbG1JQ2hvWVhOUGQyNG9ZWE56WlhSekxDQmpZVzFsYkdsNlpXUkpaQ2twSUhzZ2NtVjBkWEp1SUdGemMyVjBjMXRqWVcxbGJHbDZaV1JKWkYwZ2ZWeHVJQ0IyWVhJZ1VHRnpZMkZzUTJGelpVbGtJRDBnWTJGd2FYUmhiR2w2WlNoallXMWxiR2w2WldSSlpDazdYRzRnSUdsbUlDaG9ZWE5QZDI0b1lYTnpaWFJ6TENCUVlYTmpZV3hEWVhObFNXUXBLU0I3SUhKbGRIVnliaUJoYzNObGRITmJVR0Z6WTJGc1EyRnpaVWxrWFNCOVhHNGdJQzh2SUdaaGJHeGlZV05ySUhSdklIQnliM1J2ZEhsd1pTQmphR0ZwYmx4dUlDQjJZWElnY21WeklEMGdZWE56WlhSelcybGtYU0I4ZkNCaGMzTmxkSE5iWTJGdFpXeHBlbVZrU1dSZElIeDhJR0Z6YzJWMGMxdFFZWE5qWVd4RFlYTmxTV1JkTzF4dUlDQnBaaUFvY0hKdlkyVnpjeTVsYm5ZdVRrOUVSVjlGVGxZZ0lUMDlJQ2R3Y205a2RXTjBhVzl1SnlBbUppQjNZWEp1VFdsemMybHVaeUFtSmlBaGNtVnpLU0I3WEc0Z0lDQWdkMkZ5YmloY2JpQWdJQ0FnSUNkR1lXbHNaV1FnZEc4Z2NtVnpiMngyWlNBbklDc2dkSGx3WlM1emJHbGpaU2d3TENBdE1Ta2dLeUFuT2lBbklDc2dhV1FzWEc0Z0lDQWdJQ0J2Y0hScGIyNXpYRzRnSUNBZ0tUdGNiaUFnZlZ4dUlDQnlaWFIxY200Z2NtVnpYRzU5WEc1Y2JpOHFJQ0FxTDF4dVhHNW1kVzVqZEdsdmJpQjJZV3hwWkdGMFpWQnliM0FnS0Z4dUlDQnJaWGtzWEc0Z0lIQnliM0JQY0hScGIyNXpMRnh1SUNCd2NtOXdjMFJoZEdFc1hHNGdJSFp0WEc0cElIdGNiaUFnZG1GeUlIQnliM0FnUFNCd2NtOXdUM0IwYVc5dWMxdHJaWGxkTzF4dUlDQjJZWElnWVdKelpXNTBJRDBnSVdoaGMwOTNiaWh3Y205d2MwUmhkR0VzSUd0bGVTazdYRzRnSUhaaGNpQjJZV3gxWlNBOUlIQnliM0J6UkdGMFlWdHJaWGxkTzF4dUlDQXZMeUJvWVc1a2JHVWdZbTl2YkdWaGJpQndjbTl3YzF4dUlDQnBaaUFvYVhOVWVYQmxLRUp2YjJ4bFlXNHNJSEJ5YjNBdWRIbHdaU2twSUh0Y2JpQWdJQ0JwWmlBb1lXSnpaVzUwSUNZbUlDRm9ZWE5QZDI0b2NISnZjQ3dnSjJSbFptRjFiSFFuS1NrZ2UxeHVJQ0FnSUNBZ2RtRnNkV1VnUFNCbVlXeHpaVHRjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLQ0ZwYzFSNWNHVW9VM1J5YVc1bkxDQndjbTl3TG5SNWNHVXBJQ1ltSUNoMllXeDFaU0E5UFQwZ0p5Y2dmSHdnZG1Gc2RXVWdQVDA5SUdoNWNHaGxibUYwWlNoclpYa3BLU2tnZTF4dUlDQWdJQ0FnZG1Gc2RXVWdQU0IwY25WbE8xeHVJQ0FnSUgxY2JpQWdmVnh1SUNBdkx5QmphR1ZqYXlCa1pXWmhkV3gwSUhaaGJIVmxYRzRnSUdsbUlDaDJZV3gxWlNBOVBUMGdkVzVrWldacGJtVmtLU0I3WEc0Z0lDQWdkbUZzZFdVZ1BTQm5aWFJRY205d1JHVm1ZWFZzZEZaaGJIVmxLSFp0TENCd2NtOXdMQ0JyWlhrcE8xeHVJQ0FnSUM4dklITnBibU5sSUhSb1pTQmtaV1poZFd4MElIWmhiSFZsSUdseklHRWdabkpsYzJnZ1kyOXdlU3hjYmlBZ0lDQXZMeUJ0WVd0bElITjFjbVVnZEc4Z2IySnpaWEoyWlNCcGRDNWNiaUFnSUNCMllYSWdjSEpsZGxOb2IzVnNaRU52Ym5abGNuUWdQU0J2WW5ObGNuWmxjbE4wWVhSbExuTm9iM1ZzWkVOdmJuWmxjblE3WEc0Z0lDQWdiMkp6WlhKMlpYSlRkR0YwWlM1emFHOTFiR1JEYjI1MlpYSjBJRDBnZEhKMVpUdGNiaUFnSUNCdlluTmxjblpsS0haaGJIVmxLVHRjYmlBZ0lDQnZZbk5sY25abGNsTjBZWFJsTG5Ob2IzVnNaRU52Ym5abGNuUWdQU0J3Y21WMlUyaHZkV3hrUTI5dWRtVnlkRHRjYmlBZ2ZWeHVJQ0JwWmlBb2NISnZZMlZ6Y3k1bGJuWXVUazlFUlY5RlRsWWdJVDA5SUNkd2NtOWtkV04wYVc5dUp5a2dlMXh1SUNBZ0lHRnpjMlZ5ZEZCeWIzQW9jSEp2Y0N3Z2EyVjVMQ0IyWVd4MVpTd2dkbTBzSUdGaWMyVnVkQ2s3WEc0Z0lIMWNiaUFnY21WMGRYSnVJSFpoYkhWbFhHNTlYRzVjYmk4cUtseHVJQ29nUjJWMElIUm9aU0JrWldaaGRXeDBJSFpoYkhWbElHOW1JR0VnY0hKdmNDNWNiaUFxTDF4dVpuVnVZM1JwYjI0Z1oyVjBVSEp2Y0VSbFptRjFiSFJXWVd4MVpTQW9kbTBzSUhCeWIzQXNJR3RsZVNrZ2UxeHVJQ0F2THlCdWJ5QmtaV1poZFd4MExDQnlaWFIxY200Z2RXNWtaV1pwYm1Wa1hHNGdJR2xtSUNnaGFHRnpUM2R1S0hCeWIzQXNJQ2RrWldaaGRXeDBKeWtwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkVzVrWldacGJtVmtYRzRnSUgxY2JpQWdkbUZ5SUdSbFppQTlJSEJ5YjNBdVpHVm1ZWFZzZER0Y2JpQWdMeThnZDJGeWJpQmhaMkZwYm5OMElHNXZiaTFtWVdOMGIzSjVJR1JsWm1GMWJIUnpJR1p2Y2lCUFltcGxZM1FnSmlCQmNuSmhlVnh1SUNCcFppQW9jSEp2WTJWemN5NWxibll1VGs5RVJWOUZUbFlnSVQwOUlDZHdjbTlrZFdOMGFXOXVKeUFtSmlCcGMwOWlhbVZqZENoa1pXWXBLU0I3WEc0Z0lDQWdkMkZ5YmloY2JpQWdJQ0FnSUNkSmJuWmhiR2xrSUdSbFptRjFiSFFnZG1Gc2RXVWdabTl5SUhCeWIzQWdYQ0luSUNzZ2EyVjVJQ3NnSjF3aU9pQW5JQ3RjYmlBZ0lDQWdJQ2RRY205d2N5QjNhWFJvSUhSNWNHVWdUMkpxWldOMEwwRnljbUY1SUcxMWMzUWdkWE5sSUdFZ1ptRmpkRzl5ZVNCbWRXNWpkR2x2YmlBbklDdGNiaUFnSUNBZ0lDZDBieUJ5WlhSMWNtNGdkR2hsSUdSbFptRjFiSFFnZG1Gc2RXVXVKeXhjYmlBZ0lDQWdJSFp0WEc0Z0lDQWdLVHRjYmlBZ2ZWeHVJQ0F2THlCMGFHVWdjbUYzSUhCeWIzQWdkbUZzZFdVZ2QyRnpJR0ZzYzI4Z2RXNWtaV1pwYm1Wa0lHWnliMjBnY0hKbGRtbHZkWE1nY21WdVpHVnlMRnh1SUNBdkx5QnlaWFIxY200Z2NISmxkbWx2ZFhNZ1pHVm1ZWFZzZENCMllXeDFaU0IwYnlCaGRtOXBaQ0IxYm01bFkyVnpjMkZ5ZVNCM1lYUmphR1Z5SUhSeWFXZG5aWEpjYmlBZ2FXWWdLSFp0SUNZbUlIWnRMaVJ2Y0hScGIyNXpMbkJ5YjNCelJHRjBZU0FtSmx4dUlDQWdJSFp0TGlSdmNIUnBiMjV6TG5CeWIzQnpSR0YwWVZ0clpYbGRJRDA5UFNCMWJtUmxabWx1WldRZ0ppWmNiaUFnSUNCMmJTNWZjSEp2Y0hOYmEyVjVYU0FoUFQwZ2RXNWtaV1pwYm1Wa0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUhadExsOXdjbTl3YzF0clpYbGRYRzRnSUgxY2JpQWdMeThnWTJGc2JDQm1ZV04wYjNKNUlHWjFibU4wYVc5dUlHWnZjaUJ1YjI0dFJuVnVZM1JwYjI0Z2RIbHdaWE5jYmlBZ0x5OGdZU0IyWVd4MVpTQnBjeUJHZFc1amRHbHZiaUJwWmlCcGRITWdjSEp2ZEc5MGVYQmxJR2x6SUdaMWJtTjBhVzl1SUdWMlpXNGdZV055YjNOeklHUnBabVpsY21WdWRDQmxlR1ZqZFhScGIyNGdZMjl1ZEdWNGRGeHVJQ0J5WlhSMWNtNGdkSGx3Wlc5bUlHUmxaaUE5UFQwZ0oyWjFibU4wYVc5dUp5QW1KaUJuWlhSVWVYQmxLSEJ5YjNBdWRIbHdaU2tnSVQwOUlDZEdkVzVqZEdsdmJpZGNiaUFnSUNBL0lHUmxaaTVqWVd4c0tIWnRLVnh1SUNBZ0lEb2daR1ZtWEc1OVhHNWNiaThxS2x4dUlDb2dRWE56WlhKMElIZG9aWFJvWlhJZ1lTQndjbTl3SUdseklIWmhiR2xrTGx4dUlDb3ZYRzVtZFc1amRHbHZiaUJoYzNObGNuUlFjbTl3SUNoY2JpQWdjSEp2Y0N4Y2JpQWdibUZ0WlN4Y2JpQWdkbUZzZFdVc1hHNGdJSFp0TEZ4dUlDQmhZbk5sYm5SY2Jpa2dlMXh1SUNCcFppQW9jSEp2Y0M1eVpYRjFhWEpsWkNBbUppQmhZbk5sYm5RcElIdGNiaUFnSUNCM1lYSnVLRnh1SUNBZ0lDQWdKMDFwYzNOcGJtY2djbVZ4ZFdseVpXUWdjSEp2Y0RvZ1hDSW5JQ3NnYm1GdFpTQXJJQ2RjSWljc1hHNGdJQ0FnSUNCMmJWeHVJQ0FnSUNrN1hHNGdJQ0FnY21WMGRYSnVYRzRnSUgxY2JpQWdhV1lnS0haaGJIVmxJRDA5SUc1MWJHd2dKaVlnSVhCeWIzQXVjbVZ4ZFdseVpXUXBJSHRjYmlBZ0lDQnlaWFIxY201Y2JpQWdmVnh1SUNCMllYSWdkSGx3WlNBOUlIQnliM0F1ZEhsd1pUdGNiaUFnZG1GeUlIWmhiR2xrSUQwZ0lYUjVjR1VnZkh3Z2RIbHdaU0E5UFQwZ2RISjFaVHRjYmlBZ2RtRnlJR1Y0Y0dWamRHVmtWSGx3WlhNZ1BTQmJYVHRjYmlBZ2FXWWdLSFI1Y0dVcElIdGNiaUFnSUNCcFppQW9JVUZ5Y21GNUxtbHpRWEp5WVhrb2RIbHdaU2twSUh0Y2JpQWdJQ0FnSUhSNWNHVWdQU0JiZEhsd1pWMDdYRzRnSUNBZ2ZWeHVJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2RIbHdaUzVzWlc1bmRHZ2dKaVlnSVhaaGJHbGtPeUJwS3lzcElIdGNiaUFnSUNBZ0lIWmhjaUJoYzNObGNuUmxaRlI1Y0dVZ1BTQmhjM05sY25SVWVYQmxLSFpoYkhWbExDQjBlWEJsVzJsZEtUdGNiaUFnSUNBZ0lHVjRjR1ZqZEdWa1ZIbHdaWE11Y0hWemFDaGhjM05sY25SbFpGUjVjR1V1Wlhod1pXTjBaV1JVZVhCbElIeDhJQ2NuS1R0Y2JpQWdJQ0FnSUhaaGJHbGtJRDBnWVhOelpYSjBaV1JVZVhCbExuWmhiR2xrTzF4dUlDQWdJSDFjYmlBZ2ZWeHVJQ0JwWmlBb0lYWmhiR2xrS1NCN1hHNGdJQ0FnZDJGeWJpaGNiaUFnSUNBZ0lDZEpiblpoYkdsa0lIQnliM0E2SUhSNWNHVWdZMmhsWTJzZ1ptRnBiR1ZrSUdadmNpQndjbTl3SUZ3aUp5QXJJRzVoYldVZ0t5QW5YQ0l1SnlBclhHNGdJQ0FnSUNBbklFVjRjR1ZqZEdWa0lDY2dLeUJsZUhCbFkzUmxaRlI1Y0dWekxtMWhjQ2hqWVhCcGRHRnNhWHBsS1M1cWIybHVLQ2NzSUNjcElDdGNiaUFnSUNBZ0lDY3NJR2R2ZENBbklDc2dUMkpxWldOMExuQnliM1J2ZEhsd1pTNTBiMU4wY21sdVp5NWpZV3hzS0haaGJIVmxLUzV6YkdsalpTZzRMQ0F0TVNrZ0t5QW5MaWNzWEc0Z0lDQWdJQ0IyYlZ4dUlDQWdJQ2s3WEc0Z0lDQWdjbVYwZFhKdVhHNGdJSDFjYmlBZ2RtRnlJSFpoYkdsa1lYUnZjaUE5SUhCeWIzQXVkbUZzYVdSaGRHOXlPMXh1SUNCcFppQW9kbUZzYVdSaGRHOXlLU0I3WEc0Z0lDQWdhV1lnS0NGMllXeHBaR0YwYjNJb2RtRnNkV1VwS1NCN1hHNGdJQ0FnSUNCM1lYSnVLRnh1SUNBZ0lDQWdJQ0FuU1c1MllXeHBaQ0J3Y205d09pQmpkWE4wYjIwZ2RtRnNhV1JoZEc5eUlHTm9aV05ySUdaaGFXeGxaQ0JtYjNJZ2NISnZjQ0JjSWljZ0t5QnVZVzFsSUNzZ0oxd2lMaWNzWEc0Z0lDQWdJQ0FnSUhadFhHNGdJQ0FnSUNBcE8xeHVJQ0FnSUgxY2JpQWdmVnh1ZlZ4dVhHNHZLaXBjYmlBcUlFRnpjMlZ5ZENCMGFHVWdkSGx3WlNCdlppQmhJSFpoYkhWbFhHNGdLaTljYm1aMWJtTjBhVzl1SUdGemMyVnlkRlI1Y0dVZ0tIWmhiSFZsTENCMGVYQmxLU0I3WEc0Z0lIWmhjaUIyWVd4cFpEdGNiaUFnZG1GeUlHVjRjR1ZqZEdWa1ZIbHdaU0E5SUdkbGRGUjVjR1VvZEhsd1pTazdYRzRnSUdsbUlDaGxlSEJsWTNSbFpGUjVjR1VnUFQwOUlDZFRkSEpwYm1jbktTQjdYRzRnSUNBZ2RtRnNhV1FnUFNCMGVYQmxiMllnZG1Gc2RXVWdQVDA5SUNobGVIQmxZM1JsWkZSNWNHVWdQU0FuYzNSeWFXNW5KeWs3WEc0Z0lIMGdaV3h6WlNCcFppQW9aWGh3WldOMFpXUlVlWEJsSUQwOVBTQW5UblZ0WW1WeUp5a2dlMXh1SUNBZ0lIWmhiR2xrSUQwZ2RIbHdaVzltSUhaaGJIVmxJRDA5UFNBb1pYaHdaV04wWldSVWVYQmxJRDBnSjI1MWJXSmxjaWNwTzF4dUlDQjlJR1ZzYzJVZ2FXWWdLR1Y0Y0dWamRHVmtWSGx3WlNBOVBUMGdKMEp2YjJ4bFlXNG5LU0I3WEc0Z0lDQWdkbUZzYVdRZ1BTQjBlWEJsYjJZZ2RtRnNkV1VnUFQwOUlDaGxlSEJsWTNSbFpGUjVjR1VnUFNBblltOXZiR1ZoYmljcE8xeHVJQ0I5SUdWc2MyVWdhV1lnS0dWNGNHVmpkR1ZrVkhsd1pTQTlQVDBnSjBaMWJtTjBhVzl1SnlrZ2UxeHVJQ0FnSUhaaGJHbGtJRDBnZEhsd1pXOW1JSFpoYkhWbElEMDlQU0FvWlhod1pXTjBaV1JVZVhCbElEMGdKMloxYm1OMGFXOXVKeWs3WEc0Z0lIMGdaV3h6WlNCcFppQW9aWGh3WldOMFpXUlVlWEJsSUQwOVBTQW5UMkpxWldOMEp5a2dlMXh1SUNBZ0lIWmhiR2xrSUQwZ2FYTlFiR0ZwYms5aWFtVmpkQ2gyWVd4MVpTazdYRzRnSUgwZ1pXeHpaU0JwWmlBb1pYaHdaV04wWldSVWVYQmxJRDA5UFNBblFYSnlZWGtuS1NCN1hHNGdJQ0FnZG1Gc2FXUWdQU0JCY25KaGVTNXBjMEZ5Y21GNUtIWmhiSFZsS1R0Y2JpQWdmU0JsYkhObElIdGNiaUFnSUNCMllXeHBaQ0E5SUhaaGJIVmxJR2x1YzNSaGJtTmxiMllnZEhsd1pUdGNiaUFnZlZ4dUlDQnlaWFIxY200Z2UxeHVJQ0FnSUhaaGJHbGtPaUIyWVd4cFpDeGNiaUFnSUNCbGVIQmxZM1JsWkZSNWNHVTZJR1Y0Y0dWamRHVmtWSGx3WlZ4dUlDQjlYRzU5WEc1Y2JpOHFLbHh1SUNvZ1ZYTmxJR1oxYm1OMGFXOXVJSE4wY21sdVp5QnVZVzFsSUhSdklHTm9aV05ySUdKMWFXeDBMV2x1SUhSNWNHVnpMRnh1SUNvZ1ltVmpZWFZ6WlNCaElITnBiWEJzWlNCbGNYVmhiR2wwZVNCamFHVmpheUIzYVd4c0lHWmhhV3dnZDJobGJpQnlkVzV1YVc1blhHNGdLaUJoWTNKdmMzTWdaR2xtWm1WeVpXNTBJSFp0Y3lBdklHbG1jbUZ0WlhNdVhHNGdLaTljYm1aMWJtTjBhVzl1SUdkbGRGUjVjR1VnS0dadUtTQjdYRzRnSUhaaGNpQnRZWFJqYUNBOUlHWnVJQ1ltSUdadUxuUnZVM1J5YVc1bktDa3ViV0YwWTJnb0wxNWNYSE1xWm5WdVkzUnBiMjRnS0Z4Y2R5c3BMeWs3WEc0Z0lISmxkSFZ5YmlCdFlYUmphQ0FtSmlCdFlYUmphRnN4WFZ4dWZWeHVYRzVtZFc1amRHbHZiaUJwYzFSNWNHVWdLSFI1Y0dVc0lHWnVLU0I3WEc0Z0lHbG1JQ2doUVhKeVlYa3VhWE5CY25KaGVTaG1iaWtwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdaMlYwVkhsd1pTaG1iaWtnUFQwOUlHZGxkRlI1Y0dVb2RIbHdaU2xjYmlBZ2ZWeHVJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Dd2diR1Z1SUQwZ1ptNHViR1Z1WjNSb095QnBJRHdnYkdWdU95QnBLeXNwSUh0Y2JpQWdJQ0JwWmlBb1oyVjBWSGx3WlNobWJsdHBYU2tnUFQwOUlHZGxkRlI1Y0dVb2RIbHdaU2twSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUIwY25WbFhHNGdJQ0FnZlZ4dUlDQjlYRzRnSUM4cUlHbHpkR0Z1WW5Wc0lHbG5ibTl5WlNCdVpYaDBJQ292WEc0Z0lISmxkSFZ5YmlCbVlXeHpaVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQm9ZVzVrYkdWRmNuSnZjaUFvWlhKeUxDQjJiU3dnYVc1bWJ5a2dlMXh1SUNCcFppQW9ZMjl1Wm1sbkxtVnljbTl5U0dGdVpHeGxjaWtnZTF4dUlDQWdJR052Ym1acFp5NWxjbkp2Y2toaGJtUnNaWEl1WTJGc2JDaHVkV3hzTENCbGNuSXNJSFp0TENCcGJtWnZLVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0JwWmlBb2NISnZZMlZ6Y3k1bGJuWXVUazlFUlY5RlRsWWdJVDA5SUNkd2NtOWtkV04wYVc5dUp5a2dlMXh1SUNBZ0lDQWdkMkZ5Ymlnb1hDSkZjbkp2Y2lCcGJpQmNJaUFySUdsdVptOGdLeUJjSWpwY0lpa3NJSFp0S1R0Y2JpQWdJQ0I5WEc0Z0lDQWdMeW9nYVhOMFlXNWlkV3dnYVdkdWIzSmxJR1ZzYzJVZ0tpOWNiaUFnSUNCcFppQW9hVzVDY205M2MyVnlJQ1ltSUhSNWNHVnZaaUJqYjI1emIyeGxJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5a2dlMXh1SUNBZ0lDQWdZMjl1YzI5c1pTNWxjbkp2Y2lobGNuSXBPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCMGFISnZkeUJsY25KY2JpQWdJQ0I5WEc0Z0lIMWNibjFjYmx4dUx5b2dibTkwSUhSNWNHVWdZMmhsWTJ0cGJtY2dkR2hwY3lCbWFXeGxJR0psWTJGMWMyVWdabXh2ZHlCa2IyVnpiaWQwSUhCc1lYa2dkMlZzYkNCM2FYUm9JRkJ5YjNoNUlDb3ZYRzVjYm5aaGNpQnBibWwwVUhKdmVIazdYRzVjYm1sbUlDaHdjbTlqWlhOekxtVnVkaTVPVDBSRlgwVk9WaUFoUFQwZ0ozQnliMlIxWTNScGIyNG5LU0I3WEc0Z0lIWmhjaUJoYkd4dmQyVmtSMnh2WW1Gc2N5QTlJRzFoYTJWTllYQW9YRzRnSUNBZ0owbHVabWx1YVhSNUxIVnVaR1ZtYVc1bFpDeE9ZVTRzYVhOR2FXNXBkR1VzYVhOT1lVNHNKeUFyWEc0Z0lDQWdKM0JoY25ObFJteHZZWFFzY0dGeWMyVkpiblFzWkdWamIyUmxWVkpKTEdSbFkyOWtaVlZTU1VOdmJYQnZibVZ1ZEN4bGJtTnZaR1ZWVWtrc1pXNWpiMlJsVlZKSlEyOXRjRzl1Wlc1MExDY2dLMXh1SUNBZ0lDZE5ZWFJvTEU1MWJXSmxjaXhFWVhSbExFRnljbUY1TEU5aWFtVmpkQ3hDYjI5c1pXRnVMRk4wY21sdVp5eFNaV2RGZUhBc1RXRndMRk5sZEN4S1UwOU9MRWx1ZEd3c0p5QXJYRzRnSUNBZ0ozSmxjWFZwY21VbklDOHZJR1p2Y2lCWFpXSndZV05yTDBKeWIzZHpaWEpwWm5sY2JpQWdLVHRjYmx4dUlDQjJZWElnZDJGeWJrNXZibEJ5WlhObGJuUWdQU0JtZFc1amRHbHZiaUFvZEdGeVoyVjBMQ0JyWlhrcElIdGNiaUFnSUNCM1lYSnVLRnh1SUNBZ0lDQWdYQ0pRY205d1pYSjBlU0J2Y2lCdFpYUm9iMlFnWEZ4Y0lsd2lJQ3NnYTJWNUlDc2dYQ0pjWEZ3aUlHbHpJRzV2ZENCa1pXWnBibVZrSUc5dUlIUm9aU0JwYm5OMFlXNWpaU0JpZFhRZ1hDSWdLMXh1SUNBZ0lDQWdYQ0p5WldabGNtVnVZMlZrSUdSMWNtbHVaeUJ5Wlc1a1pYSXVJRTFoYTJVZ2MzVnlaU0IwYnlCa1pXTnNZWEpsSUhKbFlXTjBhWFpsSUdSaGRHRWdYQ0lnSzF4dUlDQWdJQ0FnWENKd2NtOXdaWEowYVdWeklHbHVJSFJvWlNCa1lYUmhJRzl3ZEdsdmJpNWNJaXhjYmlBZ0lDQWdJSFJoY21kbGRGeHVJQ0FnSUNrN1hHNGdJSDA3WEc1Y2JpQWdkbUZ5SUdoaGMxQnliM2g1SUQxY2JpQWdJQ0IwZVhCbGIyWWdVSEp2ZUhrZ0lUMDlJQ2QxYm1SbFptbHVaV1FuSUNZbVhHNGdJQ0FnVUhKdmVIa3VkRzlUZEhKcGJtY29LUzV0WVhSamFDZ3ZibUYwYVhabElHTnZaR1V2S1R0Y2JseHVJQ0JwWmlBb2FHRnpVSEp2ZUhrcElIdGNiaUFnSUNCMllYSWdhWE5DZFdsc2RFbHVUVzlrYVdacFpYSWdQU0J0WVd0bFRXRndLQ2R6ZEc5d0xIQnlaWFpsYm5Rc2MyVnNaaXhqZEhKc0xITm9hV1owTEdGc2RDeHRaWFJoSnlrN1hHNGdJQ0FnWTI5dVptbG5MbXRsZVVOdlpHVnpJRDBnYm1WM0lGQnliM2g1S0dOdmJtWnBaeTVyWlhsRGIyUmxjeXdnZTF4dUlDQWdJQ0FnYzJWME9pQm1kVzVqZEdsdmJpQnpaWFFnS0hSaGNtZGxkQ3dnYTJWNUxDQjJZV3gxWlNrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvYVhOQ2RXbHNkRWx1VFc5a2FXWnBaWElvYTJWNUtTa2dlMXh1SUNBZ0lDQWdJQ0FnSUhkaGNtNG9LRndpUVhadmFXUWdiM1psY25keWFYUnBibWNnWW5WcGJIUXRhVzRnYlc5a2FXWnBaWElnYVc0Z1kyOXVabWxuTG10bGVVTnZaR1Z6T2lBdVhDSWdLeUJyWlhrcEtUdGNiaUFnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdabUZzYzJWY2JpQWdJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ0lDQjBZWEpuWlhSYmEyVjVYU0E5SUhaaGJIVmxPMXh1SUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUIwY25WbFhHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMWNiaUFnSUNCOUtUdGNiaUFnZlZ4dVhHNGdJSFpoY2lCb1lYTklZVzVrYkdWeUlEMGdlMXh1SUNBZ0lHaGhjem9nWm5WdVkzUnBiMjRnYUdGeklDaDBZWEpuWlhRc0lHdGxlU2tnZTF4dUlDQWdJQ0FnZG1GeUlHaGhjeUE5SUd0bGVTQnBiaUIwWVhKblpYUTdYRzRnSUNBZ0lDQjJZWElnYVhOQmJHeHZkMlZrSUQwZ1lXeHNiM2RsWkVkc2IySmhiSE1vYTJWNUtTQjhmQ0JyWlhrdVkyaGhja0YwS0RBcElEMDlQU0FuWHljN1hHNGdJQ0FnSUNCcFppQW9JV2hoY3lBbUppQWhhWE5CYkd4dmQyVmtLU0I3WEc0Z0lDQWdJQ0FnSUhkaGNtNU9iMjVRY21WelpXNTBLSFJoY21kbGRDd2dhMlY1S1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUhKbGRIVnliaUJvWVhNZ2ZId2dJV2x6UVd4c2IzZGxaRnh1SUNBZ0lIMWNiaUFnZlR0Y2JseHVJQ0IyWVhJZ1oyVjBTR0Z1Wkd4bGNpQTlJSHRjYmlBZ0lDQm5aWFE2SUdaMWJtTjBhVzl1SUdkbGRDQW9kR0Z5WjJWMExDQnJaWGtwSUh0Y2JpQWdJQ0FnSUdsbUlDaDBlWEJsYjJZZ2EyVjVJRDA5UFNBbmMzUnlhVzVuSnlBbUppQWhLR3RsZVNCcGJpQjBZWEpuWlhRcEtTQjdYRzRnSUNBZ0lDQWdJSGRoY201T2IyNVFjbVZ6Wlc1MEtIUmhjbWRsZEN3Z2EyVjVLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJSEpsZEhWeWJpQjBZWEpuWlhSYmEyVjVYVnh1SUNBZ0lIMWNiaUFnZlR0Y2JseHVJQ0JwYm1sMFVISnZlSGtnUFNCbWRXNWpkR2x2YmlCcGJtbDBVSEp2ZUhrZ0tIWnRLU0I3WEc0Z0lDQWdhV1lnS0doaGMxQnliM2g1S1NCN1hHNGdJQ0FnSUNBdkx5QmtaWFJsY20xcGJtVWdkMmhwWTJnZ2NISnZlSGtnYUdGdVpHeGxjaUIwYnlCMWMyVmNiaUFnSUNBZ0lIWmhjaUJ2Y0hScGIyNXpJRDBnZG0wdUpHOXdkR2x2Ym5NN1hHNGdJQ0FnSUNCMllYSWdhR0Z1Wkd4bGNuTWdQU0J2Y0hScGIyNXpMbkpsYm1SbGNpQW1KaUJ2Y0hScGIyNXpMbkpsYm1SbGNpNWZkMmwwYUZOMGNtbHdjR1ZrWEc0Z0lDQWdJQ0FnSUQ4Z1oyVjBTR0Z1Wkd4bGNseHVJQ0FnSUNBZ0lDQTZJR2hoYzBoaGJtUnNaWEk3WEc0Z0lDQWdJQ0IyYlM1ZmNtVnVaR1Z5VUhKdmVIa2dQU0J1WlhjZ1VISnZlSGtvZG0wc0lHaGhibVJzWlhKektUdGNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnZG0wdVgzSmxibVJsY2xCeWIzaDVJRDBnZG0wN1hHNGdJQ0FnZlZ4dUlDQjlPMXh1ZlZ4dVhHNTJZWElnYldGeWF6dGNiblpoY2lCdFpXRnpkWEpsTzF4dVhHNXBaaUFvY0hKdlkyVnpjeTVsYm5ZdVRrOUVSVjlGVGxZZ0lUMDlJQ2R3Y205a2RXTjBhVzl1SnlrZ2UxeHVJQ0IyWVhJZ2NHVnlaaUE5SUdsdVFuSnZkM05sY2lBbUppQjNhVzVrYjNjdWNHVnlabTl5YldGdVkyVTdYRzRnSUM4cUlHbHpkR0Z1WW5Wc0lHbG5ibTl5WlNCcFppQXFMMXh1SUNCcFppQW9YRzRnSUNBZ2NHVnlaaUFtSmx4dUlDQWdJSEJsY21ZdWJXRnlheUFtSmx4dUlDQWdJSEJsY21ZdWJXVmhjM1Z5WlNBbUpseHVJQ0FnSUhCbGNtWXVZMnhsWVhKTllYSnJjeUFtSmx4dUlDQWdJSEJsY21ZdVkyeGxZWEpOWldGemRYSmxjMXh1SUNBcElIdGNiaUFnSUNCdFlYSnJJRDBnWm5WdVkzUnBiMjRnS0hSaFp5a2dleUJ5WlhSMWNtNGdjR1Z5Wmk1dFlYSnJLSFJoWnlrN0lIMDdYRzRnSUNBZ2JXVmhjM1Z5WlNBOUlHWjFibU4wYVc5dUlDaHVZVzFsTENCemRHRnlkRlJoWnl3Z1pXNWtWR0ZuS1NCN1hHNGdJQ0FnSUNCd1pYSm1MbTFsWVhOMWNtVW9ibUZ0WlN3Z2MzUmhjblJVWVdjc0lHVnVaRlJoWnlrN1hHNGdJQ0FnSUNCd1pYSm1MbU5zWldGeVRXRnlhM01vYzNSaGNuUlVZV2NwTzF4dUlDQWdJQ0FnY0dWeVppNWpiR1ZoY2sxaGNtdHpLR1Z1WkZSaFp5azdYRzRnSUNBZ0lDQndaWEptTG1Oc1pXRnlUV1ZoYzNWeVpYTW9ibUZ0WlNrN1hHNGdJQ0FnZlR0Y2JpQWdmVnh1ZlZ4dVhHNHZLaUFnS2k5Y2JseHVkbUZ5SUZaT2IyUmxJRDBnWm5WdVkzUnBiMjRnVms1dlpHVWdLRnh1SUNCMFlXY3NYRzRnSUdSaGRHRXNYRzRnSUdOb2FXeGtjbVZ1TEZ4dUlDQjBaWGgwTEZ4dUlDQmxiRzBzWEc0Z0lHTnZiblJsZUhRc1hHNGdJR052YlhCdmJtVnVkRTl3ZEdsdmJuTmNiaWtnZTF4dUlDQjBhR2x6TG5SaFp5QTlJSFJoWnp0Y2JpQWdkR2hwY3k1a1lYUmhJRDBnWkdGMFlUdGNiaUFnZEdocGN5NWphR2xzWkhKbGJpQTlJR05vYVd4a2NtVnVPMXh1SUNCMGFHbHpMblJsZUhRZ1BTQjBaWGgwTzF4dUlDQjBhR2x6TG1Wc2JTQTlJR1ZzYlR0Y2JpQWdkR2hwY3k1dWN5QTlJSFZ1WkdWbWFXNWxaRHRjYmlBZ2RHaHBjeTVqYjI1MFpYaDBJRDBnWTI5dWRHVjRkRHRjYmlBZ2RHaHBjeTVtZFc1amRHbHZibUZzUTI5dWRHVjRkQ0E5SUhWdVpHVm1hVzVsWkR0Y2JpQWdkR2hwY3k1clpYa2dQU0JrWVhSaElDWW1JR1JoZEdFdWEyVjVPMXh1SUNCMGFHbHpMbU52YlhCdmJtVnVkRTl3ZEdsdmJuTWdQU0JqYjIxd2IyNWxiblJQY0hScGIyNXpPMXh1SUNCMGFHbHpMbU52YlhCdmJtVnVkRWx1YzNSaGJtTmxJRDBnZFc1a1pXWnBibVZrTzF4dUlDQjBhR2x6TG5CaGNtVnVkQ0E5SUhWdVpHVm1hVzVsWkR0Y2JpQWdkR2hwY3k1eVlYY2dQU0JtWVd4elpUdGNiaUFnZEdocGN5NXBjMU4wWVhScFl5QTlJR1poYkhObE8xeHVJQ0IwYUdsekxtbHpVbTl2ZEVsdWMyVnlkQ0E5SUhSeWRXVTdYRzRnSUhSb2FYTXVhWE5EYjIxdFpXNTBJRDBnWm1Gc2MyVTdYRzRnSUhSb2FYTXVhWE5EYkc5dVpXUWdQU0JtWVd4elpUdGNiaUFnZEdocGN5NXBjMDl1WTJVZ1BTQm1ZV3h6WlR0Y2JuMDdYRzVjYm5aaGNpQndjbTkwYjNSNWNHVkJZMk5sYzNOdmNuTWdQU0I3SUdOb2FXeGtPaUI3ZlNCOU8xeHVYRzR2THlCRVJWQlNSVU5CVkVWRU9pQmhiR2xoY3lCbWIzSWdZMjl0Y0c5dVpXNTBTVzV6ZEdGdVkyVWdabTl5SUdKaFkydDNZWEprY3lCamIyMXdZWFF1WEc0dktpQnBjM1JoYm1KMWJDQnBaMjV2Y21VZ2JtVjRkQ0FxTDF4dWNISnZkRzkwZVhCbFFXTmpaWE56YjNKekxtTm9hV3hrTG1kbGRDQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdjbVYwZFhKdUlIUm9hWE11WTI5dGNHOXVaVzUwU1c1emRHRnVZMlZjYm4wN1hHNWNiazlpYW1WamRDNWtaV1pwYm1WUWNtOXdaWEowYVdWektDQldUbTlrWlM1d2NtOTBiM1I1Y0dVc0lIQnliM1J2ZEhsd1pVRmpZMlZ6YzI5eWN5QXBPMXh1WEc1MllYSWdZM0psWVhSbFJXMXdkSGxXVG05a1pTQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdkbUZ5SUc1dlpHVWdQU0J1WlhjZ1ZrNXZaR1VvS1R0Y2JpQWdibTlrWlM1MFpYaDBJRDBnSnljN1hHNGdJRzV2WkdVdWFYTkRiMjF0Wlc1MElEMGdkSEoxWlR0Y2JpQWdjbVYwZFhKdUlHNXZaR1ZjYm4wN1hHNWNibVoxYm1OMGFXOXVJR055WldGMFpWUmxlSFJXVG05a1pTQW9kbUZzS1NCN1hHNGdJSEpsZEhWeWJpQnVaWGNnVms1dlpHVW9kVzVrWldacGJtVmtMQ0IxYm1SbFptbHVaV1FzSUhWdVpHVm1hVzVsWkN3Z1UzUnlhVzVuS0haaGJDa3BYRzU5WEc1Y2JpOHZJRzl3ZEdsdGFYcGxaQ0J6YUdGc2JHOTNJR05zYjI1bFhHNHZMeUIxYzJWa0lHWnZjaUJ6ZEdGMGFXTWdibTlrWlhNZ1lXNWtJSE5zYjNRZ2JtOWtaWE1nWW1WallYVnpaU0IwYUdWNUlHMWhlU0JpWlNCeVpYVnpaV1FnWVdOeWIzTnpYRzR2THlCdGRXeDBhWEJzWlNCeVpXNWtaWEp6TENCamJHOXVhVzVuSUhSb1pXMGdZWFp2YVdSeklHVnljbTl5Y3lCM2FHVnVJRVJQVFNCdFlXNXBjSFZzWVhScGIyNXpJSEpsYkhsY2JpOHZJRzl1SUhSb1pXbHlJR1ZzYlNCeVpXWmxjbVZ1WTJVdVhHNW1kVzVqZEdsdmJpQmpiRzl1WlZaT2IyUmxJQ2gyYm05a1pTa2dlMXh1SUNCMllYSWdZMnh2Ym1Wa0lEMGdibVYzSUZaT2IyUmxLRnh1SUNBZ0lIWnViMlJsTG5SaFp5eGNiaUFnSUNCMmJtOWtaUzVrWVhSaExGeHVJQ0FnSUhadWIyUmxMbU5vYVd4a2NtVnVMRnh1SUNBZ0lIWnViMlJsTG5SbGVIUXNYRzRnSUNBZ2RtNXZaR1V1Wld4dExGeHVJQ0FnSUhadWIyUmxMbU52Ym5SbGVIUXNYRzRnSUNBZ2RtNXZaR1V1WTI5dGNHOXVaVzUwVDNCMGFXOXVjMXh1SUNBcE8xeHVJQ0JqYkc5dVpXUXVibk1nUFNCMmJtOWtaUzV1Y3p0Y2JpQWdZMnh2Ym1Wa0xtbHpVM1JoZEdsaklEMGdkbTV2WkdVdWFYTlRkR0YwYVdNN1hHNGdJR05zYjI1bFpDNXJaWGtnUFNCMmJtOWtaUzVyWlhrN1hHNGdJR05zYjI1bFpDNXBjME5zYjI1bFpDQTlJSFJ5ZFdVN1hHNGdJSEpsZEhWeWJpQmpiRzl1WldSY2JuMWNibHh1Wm5WdVkzUnBiMjRnWTJ4dmJtVldUbTlrWlhNZ0tIWnViMlJsY3lrZ2UxeHVJQ0IyWVhJZ2JHVnVJRDBnZG01dlpHVnpMbXhsYm1kMGFEdGNiaUFnZG1GeUlISmxjeUE5SUc1bGR5QkJjbkpoZVNoc1pXNHBPMXh1SUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHeGxianNnYVNzcktTQjdYRzRnSUNBZ2NtVnpXMmxkSUQwZ1kyeHZibVZXVG05a1pTaDJibTlrWlhOYmFWMHBPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQnlaWE5jYm4xY2JseHVMeW9nSUNvdlhHNWNiblpoY2lCdWIzSnRZV3hwZW1WRmRtVnVkQ0E5SUdOaFkyaGxaQ2htZFc1amRHbHZiaUFvYm1GdFpTa2dlMXh1SUNCMllYSWdiMjVqWlNRa01TQTlJRzVoYldVdVkyaGhja0YwS0RBcElEMDlQU0FuZmljN0lDOHZJRkJ5WldacGVHVmtJR3hoYzNRc0lHTm9aV05yWldRZ1ptbHljM1JjYmlBZ2JtRnRaU0E5SUc5dVkyVWtKREVnUHlCdVlXMWxMbk5zYVdObEtERXBJRG9nYm1GdFpUdGNiaUFnZG1GeUlHTmhjSFIxY21VZ1BTQnVZVzFsTG1Ob1lYSkJkQ2d3S1NBOVBUMGdKeUVuTzF4dUlDQnVZVzFsSUQwZ1kyRndkSFZ5WlNBL0lHNWhiV1V1YzJ4cFkyVW9NU2tnT2lCdVlXMWxPMXh1SUNCeVpYUjFjbTRnZTF4dUlDQWdJRzVoYldVNklHNWhiV1VzWEc0Z0lDQWdiMjVqWlRvZ2IyNWpaU1FrTVN4Y2JpQWdJQ0JqWVhCMGRYSmxPaUJqWVhCMGRYSmxYRzRnSUgxY2JuMHBPMXh1WEc1bWRXNWpkR2x2YmlCamNtVmhkR1ZHYmtsdWRtOXJaWElnS0dadWN5a2dlMXh1SUNCbWRXNWpkR2x2YmlCcGJuWnZhMlZ5SUNncElIdGNiaUFnSUNCMllYSWdZWEpuZFcxbGJuUnpKREVnUFNCaGNtZDFiV1Z1ZEhNN1hHNWNiaUFnSUNCMllYSWdabTV6SUQwZ2FXNTJiMnRsY2k1bWJuTTdYRzRnSUNBZ2FXWWdLRUZ5Y21GNUxtbHpRWEp5WVhrb1ptNXpLU2tnZTF4dUlDQWdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCbWJuTXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0FnSUNBZ1ptNXpXMmxkTG1Gd2NHeDVLRzUxYkd3c0lHRnlaM1Z0Wlc1MGN5UXhLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0x5OGdjbVYwZFhKdUlHaGhibVJzWlhJZ2NtVjBkWEp1SUhaaGJIVmxJR1p2Y2lCemFXNW5iR1VnYUdGdVpHeGxjbk5jYmlBZ0lDQWdJSEpsZEhWeWJpQm1ibk11WVhCd2JIa29iblZzYkN3Z1lYSm5kVzFsYm5SektWeHVJQ0FnSUgxY2JpQWdmVnh1SUNCcGJuWnZhMlZ5TG1adWN5QTlJR1p1Y3p0Y2JpQWdjbVYwZFhKdUlHbHVkbTlyWlhKY2JuMWNibHh1Wm5WdVkzUnBiMjRnZFhCa1lYUmxUR2x6ZEdWdVpYSnpJQ2hjYmlBZ2IyNHNYRzRnSUc5c1pFOXVMRnh1SUNCaFpHUXNYRzRnSUhKbGJXOTJaU1FrTVN4Y2JpQWdkbTFjYmlrZ2UxeHVJQ0IyWVhJZ2JtRnRaU3dnWTNWeUxDQnZiR1FzSUdWMlpXNTBPMXh1SUNCbWIzSWdLRzVoYldVZ2FXNGdiMjRwSUh0Y2JpQWdJQ0JqZFhJZ1BTQnZibHR1WVcxbFhUdGNiaUFnSUNCdmJHUWdQU0J2YkdSUGJsdHVZVzFsWFR0Y2JpQWdJQ0JsZG1WdWRDQTlJRzV2Y20xaGJHbDZaVVYyWlc1MEtHNWhiV1VwTzF4dUlDQWdJR2xtSUNnaFkzVnlLU0I3WEc0Z0lDQWdJQ0J3Y205alpYTnpMbVZ1ZGk1T1QwUkZYMFZPVmlBaFBUMGdKM0J5YjJSMVkzUnBiMjRuSUNZbUlIZGhjbTRvWEc0Z0lDQWdJQ0FnSUZ3aVNXNTJZV3hwWkNCb1lXNWtiR1Z5SUdadmNpQmxkbVZ1ZENCY1hGd2lYQ0lnS3lBb1pYWmxiblF1Ym1GdFpTa2dLeUJjSWx4Y1hDSTZJR2R2ZENCY0lpQXJJRk4wY21sdVp5aGpkWElwTEZ4dUlDQWdJQ0FnSUNCMmJWeHVJQ0FnSUNBZ0tUdGNiaUFnSUNCOUlHVnNjMlVnYVdZZ0tDRnZiR1FwSUh0Y2JpQWdJQ0FnSUdsbUlDZ2hZM1Z5TG1adWN5a2dlMXh1SUNBZ0lDQWdJQ0JqZFhJZ1BTQnZibHR1WVcxbFhTQTlJR055WldGMFpVWnVTVzUyYjJ0bGNpaGpkWElwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnWVdSa0tHVjJaVzUwTG01aGJXVXNJR04xY2l3Z1pYWmxiblF1YjI1alpTd2daWFpsYm5RdVkyRndkSFZ5WlNrN1hHNGdJQ0FnZlNCbGJITmxJR2xtSUNoamRYSWdJVDA5SUc5c1pDa2dlMXh1SUNBZ0lDQWdiMnhrTG1adWN5QTlJR04xY2p0Y2JpQWdJQ0FnSUc5dVcyNWhiV1ZkSUQwZ2IyeGtPMXh1SUNBZ0lIMWNiaUFnZlZ4dUlDQm1iM0lnS0c1aGJXVWdhVzRnYjJ4a1QyNHBJSHRjYmlBZ0lDQnBaaUFvSVc5dVcyNWhiV1ZkS1NCN1hHNGdJQ0FnSUNCbGRtVnVkQ0E5SUc1dmNtMWhiR2w2WlVWMlpXNTBLRzVoYldVcE8xeHVJQ0FnSUNBZ2NtVnRiM1psSkNReEtHVjJaVzUwTG01aGJXVXNJRzlzWkU5dVcyNWhiV1ZkTENCbGRtVnVkQzVqWVhCMGRYSmxLVHRjYmlBZ0lDQjlYRzRnSUgxY2JuMWNibHh1THlvZ0lDb3ZYRzVjYm1aMWJtTjBhVzl1SUcxbGNtZGxWazV2WkdWSWIyOXJJQ2hrWldZc0lHaHZiMnRMWlhrc0lHaHZiMnNwSUh0Y2JpQWdkbUZ5SUdsdWRtOXJaWEk3WEc0Z0lIWmhjaUJ2YkdSSWIyOXJJRDBnWkdWbVcyaHZiMnRMWlhsZE8xeHVYRzRnSUdaMWJtTjBhVzl1SUhkeVlYQndaV1JJYjI5cklDZ3BJSHRjYmlBZ0lDQm9iMjlyTG1Gd2NHeDVLSFJvYVhNc0lHRnlaM1Z0Wlc1MGN5azdYRzRnSUNBZ0x5OGdhVzF3YjNKMFlXNTBPaUJ5WlcxdmRtVWdiV1Z5WjJWa0lHaHZiMnNnZEc4Z1pXNXpkWEpsSUdsMEozTWdZMkZzYkdWa0lHOXViSGtnYjI1alpWeHVJQ0FnSUM4dklHRnVaQ0J3Y21WMlpXNTBJRzFsYlc5eWVTQnNaV0ZyWEc0Z0lDQWdjbVZ0YjNabEtHbHVkbTlyWlhJdVptNXpMQ0IzY21Gd2NHVmtTRzl2YXlrN1hHNGdJSDFjYmx4dUlDQnBaaUFvSVc5c1pFaHZiMnNwSUh0Y2JpQWdJQ0F2THlCdWJ5QmxlR2x6ZEdsdVp5Qm9iMjlyWEc0Z0lDQWdhVzUyYjJ0bGNpQTlJR055WldGMFpVWnVTVzUyYjJ0bGNpaGJkM0poY0hCbFpFaHZiMnRkS1R0Y2JpQWdmU0JsYkhObElIdGNiaUFnSUNBdktpQnBjM1JoYm1KMWJDQnBaMjV2Y21VZ2FXWWdLaTljYmlBZ0lDQnBaaUFvYjJ4a1NHOXZheTVtYm5NZ0ppWWdiMnhrU0c5dmF5NXRaWEpuWldRcElIdGNiaUFnSUNBZ0lDOHZJR0ZzY21WaFpIa2dZU0J0WlhKblpXUWdhVzUyYjJ0bGNseHVJQ0FnSUNBZ2FXNTJiMnRsY2lBOUlHOXNaRWh2YjJzN1hHNGdJQ0FnSUNCcGJuWnZhMlZ5TG1adWN5NXdkWE5vS0hkeVlYQndaV1JJYjI5cktUdGNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnTHk4Z1pYaHBjM1JwYm1jZ2NHeGhhVzRnYUc5dmExeHVJQ0FnSUNBZ2FXNTJiMnRsY2lBOUlHTnlaV0YwWlVadVNXNTJiMnRsY2loYmIyeGtTRzl2YXl3Z2QzSmhjSEJsWkVodmIydGRLVHRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0JwYm5admEyVnlMbTFsY21kbFpDQTlJSFJ5ZFdVN1hHNGdJR1JsWmx0b2IyOXJTMlY1WFNBOUlHbHVkbTlyWlhJN1hHNTlYRzVjYmk4cUlDQXFMMXh1WEc0dkx5QlVhR1VnZEdWdGNHeGhkR1VnWTI5dGNHbHNaWElnWVhSMFpXMXdkSE1nZEc4Z2JXbHVhVzFwZW1VZ2RHaGxJRzVsWldRZ1ptOXlJRzV2Y20xaGJHbDZZWFJwYjI0Z1lubGNiaTh2SUhOMFlYUnBZMkZzYkhrZ1lXNWhiSGw2YVc1bklIUm9aU0IwWlcxd2JHRjBaU0JoZENCamIyMXdhV3hsSUhScGJXVXVYRzR2TDF4dUx5OGdSbTl5SUhCc1lXbHVJRWhVVFV3Z2JXRnlhM1Z3TENCdWIzSnRZV3hwZW1GMGFXOXVJR05oYmlCaVpTQmpiMjF3YkdWMFpXeDVJSE5yYVhCd1pXUWdZbVZqWVhWelpTQjBhR1ZjYmk4dklHZGxibVZ5WVhSbFpDQnlaVzVrWlhJZ1puVnVZM1JwYjI0Z2FYTWdaM1ZoY21GdWRHVmxaQ0IwYnlCeVpYUjFjbTRnUVhKeVlYazhWazV2WkdVK0xpQlVhR1Z5WlNCaGNtVmNiaTh2SUhSM2J5QmpZWE5sY3lCM2FHVnlaU0JsZUhSeVlTQnViM0p0WVd4cGVtRjBhVzl1SUdseklHNWxaV1JsWkRwY2JseHVMeThnTVM0Z1YyaGxiaUIwYUdVZ1kyaHBiR1J5Wlc0Z1kyOXVkR0ZwYm5NZ1kyOXRjRzl1Wlc1MGN5QXRJR0psWTJGMWMyVWdZU0JtZFc1amRHbHZibUZzSUdOdmJYQnZibVZ1ZEZ4dUx5OGdiV0Y1SUhKbGRIVnliaUJoYmlCQmNuSmhlU0JwYm5OMFpXRmtJRzltSUdFZ2MybHVaMnhsSUhKdmIzUXVJRWx1SUhSb2FYTWdZMkZ6WlN3Z2FuVnpkQ0JoSUhOcGJYQnNaVnh1THk4Z2JtOXliV0ZzYVhwaGRHbHZiaUJwY3lCdVpXVmtaV1FnTFNCcFppQmhibmtnWTJocGJHUWdhWE1nWVc0Z1FYSnlZWGtzSUhkbElHWnNZWFIwWlc0Z2RHaGxJSGRvYjJ4bFhHNHZMeUIwYUdsdVp5QjNhWFJvSUVGeWNtRjVMbkJ5YjNSdmRIbHdaUzVqYjI1allYUXVJRWwwSUdseklHZDFZWEpoYm5SbFpXUWdkRzhnWW1VZ2IyNXNlU0F4TFd4bGRtVnNJR1JsWlhCY2JpOHZJR0psWTJGMWMyVWdablZ1WTNScGIyNWhiQ0JqYjIxd2IyNWxiblJ6SUdGc2NtVmhaSGtnYm05eWJXRnNhWHBsSUhSb1pXbHlJRzkzYmlCamFHbHNaSEpsYmk1Y2JtWjFibU4wYVc5dUlITnBiWEJzWlU1dmNtMWhiR2w2WlVOb2FXeGtjbVZ1SUNoamFHbHNaSEpsYmlrZ2UxeHVJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdOb2FXeGtjbVZ1TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ2FXWWdLRUZ5Y21GNUxtbHpRWEp5WVhrb1kyaHBiR1J5Wlc1YmFWMHBLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdRWEp5WVhrdWNISnZkRzkwZVhCbExtTnZibU5oZEM1aGNIQnNlU2hiWFN3Z1kyaHBiR1J5Wlc0cFhHNGdJQ0FnZlZ4dUlDQjlYRzRnSUhKbGRIVnliaUJqYUdsc1pISmxibHh1ZlZ4dVhHNHZMeUF5TGlCWGFHVnVJSFJvWlNCamFHbHNaSEpsYmlCamIyNTBZV2x1Y3lCamIyNXpkSEoxWTNSeklIUm9ZWFFnWVd4M1lYbHpJR2RsYm1WeVlYUmxaQ0J1WlhOMFpXUWdRWEp5WVhsekxGeHVMeThnWlM1bkxpQThkR1Z0Y0d4aGRHVStMQ0E4YzJ4dmRENHNJSFl0Wm05eUxDQnZjaUIzYUdWdUlIUm9aU0JqYUdsc1pISmxiaUJwY3lCd2NtOTJhV1JsWkNCaWVTQjFjMlZ5WEc0dkx5QjNhWFJvSUdoaGJtUXRkM0pwZEhSbGJpQnlaVzVrWlhJZ1puVnVZM1JwYjI1eklDOGdTbE5ZTGlCSmJpQnpkV05vSUdOaGMyVnpJR0VnWm5Wc2JDQnViM0p0WVd4cGVtRjBhVzl1WEc0dkx5QnBjeUJ1WldWa1pXUWdkRzhnWTJGMFpYSWdkRzhnWVd4c0lIQnZjM05wWW14bElIUjVjR1Z6SUc5bUlHTm9hV3hrY21WdUlIWmhiSFZsY3k1Y2JtWjFibU4wYVc5dUlHNXZjbTFoYkdsNlpVTm9hV3hrY21WdUlDaGphR2xzWkhKbGJpa2dlMXh1SUNCeVpYUjFjbTRnYVhOUWNtbHRhWFJwZG1Vb1kyaHBiR1J5Wlc0cFhHNGdJQ0FnUHlCYlkzSmxZWFJsVkdWNGRGWk9iMlJsS0dOb2FXeGtjbVZ1S1YxY2JpQWdJQ0E2SUVGeWNtRjVMbWx6UVhKeVlYa29ZMmhwYkdSeVpXNHBYRzRnSUNBZ0lDQS9JRzV2Y20xaGJHbDZaVUZ5Y21GNVEyaHBiR1J5Wlc0b1kyaHBiR1J5Wlc0cFhHNGdJQ0FnSUNBNklIVnVaR1ZtYVc1bFpGeHVmVnh1WEc1bWRXNWpkR2x2YmlCdWIzSnRZV3hwZW1WQmNuSmhlVU5vYVd4a2NtVnVJQ2hqYUdsc1pISmxiaXdnYm1WemRHVmtTVzVrWlhncElIdGNiaUFnZG1GeUlISmxjeUE5SUZ0ZE8xeHVJQ0IyWVhJZ2FTd2dZeXdnYkdGemREdGNiaUFnWm05eUlDaHBJRDBnTURzZ2FTQThJR05vYVd4a2NtVnVMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnWXlBOUlHTm9hV3hrY21WdVcybGRPMXh1SUNBZ0lHbG1JQ2hqSUQwOUlHNTFiR3dnZkh3Z2RIbHdaVzltSUdNZ1BUMDlJQ2RpYjI5c1pXRnVKeWtnZXlCamIyNTBhVzUxWlNCOVhHNGdJQ0FnYkdGemRDQTlJSEpsYzF0eVpYTXViR1Z1WjNSb0lDMGdNVjA3WEc0Z0lDQWdMeThnSUc1bGMzUmxaRnh1SUNBZ0lHbG1JQ2hCY25KaGVTNXBjMEZ5Y21GNUtHTXBLU0I3WEc0Z0lDQWdJQ0J5WlhNdWNIVnphQzVoY0hCc2VTaHlaWE1zSUc1dmNtMWhiR2w2WlVGeWNtRjVRMmhwYkdSeVpXNG9ZeXdnS0NodVpYTjBaV1JKYm1SbGVDQjhmQ0FuSnlrZ0t5QmNJbDljSWlBcklHa3BLU2s3WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2hwYzFCeWFXMXBkR2wyWlNoaktTa2dlMXh1SUNBZ0lDQWdhV1lnS0d4aGMzUWdKaVlnYkdGemRDNTBaWGgwS1NCN1hHNGdJQ0FnSUNBZ0lHeGhjM1F1ZEdWNGRDQXJQU0JUZEhKcGJtY29ZeWs3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0dNZ0lUMDlJQ2NuS1NCN1hHNGdJQ0FnSUNBZ0lDOHZJR052Ym5abGNuUWdjSEpwYldsMGFYWmxJSFJ2SUhadWIyUmxYRzRnSUNBZ0lDQWdJSEpsY3k1d2RYTm9LR055WldGMFpWUmxlSFJXVG05a1pTaGpLU2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lHbG1JQ2hqTG5SbGVIUWdKaVlnYkdGemRDQW1KaUJzWVhOMExuUmxlSFFwSUh0Y2JpQWdJQ0FnSUNBZ2NtVnpXM0psY3k1c1pXNW5kR2dnTFNBeFhTQTlJR055WldGMFpWUmxlSFJXVG05a1pTaHNZWE4wTG5SbGVIUWdLeUJqTG5SbGVIUXBPMXh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdMeThnWkdWbVlYVnNkQ0JyWlhrZ1ptOXlJRzVsYzNSbFpDQmhjbkpoZVNCamFHbHNaSEpsYmlBb2JHbHJaV3g1SUdkbGJtVnlZWFJsWkNCaWVTQjJMV1p2Y2lsY2JpQWdJQ0FnSUNBZ2FXWWdLR011ZEdGbklDWW1JR011YTJWNUlEMDlJRzUxYkd3Z0ppWWdibVZ6ZEdWa1NXNWtaWGdnSVQwZ2JuVnNiQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lHTXVhMlY1SUQwZ1hDSmZYM1pzYVhOMFhDSWdLeUJ1WlhOMFpXUkpibVJsZUNBcklGd2lYMXdpSUNzZ2FTQXJJRndpWDE5Y0lqdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0J5WlhNdWNIVnphQ2hqS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc0Z0lIMWNiaUFnY21WMGRYSnVJSEpsYzF4dWZWeHVYRzR2S2lBZ0tpOWNibHh1Wm5WdVkzUnBiMjRnWjJWMFJtbHljM1JEYjIxd2IyNWxiblJEYUdsc1pDQW9ZMmhwYkdSeVpXNHBJSHRjYmlBZ2NtVjBkWEp1SUdOb2FXeGtjbVZ1SUNZbUlHTm9hV3hrY21WdUxtWnBiSFJsY2lobWRXNWpkR2x2YmlBb1l5a2dleUJ5WlhSMWNtNGdZeUFtSmlCakxtTnZiWEJ2Ym1WdWRFOXdkR2x2Ym5NN0lIMHBXekJkWEc1OVhHNWNiaThxSUNBcUwxeHVYRzVtZFc1amRHbHZiaUJwYm1sMFJYWmxiblJ6SUNoMmJTa2dlMXh1SUNCMmJTNWZaWFpsYm5SeklEMGdUMkpxWldOMExtTnlaV0YwWlNodWRXeHNLVHRjYmlBZ2RtMHVYMmhoYzBodmIydEZkbVZ1ZENBOUlHWmhiSE5sTzF4dUlDQXZMeUJwYm1sMElIQmhjbVZ1ZENCaGRIUmhZMmhsWkNCbGRtVnVkSE5jYmlBZ2RtRnlJR3hwYzNSbGJtVnljeUE5SUhadExpUnZjSFJwYjI1ekxsOXdZWEpsYm5STWFYTjBaVzVsY25NN1hHNGdJR2xtSUNoc2FYTjBaVzVsY25NcElIdGNiaUFnSUNCMWNHUmhkR1ZEYjIxd2IyNWxiblJNYVhOMFpXNWxjbk1vZG0wc0lHeHBjM1JsYm1WeWN5azdYRzRnSUgxY2JuMWNibHh1ZG1GeUlIUmhjbWRsZER0Y2JseHVablZ1WTNScGIyNGdZV1JrSUNobGRtVnVkQ3dnWm00c0lHOXVZMlVrSkRFcElIdGNiaUFnYVdZZ0tHOXVZMlVrSkRFcElIdGNiaUFnSUNCMFlYSm5aWFF1Skc5dVkyVW9aWFpsYm5Rc0lHWnVLVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0IwWVhKblpYUXVKRzl1S0dWMlpXNTBMQ0JtYmlrN1hHNGdJSDFjYm4xY2JseHVablZ1WTNScGIyNGdjbVZ0YjNabEpERWdLR1YyWlc1MExDQm1iaWtnZTF4dUlDQjBZWEpuWlhRdUpHOW1aaWhsZG1WdWRDd2dabTRwTzF4dWZWeHVYRzVtZFc1amRHbHZiaUIxY0dSaGRHVkRiMjF3YjI1bGJuUk1hWE4wWlc1bGNuTWdLRnh1SUNCMmJTeGNiaUFnYkdsemRHVnVaWEp6TEZ4dUlDQnZiR1JNYVhOMFpXNWxjbk5jYmlrZ2UxeHVJQ0IwWVhKblpYUWdQU0IyYlR0Y2JpQWdkWEJrWVhSbFRHbHpkR1Z1WlhKektHeHBjM1JsYm1WeWN5d2diMnhrVEdsemRHVnVaWEp6SUh4OElIdDlMQ0JoWkdRc0lISmxiVzkyWlNReExDQjJiU2s3WEc1OVhHNWNibVoxYm1OMGFXOXVJR1YyWlc1MGMwMXBlR2x1SUNoV2RXVXBJSHRjYmlBZ2RtRnlJR2h2YjJ0U1JTQTlJQzllYUc5dmF6b3ZPMXh1SUNCV2RXVXVjSEp2ZEc5MGVYQmxMaVJ2YmlBOUlHWjFibU4wYVc5dUlDaGxkbVZ1ZEN3Z1ptNHBJSHRjYmlBZ0lDQjJZWElnZEdocGN5UXhJRDBnZEdocGN6dGNibHh1SUNBZ0lIWmhjaUIyYlNBOUlIUm9hWE03WEc0Z0lDQWdhV1lnS0VGeWNtRjVMbWx6UVhKeVlYa29aWFpsYm5RcEtTQjdYRzRnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTUN3Z2JDQTlJR1YyWlc1MExteGxibWQwYURzZ2FTQThJR3c3SUdrckt5a2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekpERXVKRzl1S0dWMlpXNTBXMmxkTENCbWJpazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNoMmJTNWZaWFpsYm5SelcyVjJaVzUwWFNCOGZDQW9kbTB1WDJWMlpXNTBjMXRsZG1WdWRGMGdQU0JiWFNrcExuQjFjMmdvWm00cE8xeHVJQ0FnSUNBZ0x5OGdiM0IwYVcxcGVtVWdhRzl2YXpwbGRtVnVkQ0JqYjNOMElHSjVJSFZ6YVc1bklHRWdZbTl2YkdWaGJpQm1iR0ZuSUcxaGNtdGxaQ0JoZENCeVpXZHBjM1J5WVhScGIyNWNiaUFnSUNBZ0lDOHZJR2x1YzNSbFlXUWdiMllnWVNCb1lYTm9JR3h2YjJ0MWNGeHVJQ0FnSUNBZ2FXWWdLR2h2YjJ0U1JTNTBaWE4wS0dWMlpXNTBLU2tnZTF4dUlDQWdJQ0FnSUNCMmJTNWZhR0Z6U0c5dmEwVjJaVzUwSUQwZ2RISjFaVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzRnSUNBZ2NtVjBkWEp1SUhadFhHNGdJSDA3WEc1Y2JpQWdWblZsTG5CeWIzUnZkSGx3WlM0a2IyNWpaU0E5SUdaMWJtTjBhVzl1SUNobGRtVnVkQ3dnWm00cElIdGNiaUFnSUNCMllYSWdkbTBnUFNCMGFHbHpPMXh1SUNBZ0lHWjFibU4wYVc5dUlHOXVJQ2dwSUh0Y2JpQWdJQ0FnSUhadExpUnZabVlvWlhabGJuUXNJRzl1S1R0Y2JpQWdJQ0FnSUdadUxtRndjR3g1S0hadExDQmhjbWQxYldWdWRITXBPMXh1SUNBZ0lIMWNiaUFnSUNCdmJpNW1iaUE5SUdadU8xeHVJQ0FnSUhadExpUnZiaWhsZG1WdWRDd2diMjRwTzF4dUlDQWdJSEpsZEhWeWJpQjJiVnh1SUNCOU8xeHVYRzRnSUZaMVpTNXdjbTkwYjNSNWNHVXVKRzltWmlBOUlHWjFibU4wYVc5dUlDaGxkbVZ1ZEN3Z1ptNHBJSHRjYmlBZ0lDQjJZWElnZEdocGN5UXhJRDBnZEdocGN6dGNibHh1SUNBZ0lIWmhjaUIyYlNBOUlIUm9hWE03WEc0Z0lDQWdMeThnWVd4c1hHNGdJQ0FnYVdZZ0tDRmhjbWQxYldWdWRITXViR1Z1WjNSb0tTQjdYRzRnSUNBZ0lDQjJiUzVmWlhabGJuUnpJRDBnVDJKcVpXTjBMbU55WldGMFpTaHVkV3hzS1R0Y2JpQWdJQ0FnSUhKbGRIVnliaUIyYlZ4dUlDQWdJSDFjYmlBZ0lDQXZMeUJoY25KaGVTQnZaaUJsZG1WdWRITmNiaUFnSUNCcFppQW9RWEp5WVhrdWFYTkJjbkpoZVNobGRtVnVkQ2twSUh0Y2JpQWdJQ0FnSUdadmNpQW9kbUZ5SUdra01TQTlJREFzSUd3Z1BTQmxkbVZ1ZEM1c1pXNW5kR2c3SUdra01TQThJR3c3SUdra01Tc3JLU0I3WEc0Z0lDQWdJQ0FnSUhSb2FYTWtNUzRrYjJabUtHVjJaVzUwVzJra01WMHNJR1p1S1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUhKbGRIVnliaUIyYlZ4dUlDQWdJSDFjYmlBZ0lDQXZMeUJ6Y0dWamFXWnBZeUJsZG1WdWRGeHVJQ0FnSUhaaGNpQmpZbk1nUFNCMmJTNWZaWFpsYm5SelcyVjJaVzUwWFR0Y2JpQWdJQ0JwWmlBb0lXTmljeWtnZTF4dUlDQWdJQ0FnY21WMGRYSnVJSFp0WEc0Z0lDQWdmVnh1SUNBZ0lHbG1JQ2hoY21kMWJXVnVkSE11YkdWdVozUm9JRDA5UFNBeEtTQjdYRzRnSUNBZ0lDQjJiUzVmWlhabGJuUnpXMlYyWlc1MFhTQTlJRzUxYkd3N1hHNGdJQ0FnSUNCeVpYUjFjbTRnZG0xY2JpQWdJQ0I5WEc0Z0lDQWdMeThnYzNCbFkybG1hV01nYUdGdVpHeGxjbHh1SUNBZ0lIWmhjaUJqWWp0Y2JpQWdJQ0IyWVhJZ2FTQTlJR05pY3k1c1pXNW5kR2c3WEc0Z0lDQWdkMmhwYkdVZ0tHa3RMU2tnZTF4dUlDQWdJQ0FnWTJJZ1BTQmpZbk5iYVYwN1hHNGdJQ0FnSUNCcFppQW9ZMklnUFQwOUlHWnVJSHg4SUdOaUxtWnVJRDA5UFNCbWJpa2dlMXh1SUNBZ0lDQWdJQ0JqWW5NdWMzQnNhV05sS0drc0lERXBPMXh1SUNBZ0lDQWdJQ0JpY21WaGExeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdJQ0J5WlhSMWNtNGdkbTFjYmlBZ2ZUdGNibHh1SUNCV2RXVXVjSEp2ZEc5MGVYQmxMaVJsYldsMElEMGdablZ1WTNScGIyNGdLR1YyWlc1MEtTQjdYRzRnSUNBZ2RtRnlJSFp0SUQwZ2RHaHBjenRjYmlBZ0lDQnBaaUFvY0hKdlkyVnpjeTVsYm5ZdVRrOUVSVjlGVGxZZ0lUMDlJQ2R3Y205a2RXTjBhVzl1SnlrZ2UxeHVJQ0FnSUNBZ2RtRnlJR3h2ZDJWeVEyRnpaVVYyWlc1MElEMGdaWFpsYm5RdWRHOU1iM2RsY2tOaGMyVW9LVHRjYmlBZ0lDQWdJR2xtSUNoc2IzZGxja05oYzJWRmRtVnVkQ0FoUFQwZ1pYWmxiblFnSmlZZ2RtMHVYMlYyWlc1MGMxdHNiM2RsY2tOaGMyVkZkbVZ1ZEYwcElIdGNiaUFnSUNBZ0lDQWdkR2x3S0Z4dUlDQWdJQ0FnSUNBZ0lGd2lSWFpsYm5RZ1hGeGNJbHdpSUNzZ2JHOTNaWEpEWVhObFJYWmxiblFnS3lCY0lseGNYQ0lnYVhNZ1pXMXBkSFJsWkNCcGJpQmpiMjF3YjI1bGJuUWdYQ0lnSzF4dUlDQWdJQ0FnSUNBZ0lDaG1iM0p0WVhSRGIyMXdiMjVsYm5ST1lXMWxLSFp0S1NrZ0t5QmNJaUJpZFhRZ2RHaGxJR2hoYm1Sc1pYSWdhWE1nY21WbmFYTjBaWEpsWkNCbWIzSWdYRnhjSWx3aUlDc2daWFpsYm5RZ0t5QmNJbHhjWENJdUlGd2lJQ3RjYmlBZ0lDQWdJQ0FnSUNCY0lrNXZkR1VnZEdoaGRDQklWRTFNSUdGMGRISnBZblYwWlhNZ1lYSmxJR05oYzJVdGFXNXpaVzV6YVhScGRtVWdZVzVrSUhsdmRTQmpZVzV1YjNRZ2RYTmxJRndpSUN0Y2JpQWdJQ0FnSUNBZ0lDQmNJbll0YjI0Z2RHOGdiR2x6ZEdWdUlIUnZJR05oYldWc1EyRnpaU0JsZG1WdWRITWdkMmhsYmlCMWMybHVaeUJwYmkxRVQwMGdkR1Z0Y0d4aGRHVnpMaUJjSWlBclhHNGdJQ0FnSUNBZ0lDQWdYQ0paYjNVZ2MyaHZkV3hrSUhCeWIySmhZbXg1SUhWelpTQmNYRndpWENJZ0t5QW9hSGx3YUdWdVlYUmxLR1YyWlc1MEtTa2dLeUJjSWx4Y1hDSWdhVzV6ZEdWaFpDQnZaaUJjWEZ3aVhDSWdLeUJsZG1WdWRDQXJJRndpWEZ4Y0lpNWNJbHh1SUNBZ0lDQWdJQ0FwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ0lDQjJZWElnWTJKeklEMGdkbTB1WDJWMlpXNTBjMXRsZG1WdWRGMDdYRzRnSUNBZ2FXWWdLR05pY3lrZ2UxeHVJQ0FnSUNBZ1kySnpJRDBnWTJKekxteGxibWQwYUNBK0lERWdQeUIwYjBGeWNtRjVLR05pY3lrZ09pQmpZbk03WEc0Z0lDQWdJQ0IyWVhJZ1lYSm5jeUE5SUhSdlFYSnlZWGtvWVhKbmRXMWxiblJ6TENBeEtUdGNiaUFnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3TENCc0lEMGdZMkp6TG14bGJtZDBhRHNnYVNBOElHdzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ0lDQmpZbk5iYVYwdVlYQndiSGtvZG0wc0lHRnlaM01wTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ0lDQnlaWFIxY200Z2RtMWNiaUFnZlR0Y2JuMWNibHh1THlvZ0lDb3ZYRzVjYmk4cUtseHVJQ29nVW5WdWRHbHRaU0JvWld4d1pYSWdabTl5SUhKbGMyOXNkbWx1WnlCeVlYY2dZMmhwYkdSeVpXNGdWazV2WkdWeklHbHVkRzhnWVNCemJHOTBJRzlpYW1WamRDNWNiaUFxTDF4dVpuVnVZM1JwYjI0Z2NtVnpiMngyWlZOc2IzUnpJQ2hjYmlBZ1kyaHBiR1J5Wlc0c1hHNGdJR052Ym5SbGVIUmNiaWtnZTF4dUlDQjJZWElnYzJ4dmRITWdQU0I3ZlR0Y2JpQWdhV1lnS0NGamFHbHNaSEpsYmlrZ2UxeHVJQ0FnSUhKbGRIVnliaUJ6Ykc5MGMxeHVJQ0I5WEc0Z0lIWmhjaUJrWldaaGRXeDBVMnh2ZENBOUlGdGRPMXh1SUNCMllYSWdibUZ0WlN3Z1kyaHBiR1E3WEc0Z0lHWnZjaUFvZG1GeUlHa2dQU0F3TENCc0lEMGdZMmhwYkdSeVpXNHViR1Z1WjNSb095QnBJRHdnYkRzZ2FTc3JLU0I3WEc0Z0lDQWdZMmhwYkdRZ1BTQmphR2xzWkhKbGJsdHBYVHRjYmlBZ0lDQXZMeUJ1WVcxbFpDQnpiRzkwY3lCemFHOTFiR1FnYjI1c2VTQmlaU0J5WlhOd1pXTjBaV1FnYVdZZ2RHaGxJSFp1YjJSbElIZGhjeUJ5Wlc1a1pYSmxaQ0JwYmlCMGFHVmNiaUFnSUNBdkx5QnpZVzFsSUdOdmJuUmxlSFF1WEc0Z0lDQWdhV1lnS0NoamFHbHNaQzVqYjI1MFpYaDBJRDA5UFNCamIyNTBaWGgwSUh4OElHTm9hV3hrTG1aMWJtTjBhVzl1WVd4RGIyNTBaWGgwSUQwOVBTQmpiMjUwWlhoMEtTQW1KbHh1SUNBZ0lDQWdJQ0JqYUdsc1pDNWtZWFJoSUNZbUlDaHVZVzFsSUQwZ1kyaHBiR1F1WkdGMFlTNXpiRzkwS1NrZ2UxeHVJQ0FnSUNBZ2RtRnlJSE5zYjNRZ1BTQW9jMnh2ZEhOYmJtRnRaVjBnZkh3Z0tITnNiM1J6VzI1aGJXVmRJRDBnVzEwcEtUdGNiaUFnSUNBZ0lHbG1JQ2hqYUdsc1pDNTBZV2NnUFQwOUlDZDBaVzF3YkdGMFpTY3BJSHRjYmlBZ0lDQWdJQ0FnYzJ4dmRDNXdkWE5vTG1Gd2NHeDVLSE5zYjNRc0lHTm9hV3hrTG1Ob2FXeGtjbVZ1S1R0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUhOc2IzUXVjSFZ6YUNoamFHbHNaQ2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lHUmxabUYxYkhSVGJHOTBMbkIxYzJnb1kyaHBiR1FwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVJQ0F2THlCcFoyNXZjbVVnZDJocGRHVnpjR0ZqWlZ4dUlDQnBaaUFvSVdSbFptRjFiSFJUYkc5MExtVjJaWEo1S0dselYyaHBkR1Z6Y0dGalpTa3BJSHRjYmlBZ0lDQnpiRzkwY3k1a1pXWmhkV3gwSUQwZ1pHVm1ZWFZzZEZOc2IzUTdYRzRnSUgxY2JpQWdjbVYwZFhKdUlITnNiM1J6WEc1OVhHNWNibVoxYm1OMGFXOXVJR2x6VjJocGRHVnpjR0ZqWlNBb2JtOWtaU2tnZTF4dUlDQnlaWFIxY200Z2JtOWtaUzVwYzBOdmJXMWxiblFnZkh3Z2JtOWtaUzUwWlhoMElEMDlQU0FuSUNkY2JuMWNibHh1Wm5WdVkzUnBiMjRnY21WemIyeDJaVk5qYjNCbFpGTnNiM1J6SUNoY2JpQWdabTV6WEc0cElIdGNiaUFnZG1GeUlISmxjeUE5SUh0OU8xeHVJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdadWN5NXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJSEpsYzF0bWJuTmJhVjFiTUYxZElEMGdabTV6VzJsZFd6RmRPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQnlaWE5jYm4xY2JseHVMeW9nSUNvdlhHNWNiblpoY2lCaFkzUnBkbVZKYm5OMFlXNWpaU0E5SUc1MWJHdzdYRzVjYm1aMWJtTjBhVzl1SUdsdWFYUk1hV1psWTNsamJHVWdLSFp0S1NCN1hHNGdJSFpoY2lCdmNIUnBiMjV6SUQwZ2RtMHVKRzl3ZEdsdmJuTTdYRzVjYmlBZ0x5OGdiRzlqWVhSbElHWnBjbk4wSUc1dmJpMWhZbk4wY21GamRDQndZWEpsYm5SY2JpQWdkbUZ5SUhCaGNtVnVkQ0E5SUc5d2RHbHZibk11Y0dGeVpXNTBPMXh1SUNCcFppQW9jR0Z5Wlc1MElDWW1JQ0Z2Y0hScGIyNXpMbUZpYzNSeVlXTjBLU0I3WEc0Z0lDQWdkMmhwYkdVZ0tIQmhjbVZ1ZEM0a2IzQjBhVzl1Y3k1aFluTjBjbUZqZENBbUppQndZWEpsYm5RdUpIQmhjbVZ1ZENrZ2UxeHVJQ0FnSUNBZ2NHRnlaVzUwSUQwZ2NHRnlaVzUwTGlSd1lYSmxiblE3WEc0Z0lDQWdmVnh1SUNBZ0lIQmhjbVZ1ZEM0a1kyaHBiR1J5Wlc0dWNIVnphQ2gyYlNrN1hHNGdJSDFjYmx4dUlDQjJiUzRrY0dGeVpXNTBJRDBnY0dGeVpXNTBPMXh1SUNCMmJTNGtjbTl2ZENBOUlIQmhjbVZ1ZENBL0lIQmhjbVZ1ZEM0a2NtOXZkQ0E2SUhadE8xeHVYRzRnSUhadExpUmphR2xzWkhKbGJpQTlJRnRkTzF4dUlDQjJiUzRrY21WbWN5QTlJSHQ5TzF4dVhHNGdJSFp0TGw5M1lYUmphR1Z5SUQwZ2JuVnNiRHRjYmlBZ2RtMHVYMmx1WVdOMGFYWmxJRDBnYm5Wc2JEdGNiaUFnZG0wdVgyUnBjbVZqZEVsdVlXTjBhWFpsSUQwZ1ptRnNjMlU3WEc0Z0lIWnRMbDlwYzAxdmRXNTBaV1FnUFNCbVlXeHpaVHRjYmlBZ2RtMHVYMmx6UkdWemRISnZlV1ZrSUQwZ1ptRnNjMlU3WEc0Z0lIWnRMbDlwYzBKbGFXNW5SR1Z6ZEhKdmVXVmtJRDBnWm1Gc2MyVTdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHeHBabVZqZVdOc1pVMXBlR2x1SUNoV2RXVXBJSHRjYmlBZ1ZuVmxMbkJ5YjNSdmRIbHdaUzVmZFhCa1lYUmxJRDBnWm5WdVkzUnBiMjRnS0hadWIyUmxMQ0JvZVdSeVlYUnBibWNwSUh0Y2JpQWdJQ0IyWVhJZ2RtMGdQU0IwYUdsek8xeHVJQ0FnSUdsbUlDaDJiUzVmYVhOTmIzVnVkR1ZrS1NCN1hHNGdJQ0FnSUNCallXeHNTRzl2YXloMmJTd2dKMkpsWm05eVpWVndaR0YwWlNjcE8xeHVJQ0FnSUgxY2JpQWdJQ0IyWVhJZ2NISmxka1ZzSUQwZ2RtMHVKR1ZzTzF4dUlDQWdJSFpoY2lCd2NtVjJWbTV2WkdVZ1BTQjJiUzVmZG01dlpHVTdYRzRnSUNBZ2RtRnlJSEJ5WlhaQlkzUnBkbVZKYm5OMFlXNWpaU0E5SUdGamRHbDJaVWx1YzNSaGJtTmxPMXh1SUNBZ0lHRmpkR2wyWlVsdWMzUmhibU5sSUQwZ2RtMDdYRzRnSUNBZ2RtMHVYM1p1YjJSbElEMGdkbTV2WkdVN1hHNGdJQ0FnTHk4Z1ZuVmxMbkJ5YjNSdmRIbHdaUzVmWDNCaGRHTm9YMThnYVhNZ2FXNXFaV04wWldRZ2FXNGdaVzUwY25rZ2NHOXBiblJ6WEc0Z0lDQWdMeThnWW1GelpXUWdiMjRnZEdobElISmxibVJsY21sdVp5QmlZV05yWlc1a0lIVnpaV1F1WEc0Z0lDQWdhV1lnS0NGd2NtVjJWbTV2WkdVcElIdGNiaUFnSUNBZ0lDOHZJR2x1YVhScFlXd2djbVZ1WkdWeVhHNGdJQ0FnSUNCMmJTNGtaV3dnUFNCMmJTNWZYM0JoZEdOb1gxOG9YRzRnSUNBZ0lDQWdJSFp0TGlSbGJDd2dkbTV2WkdVc0lHaDVaSEpoZEdsdVp5d2dabUZzYzJVZ0x5b2djbVZ0YjNabFQyNXNlU0FxTHl4Y2JpQWdJQ0FnSUNBZ2RtMHVKRzl3ZEdsdmJuTXVYM0JoY21WdWRFVnNiU3hjYmlBZ0lDQWdJQ0FnZG0wdUpHOXdkR2x2Ym5NdVgzSmxaa1ZzYlZ4dUlDQWdJQ0FnS1R0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdMeThnZFhCa1lYUmxjMXh1SUNBZ0lDQWdkbTB1SkdWc0lEMGdkbTB1WDE5d1lYUmphRjlmS0hCeVpYWldibTlrWlN3Z2RtNXZaR1VwTzF4dUlDQWdJSDFjYmlBZ0lDQmhZM1JwZG1WSmJuTjBZVzVqWlNBOUlIQnlaWFpCWTNScGRtVkpibk4wWVc1alpUdGNiaUFnSUNBdkx5QjFjR1JoZEdVZ1gxOTJkV1ZmWHlCeVpXWmxjbVZ1WTJWY2JpQWdJQ0JwWmlBb2NISmxka1ZzS1NCN1hHNGdJQ0FnSUNCd2NtVjJSV3d1WDE5MmRXVmZYeUE5SUc1MWJHdzdYRzRnSUNBZ2ZWeHVJQ0FnSUdsbUlDaDJiUzRrWld3cElIdGNiaUFnSUNBZ0lIWnRMaVJsYkM1ZlgzWjFaVjlmSUQwZ2RtMDdYRzRnSUNBZ2ZWeHVJQ0FnSUM4dklHbG1JSEJoY21WdWRDQnBjeUJoYmlCSVQwTXNJSFZ3WkdGMFpTQnBkSE1nSkdWc0lHRnpJSGRsYkd4Y2JpQWdJQ0JwWmlBb2RtMHVKSFp1YjJSbElDWW1JSFp0TGlSd1lYSmxiblFnSmlZZ2RtMHVKSFp1YjJSbElEMDlQU0IyYlM0a2NHRnlaVzUwTGw5MmJtOWtaU2tnZTF4dUlDQWdJQ0FnZG0wdUpIQmhjbVZ1ZEM0a1pXd2dQU0IyYlM0a1pXdzdYRzRnSUNBZ2ZWeHVJQ0FnSUM4dklIVndaR0YwWldRZ2FHOXZheUJwY3lCallXeHNaV1FnWW5rZ2RHaGxJSE5qYUdWa2RXeGxjaUIwYnlCbGJuTjFjbVVnZEdoaGRDQmphR2xzWkhKbGJpQmhjbVZjYmlBZ0lDQXZMeUIxY0dSaGRHVmtJR2x1SUdFZ2NHRnlaVzUwSjNNZ2RYQmtZWFJsWkNCb2IyOXJMbHh1SUNCOU8xeHVYRzRnSUZaMVpTNXdjbTkwYjNSNWNHVXVKR1p2Y21ObFZYQmtZWFJsSUQwZ1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNBZ0lIWmhjaUIyYlNBOUlIUm9hWE03WEc0Z0lDQWdhV1lnS0hadExsOTNZWFJqYUdWeUtTQjdYRzRnSUNBZ0lDQjJiUzVmZDJGMFkyaGxjaTUxY0dSaGRHVW9LVHRjYmlBZ0lDQjlYRzRnSUgwN1hHNWNiaUFnVm5WbExuQnliM1J2ZEhsd1pTNGtaR1Z6ZEhKdmVTQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdJQ0IyWVhJZ2RtMGdQU0IwYUdsek8xeHVJQ0FnSUdsbUlDaDJiUzVmYVhOQ1pXbHVaMFJsYzNSeWIzbGxaQ2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVYRzRnSUNBZ2ZWeHVJQ0FnSUdOaGJHeEliMjlyS0hadExDQW5ZbVZtYjNKbFJHVnpkSEp2ZVNjcE8xeHVJQ0FnSUhadExsOXBjMEpsYVc1blJHVnpkSEp2ZVdWa0lEMGdkSEoxWlR0Y2JpQWdJQ0F2THlCeVpXMXZkbVVnYzJWc1ppQm1jbTl0SUhCaGNtVnVkRnh1SUNBZ0lIWmhjaUJ3WVhKbGJuUWdQU0IyYlM0a2NHRnlaVzUwTzF4dUlDQWdJR2xtSUNod1lYSmxiblFnSmlZZ0lYQmhjbVZ1ZEM1ZmFYTkNaV2x1WjBSbGMzUnliM2xsWkNBbUppQWhkbTB1Skc5d2RHbHZibk11WVdKemRISmhZM1FwSUh0Y2JpQWdJQ0FnSUhKbGJXOTJaU2h3WVhKbGJuUXVKR05vYVd4a2NtVnVMQ0IyYlNrN1hHNGdJQ0FnZlZ4dUlDQWdJQzh2SUhSbFlYSmtiM2R1SUhkaGRHTm9aWEp6WEc0Z0lDQWdhV1lnS0hadExsOTNZWFJqYUdWeUtTQjdYRzRnSUNBZ0lDQjJiUzVmZDJGMFkyaGxjaTUwWldGeVpHOTNiaWdwTzF4dUlDQWdJSDFjYmlBZ0lDQjJZWElnYVNBOUlIWnRMbDkzWVhSamFHVnljeTVzWlc1bmRHZzdYRzRnSUNBZ2QyaHBiR1VnS0drdExTa2dlMXh1SUNBZ0lDQWdkbTB1WDNkaGRHTm9aWEp6VzJsZExuUmxZWEprYjNkdUtDazdYRzRnSUNBZ2ZWeHVJQ0FnSUM4dklISmxiVzkyWlNCeVpXWmxjbVZ1WTJVZ1puSnZiU0JrWVhSaElHOWlYRzRnSUNBZ0x5OGdabkp2ZW1WdUlHOWlhbVZqZENCdFlYa2dibTkwSUdoaGRtVWdiMkp6WlhKMlpYSXVYRzRnSUNBZ2FXWWdLSFp0TGw5a1lYUmhMbDlmYjJKZlh5a2dlMXh1SUNBZ0lDQWdkbTB1WDJSaGRHRXVYMTl2WWw5ZkxuWnRRMjkxYm5RdExUdGNiaUFnSUNCOVhHNGdJQ0FnTHk4Z1kyRnNiQ0IwYUdVZ2JHRnpkQ0JvYjI5ckxpNHVYRzRnSUNBZ2RtMHVYMmx6UkdWemRISnZlV1ZrSUQwZ2RISjFaVHRjYmlBZ0lDQXZMeUJwYm5admEyVWdaR1Z6ZEhKdmVTQm9iMjlyY3lCdmJpQmpkWEp5Wlc1MElISmxibVJsY21Wa0lIUnlaV1ZjYmlBZ0lDQjJiUzVmWDNCaGRHTm9YMThvZG0wdVgzWnViMlJsTENCdWRXeHNLVHRjYmlBZ0lDQXZMeUJtYVhKbElHUmxjM1J5YjNsbFpDQm9iMjlyWEc0Z0lDQWdZMkZzYkVodmIyc29kbTBzSUNka1pYTjBjbTk1WldRbktUdGNiaUFnSUNBdkx5QjBkWEp1SUc5bVppQmhiR3dnYVc1emRHRnVZMlVnYkdsemRHVnVaWEp6TGx4dUlDQWdJSFp0TGlSdlptWW9LVHRjYmlBZ0lDQXZMeUJ5WlcxdmRtVWdYMTkyZFdWZlh5QnlaV1psY21WdVkyVmNiaUFnSUNCcFppQW9kbTB1SkdWc0tTQjdYRzRnSUNBZ0lDQjJiUzRrWld3dVgxOTJkV1ZmWHlBOUlHNTFiR3c3WEc0Z0lDQWdmVnh1SUNBZ0lDOHZJSEpsYlc5MlpTQnlaV1psY21WdVkyVWdkRzhnUkU5TklHNXZaR1Z6SUNod2NtVjJaVzUwY3lCc1pXRnJLVnh1SUNBZ0lIWnRMaVJ2Y0hScGIyNXpMbDl3WVhKbGJuUkZiRzBnUFNCMmJTNGtiM0IwYVc5dWN5NWZjbVZtUld4dElEMGdiblZzYkR0Y2JpQWdmVHRjYm4xY2JseHVablZ1WTNScGIyNGdiVzkxYm5SRGIyMXdiMjVsYm5RZ0tGeHVJQ0IyYlN4Y2JpQWdaV3dzWEc0Z0lHaDVaSEpoZEdsdVoxeHVLU0I3WEc0Z0lIWnRMaVJsYkNBOUlHVnNPMXh1SUNCcFppQW9JWFp0TGlSdmNIUnBiMjV6TG5KbGJtUmxjaWtnZTF4dUlDQWdJSFp0TGlSdmNIUnBiMjV6TG5KbGJtUmxjaUE5SUdOeVpXRjBaVVZ0Y0hSNVZrNXZaR1U3WEc0Z0lDQWdhV1lnS0hCeWIyTmxjM011Wlc1MkxrNVBSRVZmUlU1V0lDRTlQU0FuY0hKdlpIVmpkR2x2YmljcElIdGNiaUFnSUNBZ0lDOHFJR2x6ZEdGdVluVnNJR2xuYm05eVpTQnBaaUFxTDF4dUlDQWdJQ0FnYVdZZ0tDaDJiUzRrYjNCMGFXOXVjeTUwWlcxd2JHRjBaU0FtSmlCMmJTNGtiM0IwYVc5dWN5NTBaVzF3YkdGMFpTNWphR0Z5UVhRb01Da2dJVDA5SUNjakp5a2dmSHhjYmlBZ0lDQWdJQ0FnZG0wdUpHOXdkR2x2Ym5NdVpXd2dmSHdnWld3cElIdGNiaUFnSUNBZ0lDQWdkMkZ5YmloY2JpQWdJQ0FnSUNBZ0lDQW5XVzkxSUdGeVpTQjFjMmx1WnlCMGFHVWdjblZ1ZEdsdFpTMXZibXg1SUdKMWFXeGtJRzltSUZaMVpTQjNhR1Z5WlNCMGFHVWdkR1Z0Y0d4aGRHVWdKeUFyWEc0Z0lDQWdJQ0FnSUNBZ0oyTnZiWEJwYkdWeUlHbHpJRzV2ZENCaGRtRnBiR0ZpYkdVdUlFVnBkR2hsY2lCd2NtVXRZMjl0Y0dsc1pTQjBhR1VnZEdWdGNHeGhkR1Z6SUdsdWRHOGdKeUFyWEc0Z0lDQWdJQ0FnSUNBZ0ozSmxibVJsY2lCbWRXNWpkR2x2Ym5Nc0lHOXlJSFZ6WlNCMGFHVWdZMjl0Y0dsc1pYSXRhVzVqYkhWa1pXUWdZblZwYkdRdUp5eGNiaUFnSUNBZ0lDQWdJQ0IyYlZ4dUlDQWdJQ0FnSUNBcE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2QyRnliaWhjYmlBZ0lDQWdJQ0FnSUNBblJtRnBiR1ZrSUhSdklHMXZkVzUwSUdOdmJYQnZibVZ1ZERvZ2RHVnRjR3hoZEdVZ2IzSWdjbVZ1WkdWeUlHWjFibU4wYVc5dUlHNXZkQ0JrWldacGJtVmtMaWNzWEc0Z0lDQWdJQ0FnSUNBZ2RtMWNiaUFnSUNBZ0lDQWdLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzRnSUgxY2JpQWdZMkZzYkVodmIyc29kbTBzSUNkaVpXWnZjbVZOYjNWdWRDY3BPMXh1WEc0Z0lIWmhjaUIxY0dSaGRHVkRiMjF3YjI1bGJuUTdYRzRnSUM4cUlHbHpkR0Z1WW5Wc0lHbG5ibTl5WlNCcFppQXFMMXh1SUNCcFppQW9jSEp2WTJWemN5NWxibll1VGs5RVJWOUZUbFlnSVQwOUlDZHdjbTlrZFdOMGFXOXVKeUFtSmlCamIyNW1hV2N1Y0dWeVptOXliV0Z1WTJVZ0ppWWdiV0Z5YXlrZ2UxeHVJQ0FnSUhWd1pHRjBaVU52YlhCdmJtVnVkQ0E5SUdaMWJtTjBhVzl1SUNncElIdGNiaUFnSUNBZ0lIWmhjaUJ1WVcxbElEMGdkbTB1WDI1aGJXVTdYRzRnSUNBZ0lDQjJZWElnYVdRZ1BTQjJiUzVmZFdsa08xeHVJQ0FnSUNBZ2RtRnlJSE4wWVhKMFZHRm5JRDBnWENKMmRXVXRjR1Z5WmkxemRHRnlkRHBjSWlBcklHbGtPMXh1SUNBZ0lDQWdkbUZ5SUdWdVpGUmhaeUE5SUZ3aWRuVmxMWEJsY21ZdFpXNWtPbHdpSUNzZ2FXUTdYRzVjYmlBZ0lDQWdJRzFoY21zb2MzUmhjblJVWVdjcE8xeHVJQ0FnSUNBZ2RtRnlJSFp1YjJSbElEMGdkbTB1WDNKbGJtUmxjaWdwTzF4dUlDQWdJQ0FnYldGeWF5aGxibVJVWVdjcE8xeHVJQ0FnSUNBZ2JXVmhjM1Z5WlNnb2JtRnRaU0FySUZ3aUlISmxibVJsY2x3aUtTd2djM1JoY25SVVlXY3NJR1Z1WkZSaFp5azdYRzVjYmlBZ0lDQWdJRzFoY21zb2MzUmhjblJVWVdjcE8xeHVJQ0FnSUNBZ2RtMHVYM1Z3WkdGMFpTaDJibTlrWlN3Z2FIbGtjbUYwYVc1bktUdGNiaUFnSUNBZ0lHMWhjbXNvWlc1a1ZHRm5LVHRjYmlBZ0lDQWdJRzFsWVhOMWNtVW9LRzVoYldVZ0t5QmNJaUJ3WVhSamFGd2lLU3dnYzNSaGNuUlVZV2NzSUdWdVpGUmhaeWs3WEc0Z0lDQWdmVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0IxY0dSaGRHVkRiMjF3YjI1bGJuUWdQU0JtZFc1amRHbHZiaUFvS1NCN1hHNGdJQ0FnSUNCMmJTNWZkWEJrWVhSbEtIWnRMbDl5Wlc1a1pYSW9LU3dnYUhsa2NtRjBhVzVuS1R0Y2JpQWdJQ0I5TzF4dUlDQjlYRzVjYmlBZ2RtMHVYM2RoZEdOb1pYSWdQU0J1WlhjZ1YyRjBZMmhsY2loMmJTd2dkWEJrWVhSbFEyOXRjRzl1Wlc1MExDQnViMjl3S1R0Y2JpQWdhSGxrY21GMGFXNW5JRDBnWm1Gc2MyVTdYRzVjYmlBZ0x5OGdiV0Z1ZFdGc2JIa2diVzkxYm5SbFpDQnBibk4wWVc1alpTd2dZMkZzYkNCdGIzVnVkR1ZrSUc5dUlITmxiR1pjYmlBZ0x5OGdiVzkxYm5SbFpDQnBjeUJqWVd4c1pXUWdabTl5SUhKbGJtUmxjaTFqY21WaGRHVmtJR05vYVd4a0lHTnZiWEJ2Ym1WdWRITWdhVzRnYVhSeklHbHVjMlZ5ZEdWa0lHaHZiMnRjYmlBZ2FXWWdLSFp0TGlSMmJtOWtaU0E5UFNCdWRXeHNLU0I3WEc0Z0lDQWdkbTB1WDJselRXOTFiblJsWkNBOUlIUnlkV1U3WEc0Z0lDQWdZMkZzYkVodmIyc29kbTBzSUNkdGIzVnVkR1ZrSnlrN1hHNGdJSDFjYmlBZ2NtVjBkWEp1SUhadFhHNTlYRzVjYm1aMWJtTjBhVzl1SUhWd1pHRjBaVU5vYVd4a1EyOXRjRzl1Wlc1MElDaGNiaUFnZG0wc1hHNGdJSEJ5YjNCelJHRjBZU3hjYmlBZ2JHbHpkR1Z1WlhKekxGeHVJQ0J3WVhKbGJuUldibTlrWlN4Y2JpQWdjbVZ1WkdWeVEyaHBiR1J5Wlc1Y2Jpa2dlMXh1SUNBdkx5QmtaWFJsY20xcGJtVWdkMmhsZEdobGNpQmpiMjF3YjI1bGJuUWdhR0Z6SUhOc2IzUWdZMmhwYkdSeVpXNWNiaUFnTHk4Z2QyVWdibVZsWkNCMGJ5QmtieUIwYUdseklHSmxabTl5WlNCdmRtVnlkM0pwZEdsdVp5QWtiM0IwYVc5dWN5NWZjbVZ1WkdWeVEyaHBiR1J5Wlc1Y2JpQWdkbUZ5SUdoaGMwTm9hV3hrY21WdUlEMGdJU0VvWEc0Z0lDQWdjbVZ1WkdWeVEyaHBiR1J5Wlc0Z2ZId2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBdkx5Qm9ZWE1nYm1WM0lITjBZWFJwWXlCemJHOTBjMXh1SUNBZ0lIWnRMaVJ2Y0hScGIyNXpMbDl5Wlc1a1pYSkRhR2xzWkhKbGJpQjhmQ0FnTHk4Z2FHRnpJRzlzWkNCemRHRjBhV01nYzJ4dmRITmNiaUFnSUNCd1lYSmxiblJXYm05a1pTNWtZWFJoTG5OamIzQmxaRk5zYjNSeklIeDhJQzh2SUdoaGN5QnVaWGNnYzJOdmNHVmtJSE5zYjNSelhHNGdJQ0FnZG0wdUpITmpiM0JsWkZOc2IzUnpJQ0U5UFNCbGJYQjBlVTlpYW1WamRDQXZMeUJvWVhNZ2IyeGtJSE5qYjNCbFpDQnpiRzkwYzF4dUlDQXBPMXh1WEc0Z0lIWnRMaVJ2Y0hScGIyNXpMbDl3WVhKbGJuUldibTlrWlNBOUlIQmhjbVZ1ZEZadWIyUmxPMXh1SUNCMmJTNGtkbTV2WkdVZ1BTQndZWEpsYm5SV2JtOWtaVHNnTHk4Z2RYQmtZWFJsSUhadEozTWdjR3hoWTJWb2IyeGtaWElnYm05a1pTQjNhWFJvYjNWMElISmxMWEpsYm1SbGNseHVJQ0JwWmlBb2RtMHVYM1p1YjJSbEtTQjdJQzh2SUhWd1pHRjBaU0JqYUdsc1pDQjBjbVZsSjNNZ2NHRnlaVzUwWEc0Z0lDQWdkbTB1WDNadWIyUmxMbkJoY21WdWRDQTlJSEJoY21WdWRGWnViMlJsTzF4dUlDQjlYRzRnSUhadExpUnZjSFJwYjI1ekxsOXlaVzVrWlhKRGFHbHNaSEpsYmlBOUlISmxibVJsY2tOb2FXeGtjbVZ1TzF4dVhHNGdJQzh2SUhWd1pHRjBaU0J3Y205d2MxeHVJQ0JwWmlBb2NISnZjSE5FWVhSaElDWW1JSFp0TGlSdmNIUnBiMjV6TG5CeWIzQnpLU0I3WEc0Z0lDQWdiMkp6WlhKMlpYSlRkR0YwWlM1emFHOTFiR1JEYjI1MlpYSjBJRDBnWm1Gc2MyVTdYRzRnSUNBZ2FXWWdLSEJ5YjJObGMzTXVaVzUyTGs1UFJFVmZSVTVXSUNFOVBTQW5jSEp2WkhWamRHbHZiaWNwSUh0Y2JpQWdJQ0FnSUc5aWMyVnlkbVZ5VTNSaGRHVXVhWE5UWlhSMGFXNW5VSEp2Y0hNZ1BTQjBjblZsTzF4dUlDQWdJSDFjYmlBZ0lDQjJZWElnY0hKdmNITWdQU0IyYlM1ZmNISnZjSE03WEc0Z0lDQWdkbUZ5SUhCeWIzQkxaWGx6SUQwZ2RtMHVKRzl3ZEdsdmJuTXVYM0J5YjNCTFpYbHpJSHg4SUZ0ZE8xeHVJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2NISnZjRXRsZVhNdWJHVnVaM1JvT3lCcEt5c3BJSHRjYmlBZ0lDQWdJSFpoY2lCclpYa2dQU0J3Y205d1MyVjVjMXRwWFR0Y2JpQWdJQ0FnSUhCeWIzQnpXMnRsZVYwZ1BTQjJZV3hwWkdGMFpWQnliM0FvYTJWNUxDQjJiUzRrYjNCMGFXOXVjeTV3Y205d2N5d2djSEp2Y0hORVlYUmhMQ0IyYlNrN1hHNGdJQ0FnZlZ4dUlDQWdJRzlpYzJWeWRtVnlVM1JoZEdVdWMyaHZkV3hrUTI5dWRtVnlkQ0E5SUhSeWRXVTdYRzRnSUNBZ2FXWWdLSEJ5YjJObGMzTXVaVzUyTGs1UFJFVmZSVTVXSUNFOVBTQW5jSEp2WkhWamRHbHZiaWNwSUh0Y2JpQWdJQ0FnSUc5aWMyVnlkbVZ5VTNSaGRHVXVhWE5UWlhSMGFXNW5VSEp2Y0hNZ1BTQm1ZV3h6WlR0Y2JpQWdJQ0I5WEc0Z0lDQWdMeThnYTJWbGNDQmhJR052Y0hrZ2IyWWdjbUYzSUhCeWIzQnpSR0YwWVZ4dUlDQWdJSFp0TGlSdmNIUnBiMjV6TG5CeWIzQnpSR0YwWVNBOUlIQnliM0J6UkdGMFlUdGNiaUFnZlZ4dUlDQXZMeUIxY0dSaGRHVWdiR2x6ZEdWdVpYSnpYRzRnSUdsbUlDaHNhWE4wWlc1bGNuTXBJSHRjYmlBZ0lDQjJZWElnYjJ4a1RHbHpkR1Z1WlhKeklEMGdkbTB1Skc5d2RHbHZibk11WDNCaGNtVnVkRXhwYzNSbGJtVnljenRjYmlBZ0lDQjJiUzRrYjNCMGFXOXVjeTVmY0dGeVpXNTBUR2x6ZEdWdVpYSnpJRDBnYkdsemRHVnVaWEp6TzF4dUlDQWdJSFZ3WkdGMFpVTnZiWEJ2Ym1WdWRFeHBjM1JsYm1WeWN5aDJiU3dnYkdsemRHVnVaWEp6TENCdmJHUk1hWE4wWlc1bGNuTXBPMXh1SUNCOVhHNGdJQzh2SUhKbGMyOXNkbVVnYzJ4dmRITWdLeUJtYjNKalpTQjFjR1JoZEdVZ2FXWWdhR0Z6SUdOb2FXeGtjbVZ1WEc0Z0lHbG1JQ2hvWVhORGFHbHNaSEpsYmlrZ2UxeHVJQ0FnSUhadExpUnpiRzkwY3lBOUlISmxjMjlzZG1WVGJHOTBjeWh5Wlc1a1pYSkRhR2xzWkhKbGJpd2djR0Z5Wlc1MFZtNXZaR1V1WTI5dWRHVjRkQ2s3WEc0Z0lDQWdkbTB1SkdadmNtTmxWWEJrWVhSbEtDazdYRzRnSUgxY2JuMWNibHh1Wm5WdVkzUnBiMjRnYVhOSmJrbHVZV04wYVhabFZISmxaU0FvZG0wcElIdGNiaUFnZDJocGJHVWdLSFp0SUNZbUlDaDJiU0E5SUhadExpUndZWEpsYm5RcEtTQjdYRzRnSUNBZ2FXWWdLSFp0TGw5cGJtRmpkR2wyWlNrZ2V5QnlaWFIxY200Z2RISjFaU0I5WEc0Z0lIMWNiaUFnY21WMGRYSnVJR1poYkhObFhHNTlYRzVjYm1aMWJtTjBhVzl1SUdGamRHbDJZWFJsUTJocGJHUkRiMjF3YjI1bGJuUWdLSFp0TENCa2FYSmxZM1FwSUh0Y2JpQWdhV1lnS0dScGNtVmpkQ2tnZTF4dUlDQWdJSFp0TGw5a2FYSmxZM1JKYm1GamRHbDJaU0E5SUdaaGJITmxPMXh1SUNBZ0lHbG1JQ2hwYzBsdVNXNWhZM1JwZG1WVWNtVmxLSFp0S1NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1WEc0Z0lDQWdmVnh1SUNCOUlHVnNjMlVnYVdZZ0tIWnRMbDlrYVhKbFkzUkpibUZqZEdsMlpTa2dlMXh1SUNBZ0lISmxkSFZ5Ymx4dUlDQjlYRzRnSUdsbUlDaDJiUzVmYVc1aFkzUnBkbVVnZkh3Z2RtMHVYMmx1WVdOMGFYWmxJRDA5SUc1MWJHd3BJSHRjYmlBZ0lDQjJiUzVmYVc1aFkzUnBkbVVnUFNCbVlXeHpaVHRjYmlBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJSFp0TGlSamFHbHNaSEpsYmk1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lDQWdZV04wYVhaaGRHVkRhR2xzWkVOdmJYQnZibVZ1ZENoMmJTNGtZMmhwYkdSeVpXNWJhVjBwTzF4dUlDQWdJSDFjYmlBZ0lDQmpZV3hzU0c5dmF5aDJiU3dnSjJGamRHbDJZWFJsWkNjcE8xeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJR1JsWVdOMGFYWmhkR1ZEYUdsc1pFTnZiWEJ2Ym1WdWRDQW9kbTBzSUdScGNtVmpkQ2tnZTF4dUlDQnBaaUFvWkdseVpXTjBLU0I3WEc0Z0lDQWdkbTB1WDJScGNtVmpkRWx1WVdOMGFYWmxJRDBnZEhKMVpUdGNiaUFnSUNCcFppQW9hWE5KYmtsdVlXTjBhWFpsVkhKbFpTaDJiU2twSUh0Y2JpQWdJQ0FnSUhKbGRIVnlibHh1SUNBZ0lIMWNiaUFnZlZ4dUlDQnBaaUFvSVhadExsOXBibUZqZEdsMlpTa2dlMXh1SUNBZ0lIWnRMbDlwYm1GamRHbDJaU0E5SUhSeWRXVTdYRzRnSUNBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQjJiUzRrWTJocGJHUnlaVzR1YkdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNBZ0lHUmxZV04wYVhaaGRHVkRhR2xzWkVOdmJYQnZibVZ1ZENoMmJTNGtZMmhwYkdSeVpXNWJhVjBwTzF4dUlDQWdJSDFjYmlBZ0lDQmpZV3hzU0c5dmF5aDJiU3dnSjJSbFlXTjBhWFpoZEdWa0p5azdYRzRnSUgxY2JuMWNibHh1Wm5WdVkzUnBiMjRnWTJGc2JFaHZiMnNnS0hadExDQm9iMjlyS1NCN1hHNGdJSFpoY2lCb1lXNWtiR1Z5Y3lBOUlIWnRMaVJ2Y0hScGIyNXpXMmh2YjJ0ZE8xeHVJQ0JwWmlBb2FHRnVaR3hsY25NcElIdGNiaUFnSUNCbWIzSWdLSFpoY2lCcElEMGdNQ3dnYWlBOUlHaGhibVJzWlhKekxteGxibWQwYURzZ2FTQThJR283SUdrckt5a2dlMXh1SUNBZ0lDQWdkSEo1SUh0Y2JpQWdJQ0FnSUNBZ2FHRnVaR3hsY25OYmFWMHVZMkZzYkNoMmJTazdYRzRnSUNBZ0lDQjlJR05oZEdOb0lDaGxLU0I3WEc0Z0lDQWdJQ0FnSUdoaGJtUnNaVVZ5Y205eUtHVXNJSFp0TENBb2FHOXZheUFySUZ3aUlHaHZiMnRjSWlrcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdmVnh1SUNCcFppQW9kbTB1WDJoaGMwaHZiMnRGZG1WdWRDa2dlMXh1SUNBZ0lIWnRMaVJsYldsMEtDZG9iMjlyT2ljZ0t5Qm9iMjlyS1R0Y2JpQWdmVnh1ZlZ4dVhHNHZLaUFnS2k5Y2JseHVYRzUyWVhJZ2NYVmxkV1VnUFNCYlhUdGNiblpoY2lCb1lYTWdQU0I3ZlR0Y2JuWmhjaUJqYVhKamRXeGhjaUE5SUh0OU8xeHVkbUZ5SUhkaGFYUnBibWNnUFNCbVlXeHpaVHRjYm5aaGNpQm1iSFZ6YUdsdVp5QTlJR1poYkhObE8xeHVkbUZ5SUdsdVpHVjRJRDBnTUR0Y2JseHVMeW9xWEc0Z0tpQlNaWE5sZENCMGFHVWdjMk5vWldSMWJHVnlKM01nYzNSaGRHVXVYRzRnS2k5Y2JtWjFibU4wYVc5dUlISmxjMlYwVTJOb1pXUjFiR1Z5VTNSaGRHVWdLQ2tnZTF4dUlDQnhkV1YxWlM1c1pXNW5kR2dnUFNBd08xeHVJQ0JvWVhNZ1BTQjdmVHRjYmlBZ2FXWWdLSEJ5YjJObGMzTXVaVzUyTGs1UFJFVmZSVTVXSUNFOVBTQW5jSEp2WkhWamRHbHZiaWNwSUh0Y2JpQWdJQ0JqYVhKamRXeGhjaUE5SUh0OU8xeHVJQ0I5WEc0Z0lIZGhhWFJwYm1jZ1BTQm1iSFZ6YUdsdVp5QTlJR1poYkhObE8xeHVmVnh1WEc0dktpcGNiaUFxSUVac2RYTm9JR0p2ZEdnZ2NYVmxkV1Z6SUdGdVpDQnlkVzRnZEdobElIZGhkR05vWlhKekxseHVJQ292WEc1bWRXNWpkR2x2YmlCbWJIVnphRk5qYUdWa2RXeGxjbEYxWlhWbElDZ3BJSHRjYmlBZ1pteDFjMmhwYm1jZ1BTQjBjblZsTzF4dUlDQjJZWElnZDJGMFkyaGxjaXdnYVdRc0lIWnRPMXh1WEc0Z0lDOHZJRk52Y25RZ2NYVmxkV1VnWW1WbWIzSmxJR1pzZFhOb0xseHVJQ0F2THlCVWFHbHpJR1Z1YzNWeVpYTWdkR2hoZERwY2JpQWdMeThnTVM0Z1EyOXRjRzl1Wlc1MGN5QmhjbVVnZFhCa1lYUmxaQ0JtY205dElIQmhjbVZ1ZENCMGJ5QmphR2xzWkM0Z0tHSmxZMkYxYzJVZ2NHRnlaVzUwSUdseklHRnNkMkY1YzF4dUlDQXZMeUFnSUNCamNtVmhkR1ZrSUdKbFptOXlaU0IwYUdVZ1kyaHBiR1FwWEc0Z0lDOHZJREl1SUVFZ1kyOXRjRzl1Wlc1MEozTWdkWE5sY2lCM1lYUmphR1Z5Y3lCaGNtVWdjblZ1SUdKbFptOXlaU0JwZEhNZ2NtVnVaR1Z5SUhkaGRHTm9aWElnS0dKbFkyRjFjMlZjYmlBZ0x5OGdJQ0FnZFhObGNpQjNZWFJqYUdWeWN5QmhjbVVnWTNKbFlYUmxaQ0JpWldadmNtVWdkR2hsSUhKbGJtUmxjaUIzWVhSamFHVnlLVnh1SUNBdkx5QXpMaUJKWmlCaElHTnZiWEJ2Ym1WdWRDQnBjeUJrWlhOMGNtOTVaV1FnWkhWeWFXNW5JR0VnY0dGeVpXNTBJR052YlhCdmJtVnVkQ2R6SUhkaGRHTm9aWElnY25WdUxGeHVJQ0F2THlBZ0lDQnBkSE1nZDJGMFkyaGxjbk1nWTJGdUlHSmxJSE5yYVhCd1pXUXVYRzRnSUhGMVpYVmxMbk52Y25Rb1puVnVZM1JwYjI0Z0tHRXNJR0lwSUhzZ2NtVjBkWEp1SUdFdWFXUWdMU0JpTG1sa095QjlLVHRjYmx4dUlDQXZMeUJrYnlCdWIzUWdZMkZqYUdVZ2JHVnVaM1JvSUdKbFkyRjFjMlVnYlc5eVpTQjNZWFJqYUdWeWN5QnRhV2RvZENCaVpTQndkWE5vWldSY2JpQWdMeThnWVhNZ2QyVWdjblZ1SUdWNGFYTjBhVzVuSUhkaGRHTm9aWEp6WEc0Z0lHWnZjaUFvYVc1a1pYZ2dQU0F3T3lCcGJtUmxlQ0E4SUhGMVpYVmxMbXhsYm1kMGFEc2dhVzVrWlhnckt5a2dlMXh1SUNBZ0lIZGhkR05vWlhJZ1BTQnhkV1YxWlZ0cGJtUmxlRjA3WEc0Z0lDQWdhV1FnUFNCM1lYUmphR1Z5TG1sa08xeHVJQ0FnSUdoaGMxdHBaRjBnUFNCdWRXeHNPMXh1SUNBZ0lIZGhkR05vWlhJdWNuVnVLQ2s3WEc0Z0lDQWdMeThnYVc0Z1pHVjJJR0oxYVd4a0xDQmphR1ZqYXlCaGJtUWdjM1J2Y0NCamFYSmpkV3hoY2lCMWNHUmhkR1Z6TGx4dUlDQWdJR2xtSUNod2NtOWpaWE56TG1WdWRpNU9UMFJGWDBWT1ZpQWhQVDBnSjNCeWIyUjFZM1JwYjI0bklDWW1JR2hoYzF0cFpGMGdJVDBnYm5Wc2JDa2dlMXh1SUNBZ0lDQWdZMmx5WTNWc1lYSmJhV1JkSUQwZ0tHTnBjbU4xYkdGeVcybGtYU0I4ZkNBd0tTQXJJREU3WEc0Z0lDQWdJQ0JwWmlBb1kybHlZM1ZzWVhKYmFXUmRJRDRnWTI5dVptbG5MbDl0WVhoVmNHUmhkR1ZEYjNWdWRDa2dlMXh1SUNBZ0lDQWdJQ0IzWVhKdUtGeHVJQ0FnSUNBZ0lDQWdJQ2RaYjNVZ2JXRjVJR2hoZG1VZ1lXNGdhVzVtYVc1cGRHVWdkWEJrWVhSbElHeHZiM0FnSnlBcklDaGNiaUFnSUNBZ0lDQWdJQ0FnSUhkaGRHTm9aWEl1ZFhObGNseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBL0lDaGNJbWx1SUhkaGRHTm9aWElnZDJsMGFDQmxlSEJ5WlhOemFXOXVJRnhjWENKY0lpQXJJQ2gzWVhSamFHVnlMbVY0Y0hKbGMzTnBiMjRwSUNzZ1hDSmNYRndpWENJcFhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSURvZ1hDSnBiaUJoSUdOdmJYQnZibVZ1ZENCeVpXNWtaWElnWm5WdVkzUnBiMjR1WENKY2JpQWdJQ0FnSUNBZ0lDQXBMRnh1SUNBZ0lDQWdJQ0FnSUhkaGRHTm9aWEl1ZG0xY2JpQWdJQ0FnSUNBZ0tUdGNiaUFnSUNBZ0lDQWdZbkpsWVd0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNBdkx5QnlaWE5sZENCelkyaGxaSFZzWlhJZ1ltVm1iM0psSUhWd1pHRjBaV1FnYUc5dmF5QmpZV3hzWldSY2JpQWdkbUZ5SUc5c1pGRjFaWFZsSUQwZ2NYVmxkV1V1YzJ4cFkyVW9LVHRjYmlBZ2NtVnpaWFJUWTJobFpIVnNaWEpUZEdGMFpTZ3BPMXh1WEc0Z0lDOHZJR05oYkd3Z2RYQmtZWFJsWkNCb2IyOXJjMXh1SUNCcGJtUmxlQ0E5SUc5c1pGRjFaWFZsTG14bGJtZDBhRHRjYmlBZ2QyaHBiR1VnS0dsdVpHVjRMUzBwSUh0Y2JpQWdJQ0IzWVhSamFHVnlJRDBnYjJ4a1VYVmxkV1ZiYVc1a1pYaGRPMXh1SUNBZ0lIWnRJRDBnZDJGMFkyaGxjaTUyYlR0Y2JpQWdJQ0JwWmlBb2RtMHVYM2RoZEdOb1pYSWdQVDA5SUhkaGRHTm9aWElnSmlZZ2RtMHVYMmx6VFc5MWJuUmxaQ2tnZTF4dUlDQWdJQ0FnWTJGc2JFaHZiMnNvZG0wc0lDZDFjR1JoZEdWa0p5azdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdMeThnWkdWMmRHOXZiQ0JvYjI5clhHNGdJQzhxSUdsemRHRnVZblZzSUdsbmJtOXlaU0JwWmlBcUwxeHVJQ0JwWmlBb1pHVjJkRzl2YkhNZ0ppWWdZMjl1Wm1sbkxtUmxkblJ2YjJ4ektTQjdYRzRnSUNBZ1pHVjJkRzl2YkhNdVpXMXBkQ2duWm14MWMyZ25LVHRjYmlBZ2ZWeHVmVnh1WEc0dktpcGNiaUFxSUZCMWMyZ2dZU0IzWVhSamFHVnlJR2x1ZEc4Z2RHaGxJSGRoZEdOb1pYSWdjWFZsZFdVdVhHNGdLaUJLYjJKeklIZHBkR2dnWkhWd2JHbGpZWFJsSUVsRWN5QjNhV3hzSUdKbElITnJhWEJ3WldRZ2RXNXNaWE56SUdsMEozTmNiaUFxSUhCMWMyaGxaQ0IzYUdWdUlIUm9aU0J4ZFdWMVpTQnBjeUJpWldsdVp5Qm1iSFZ6YUdWa0xseHVJQ292WEc1bWRXNWpkR2x2YmlCeGRXVjFaVmRoZEdOb1pYSWdLSGRoZEdOb1pYSXBJSHRjYmlBZ2RtRnlJR2xrSUQwZ2QyRjBZMmhsY2k1cFpEdGNiaUFnYVdZZ0tHaGhjMXRwWkYwZ1BUMGdiblZzYkNrZ2UxeHVJQ0FnSUdoaGMxdHBaRjBnUFNCMGNuVmxPMXh1SUNBZ0lHbG1JQ2doWm14MWMyaHBibWNwSUh0Y2JpQWdJQ0FnSUhGMVpYVmxMbkIxYzJnb2QyRjBZMmhsY2lrN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQzh2SUdsbUlHRnNjbVZoWkhrZ1pteDFjMmhwYm1jc0lITndiR2xqWlNCMGFHVWdkMkYwWTJobGNpQmlZWE5sWkNCdmJpQnBkSE1nYVdSY2JpQWdJQ0FnSUM4dklHbG1JR0ZzY21WaFpIa2djR0Z6ZENCcGRITWdhV1FzSUdsMElIZHBiR3dnWW1VZ2NuVnVJRzVsZUhRZ2FXMXRaV1JwWVhSbGJIa3VYRzRnSUNBZ0lDQjJZWElnYVNBOUlIRjFaWFZsTG14bGJtZDBhQ0F0SURFN1hHNGdJQ0FnSUNCM2FHbHNaU0FvYVNBK1BTQXdJQ1ltSUhGMVpYVmxXMmxkTG1sa0lENGdkMkYwWTJobGNpNXBaQ2tnZTF4dUlDQWdJQ0FnSUNCcExTMDdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnhkV1YxWlM1emNHeHBZMlVvVFdGMGFDNXRZWGdvYVN3Z2FXNWtaWGdwSUNzZ01Td2dNQ3dnZDJGMFkyaGxjaWs3WEc0Z0lDQWdmVnh1SUNBZ0lDOHZJSEYxWlhWbElIUm9aU0JtYkhWemFGeHVJQ0FnSUdsbUlDZ2hkMkZwZEdsdVp5a2dlMXh1SUNBZ0lDQWdkMkZwZEdsdVp5QTlJSFJ5ZFdVN1hHNGdJQ0FnSUNCdVpYaDBWR2xqYXlobWJIVnphRk5qYUdWa2RXeGxjbEYxWlhWbEtUdGNiaUFnSUNCOVhHNGdJSDFjYm4xY2JseHVMeW9nSUNvdlhHNWNiblpoY2lCMWFXUWtNaUE5SURBN1hHNWNiaThxS2x4dUlDb2dRU0IzWVhSamFHVnlJSEJoY25ObGN5QmhiaUJsZUhCeVpYTnphVzl1TENCamIyeHNaV04wY3lCa1pYQmxibVJsYm1OcFpYTXNYRzRnS2lCaGJtUWdabWx5WlhNZ1kyRnNiR0poWTJzZ2QyaGxiaUIwYUdVZ1pYaHdjbVZ6YzJsdmJpQjJZV3gxWlNCamFHRnVaMlZ6TGx4dUlDb2dWR2hwY3lCcGN5QjFjMlZrSUdadmNpQmliM1JvSUhSb1pTQWtkMkYwWTJnb0tTQmhjR2tnWVc1a0lHUnBjbVZqZEdsMlpYTXVYRzRnS2k5Y2JuWmhjaUJYWVhSamFHVnlJRDBnWm5WdVkzUnBiMjRnVjJGMFkyaGxjaUFvWEc0Z0lIWnRMRnh1SUNCbGVIQlBja1p1TEZ4dUlDQmpZaXhjYmlBZ2IzQjBhVzl1YzF4dUtTQjdYRzRnSUhSb2FYTXVkbTBnUFNCMmJUdGNiaUFnZG0wdVgzZGhkR05vWlhKekxuQjFjMmdvZEdocGN5azdYRzRnSUM4dklHOXdkR2x2Ym5OY2JpQWdhV1lnS0c5d2RHbHZibk1wSUh0Y2JpQWdJQ0IwYUdsekxtUmxaWEFnUFNBaElXOXdkR2x2Ym5NdVpHVmxjRHRjYmlBZ0lDQjBhR2x6TG5WelpYSWdQU0FoSVc5d2RHbHZibk11ZFhObGNqdGNiaUFnSUNCMGFHbHpMbXhoZW5rZ1BTQWhJVzl3ZEdsdmJuTXViR0Y2ZVR0Y2JpQWdJQ0IwYUdsekxuTjVibU1nUFNBaElXOXdkR2x2Ym5NdWMzbHVZenRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0IwYUdsekxtUmxaWEFnUFNCMGFHbHpMblZ6WlhJZ1BTQjBhR2x6TG14aGVua2dQU0IwYUdsekxuTjVibU1nUFNCbVlXeHpaVHRjYmlBZ2ZWeHVJQ0IwYUdsekxtTmlJRDBnWTJJN1hHNGdJSFJvYVhNdWFXUWdQU0FySzNWcFpDUXlPeUF2THlCMWFXUWdabTl5SUdKaGRHTm9hVzVuWEc0Z0lIUm9hWE11WVdOMGFYWmxJRDBnZEhKMVpUdGNiaUFnZEdocGN5NWthWEowZVNBOUlIUm9hWE11YkdGNmVUc2dMeThnWm05eUlHeGhlbmtnZDJGMFkyaGxjbk5jYmlBZ2RHaHBjeTVrWlhCeklEMGdXMTA3WEc0Z0lIUm9hWE11Ym1WM1JHVndjeUE5SUZ0ZE8xeHVJQ0IwYUdsekxtUmxjRWxrY3lBOUlHNWxkeUJmVTJWMEtDazdYRzRnSUhSb2FYTXVibVYzUkdWd1NXUnpJRDBnYm1WM0lGOVRaWFFvS1R0Y2JpQWdkR2hwY3k1bGVIQnlaWE56YVc5dUlEMGdjSEp2WTJWemN5NWxibll1VGs5RVJWOUZUbFlnSVQwOUlDZHdjbTlrZFdOMGFXOXVKMXh1SUNBZ0lEOGdaWGh3VDNKR2JpNTBiMU4wY21sdVp5Z3BYRzRnSUNBZ09pQW5KenRjYmlBZ0x5OGdjR0Z5YzJVZ1pYaHdjbVZ6YzJsdmJpQm1iM0lnWjJWMGRHVnlYRzRnSUdsbUlDaDBlWEJsYjJZZ1pYaHdUM0pHYmlBOVBUMGdKMloxYm1OMGFXOXVKeWtnZTF4dUlDQWdJSFJvYVhNdVoyVjBkR1Z5SUQwZ1pYaHdUM0pHYmp0Y2JpQWdmU0JsYkhObElIdGNiaUFnSUNCMGFHbHpMbWRsZEhSbGNpQTlJSEJoY25ObFVHRjBhQ2hsZUhCUGNrWnVLVHRjYmlBZ0lDQnBaaUFvSVhSb2FYTXVaMlYwZEdWeUtTQjdYRzRnSUNBZ0lDQjBhR2x6TG1kbGRIUmxjaUE5SUdaMWJtTjBhVzl1SUNncElIdDlPMXh1SUNBZ0lDQWdjSEp2WTJWemN5NWxibll1VGs5RVJWOUZUbFlnSVQwOUlDZHdjbTlrZFdOMGFXOXVKeUFtSmlCM1lYSnVLRnh1SUNBZ0lDQWdJQ0JjSWtaaGFXeGxaQ0IzWVhSamFHbHVaeUJ3WVhSb09pQmNYRndpWENJZ0t5QmxlSEJQY2tadUlDc2dYQ0pjWEZ3aUlGd2lJQ3RjYmlBZ0lDQWdJQ0FnSjFkaGRHTm9aWElnYjI1c2VTQmhZMk5sY0hSeklITnBiWEJzWlNCa2IzUXRaR1ZzYVcxcGRHVmtJSEJoZEdoekxpQW5JQ3RjYmlBZ0lDQWdJQ0FnSjBadmNpQm1kV3hzSUdOdmJuUnliMndzSUhWelpTQmhJR1oxYm1OMGFXOXVJR2x1YzNSbFlXUXVKeXhjYmlBZ0lDQWdJQ0FnZG0xY2JpQWdJQ0FnSUNrN1hHNGdJQ0FnZlZ4dUlDQjlYRzRnSUhSb2FYTXVkbUZzZFdVZ1BTQjBhR2x6TG14aGVubGNiaUFnSUNBL0lIVnVaR1ZtYVc1bFpGeHVJQ0FnSURvZ2RHaHBjeTVuWlhRb0tUdGNibjA3WEc1Y2JpOHFLbHh1SUNvZ1JYWmhiSFZoZEdVZ2RHaGxJR2RsZEhSbGNpd2dZVzVrSUhKbExXTnZiR3hsWTNRZ1pHVndaVzVrWlc1amFXVnpMbHh1SUNvdlhHNVhZWFJqYUdWeUxuQnliM1J2ZEhsd1pTNW5aWFFnUFNCbWRXNWpkR2x2YmlCblpYUWdLQ2tnZTF4dUlDQndkWE5vVkdGeVoyVjBLSFJvYVhNcE8xeHVJQ0IyWVhJZ2RtRnNkV1U3WEc0Z0lIWmhjaUIyYlNBOUlIUm9hWE11ZG0wN1hHNGdJR2xtSUNoMGFHbHpMblZ6WlhJcElIdGNiaUFnSUNCMGNua2dlMXh1SUNBZ0lDQWdkbUZzZFdVZ1BTQjBhR2x6TG1kbGRIUmxjaTVqWVd4c0tIWnRMQ0IyYlNrN1hHNGdJQ0FnZlNCallYUmphQ0FvWlNrZ2UxeHVJQ0FnSUNBZ2FHRnVaR3hsUlhKeWIzSW9aU3dnZG0wc0lDaGNJbWRsZEhSbGNpQm1iM0lnZDJGMFkyaGxjaUJjWEZ3aVhDSWdLeUFvZEdocGN5NWxlSEJ5WlhOemFXOXVLU0FySUZ3aVhGeGNJbHdpS1NrN1hHNGdJQ0FnZlZ4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUhaaGJIVmxJRDBnZEdocGN5NW5aWFIwWlhJdVkyRnNiQ2gyYlN3Z2RtMHBPMXh1SUNCOVhHNGdJQzh2SUZ3aWRHOTFZMmhjSWlCbGRtVnllU0J3Y205d1pYSjBlU0J6YnlCMGFHVjVJR0Z5WlNCaGJHd2dkSEpoWTJ0bFpDQmhjMXh1SUNBdkx5QmtaWEJsYm1SbGJtTnBaWE1nWm05eUlHUmxaWEFnZDJGMFkyaHBibWRjYmlBZ2FXWWdLSFJvYVhNdVpHVmxjQ2tnZTF4dUlDQWdJSFJ5WVhabGNuTmxLSFpoYkhWbEtUdGNiaUFnZlZ4dUlDQndiM0JVWVhKblpYUW9LVHRjYmlBZ2RHaHBjeTVqYkdWaGJuVndSR1Z3Y3lncE8xeHVJQ0J5WlhSMWNtNGdkbUZzZFdWY2JuMDdYRzVjYmk4cUtseHVJQ29nUVdSa0lHRWdaR1Z3Wlc1a1pXNWplU0IwYnlCMGFHbHpJR1JwY21WamRHbDJaUzVjYmlBcUwxeHVWMkYwWTJobGNpNXdjbTkwYjNSNWNHVXVZV1JrUkdWd0lEMGdablZ1WTNScGIyNGdZV1JrUkdWd0lDaGtaWEFwSUh0Y2JpQWdkbUZ5SUdsa0lEMGdaR1Z3TG1sa08xeHVJQ0JwWmlBb0lYUm9hWE11Ym1WM1JHVndTV1J6TG1oaGN5aHBaQ2twSUh0Y2JpQWdJQ0IwYUdsekxtNWxkMFJsY0Vsa2N5NWhaR1FvYVdRcE8xeHVJQ0FnSUhSb2FYTXVibVYzUkdWd2N5NXdkWE5vS0dSbGNDazdYRzRnSUNBZ2FXWWdLQ0YwYUdsekxtUmxjRWxrY3k1b1lYTW9hV1FwS1NCN1hHNGdJQ0FnSUNCa1pYQXVZV1JrVTNWaUtIUm9hWE1wTzF4dUlDQWdJSDFjYmlBZ2ZWeHVmVHRjYmx4dUx5b3FYRzRnS2lCRGJHVmhiaUIxY0NCbWIzSWdaR1Z3Wlc1a1pXNWplU0JqYjJ4c1pXTjBhVzl1TGx4dUlDb3ZYRzVYWVhSamFHVnlMbkJ5YjNSdmRIbHdaUzVqYkdWaGJuVndSR1Z3Y3lBOUlHWjFibU4wYVc5dUlHTnNaV0Z1ZFhCRVpYQnpJQ2dwSUh0Y2JpQWdJQ0IyWVhJZ2RHaHBjeVF4SUQwZ2RHaHBjenRjYmx4dUlDQjJZWElnYVNBOUlIUm9hWE11WkdWd2N5NXNaVzVuZEdnN1hHNGdJSGRvYVd4bElDaHBMUzBwSUh0Y2JpQWdJQ0IyWVhJZ1pHVndJRDBnZEdocGN5UXhMbVJsY0hOYmFWMDdYRzRnSUNBZ2FXWWdLQ0YwYUdsekpERXVibVYzUkdWd1NXUnpMbWhoY3loa1pYQXVhV1FwS1NCN1hHNGdJQ0FnSUNCa1pYQXVjbVZ0YjNabFUzVmlLSFJvYVhNa01TazdYRzRnSUNBZ2ZWeHVJQ0I5WEc0Z0lIWmhjaUIwYlhBZ1BTQjBhR2x6TG1SbGNFbGtjenRjYmlBZ2RHaHBjeTVrWlhCSlpITWdQU0IwYUdsekxtNWxkMFJsY0Vsa2N6dGNiaUFnZEdocGN5NXVaWGRFWlhCSlpITWdQU0IwYlhBN1hHNGdJSFJvYVhNdWJtVjNSR1Z3U1dSekxtTnNaV0Z5S0NrN1hHNGdJSFJ0Y0NBOUlIUm9hWE11WkdWd2N6dGNiaUFnZEdocGN5NWtaWEJ6SUQwZ2RHaHBjeTV1WlhkRVpYQnpPMXh1SUNCMGFHbHpMbTVsZDBSbGNITWdQU0IwYlhBN1hHNGdJSFJvYVhNdWJtVjNSR1Z3Y3k1c1pXNW5kR2dnUFNBd08xeHVmVHRjYmx4dUx5b3FYRzRnS2lCVGRXSnpZM0pwWW1WeUlHbHVkR1Z5Wm1GalpTNWNiaUFxSUZkcGJHd2dZbVVnWTJGc2JHVmtJSGRvWlc0Z1lTQmtaWEJsYm1SbGJtTjVJR05vWVc1blpYTXVYRzRnS2k5Y2JsZGhkR05vWlhJdWNISnZkRzkwZVhCbExuVndaR0YwWlNBOUlHWjFibU4wYVc5dUlIVndaR0YwWlNBb0tTQjdYRzRnSUM4cUlHbHpkR0Z1WW5Wc0lHbG5ibTl5WlNCbGJITmxJQ292WEc0Z0lHbG1JQ2gwYUdsekxteGhlbmtwSUh0Y2JpQWdJQ0IwYUdsekxtUnBjblI1SUQwZ2RISjFaVHRjYmlBZ2ZTQmxiSE5sSUdsbUlDaDBhR2x6TG5ONWJtTXBJSHRjYmlBZ0lDQjBhR2x6TG5KMWJpZ3BPMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJSEYxWlhWbFYyRjBZMmhsY2loMGFHbHpLVHRjYmlBZ2ZWeHVmVHRjYmx4dUx5b3FYRzRnS2lCVFkyaGxaSFZzWlhJZ2FtOWlJR2x1ZEdWeVptRmpaUzVjYmlBcUlGZHBiR3dnWW1VZ1kyRnNiR1ZrSUdKNUlIUm9aU0J6WTJobFpIVnNaWEl1WEc0Z0tpOWNibGRoZEdOb1pYSXVjSEp2ZEc5MGVYQmxMbkoxYmlBOUlHWjFibU4wYVc5dUlISjFiaUFvS1NCN1hHNGdJR2xtSUNoMGFHbHpMbUZqZEdsMlpTa2dlMXh1SUNBZ0lIWmhjaUIyWVd4MVpTQTlJSFJvYVhNdVoyVjBLQ2s3WEc0Z0lDQWdhV1lnS0Z4dUlDQWdJQ0FnZG1Gc2RXVWdJVDA5SUhSb2FYTXVkbUZzZFdVZ2ZIeGNiaUFnSUNBZ0lDOHZJRVJsWlhBZ2QyRjBZMmhsY25NZ1lXNWtJSGRoZEdOb1pYSnpJRzl1SUU5aWFtVmpkQzlCY25KaGVYTWdjMmh2ZFd4a0lHWnBjbVVnWlhabGJseHVJQ0FnSUNBZ0x5OGdkMmhsYmlCMGFHVWdkbUZzZFdVZ2FYTWdkR2hsSUhOaGJXVXNJR0psWTJGMWMyVWdkR2hsSUhaaGJIVmxJRzFoZVZ4dUlDQWdJQ0FnTHk4Z2FHRjJaU0J0ZFhSaGRHVmtMbHh1SUNBZ0lDQWdhWE5QWW1wbFkzUW9kbUZzZFdVcElIeDhYRzRnSUNBZ0lDQjBhR2x6TG1SbFpYQmNiaUFnSUNBcElIdGNiaUFnSUNBZ0lDOHZJSE5sZENCdVpYY2dkbUZzZFdWY2JpQWdJQ0FnSUhaaGNpQnZiR1JXWVd4MVpTQTlJSFJvYVhNdWRtRnNkV1U3WEc0Z0lDQWdJQ0IwYUdsekxuWmhiSFZsSUQwZ2RtRnNkV1U3WEc0Z0lDQWdJQ0JwWmlBb2RHaHBjeTUxYzJWeUtTQjdYRzRnSUNBZ0lDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNBZ0lDQWdkR2hwY3k1allpNWpZV3hzS0hSb2FYTXVkbTBzSUhaaGJIVmxMQ0J2YkdSV1lXeDFaU2s3WEc0Z0lDQWdJQ0FnSUgwZ1kyRjBZMmdnS0dVcElIdGNiaUFnSUNBZ0lDQWdJQ0JvWVc1a2JHVkZjbkp2Y2lobExDQjBhR2x6TG5adExDQW9YQ0pqWVd4c1ltRmpheUJtYjNJZ2QyRjBZMmhsY2lCY1hGd2lYQ0lnS3lBb2RHaHBjeTVsZUhCeVpYTnphVzl1S1NBcklGd2lYRnhjSWx3aUtTazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdVkySXVZMkZzYkNoMGFHbHpMblp0TENCMllXeDFaU3dnYjJ4a1ZtRnNkV1VwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ2ZWeHVmVHRjYmx4dUx5b3FYRzRnS2lCRmRtRnNkV0YwWlNCMGFHVWdkbUZzZFdVZ2IyWWdkR2hsSUhkaGRHTm9aWEl1WEc0Z0tpQlVhR2x6SUc5dWJIa2daMlYwY3lCallXeHNaV1FnWm05eUlHeGhlbmtnZDJGMFkyaGxjbk11WEc0Z0tpOWNibGRoZEdOb1pYSXVjSEp2ZEc5MGVYQmxMbVYyWVd4MVlYUmxJRDBnWm5WdVkzUnBiMjRnWlhaaGJIVmhkR1VnS0NrZ2UxeHVJQ0IwYUdsekxuWmhiSFZsSUQwZ2RHaHBjeTVuWlhRb0tUdGNiaUFnZEdocGN5NWthWEowZVNBOUlHWmhiSE5sTzF4dWZUdGNibHh1THlvcVhHNGdLaUJFWlhCbGJtUWdiMjRnWVd4c0lHUmxjSE1nWTI5c2JHVmpkR1ZrSUdKNUlIUm9hWE1nZDJGMFkyaGxjaTVjYmlBcUwxeHVWMkYwWTJobGNpNXdjbTkwYjNSNWNHVXVaR1Z3Wlc1a0lEMGdablZ1WTNScGIyNGdaR1Z3Wlc1a0lDZ3BJSHRjYmlBZ0lDQjJZWElnZEdocGN5UXhJRDBnZEdocGN6dGNibHh1SUNCMllYSWdhU0E5SUhSb2FYTXVaR1Z3Y3k1c1pXNW5kR2c3WEc0Z0lIZG9hV3hsSUNocExTMHBJSHRjYmlBZ0lDQjBhR2x6SkRFdVpHVndjMXRwWFM1a1pYQmxibVFvS1R0Y2JpQWdmVnh1ZlR0Y2JseHVMeW9xWEc0Z0tpQlNaVzF2ZG1VZ2MyVnNaaUJtY205dElHRnNiQ0JrWlhCbGJtUmxibU5wWlhNbklITjFZbk5qY21saVpYSWdiR2x6ZEM1Y2JpQXFMMXh1VjJGMFkyaGxjaTV3Y205MGIzUjVjR1V1ZEdWaGNtUnZkMjRnUFNCbWRXNWpkR2x2YmlCMFpXRnlaRzkzYmlBb0tTQjdYRzRnSUNBZ2RtRnlJSFJvYVhNa01TQTlJSFJvYVhNN1hHNWNiaUFnYVdZZ0tIUm9hWE11WVdOMGFYWmxLU0I3WEc0Z0lDQWdMeThnY21WdGIzWmxJSE5sYkdZZ1puSnZiU0IyYlNkeklIZGhkR05vWlhJZ2JHbHpkRnh1SUNBZ0lDOHZJSFJvYVhNZ2FYTWdZU0J6YjIxbGQyaGhkQ0JsZUhCbGJuTnBkbVVnYjNCbGNtRjBhVzl1SUhOdklIZGxJSE5yYVhBZ2FYUmNiaUFnSUNBdkx5QnBaaUIwYUdVZ2RtMGdhWE1nWW1WcGJtY2daR1Z6ZEhKdmVXVmtMbHh1SUNBZ0lHbG1JQ2doZEdocGN5NTJiUzVmYVhOQ1pXbHVaMFJsYzNSeWIzbGxaQ2tnZTF4dUlDQWdJQ0FnY21WdGIzWmxLSFJvYVhNdWRtMHVYM2RoZEdOb1pYSnpMQ0IwYUdsektUdGNiaUFnSUNCOVhHNGdJQ0FnZG1GeUlHa2dQU0IwYUdsekxtUmxjSE11YkdWdVozUm9PMXh1SUNBZ0lIZG9hV3hsSUNocExTMHBJSHRjYmlBZ0lDQWdJSFJvYVhNa01TNWtaWEJ6VzJsZExuSmxiVzkyWlZOMVlpaDBhR2x6SkRFcE8xeHVJQ0FnSUgxY2JpQWdJQ0IwYUdsekxtRmpkR2wyWlNBOUlHWmhiSE5sTzF4dUlDQjlYRzU5TzF4dVhHNHZLaXBjYmlBcUlGSmxZM1Z5YzJsMlpXeDVJSFJ5WVhabGNuTmxJR0Z1SUc5aWFtVmpkQ0IwYnlCbGRtOXJaU0JoYkd3Z1kyOXVkbVZ5ZEdWa1hHNGdLaUJuWlhSMFpYSnpMQ0J6YnlCMGFHRjBJR1YyWlhKNUlHNWxjM1JsWkNCd2NtOXdaWEowZVNCcGJuTnBaR1VnZEdobElHOWlhbVZqZEZ4dUlDb2dhWE1nWTI5c2JHVmpkR1ZrSUdGeklHRWdYQ0prWldWd1hDSWdaR1Z3Wlc1a1pXNWplUzVjYmlBcUwxeHVkbUZ5SUhObFpXNVBZbXBsWTNSeklEMGdibVYzSUY5VFpYUW9LVHRjYm1aMWJtTjBhVzl1SUhSeVlYWmxjbk5sSUNoMllXd3BJSHRjYmlBZ2MyVmxiazlpYW1WamRITXVZMnhsWVhJb0tUdGNiaUFnWDNSeVlYWmxjbk5sS0haaGJDd2djMlZsYms5aWFtVmpkSE1wTzF4dWZWeHVYRzVtZFc1amRHbHZiaUJmZEhKaGRtVnljMlVnS0haaGJDd2djMlZsYmlrZ2UxeHVJQ0IyWVhJZ2FTd2dhMlY1Y3p0Y2JpQWdkbUZ5SUdselFTQTlJRUZ5Y21GNUxtbHpRWEp5WVhrb2RtRnNLVHRjYmlBZ2FXWWdLQ2doYVhOQklDWW1JQ0ZwYzA5aWFtVmpkQ2gyWVd3cEtTQjhmQ0FoVDJKcVpXTjBMbWx6UlhoMFpXNXphV0pzWlNoMllXd3BLU0I3WEc0Z0lDQWdjbVYwZFhKdVhHNGdJSDFjYmlBZ2FXWWdLSFpoYkM1ZlgyOWlYMThwSUh0Y2JpQWdJQ0IyWVhJZ1pHVndTV1FnUFNCMllXd3VYMTl2WWw5ZkxtUmxjQzVwWkR0Y2JpQWdJQ0JwWmlBb2MyVmxiaTVvWVhNb1pHVndTV1FwS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTVjYmlBZ0lDQjlYRzRnSUNBZ2MyVmxiaTVoWkdRb1pHVndTV1FwTzF4dUlDQjlYRzRnSUdsbUlDaHBjMEVwSUh0Y2JpQWdJQ0JwSUQwZ2RtRnNMbXhsYm1kMGFEdGNiaUFnSUNCM2FHbHNaU0FvYVMwdEtTQjdJRjkwY21GMlpYSnpaU2gyWVd4YmFWMHNJSE5sWlc0cE95QjlYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdhMlY1Y3lBOUlFOWlhbVZqZEM1clpYbHpLSFpoYkNrN1hHNGdJQ0FnYVNBOUlHdGxlWE11YkdWdVozUm9PMXh1SUNBZ0lIZG9hV3hsSUNocExTMHBJSHNnWDNSeVlYWmxjbk5sS0haaGJGdHJaWGx6VzJsZFhTd2djMlZsYmlrN0lIMWNiaUFnZlZ4dWZWeHVYRzR2S2lBZ0tpOWNibHh1ZG1GeUlITm9ZWEpsWkZCeWIzQmxjblI1UkdWbWFXNXBkR2x2YmlBOUlIdGNiaUFnWlc1MWJXVnlZV0pzWlRvZ2RISjFaU3hjYmlBZ1kyOXVabWxuZFhKaFlteGxPaUIwY25WbExGeHVJQ0JuWlhRNklHNXZiM0FzWEc0Z0lITmxkRG9nYm05dmNGeHVmVHRjYmx4dVpuVnVZM1JwYjI0Z2NISnZlSGtnS0hSaGNtZGxkQ3dnYzI5MWNtTmxTMlY1TENCclpYa3BJSHRjYmlBZ2MyaGhjbVZrVUhKdmNHVnlkSGxFWldacGJtbDBhVzl1TG1kbGRDQTlJR1oxYm1OMGFXOXVJSEJ5YjNoNVIyVjBkR1Z5SUNncElIdGNiaUFnSUNCeVpYUjFjbTRnZEdocGMxdHpiM1Z5WTJWTFpYbGRXMnRsZVYxY2JpQWdmVHRjYmlBZ2MyaGhjbVZrVUhKdmNHVnlkSGxFWldacGJtbDBhVzl1TG5ObGRDQTlJR1oxYm1OMGFXOXVJSEJ5YjNoNVUyVjBkR1Z5SUNoMllXd3BJSHRjYmlBZ0lDQjBhR2x6VzNOdmRYSmpaVXRsZVYxYmEyVjVYU0E5SUhaaGJEdGNiaUFnZlR0Y2JpQWdUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblI1S0hSaGNtZGxkQ3dnYTJWNUxDQnphR0Z5WldSUWNtOXdaWEowZVVSbFptbHVhWFJwYjI0cE8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCcGJtbDBVM1JoZEdVZ0tIWnRLU0I3WEc0Z0lIWnRMbDkzWVhSamFHVnljeUE5SUZ0ZE8xeHVJQ0IyWVhJZ2IzQjBjeUE5SUhadExpUnZjSFJwYjI1ek8xeHVJQ0JwWmlBb2IzQjBjeTV3Y205d2N5a2dleUJwYm1sMFVISnZjSE1vZG0wc0lHOXdkSE11Y0hKdmNITXBPeUI5WEc0Z0lHbG1JQ2h2Y0hSekxtMWxkR2h2WkhNcElIc2dhVzVwZEUxbGRHaHZaSE1vZG0wc0lHOXdkSE11YldWMGFHOWtjeWs3SUgxY2JpQWdhV1lnS0c5d2RITXVaR0YwWVNrZ2UxeHVJQ0FnSUdsdWFYUkVZWFJoS0hadEtUdGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQnZZbk5sY25abEtIWnRMbDlrWVhSaElEMGdlMzBzSUhSeWRXVWdMeW9nWVhOU2IyOTBSR0YwWVNBcUx5azdYRzRnSUgxY2JpQWdhV1lnS0c5d2RITXVZMjl0Y0hWMFpXUXBJSHNnYVc1cGRFTnZiWEIxZEdWa0tIWnRMQ0J2Y0hSekxtTnZiWEIxZEdWa0tUc2dmVnh1SUNCcFppQW9iM0IwY3k1M1lYUmphQ2tnZXlCcGJtbDBWMkYwWTJnb2RtMHNJRzl3ZEhNdWQyRjBZMmdwT3lCOVhHNTlYRzVjYm5aaGNpQnBjMUpsYzJWeWRtVmtVSEp2Y0NBOUlIc2dhMlY1T2lBeExDQnlaV1k2SURFc0lITnNiM1E2SURFZ2ZUdGNibHh1Wm5WdVkzUnBiMjRnYVc1cGRGQnliM0J6SUNoMmJTd2djSEp2Y0hOUGNIUnBiMjV6S1NCN1hHNGdJSFpoY2lCd2NtOXdjMFJoZEdFZ1BTQjJiUzRrYjNCMGFXOXVjeTV3Y205d2MwUmhkR0VnZkh3Z2UzMDdYRzRnSUhaaGNpQndjbTl3Y3lBOUlIWnRMbDl3Y205d2N5QTlJSHQ5TzF4dUlDQXZMeUJqWVdOb1pTQndjbTl3SUd0bGVYTWdjMjhnZEdoaGRDQm1kWFIxY21VZ2NISnZjSE1nZFhCa1lYUmxjeUJqWVc0Z2FYUmxjbUYwWlNCMWMybHVaeUJCY25KaGVWeHVJQ0F2THlCcGJuTjBaV0ZrSUc5bUlHUjVibUZ0YVdNZ2IySnFaV04wSUd0bGVTQmxiblZ0WlhKaGRHbHZiaTVjYmlBZ2RtRnlJR3RsZVhNZ1BTQjJiUzRrYjNCMGFXOXVjeTVmY0hKdmNFdGxlWE1nUFNCYlhUdGNiaUFnZG1GeUlHbHpVbTl2ZENBOUlDRjJiUzRrY0dGeVpXNTBPMXh1SUNBdkx5QnliMjkwSUdsdWMzUmhibU5sSUhCeWIzQnpJSE5vYjNWc1pDQmlaU0JqYjI1MlpYSjBaV1JjYmlBZ2IySnpaWEoyWlhKVGRHRjBaUzV6YUc5MWJHUkRiMjUyWlhKMElEMGdhWE5TYjI5ME8xeHVJQ0IyWVhJZ2JHOXZjQ0E5SUdaMWJtTjBhVzl1SUNnZ2EyVjVJQ2tnZTF4dUlDQWdJR3RsZVhNdWNIVnphQ2hyWlhrcE8xeHVJQ0FnSUhaaGNpQjJZV3gxWlNBOUlIWmhiR2xrWVhSbFVISnZjQ2hyWlhrc0lIQnliM0J6VDNCMGFXOXVjeXdnY0hKdmNITkVZWFJoTENCMmJTazdYRzRnSUNBZ0x5b2dhWE4wWVc1aWRXd2dhV2R1YjNKbElHVnNjMlVnS2k5Y2JpQWdJQ0JwWmlBb2NISnZZMlZ6Y3k1bGJuWXVUazlFUlY5RlRsWWdJVDA5SUNkd2NtOWtkV04wYVc5dUp5a2dlMXh1SUNBZ0lDQWdhV1lnS0dselVtVnpaWEoyWldSUWNtOXdXMnRsZVYwcElIdGNiaUFnSUNBZ0lDQWdkMkZ5YmloY2JpQWdJQ0FnSUNBZ0lDQW9YQ0pjWEZ3aVhDSWdLeUJyWlhrZ0t5QmNJbHhjWENJZ2FYTWdZU0J5WlhObGNuWmxaQ0JoZEhSeWFXSjFkR1VnWVc1a0lHTmhibTV2ZENCaVpTQjFjMlZrSUdGeklHTnZiWEJ2Ym1WdWRDQndjbTl3TGx3aUtTeGNiaUFnSUNBZ0lDQWdJQ0IyYlZ4dUlDQWdJQ0FnSUNBcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ1pHVm1hVzVsVW1WaFkzUnBkbVVrSkRFb2NISnZjSE1zSUd0bGVTd2dkbUZzZFdVc0lHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ0lDQWdJQ0FnYVdZZ0tIWnRMaVJ3WVhKbGJuUWdKaVlnSVc5aWMyVnlkbVZ5VTNSaGRHVXVhWE5UWlhSMGFXNW5VSEp2Y0hNcElIdGNiaUFnSUNBZ0lDQWdJQ0IzWVhKdUtGeHVJQ0FnSUNBZ0lDQWdJQ0FnWENKQmRtOXBaQ0J0ZFhSaGRHbHVaeUJoSUhCeWIzQWdaR2x5WldOMGJIa2djMmx1WTJVZ2RHaGxJSFpoYkhWbElIZHBiR3dnWW1VZ1hDSWdLMXh1SUNBZ0lDQWdJQ0FnSUNBZ1hDSnZkbVZ5ZDNKcGRIUmxiaUIzYUdWdVpYWmxjaUIwYUdVZ2NHRnlaVzUwSUdOdmJYQnZibVZ1ZENCeVpTMXlaVzVrWlhKekxpQmNJaUFyWEc0Z0lDQWdJQ0FnSUNBZ0lDQmNJa2x1YzNSbFlXUXNJSFZ6WlNCaElHUmhkR0VnYjNJZ1kyOXRjSFYwWldRZ2NISnZjR1Z5ZEhrZ1ltRnpaV1FnYjI0Z2RHaGxJSEJ5YjNBbmN5QmNJaUFyWEc0Z0lDQWdJQ0FnSUNBZ0lDQmNJblpoYkhWbExpQlFjbTl3SUdKbGFXNW5JRzExZEdGMFpXUTZJRnhjWENKY0lpQXJJR3RsZVNBcklGd2lYRnhjSWx3aUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnZG0xY2JpQWdJQ0FnSUNBZ0lDQXBPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5S1R0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdaR1ZtYVc1bFVtVmhZM1JwZG1Va0pERW9jSEp2Y0hNc0lHdGxlU3dnZG1Gc2RXVXBPMXh1SUNBZ0lIMWNiaUFnSUNBdkx5QnpkR0YwYVdNZ2NISnZjSE1nWVhKbElHRnNjbVZoWkhrZ2NISnZlR2xsWkNCdmJpQjBhR1VnWTI5dGNHOXVaVzUwSjNNZ2NISnZkRzkwZVhCbFhHNGdJQ0FnTHk4Z1pIVnlhVzVuSUZaMVpTNWxlSFJsYm1Rb0tTNGdWMlVnYjI1c2VTQnVaV1ZrSUhSdklIQnliM2g1SUhCeWIzQnpJR1JsWm1sdVpXUWdZWFJjYmlBZ0lDQXZMeUJwYm5OMFlXNTBhV0YwYVc5dUlHaGxjbVV1WEc0Z0lDQWdhV1lnS0NFb2EyVjVJR2x1SUhadEtTa2dlMXh1SUNBZ0lDQWdjSEp2ZUhrb2RtMHNJRndpWDNCeWIzQnpYQ0lzSUd0bGVTazdYRzRnSUNBZ2ZWeHVJQ0I5TzF4dVhHNGdJR1p2Y2lBb2RtRnlJR3RsZVNCcGJpQndjbTl3YzA5d2RHbHZibk1wSUd4dmIzQW9JR3RsZVNBcE8xeHVJQ0J2WW5ObGNuWmxjbE4wWVhSbExuTm9iM1ZzWkVOdmJuWmxjblFnUFNCMGNuVmxPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQnBibWwwUkdGMFlTQW9kbTBwSUh0Y2JpQWdkbUZ5SUdSaGRHRWdQU0IyYlM0a2IzQjBhVzl1Y3k1a1lYUmhPMXh1SUNCa1lYUmhJRDBnZG0wdVgyUmhkR0VnUFNCMGVYQmxiMllnWkdGMFlTQTlQVDBnSjJaMWJtTjBhVzl1SjF4dUlDQWdJRDhnWjJWMFJHRjBZU2hrWVhSaExDQjJiU2xjYmlBZ0lDQTZJR1JoZEdFZ2ZId2dlMzA3WEc0Z0lHbG1JQ2doYVhOUWJHRnBiazlpYW1WamRDaGtZWFJoS1NrZ2UxeHVJQ0FnSUdSaGRHRWdQU0I3ZlR0Y2JpQWdJQ0J3Y205alpYTnpMbVZ1ZGk1T1QwUkZYMFZPVmlBaFBUMGdKM0J5YjJSMVkzUnBiMjRuSUNZbUlIZGhjbTRvWEc0Z0lDQWdJQ0FuWkdGMFlTQm1kVzVqZEdsdmJuTWdjMmh2ZFd4a0lISmxkSFZ5YmlCaGJpQnZZbXBsWTNRNlhGeHVKeUFyWEc0Z0lDQWdJQ0FuYUhSMGNITTZMeTkyZFdWcWN5NXZjbWN2ZGpJdlozVnBaR1V2WTI5dGNHOXVaVzUwY3k1b2RHMXNJMlJoZEdFdFRYVnpkQzFDWlMxaExVWjFibU4wYVc5dUp5eGNiaUFnSUNBZ0lIWnRYRzRnSUNBZ0tUdGNiaUFnZlZ4dUlDQXZMeUJ3Y205NGVTQmtZWFJoSUc5dUlHbHVjM1JoYm1ObFhHNGdJSFpoY2lCclpYbHpJRDBnVDJKcVpXTjBMbXRsZVhNb1pHRjBZU2s3WEc0Z0lIWmhjaUJ3Y205d2N5QTlJSFp0TGlSdmNIUnBiMjV6TG5CeWIzQnpPMXh1SUNCMllYSWdhU0E5SUd0bGVYTXViR1Z1WjNSb08xeHVJQ0IzYUdsc1pTQW9hUzB0S1NCN1hHNGdJQ0FnYVdZZ0tIQnliM0J6SUNZbUlHaGhjMDkzYmlod2NtOXdjeXdnYTJWNWMxdHBYU2twSUh0Y2JpQWdJQ0FnSUhCeWIyTmxjM011Wlc1MkxrNVBSRVZmUlU1V0lDRTlQU0FuY0hKdlpIVmpkR2x2YmljZ0ppWWdkMkZ5YmloY2JpQWdJQ0FnSUNBZ1hDSlVhR1VnWkdGMFlTQndjbTl3WlhKMGVTQmNYRndpWENJZ0t5QW9hMlY1YzF0cFhTa2dLeUJjSWx4Y1hDSWdhWE1nWVd4eVpXRmtlU0JrWldOc1lYSmxaQ0JoY3lCaElIQnliM0F1SUZ3aUlDdGNiaUFnSUNBZ0lDQWdYQ0pWYzJVZ2NISnZjQ0JrWldaaGRXeDBJSFpoYkhWbElHbHVjM1JsWVdRdVhDSXNYRzRnSUNBZ0lDQWdJSFp0WEc0Z0lDQWdJQ0FwTzF4dUlDQWdJSDBnWld4elpTQnBaaUFvSVdselVtVnpaWEoyWldRb2EyVjVjMXRwWFNrcElIdGNiaUFnSUNBZ0lIQnliM2g1S0hadExDQmNJbDlrWVhSaFhDSXNJR3RsZVhOYmFWMHBPMXh1SUNBZ0lIMWNiaUFnZlZ4dUlDQXZMeUJ2WW5ObGNuWmxJR1JoZEdGY2JpQWdiMkp6WlhKMlpTaGtZWFJoTENCMGNuVmxJQzhxSUdGelVtOXZkRVJoZEdFZ0tpOHBPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQm5aWFJFWVhSaElDaGtZWFJoTENCMmJTa2dlMXh1SUNCMGNua2dlMXh1SUNBZ0lISmxkSFZ5YmlCa1lYUmhMbU5oYkd3b2RtMHBYRzRnSUgwZ1kyRjBZMmdnS0dVcElIdGNiaUFnSUNCb1lXNWtiR1ZGY25KdmNpaGxMQ0IyYlN3Z1hDSmtZWFJoS0NsY0lpazdYRzRnSUNBZ2NtVjBkWEp1SUh0OVhHNGdJSDFjYm4xY2JseHVkbUZ5SUdOdmJYQjFkR1ZrVjJGMFkyaGxjazl3ZEdsdmJuTWdQU0I3SUd4aGVuazZJSFJ5ZFdVZ2ZUdGNibHh1Wm5WdVkzUnBiMjRnYVc1cGRFTnZiWEIxZEdWa0lDaDJiU3dnWTI5dGNIVjBaV1FwSUh0Y2JpQWdkbUZ5SUhkaGRHTm9aWEp6SUQwZ2RtMHVYMk52YlhCMWRHVmtWMkYwWTJobGNuTWdQU0JQWW1wbFkzUXVZM0psWVhSbEtHNTFiR3dwTzF4dVhHNGdJR1p2Y2lBb2RtRnlJR3RsZVNCcGJpQmpiMjF3ZFhSbFpDa2dlMXh1SUNBZ0lIWmhjaUIxYzJWeVJHVm1JRDBnWTI5dGNIVjBaV1JiYTJWNVhUdGNiaUFnSUNCMllYSWdaMlYwZEdWeUlEMGdkSGx3Wlc5bUlIVnpaWEpFWldZZ1BUMDlJQ2RtZFc1amRHbHZiaWNnUHlCMWMyVnlSR1ZtSURvZ2RYTmxja1JsWmk1blpYUTdYRzRnSUNBZ2FXWWdLSEJ5YjJObGMzTXVaVzUyTGs1UFJFVmZSVTVXSUNFOVBTQW5jSEp2WkhWamRHbHZiaWNwSUh0Y2JpQWdJQ0FnSUdsbUlDaG5aWFIwWlhJZ1BUMDlJSFZ1WkdWbWFXNWxaQ2tnZTF4dUlDQWdJQ0FnSUNCM1lYSnVLRnh1SUNBZ0lDQWdJQ0FnSUNoY0lrNXZJR2RsZEhSbGNpQm1kVzVqZEdsdmJpQm9ZWE1nWW1WbGJpQmtaV1pwYm1Wa0lHWnZjaUJqYjIxd2RYUmxaQ0J3Y205d1pYSjBlU0JjWEZ3aVhDSWdLeUJyWlhrZ0t5QmNJbHhjWENJdVhDSXBMRnh1SUNBZ0lDQWdJQ0FnSUhadFhHNGdJQ0FnSUNBZ0lDazdYRzRnSUNBZ0lDQWdJR2RsZEhSbGNpQTlJRzV2YjNBN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dUlDQWdJQzh2SUdOeVpXRjBaU0JwYm5SbGNtNWhiQ0IzWVhSamFHVnlJR1p2Y2lCMGFHVWdZMjl0Y0hWMFpXUWdjSEp2Y0dWeWRIa3VYRzRnSUNBZ2QyRjBZMmhsY25OYmEyVjVYU0E5SUc1bGR5QlhZWFJqYUdWeUtIWnRMQ0JuWlhSMFpYSXNJRzV2YjNBc0lHTnZiWEIxZEdWa1YyRjBZMmhsY2s5d2RHbHZibk1wTzF4dVhHNGdJQ0FnTHk4Z1kyOXRjRzl1Wlc1MExXUmxabWx1WldRZ1kyOXRjSFYwWldRZ2NISnZjR1Z5ZEdsbGN5QmhjbVVnWVd4eVpXRmtlU0JrWldacGJtVmtJRzl1SUhSb1pWeHVJQ0FnSUM4dklHTnZiWEJ2Ym1WdWRDQndjbTkwYjNSNWNHVXVJRmRsSUc5dWJIa2dibVZsWkNCMGJ5QmtaV1pwYm1VZ1kyOXRjSFYwWldRZ2NISnZjR1Z5ZEdsbGN5QmtaV1pwYm1Wa1hHNGdJQ0FnTHk4Z1lYUWdhVzV6ZEdGdWRHbGhkR2x2YmlCb1pYSmxMbHh1SUNBZ0lHbG1JQ2doS0d0bGVTQnBiaUIyYlNrcElIdGNiaUFnSUNBZ0lHUmxabWx1WlVOdmJYQjFkR1ZrS0hadExDQnJaWGtzSUhWelpYSkVaV1lwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVmVnh1WEc1bWRXNWpkR2x2YmlCa1pXWnBibVZEYjIxd2RYUmxaQ0FvZEdGeVoyVjBMQ0JyWlhrc0lIVnpaWEpFWldZcElIdGNiaUFnYVdZZ0tIUjVjR1Z2WmlCMWMyVnlSR1ZtSUQwOVBTQW5ablZ1WTNScGIyNG5LU0I3WEc0Z0lDQWdjMmhoY21Wa1VISnZjR1Z5ZEhsRVpXWnBibWwwYVc5dUxtZGxkQ0E5SUdOeVpXRjBaVU52YlhCMWRHVmtSMlYwZEdWeUtHdGxlU2s3WEc0Z0lDQWdjMmhoY21Wa1VISnZjR1Z5ZEhsRVpXWnBibWwwYVc5dUxuTmxkQ0E5SUc1dmIzQTdYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdjMmhoY21Wa1VISnZjR1Z5ZEhsRVpXWnBibWwwYVc5dUxtZGxkQ0E5SUhWelpYSkVaV1l1WjJWMFhHNGdJQ0FnSUNBL0lIVnpaWEpFWldZdVkyRmphR1VnSVQwOUlHWmhiSE5sWEc0Z0lDQWdJQ0FnSUQ4Z1kzSmxZWFJsUTI5dGNIVjBaV1JIWlhSMFpYSW9hMlY1S1Z4dUlDQWdJQ0FnSUNBNklIVnpaWEpFWldZdVoyVjBYRzRnSUNBZ0lDQTZJRzV2YjNBN1hHNGdJQ0FnYzJoaGNtVmtVSEp2Y0dWeWRIbEVaV1pwYm1sMGFXOXVMbk5sZENBOUlIVnpaWEpFWldZdWMyVjBYRzRnSUNBZ0lDQS9JSFZ6WlhKRVpXWXVjMlYwWEc0Z0lDQWdJQ0E2SUc1dmIzQTdYRzRnSUgxY2JpQWdUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblI1S0hSaGNtZGxkQ3dnYTJWNUxDQnphR0Z5WldSUWNtOXdaWEowZVVSbFptbHVhWFJwYjI0cE8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCamNtVmhkR1ZEYjIxd2RYUmxaRWRsZEhSbGNpQW9hMlY1S1NCN1hHNGdJSEpsZEhWeWJpQm1kVzVqZEdsdmJpQmpiMjF3ZFhSbFpFZGxkSFJsY2lBb0tTQjdYRzRnSUNBZ2RtRnlJSGRoZEdOb1pYSWdQU0IwYUdsekxsOWpiMjF3ZFhSbFpGZGhkR05vWlhKeklDWW1JSFJvYVhNdVgyTnZiWEIxZEdWa1YyRjBZMmhsY25OYmEyVjVYVHRjYmlBZ0lDQnBaaUFvZDJGMFkyaGxjaWtnZTF4dUlDQWdJQ0FnYVdZZ0tIZGhkR05vWlhJdVpHbHlkSGtwSUh0Y2JpQWdJQ0FnSUNBZ2QyRjBZMmhsY2k1bGRtRnNkV0YwWlNncE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2FXWWdLRVJsY0M1MFlYSm5aWFFwSUh0Y2JpQWdJQ0FnSUNBZ2QyRjBZMmhsY2k1a1pYQmxibVFvS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUhKbGRIVnliaUIzWVhSamFHVnlMblpoYkhWbFhHNGdJQ0FnZlZ4dUlDQjlYRzU5WEc1Y2JtWjFibU4wYVc5dUlHbHVhWFJOWlhSb2IyUnpJQ2gyYlN3Z2JXVjBhRzlrY3lrZ2UxeHVJQ0IyWVhJZ2NISnZjSE1nUFNCMmJTNGtiM0IwYVc5dWN5NXdjbTl3Y3p0Y2JpQWdabTl5SUNoMllYSWdhMlY1SUdsdUlHMWxkR2h2WkhNcElIdGNiaUFnSUNCMmJWdHJaWGxkSUQwZ2JXVjBhRzlrYzF0clpYbGRJRDA5SUc1MWJHd2dQeUJ1YjI5d0lEb2dZbWx1WkNodFpYUm9iMlJ6VzJ0bGVWMHNJSFp0S1R0Y2JpQWdJQ0JwWmlBb2NISnZZMlZ6Y3k1bGJuWXVUazlFUlY5RlRsWWdJVDA5SUNkd2NtOWtkV04wYVc5dUp5a2dlMXh1SUNBZ0lDQWdhV1lnS0cxbGRHaHZaSE5iYTJWNVhTQTlQU0J1ZFd4c0tTQjdYRzRnSUNBZ0lDQWdJSGRoY200b1hHNGdJQ0FnSUNBZ0lDQWdYQ0p0WlhSb2IyUWdYRnhjSWx3aUlDc2dhMlY1SUNzZ1hDSmNYRndpSUdoaGN5QmhiaUIxYm1SbFptbHVaV1FnZG1Gc2RXVWdhVzRnZEdobElHTnZiWEJ2Ym1WdWRDQmtaV1pwYm1sMGFXOXVMaUJjSWlBclhHNGdJQ0FnSUNBZ0lDQWdYQ0pFYVdRZ2VXOTFJSEpsWm1WeVpXNWpaU0IwYUdVZ1puVnVZM1JwYjI0Z1kyOXljbVZqZEd4NVAxd2lMRnh1SUNBZ0lDQWdJQ0FnSUhadFhHNGdJQ0FnSUNBZ0lDazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnBaaUFvY0hKdmNITWdKaVlnYUdGelQzZHVLSEJ5YjNCekxDQnJaWGtwS1NCN1hHNGdJQ0FnSUNBZ0lIZGhjbTRvWEc0Z0lDQWdJQ0FnSUNBZ0tGd2liV1YwYUc5a0lGeGNYQ0pjSWlBcklHdGxlU0FySUZ3aVhGeGNJaUJvWVhNZ1lXeHlaV0ZrZVNCaVpXVnVJR1JsWm1sdVpXUWdZWE1nWVNCd2NtOXdMbHdpS1N4Y2JpQWdJQ0FnSUNBZ0lDQjJiVnh1SUNBZ0lDQWdJQ0FwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ2ZWeHVmVnh1WEc1bWRXNWpkR2x2YmlCcGJtbDBWMkYwWTJnZ0tIWnRMQ0IzWVhSamFDa2dlMXh1SUNCbWIzSWdLSFpoY2lCclpYa2dhVzRnZDJGMFkyZ3BJSHRjYmlBZ0lDQjJZWElnYUdGdVpHeGxjaUE5SUhkaGRHTm9XMnRsZVYwN1hHNGdJQ0FnYVdZZ0tFRnljbUY1TG1selFYSnlZWGtvYUdGdVpHeGxjaWtwSUh0Y2JpQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2FHRnVaR3hsY2k1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lDQWdJQ0JqY21WaGRHVlhZWFJqYUdWeUtIWnRMQ0JyWlhrc0lHaGhibVJzWlhKYmFWMHBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCamNtVmhkR1ZYWVhSamFHVnlLSFp0TENCclpYa3NJR2hoYm1Sc1pYSXBPMXh1SUNBZ0lIMWNiaUFnZlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJqY21WaGRHVlhZWFJqYUdWeUlDaDJiU3dnYTJWNUxDQm9ZVzVrYkdWeUtTQjdYRzRnSUhaaGNpQnZjSFJwYjI1ek8xeHVJQ0JwWmlBb2FYTlFiR0ZwYms5aWFtVmpkQ2hvWVc1a2JHVnlLU2tnZTF4dUlDQWdJRzl3ZEdsdmJuTWdQU0JvWVc1a2JHVnlPMXh1SUNBZ0lHaGhibVJzWlhJZ1BTQm9ZVzVrYkdWeUxtaGhibVJzWlhJN1hHNGdJSDFjYmlBZ2FXWWdLSFI1Y0dWdlppQm9ZVzVrYkdWeUlEMDlQU0FuYzNSeWFXNW5KeWtnZTF4dUlDQWdJR2hoYm1Sc1pYSWdQU0IyYlZ0b1lXNWtiR1Z5WFR0Y2JpQWdmVnh1SUNCMmJTNGtkMkYwWTJnb2EyVjVMQ0JvWVc1a2JHVnlMQ0J2Y0hScGIyNXpLVHRjYm4xY2JseHVablZ1WTNScGIyNGdjM1JoZEdWTmFYaHBiaUFvVm5WbEtTQjdYRzRnSUM4dklHWnNiM2NnYzI5dFpXaHZkeUJvWVhNZ2NISnZZbXhsYlhNZ2QybDBhQ0JrYVhKbFkzUnNlU0JrWldOc1lYSmxaQ0JrWldacGJtbDBhVzl1SUc5aWFtVmpkRnh1SUNBdkx5QjNhR1Z1SUhWemFXNW5JRTlpYW1WamRDNWtaV1pwYm1WUWNtOXdaWEowZVN3Z2MyOGdkMlVnYUdGMlpTQjBieUJ3Y205alpXUjFjbUZzYkhrZ1luVnBiR1FnZFhCY2JpQWdMeThnZEdobElHOWlhbVZqZENCb1pYSmxMbHh1SUNCMllYSWdaR0YwWVVSbFppQTlJSHQ5TzF4dUlDQmtZWFJoUkdWbUxtZGxkQ0E5SUdaMWJtTjBhVzl1SUNncElIc2djbVYwZFhKdUlIUm9hWE11WDJSaGRHRWdmVHRjYmlBZ2RtRnlJSEJ5YjNCelJHVm1JRDBnZTMwN1hHNGdJSEJ5YjNCelJHVm1MbWRsZENBOUlHWjFibU4wYVc5dUlDZ3BJSHNnY21WMGRYSnVJSFJvYVhNdVgzQnliM0J6SUgwN1hHNGdJR2xtSUNod2NtOWpaWE56TG1WdWRpNU9UMFJGWDBWT1ZpQWhQVDBnSjNCeWIyUjFZM1JwYjI0bktTQjdYRzRnSUNBZ1pHRjBZVVJsWmk1elpYUWdQU0JtZFc1amRHbHZiaUFvYm1WM1JHRjBZU2tnZTF4dUlDQWdJQ0FnZDJGeWJpaGNiaUFnSUNBZ0lDQWdKMEYyYjJsa0lISmxjR3hoWTJsdVp5QnBibk4wWVc1alpTQnliMjkwSUNSa1lYUmhMaUFuSUN0Y2JpQWdJQ0FnSUNBZ0oxVnpaU0J1WlhOMFpXUWdaR0YwWVNCd2NtOXdaWEowYVdWeklHbHVjM1JsWVdRdUp5eGNiaUFnSUNBZ0lDQWdkR2hwYzF4dUlDQWdJQ0FnS1R0Y2JpQWdJQ0I5TzF4dUlDQWdJSEJ5YjNCelJHVm1Mbk5sZENBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ0lDQWdJSGRoY200b1hDSWtjSEp2Y0hNZ2FYTWdjbVZoWkc5dWJIa3VYQ0lzSUhSb2FYTXBPMXh1SUNBZ0lIMDdYRzRnSUgxY2JpQWdUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblI1S0ZaMVpTNXdjbTkwYjNSNWNHVXNJQ2NrWkdGMFlTY3NJR1JoZEdGRVpXWXBPMXh1SUNCUFltcGxZM1F1WkdWbWFXNWxVSEp2Y0dWeWRIa29WblZsTG5CeWIzUnZkSGx3WlN3Z0p5UndjbTl3Y3ljc0lIQnliM0J6UkdWbUtUdGNibHh1SUNCV2RXVXVjSEp2ZEc5MGVYQmxMaVJ6WlhRZ1BTQnpaWFE3WEc0Z0lGWjFaUzV3Y205MGIzUjVjR1V1SkdSbGJHVjBaU0E5SUdSbGJEdGNibHh1SUNCV2RXVXVjSEp2ZEc5MGVYQmxMaVIzWVhSamFDQTlJR1oxYm1OMGFXOXVJQ2hjYmlBZ0lDQmxlSEJQY2tadUxGeHVJQ0FnSUdOaUxGeHVJQ0FnSUc5d2RHbHZibk5jYmlBZ0tTQjdYRzRnSUNBZ2RtRnlJSFp0SUQwZ2RHaHBjenRjYmlBZ0lDQnZjSFJwYjI1eklEMGdiM0IwYVc5dWN5QjhmQ0I3ZlR0Y2JpQWdJQ0J2Y0hScGIyNXpMblZ6WlhJZ1BTQjBjblZsTzF4dUlDQWdJSFpoY2lCM1lYUmphR1Z5SUQwZ2JtVjNJRmRoZEdOb1pYSW9kbTBzSUdWNGNFOXlSbTRzSUdOaUxDQnZjSFJwYjI1ektUdGNiaUFnSUNCcFppQW9iM0IwYVc5dWN5NXBiVzFsWkdsaGRHVXBJSHRjYmlBZ0lDQWdJR05pTG1OaGJHd29kbTBzSUhkaGRHTm9aWEl1ZG1Gc2RXVXBPMXh1SUNBZ0lIMWNiaUFnSUNCeVpYUjFjbTRnWm5WdVkzUnBiMjRnZFc1M1lYUmphRVp1SUNncElIdGNiaUFnSUNBZ0lIZGhkR05vWlhJdWRHVmhjbVJ2ZDI0b0tUdGNiaUFnSUNCOVhHNGdJSDA3WEc1OVhHNWNiaThxSUNBcUwxeHVYRzR2THlCb2IyOXJjeUIwYnlCaVpTQnBiblp2YTJWa0lHOXVJR052YlhCdmJtVnVkQ0JXVG05a1pYTWdaSFZ5YVc1bklIQmhkR05vWEc1MllYSWdZMjl0Y0c5dVpXNTBWazV2WkdWSWIyOXJjeUE5SUh0Y2JpQWdhVzVwZERvZ1puVnVZM1JwYjI0Z2FXNXBkQ0FvWEc0Z0lDQWdkbTV2WkdVc1hHNGdJQ0FnYUhsa2NtRjBhVzVuTEZ4dUlDQWdJSEJoY21WdWRFVnNiU3hjYmlBZ0lDQnlaV1pGYkcxY2JpQWdLU0I3WEc0Z0lDQWdhV1lnS0NGMmJtOWtaUzVqYjIxd2IyNWxiblJKYm5OMFlXNWpaU0I4ZkNCMmJtOWtaUzVqYjIxd2IyNWxiblJKYm5OMFlXNWpaUzVmYVhORVpYTjBjbTk1WldRcElIdGNiaUFnSUNBZ0lIWmhjaUJqYUdsc1pDQTlJSFp1YjJSbExtTnZiWEJ2Ym1WdWRFbHVjM1JoYm1ObElEMGdZM0psWVhSbFEyOXRjRzl1Wlc1MFNXNXpkR0Z1WTJWR2IzSldibTlrWlNoY2JpQWdJQ0FnSUNBZ2RtNXZaR1VzWEc0Z0lDQWdJQ0FnSUdGamRHbDJaVWx1YzNSaGJtTmxMRnh1SUNBZ0lDQWdJQ0J3WVhKbGJuUkZiRzBzWEc0Z0lDQWdJQ0FnSUhKbFprVnNiVnh1SUNBZ0lDQWdLVHRjYmlBZ0lDQWdJR05vYVd4a0xpUnRiM1Z1ZENob2VXUnlZWFJwYm1jZ1B5QjJibTlrWlM1bGJHMGdPaUIxYm1SbFptbHVaV1FzSUdoNVpISmhkR2x1WnlrN1hHNGdJQ0FnZlNCbGJITmxJR2xtSUNoMmJtOWtaUzVrWVhSaExtdGxaWEJCYkdsMlpTa2dlMXh1SUNBZ0lDQWdMeThnYTJWd2RDMWhiR2wyWlNCamIyMXdiMjVsYm5SekxDQjBjbVZoZENCaGN5QmhJSEJoZEdOb1hHNGdJQ0FnSUNCMllYSWdiVzkxYm5SbFpFNXZaR1VnUFNCMmJtOWtaVHNnTHk4Z2QyOXlheUJoY205MWJtUWdabXh2ZDF4dUlDQWdJQ0FnWTI5dGNHOXVaVzUwVms1dlpHVkliMjlyY3k1d2NtVndZWFJqYUNodGIzVnVkR1ZrVG05a1pTd2diVzkxYm5SbFpFNXZaR1VwTzF4dUlDQWdJSDFjYmlBZ2ZTeGNibHh1SUNCd2NtVndZWFJqYURvZ1puVnVZM1JwYjI0Z2NISmxjR0YwWTJnZ0tHOXNaRlp1YjJSbExDQjJibTlrWlNrZ2UxeHVJQ0FnSUhaaGNpQnZjSFJwYjI1eklEMGdkbTV2WkdVdVkyOXRjRzl1Wlc1MFQzQjBhVzl1Y3p0Y2JpQWdJQ0IyWVhJZ1kyaHBiR1FnUFNCMmJtOWtaUzVqYjIxd2IyNWxiblJKYm5OMFlXNWpaU0E5SUc5c1pGWnViMlJsTG1OdmJYQnZibVZ1ZEVsdWMzUmhibU5sTzF4dUlDQWdJSFZ3WkdGMFpVTm9hV3hrUTI5dGNHOXVaVzUwS0Z4dUlDQWdJQ0FnWTJocGJHUXNYRzRnSUNBZ0lDQnZjSFJwYjI1ekxuQnliM0J6UkdGMFlTd2dMeThnZFhCa1lYUmxaQ0J3Y205d2MxeHVJQ0FnSUNBZ2IzQjBhVzl1Y3k1c2FYTjBaVzVsY25Nc0lDOHZJSFZ3WkdGMFpXUWdiR2x6ZEdWdVpYSnpYRzRnSUNBZ0lDQjJibTlrWlN3Z0x5OGdibVYzSUhCaGNtVnVkQ0IyYm05a1pWeHVJQ0FnSUNBZ2IzQjBhVzl1Y3k1amFHbHNaSEpsYmlBdkx5QnVaWGNnWTJocGJHUnlaVzVjYmlBZ0lDQXBPMXh1SUNCOUxGeHVYRzRnSUdsdWMyVnlkRG9nWm5WdVkzUnBiMjRnYVc1elpYSjBJQ2gyYm05a1pTa2dlMXh1SUNBZ0lHbG1JQ2doZG01dlpHVXVZMjl0Y0c5dVpXNTBTVzV6ZEdGdVkyVXVYMmx6VFc5MWJuUmxaQ2tnZTF4dUlDQWdJQ0FnZG01dlpHVXVZMjl0Y0c5dVpXNTBTVzV6ZEdGdVkyVXVYMmx6VFc5MWJuUmxaQ0E5SUhSeWRXVTdYRzRnSUNBZ0lDQmpZV3hzU0c5dmF5aDJibTlrWlM1amIyMXdiMjVsYm5SSmJuTjBZVzVqWlN3Z0oyMXZkVzUwWldRbktUdGNiaUFnSUNCOVhHNGdJQ0FnYVdZZ0tIWnViMlJsTG1SaGRHRXVhMlZsY0VGc2FYWmxLU0I3WEc0Z0lDQWdJQ0JoWTNScGRtRjBaVU5vYVd4a1EyOXRjRzl1Wlc1MEtIWnViMlJsTG1OdmJYQnZibVZ1ZEVsdWMzUmhibU5sTENCMGNuVmxJQzhxSUdScGNtVmpkQ0FxTHlrN1hHNGdJQ0FnZlZ4dUlDQjlMRnh1WEc0Z0lHUmxjM1J5YjNrNklHWjFibU4wYVc5dUlHUmxjM1J5YjNrZ0tIWnViMlJsS1NCN1hHNGdJQ0FnYVdZZ0tDRjJibTlrWlM1amIyMXdiMjVsYm5SSmJuTjBZVzVqWlM1ZmFYTkVaWE4wY205NVpXUXBJSHRjYmlBZ0lDQWdJR2xtSUNnaGRtNXZaR1V1WkdGMFlTNXJaV1Z3UVd4cGRtVXBJSHRjYmlBZ0lDQWdJQ0FnZG01dlpHVXVZMjl0Y0c5dVpXNTBTVzV6ZEdGdVkyVXVKR1JsYzNSeWIza29LVHRjYmlBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJR1JsWVdOMGFYWmhkR1ZEYUdsc1pFTnZiWEJ2Ym1WdWRDaDJibTlrWlM1amIyMXdiMjVsYm5SSmJuTjBZVzVqWlN3Z2RISjFaU0F2S2lCa2FYSmxZM1FnS2k4cE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdmVnh1ZlR0Y2JseHVkbUZ5SUdodmIydHpWRzlOWlhKblpTQTlJRTlpYW1WamRDNXJaWGx6S0dOdmJYQnZibVZ1ZEZaT2IyUmxTRzl2YTNNcE8xeHVYRzVtZFc1amRHbHZiaUJqY21WaGRHVkRiMjF3YjI1bGJuUWdLRnh1SUNCRGRHOXlMRnh1SUNCa1lYUmhMRnh1SUNCamIyNTBaWGgwTEZ4dUlDQmphR2xzWkhKbGJpeGNiaUFnZEdGblhHNHBJSHRjYmlBZ2FXWWdLQ0ZEZEc5eUtTQjdYRzRnSUNBZ2NtVjBkWEp1WEc0Z0lIMWNibHh1SUNCMllYSWdZbUZ6WlVOMGIzSWdQU0JqYjI1MFpYaDBMaVJ2Y0hScGIyNXpMbDlpWVhObE8xeHVJQ0JwWmlBb2FYTlBZbXBsWTNRb1EzUnZjaWtwSUh0Y2JpQWdJQ0JEZEc5eUlEMGdZbUZ6WlVOMGIzSXVaWGgwWlc1a0tFTjBiM0lwTzF4dUlDQjlYRzVjYmlBZ2FXWWdLSFI1Y0dWdlppQkRkRzl5SUNFOVBTQW5ablZ1WTNScGIyNG5LU0I3WEc0Z0lDQWdhV1lnS0hCeWIyTmxjM011Wlc1MkxrNVBSRVZmUlU1V0lDRTlQU0FuY0hKdlpIVmpkR2x2YmljcElIdGNiaUFnSUNBZ0lIZGhjbTRvS0Z3aVNXNTJZV3hwWkNCRGIyMXdiMjVsYm5RZ1pHVm1hVzVwZEdsdmJqb2dYQ0lnS3lBb1UzUnlhVzVuS0VOMGIzSXBLU2tzSUdOdmJuUmxlSFFwTzF4dUlDQWdJSDFjYmlBZ0lDQnlaWFIxY201Y2JpQWdmVnh1WEc0Z0lDOHZJR0Z6ZVc1aklHTnZiWEJ2Ym1WdWRGeHVJQ0JwWmlBb0lVTjBiM0l1WTJsa0tTQjdYRzRnSUNBZ2FXWWdLRU4wYjNJdWNtVnpiMngyWldRcElIdGNiaUFnSUNBZ0lFTjBiM0lnUFNCRGRHOXlMbkpsYzI5c2RtVmtPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCRGRHOXlJRDBnY21WemIyeDJaVUZ6ZVc1alEyOXRjRzl1Wlc1MEtFTjBiM0lzSUdKaGMyVkRkRzl5TENCbWRXNWpkR2x2YmlBb0tTQjdYRzRnSUNBZ0lDQWdJQzh2SUdsMEozTWdiMnNnZEc4Z2NYVmxkV1VnZEdocGN5QnZiaUJsZG1WeWVTQnlaVzVrWlhJZ1ltVmpZWFZ6WlZ4dUlDQWdJQ0FnSUNBdkx5QWtabTl5WTJWVmNHUmhkR1VnYVhNZ1luVm1abVZ5WldRZ1lua2dkR2hsSUhOamFHVmtkV3hsY2k1Y2JpQWdJQ0FnSUNBZ1kyOXVkR1Y0ZEM0a1ptOXlZMlZWY0dSaGRHVW9LVHRjYmlBZ0lDQWdJSDBwTzF4dUlDQWdJQ0FnYVdZZ0tDRkRkRzl5S1NCN1hHNGdJQ0FnSUNBZ0lDOHZJSEpsZEhWeWJpQnViM1JvYVc1bklHbG1JSFJvYVhNZ2FYTWdhVzVrWldWa0lHRnVJR0Z6ZVc1aklHTnZiWEJ2Ym1WdWRGeHVJQ0FnSUNBZ0lDQXZMeUIzWVdsMElHWnZjaUIwYUdVZ1kyRnNiR0poWTJzZ2RHOGdkSEpwWjJkbGNpQndZWEpsYm5RZ2RYQmtZWFJsTGx4dUlDQWdJQ0FnSUNCeVpYUjFjbTVjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0F2THlCeVpYTnZiSFpsSUdOdmJuTjBjblZqZEc5eUlHOXdkR2x2Ym5NZ2FXNGdZMkZ6WlNCbmJHOWlZV3dnYldsNGFXNXpJR0Z5WlNCaGNIQnNhV1ZrSUdGbWRHVnlYRzRnSUM4dklHTnZiWEJ2Ym1WdWRDQmpiMjV6ZEhKMVkzUnZjaUJqY21WaGRHbHZibHh1SUNCeVpYTnZiSFpsUTI5dWMzUnlkV04wYjNKUGNIUnBiMjV6S0VOMGIzSXBPMXh1WEc0Z0lHUmhkR0VnUFNCa1lYUmhJSHg4SUh0OU8xeHVYRzRnSUM4dklIUnlZVzV6Wm05eWJTQmpiMjF3YjI1bGJuUWdkaTF0YjJSbGJDQmtZWFJoSUdsdWRHOGdjSEp2Y0hNZ0ppQmxkbVZ1ZEhOY2JpQWdhV1lnS0dSaGRHRXViVzlrWld3cElIdGNiaUFnSUNCMGNtRnVjMlp2Y20xTmIyUmxiQ2hEZEc5eUxtOXdkR2x2Ym5Nc0lHUmhkR0VwTzF4dUlDQjlYRzVjYmlBZ0x5OGdaWGgwY21GamRDQndjbTl3YzF4dUlDQjJZWElnY0hKdmNITkVZWFJoSUQwZ1pYaDBjbUZqZEZCeWIzQnpLR1JoZEdFc0lFTjBiM0lzSUhSaFp5azdYRzVjYmlBZ0x5OGdablZ1WTNScGIyNWhiQ0JqYjIxd2IyNWxiblJjYmlBZ2FXWWdLRU4wYjNJdWIzQjBhVzl1Y3k1bWRXNWpkR2x2Ym1Gc0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUdOeVpXRjBaVVoxYm1OMGFXOXVZV3hEYjIxd2IyNWxiblFvUTNSdmNpd2djSEp2Y0hORVlYUmhMQ0JrWVhSaExDQmpiMjUwWlhoMExDQmphR2xzWkhKbGJpbGNiaUFnZlZ4dVhHNGdJQzh2SUdWNGRISmhZM1FnYkdsemRHVnVaWEp6TENCemFXNWpaU0IwYUdWelpTQnVaV1ZrY3lCMGJ5QmlaU0IwY21WaGRHVmtJR0Z6WEc0Z0lDOHZJR05vYVd4a0lHTnZiWEJ2Ym1WdWRDQnNhWE4wWlc1bGNuTWdhVzV6ZEdWaFpDQnZaaUJFVDAwZ2JHbHpkR1Z1WlhKelhHNGdJSFpoY2lCc2FYTjBaVzVsY25NZ1BTQmtZWFJoTG05dU8xeHVJQ0F2THlCeVpYQnNZV05sSUhkcGRHZ2diR2x6ZEdWdVpYSnpJSGRwZEdnZ0xtNWhkR2wyWlNCdGIyUnBabWxsY2x4dUlDQmtZWFJoTG05dUlEMGdaR0YwWVM1dVlYUnBkbVZQYmp0Y2JseHVJQ0JwWmlBb1EzUnZjaTV2Y0hScGIyNXpMbUZpYzNSeVlXTjBLU0I3WEc0Z0lDQWdMeThnWVdKemRISmhZM1FnWTI5dGNHOXVaVzUwY3lCa2J5QnViM1FnYTJWbGNDQmhibmwwYUdsdVoxeHVJQ0FnSUM4dklHOTBhR1Z5SUhSb1lXNGdjSEp2Y0hNZ0ppQnNhWE4wWlc1bGNuTmNiaUFnSUNCa1lYUmhJRDBnZTMwN1hHNGdJSDFjYmx4dUlDQXZMeUJ0WlhKblpTQmpiMjF3YjI1bGJuUWdiV0Z1WVdkbGJXVnVkQ0JvYjI5cmN5QnZiblJ2SUhSb1pTQndiR0ZqWldodmJHUmxjaUJ1YjJSbFhHNGdJRzFsY21kbFNHOXZhM01vWkdGMFlTazdYRzVjYmlBZ0x5OGdjbVYwZFhKdUlHRWdjR3hoWTJWb2IyeGtaWElnZG01dlpHVmNiaUFnZG1GeUlHNWhiV1VnUFNCRGRHOXlMbTl3ZEdsdmJuTXVibUZ0WlNCOGZDQjBZV2M3WEc0Z0lIWmhjaUIyYm05a1pTQTlJRzVsZHlCV1RtOWtaU2hjYmlBZ0lDQW9YQ0oyZFdVdFkyOXRjRzl1Wlc1MExWd2lJQ3NnS0VOMGIzSXVZMmxrS1NBcklDaHVZVzFsSUQ4Z0tGd2lMVndpSUNzZ2JtRnRaU2tnT2lBbkp5a3BMRnh1SUNBZ0lHUmhkR0VzSUhWdVpHVm1hVzVsWkN3Z2RXNWtaV1pwYm1Wa0xDQjFibVJsWm1sdVpXUXNJR052Ym5SbGVIUXNYRzRnSUNBZ2V5QkRkRzl5T2lCRGRHOXlMQ0J3Y205d2MwUmhkR0U2SUhCeWIzQnpSR0YwWVN3Z2JHbHpkR1Z1WlhKek9pQnNhWE4wWlc1bGNuTXNJSFJoWnpvZ2RHRm5MQ0JqYUdsc1pISmxiam9nWTJocGJHUnlaVzRnZlZ4dUlDQXBPMXh1SUNCeVpYUjFjbTRnZG01dlpHVmNibjFjYmx4dVpuVnVZM1JwYjI0Z1kzSmxZWFJsUm5WdVkzUnBiMjVoYkVOdmJYQnZibVZ1ZENBb1hHNGdJRU4wYjNJc1hHNGdJSEJ5YjNCelJHRjBZU3hjYmlBZ1pHRjBZU3hjYmlBZ1kyOXVkR1Y0ZEN4Y2JpQWdZMmhwYkdSeVpXNWNiaWtnZTF4dUlDQjJZWElnY0hKdmNITWdQU0I3ZlR0Y2JpQWdkbUZ5SUhCeWIzQlBjSFJwYjI1eklEMGdRM1J2Y2k1dmNIUnBiMjV6TG5CeWIzQnpPMXh1SUNCcFppQW9jSEp2Y0U5d2RHbHZibk1wSUh0Y2JpQWdJQ0JtYjNJZ0tIWmhjaUJyWlhrZ2FXNGdjSEp2Y0U5d2RHbHZibk1wSUh0Y2JpQWdJQ0FnSUhCeWIzQnpXMnRsZVYwZ1BTQjJZV3hwWkdGMFpWQnliM0FvYTJWNUxDQndjbTl3VDNCMGFXOXVjeXdnY0hKdmNITkVZWFJoS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNiaUFnTHk4Z1pXNXpkWEpsSUhSb1pTQmpjbVZoZEdWRmJHVnRaVzUwSUdaMWJtTjBhVzl1SUdsdUlHWjFibU4wYVc5dVlXd2dZMjl0Y0c5dVpXNTBjMXh1SUNBdkx5Qm5aWFJ6SUdFZ2RXNXBjWFZsSUdOdmJuUmxlSFFnTFNCMGFHbHpJR2x6SUc1bFkyVnpjMkZ5ZVNCbWIzSWdZMjl5Y21WamRDQnVZVzFsWkNCemJHOTBJR05vWldOclhHNGdJSFpoY2lCZlkyOXVkR1Y0ZENBOUlFOWlhbVZqZEM1amNtVmhkR1VvWTI5dWRHVjRkQ2s3WEc0Z0lIWmhjaUJvSUQwZ1puVnVZM1JwYjI0Z0tHRXNJR0lzSUdNc0lHUXBJSHNnY21WMGRYSnVJR055WldGMFpVVnNaVzFsYm5Rb1gyTnZiblJsZUhRc0lHRXNJR0lzSUdNc0lHUXNJSFJ5ZFdVcE95QjlPMXh1SUNCMllYSWdkbTV2WkdVZ1BTQkRkRzl5TG05d2RHbHZibk11Y21WdVpHVnlMbU5oYkd3b2JuVnNiQ3dnYUN3Z2UxeHVJQ0FnSUhCeWIzQnpPaUJ3Y205d2N5eGNiaUFnSUNCa1lYUmhPaUJrWVhSaExGeHVJQ0FnSUhCaGNtVnVkRG9nWTI5dWRHVjRkQ3hjYmlBZ0lDQmphR2xzWkhKbGJqb2dZMmhwYkdSeVpXNHNYRzRnSUNBZ2MyeHZkSE02SUdaMWJtTjBhVzl1SUNncElIc2djbVYwZFhKdUlISmxjMjlzZG1WVGJHOTBjeWhqYUdsc1pISmxiaXdnWTI5dWRHVjRkQ2s3SUgxY2JpQWdmU2s3WEc0Z0lHbG1JQ2gyYm05a1pTQnBibk4wWVc1alpXOW1JRlpPYjJSbEtTQjdYRzRnSUNBZ2RtNXZaR1V1Wm5WdVkzUnBiMjVoYkVOdmJuUmxlSFFnUFNCamIyNTBaWGgwTzF4dUlDQWdJR2xtSUNoa1lYUmhMbk5zYjNRcElIdGNiaUFnSUNBZ0lDaDJibTlrWlM1a1lYUmhJSHg4SUNoMmJtOWtaUzVrWVhSaElEMGdlMzBwS1M1emJHOTBJRDBnWkdGMFlTNXpiRzkwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdkbTV2WkdWY2JuMWNibHh1Wm5WdVkzUnBiMjRnWTNKbFlYUmxRMjl0Y0c5dVpXNTBTVzV6ZEdGdVkyVkdiM0pXYm05a1pTQW9YRzRnSUhadWIyUmxMQ0F2THlCM1pTQnJibTkzSUdsMEozTWdUVzkxYm5SbFpFTnZiWEJ2Ym1WdWRGWk9iMlJsSUdKMWRDQm1iRzkzSUdSdlpYTnVKM1JjYmlBZ2NHRnlaVzUwTENBdkx5QmhZM1JwZG1WSmJuTjBZVzVqWlNCcGJpQnNhV1psWTNsamJHVWdjM1JoZEdWY2JpQWdjR0Z5Wlc1MFJXeHRMRnh1SUNCeVpXWkZiRzFjYmlrZ2UxeHVJQ0IyWVhJZ2RtNXZaR1ZEYjIxd2IyNWxiblJQY0hScGIyNXpJRDBnZG01dlpHVXVZMjl0Y0c5dVpXNTBUM0IwYVc5dWN6dGNiaUFnZG1GeUlHOXdkR2x2Ym5NZ1BTQjdYRzRnSUNBZ1gybHpRMjl0Y0c5dVpXNTBPaUIwY25WbExGeHVJQ0FnSUhCaGNtVnVkRG9nY0dGeVpXNTBMRnh1SUNBZ0lIQnliM0J6UkdGMFlUb2dkbTV2WkdWRGIyMXdiMjVsYm5SUGNIUnBiMjV6TG5CeWIzQnpSR0YwWVN4Y2JpQWdJQ0JmWTI5dGNHOXVaVzUwVkdGbk9pQjJibTlrWlVOdmJYQnZibVZ1ZEU5d2RHbHZibk11ZEdGbkxGeHVJQ0FnSUY5d1lYSmxiblJXYm05a1pUb2dkbTV2WkdVc1hHNGdJQ0FnWDNCaGNtVnVkRXhwYzNSbGJtVnljem9nZG01dlpHVkRiMjF3YjI1bGJuUlBjSFJwYjI1ekxteHBjM1JsYm1WeWN5eGNiaUFnSUNCZmNtVnVaR1Z5UTJocGJHUnlaVzQ2SUhadWIyUmxRMjl0Y0c5dVpXNTBUM0IwYVc5dWN5NWphR2xzWkhKbGJpeGNiaUFnSUNCZmNHRnlaVzUwUld4dE9pQndZWEpsYm5SRmJHMGdmSHdnYm5Wc2JDeGNiaUFnSUNCZmNtVm1SV3h0T2lCeVpXWkZiRzBnZkh3Z2JuVnNiRnh1SUNCOU8xeHVJQ0F2THlCamFHVmpheUJwYm14cGJtVXRkR1Z0Y0d4aGRHVWdjbVZ1WkdWeUlHWjFibU4wYVc5dWMxeHVJQ0IyWVhJZ2FXNXNhVzVsVkdWdGNHeGhkR1VnUFNCMmJtOWtaUzVrWVhSaExtbHViR2x1WlZSbGJYQnNZWFJsTzF4dUlDQnBaaUFvYVc1c2FXNWxWR1Z0Y0d4aGRHVXBJSHRjYmlBZ0lDQnZjSFJwYjI1ekxuSmxibVJsY2lBOUlHbHViR2x1WlZSbGJYQnNZWFJsTG5KbGJtUmxjanRjYmlBZ0lDQnZjSFJwYjI1ekxuTjBZWFJwWTFKbGJtUmxja1p1Y3lBOUlHbHViR2x1WlZSbGJYQnNZWFJsTG5OMFlYUnBZMUpsYm1SbGNrWnVjenRjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdibVYzSUhadWIyUmxRMjl0Y0c5dVpXNTBUM0IwYVc5dWN5NURkRzl5S0c5d2RHbHZibk1wWEc1OVhHNWNibVoxYm1OMGFXOXVJSEpsYzI5c2RtVkJjM2x1WTBOdmJYQnZibVZ1ZENBb1hHNGdJR1poWTNSdmNua3NYRzRnSUdKaGMyVkRkRzl5TEZ4dUlDQmpZbHh1S1NCN1hHNGdJR2xtSUNobVlXTjBiM0o1TG5KbGNYVmxjM1JsWkNrZ2UxeHVJQ0FnSUM4dklIQnZiMndnWTJGc2JHSmhZMnR6WEc0Z0lDQWdabUZqZEc5eWVTNXdaVzVrYVc1blEyRnNiR0poWTJ0ekxuQjFjMmdvWTJJcE8xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lHWmhZM1J2Y25rdWNtVnhkV1Z6ZEdWa0lEMGdkSEoxWlR0Y2JpQWdJQ0IyWVhJZ1kySnpJRDBnWm1GamRHOXllUzV3Wlc1a2FXNW5RMkZzYkdKaFkydHpJRDBnVzJOaVhUdGNiaUFnSUNCMllYSWdjM2x1WXlBOUlIUnlkV1U3WEc1Y2JpQWdJQ0IyWVhJZ2NtVnpiMngyWlNBOUlHWjFibU4wYVc5dUlDaHlaWE1wSUh0Y2JpQWdJQ0FnSUdsbUlDaHBjMDlpYW1WamRDaHlaWE1wS1NCN1hHNGdJQ0FnSUNBZ0lISmxjeUE5SUdKaGMyVkRkRzl5TG1WNGRHVnVaQ2h5WlhNcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0x5OGdZMkZqYUdVZ2NtVnpiMngyWldSY2JpQWdJQ0FnSUdaaFkzUnZjbmt1Y21WemIyeDJaV1FnUFNCeVpYTTdYRzRnSUNBZ0lDQXZMeUJwYm5admEyVWdZMkZzYkdKaFkydHpJRzl1YkhrZ2FXWWdkR2hwY3lCcGN5QnViM1FnWVNCemVXNWphSEp2Ym05MWN5QnlaWE52YkhabFhHNGdJQ0FnSUNBdkx5QW9ZWE41Ym1NZ2NtVnpiMngyWlhNZ1lYSmxJSE5vYVcxdFpXUWdZWE1nYzNsdVkyaHliMjV2ZFhNZ1pIVnlhVzVuSUZOVFVpbGNiaUFnSUNBZ0lHbG1JQ2doYzNsdVl5a2dlMXh1SUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Dd2diQ0E5SUdOaWN5NXNaVzVuZEdnN0lHa2dQQ0JzT3lCcEt5c3BJSHRjYmlBZ0lDQWdJQ0FnSUNCalluTmJhVjBvY21WektUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1SUNBZ0lIMDdYRzVjYmlBZ0lDQjJZWElnY21WcVpXTjBJRDBnWm5WdVkzUnBiMjRnS0hKbFlYTnZiaWtnZTF4dUlDQWdJQ0FnY0hKdlkyVnpjeTVsYm5ZdVRrOUVSVjlGVGxZZ0lUMDlJQ2R3Y205a2RXTjBhVzl1SnlBbUppQjNZWEp1S0Z4dUlDQWdJQ0FnSUNCY0lrWmhhV3hsWkNCMGJ5QnlaWE52YkhabElHRnplVzVqSUdOdmJYQnZibVZ1ZERvZ1hDSWdLeUFvVTNSeWFXNW5LR1poWTNSdmNua3BLU0FyWEc0Z0lDQWdJQ0FnSUNoeVpXRnpiMjRnUHlBb1hDSmNYRzVTWldGemIyNDZJRndpSUNzZ2NtVmhjMjl1S1NBNklDY25LVnh1SUNBZ0lDQWdLVHRjYmlBZ0lDQjlPMXh1WEc0Z0lDQWdkbUZ5SUhKbGN5QTlJR1poWTNSdmNua29jbVZ6YjJ4MlpTd2djbVZxWldOMEtUdGNibHh1SUNBZ0lDOHZJR2hoYm1Sc1pTQndjbTl0YVhObFhHNGdJQ0FnYVdZZ0tISmxjeUFtSmlCMGVYQmxiMllnY21WekxuUm9aVzRnUFQwOUlDZG1kVzVqZEdsdmJpY2dKaVlnSVdaaFkzUnZjbmt1Y21WemIyeDJaV1FwSUh0Y2JpQWdJQ0FnSUhKbGN5NTBhR1Z1S0hKbGMyOXNkbVVzSUhKbGFtVmpkQ2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjM2x1WXlBOUlHWmhiSE5sTzF4dUlDQWdJQzh2SUhKbGRIVnliaUJwYmlCallYTmxJSEpsYzI5c2RtVmtJSE41Ym1Ob2NtOXViM1Z6YkhsY2JpQWdJQ0J5WlhSMWNtNGdabUZqZEc5eWVTNXlaWE52YkhabFpGeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJR1Y0ZEhKaFkzUlFjbTl3Y3lBb1pHRjBZU3dnUTNSdmNpd2dkR0ZuS1NCN1hHNGdJQzh2SUhkbElHRnlaU0J2Ym14NUlHVjRkSEpoWTNScGJtY2djbUYzSUhaaGJIVmxjeUJvWlhKbExseHVJQ0F2THlCMllXeHBaR0YwYVc5dUlHRnVaQ0JrWldaaGRXeDBJSFpoYkhWbGN5QmhjbVVnYUdGdVpHeGxaQ0JwYmlCMGFHVWdZMmhwYkdSY2JpQWdMeThnWTI5dGNHOXVaVzUwSUdsMGMyVnNaaTVjYmlBZ2RtRnlJSEJ5YjNCUGNIUnBiMjV6SUQwZ1EzUnZjaTV2Y0hScGIyNXpMbkJ5YjNCek8xeHVJQ0JwWmlBb0lYQnliM0JQY0hScGIyNXpLU0I3WEc0Z0lDQWdjbVYwZFhKdVhHNGdJSDFjYmlBZ2RtRnlJSEpsY3lBOUlIdDlPMXh1SUNCMllYSWdZWFIwY25NZ1BTQmtZWFJoTG1GMGRISnpPMXh1SUNCMllYSWdjSEp2Y0hNZ1BTQmtZWFJoTG5CeWIzQnpPMXh1SUNCMllYSWdaRzl0VUhKdmNITWdQU0JrWVhSaExtUnZiVkJ5YjNCek8xeHVJQ0JwWmlBb1lYUjBjbk1nZkh3Z2NISnZjSE1nZkh3Z1pHOXRVSEp2Y0hNcElIdGNiaUFnSUNCbWIzSWdLSFpoY2lCclpYa2dhVzRnY0hKdmNFOXdkR2x2Ym5NcElIdGNiaUFnSUNBZ0lIWmhjaUJoYkhSTFpYa2dQU0JvZVhCb1pXNWhkR1VvYTJWNUtUdGNiaUFnSUNBZ0lHbG1JQ2h3Y205alpYTnpMbVZ1ZGk1T1QwUkZYMFZPVmlBaFBUMGdKM0J5YjJSMVkzUnBiMjRuS1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUJyWlhsSmJreHZkMlZ5UTJGelpTQTlJR3RsZVM1MGIweHZkMlZ5UTJGelpTZ3BPMXh1SUNBZ0lDQWdJQ0JwWmlBb1hHNGdJQ0FnSUNBZ0lDQWdhMlY1SUNFOVBTQnJaWGxKYmt4dmQyVnlRMkZ6WlNBbUpseHVJQ0FnSUNBZ0lDQWdJR0YwZEhKeklDWW1JR0YwZEhKekxtaGhjMDkzYmxCeWIzQmxjblI1S0d0bGVVbHVURzkzWlhKRFlYTmxLVnh1SUNBZ0lDQWdJQ0FwSUh0Y2JpQWdJQ0FnSUNBZ0lDQjBhWEFvWEc0Z0lDQWdJQ0FnSUNBZ0lDQmNJbEJ5YjNBZ1hGeGNJbHdpSUNzZ2EyVjVTVzVNYjNkbGNrTmhjMlVnS3lCY0lseGNYQ0lnYVhNZ2NHRnpjMlZrSUhSdklHTnZiWEJ2Ym1WdWRDQmNJaUFyWEc0Z0lDQWdJQ0FnSUNBZ0lDQW9abTl5YldGMFEyOXRjRzl1Wlc1MFRtRnRaU2gwWVdjZ2ZId2dRM1J2Y2lrcElDc2dYQ0lzSUdKMWRDQjBhR1VnWkdWamJHRnlaV1FnY0hKdmNDQnVZVzFsSUdselhDSWdLMXh1SUNBZ0lDQWdJQ0FnSUNBZ1hDSWdYRnhjSWx3aUlDc2dhMlY1SUNzZ1hDSmNYRndpTGlCY0lpQXJYRzRnSUNBZ0lDQWdJQ0FnSUNCY0lrNXZkR1VnZEdoaGRDQklWRTFNSUdGMGRISnBZblYwWlhNZ1lYSmxJR05oYzJVdGFXNXpaVzV6YVhScGRtVWdZVzVrSUdOaGJXVnNRMkZ6WldRZ1hDSWdLMXh1SUNBZ0lDQWdJQ0FnSUNBZ1hDSndjbTl3Y3lCdVpXVmtJSFJ2SUhWelpTQjBhR1ZwY2lCclpXSmhZaTFqWVhObElHVnhkV2wyWVd4bGJuUnpJSGRvWlc0Z2RYTnBibWNnYVc0dFJFOU5JRndpSUN0Y2JpQWdJQ0FnSUNBZ0lDQWdJRndpZEdWdGNHeGhkR1Z6TGlCWmIzVWdjMmh2ZFd4a0lIQnliMkpoWW14NUlIVnpaU0JjWEZ3aVhDSWdLeUJoYkhSTFpYa2dLeUJjSWx4Y1hDSWdhVzV6ZEdWaFpDQnZaaUJjWEZ3aVhDSWdLeUJyWlhrZ0t5QmNJbHhjWENJdVhDSmNiaUFnSUNBZ0lDQWdJQ0FwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNCamFHVmphMUJ5YjNBb2NtVnpMQ0J3Y205d2N5d2dhMlY1TENCaGJIUkxaWGtzSUhSeWRXVXBJSHg4WEc0Z0lDQWdJQ0JqYUdWamExQnliM0FvY21WekxDQmhkSFJ5Y3l3Z2EyVjVMQ0JoYkhSTFpYa3BJSHg4WEc0Z0lDQWdJQ0JqYUdWamExQnliM0FvY21WekxDQmtiMjFRY205d2N5d2dhMlY1TENCaGJIUkxaWGtwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdjbVZ6WEc1OVhHNWNibVoxYm1OMGFXOXVJR05vWldOclVISnZjQ0FvWEc0Z0lISmxjeXhjYmlBZ2FHRnphQ3hjYmlBZ2EyVjVMRnh1SUNCaGJIUkxaWGtzWEc0Z0lIQnlaWE5sY25abFhHNHBJSHRjYmlBZ2FXWWdLR2hoYzJncElIdGNiaUFnSUNCcFppQW9hR0Z6VDNkdUtHaGhjMmdzSUd0bGVTa3BJSHRjYmlBZ0lDQWdJSEpsYzF0clpYbGRJRDBnYUdGemFGdHJaWGxkTzF4dUlDQWdJQ0FnYVdZZ0tDRndjbVZ6WlhKMlpTa2dlMXh1SUNBZ0lDQWdJQ0JrWld4bGRHVWdhR0Z6YUZ0clpYbGRPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdjbVYwZFhKdUlIUnlkV1ZjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLR2hoYzA5M2JpaG9ZWE5vTENCaGJIUkxaWGtwS1NCN1hHNGdJQ0FnSUNCeVpYTmJhMlY1WFNBOUlHaGhjMmhiWVd4MFMyVjVYVHRjYmlBZ0lDQWdJR2xtSUNnaGNISmxjMlZ5ZG1VcElIdGNiaUFnSUNBZ0lDQWdaR1ZzWlhSbElHaGhjMmhiWVd4MFMyVjVYVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJSEpsZEhWeWJpQjBjblZsWEc0Z0lDQWdmVnh1SUNCOVhHNGdJSEpsZEhWeWJpQm1ZV3h6WlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJ0WlhKblpVaHZiMnR6SUNoa1lYUmhLU0I3WEc0Z0lHbG1JQ2doWkdGMFlTNW9iMjlyS1NCN1hHNGdJQ0FnWkdGMFlTNW9iMjlySUQwZ2UzMDdYRzRnSUgxY2JpQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JvYjI5cmMxUnZUV1Z5WjJVdWJHVnVaM1JvT3lCcEt5c3BJSHRjYmlBZ0lDQjJZWElnYTJWNUlEMGdhRzl2YTNOVWIwMWxjbWRsVzJsZE8xeHVJQ0FnSUhaaGNpQm1jbTl0VUdGeVpXNTBJRDBnWkdGMFlTNW9iMjlyVzJ0bGVWMDdYRzRnSUNBZ2RtRnlJRzkxY25NZ1BTQmpiMjF3YjI1bGJuUldUbTlrWlVodmIydHpXMnRsZVYwN1hHNGdJQ0FnWkdGMFlTNW9iMjlyVzJ0bGVWMGdQU0JtY205dFVHRnlaVzUwSUQ4Z2JXVnlaMlZJYjI5ckpERW9iM1Z5Y3l3Z1puSnZiVkJoY21WdWRDa2dPaUJ2ZFhKek8xeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJRzFsY21kbFNHOXZheVF4SUNodmJtVXNJSFIzYnlrZ2UxeHVJQ0J5WlhSMWNtNGdablZ1WTNScGIyNGdLR0VzSUdJc0lHTXNJR1FwSUh0Y2JpQWdJQ0J2Ym1Vb1lTd2dZaXdnWXl3Z1pDazdYRzRnSUNBZ2RIZHZLR0VzSUdJc0lHTXNJR1FwTzF4dUlDQjlYRzU5WEc1Y2JpOHZJSFJ5WVc1elptOXliU0JqYjIxd2IyNWxiblFnZGkxdGIyUmxiQ0JwYm1adklDaDJZV3gxWlNCaGJtUWdZMkZzYkdKaFkyc3BJR2x1ZEc5Y2JpOHZJSEJ5YjNBZ1lXNWtJR1YyWlc1MElHaGhibVJzWlhJZ2NtVnpjR1ZqZEdsMlpXeDVMbHh1Wm5WdVkzUnBiMjRnZEhKaGJuTm1iM0p0VFc5a1pXd2dLRzl3ZEdsdmJuTXNJR1JoZEdFcElIdGNiaUFnZG1GeUlIQnliM0FnUFNBb2IzQjBhVzl1Y3k1dGIyUmxiQ0FtSmlCdmNIUnBiMjV6TG0xdlpHVnNMbkJ5YjNBcElIeDhJQ2QyWVd4MVpTYzdYRzRnSUhaaGNpQmxkbVZ1ZENBOUlDaHZjSFJwYjI1ekxtMXZaR1ZzSUNZbUlHOXdkR2x2Ym5NdWJXOWtaV3d1WlhabGJuUXBJSHg4SUNkcGJuQjFkQ2M3S0dSaGRHRXVjSEp2Y0hNZ2ZId2dLR1JoZEdFdWNISnZjSE1nUFNCN2ZTa3BXM0J5YjNCZElEMGdaR0YwWVM1dGIyUmxiQzUyWVd4MVpUdGNiaUFnZG1GeUlHOXVJRDBnWkdGMFlTNXZiaUI4ZkNBb1pHRjBZUzV2YmlBOUlIdDlLVHRjYmlBZ2FXWWdLRzl1VzJWMlpXNTBYU2tnZTF4dUlDQWdJRzl1VzJWMlpXNTBYU0E5SUZ0a1lYUmhMbTF2WkdWc0xtTmhiR3hpWVdOclhTNWpiMjVqWVhRb2IyNWJaWFpsYm5SZEtUdGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQnZibHRsZG1WdWRGMGdQU0JrWVhSaExtMXZaR1ZzTG1OaGJHeGlZV05yTzF4dUlDQjlYRzU5WEc1Y2JpOHFJQ0FxTDF4dVhHNTJZWElnVTBsTlVFeEZYMDVQVWsxQlRFbGFSU0E5SURFN1hHNTJZWElnUVV4WFFWbFRYMDVQVWsxQlRFbGFSU0E5SURJN1hHNWNiaTh2SUhkeVlYQndaWElnWm5WdVkzUnBiMjRnWm05eUlIQnliM1pwWkdsdVp5QmhJRzF2Y21VZ1pteGxlR2xpYkdVZ2FXNTBaWEptWVdObFhHNHZMeUIzYVhSb2IzVjBJR2RsZEhScGJtY2dlV1ZzYkdWa0lHRjBJR0o1SUdac2IzZGNibVoxYm1OMGFXOXVJR055WldGMFpVVnNaVzFsYm5RZ0tGeHVJQ0JqYjI1MFpYaDBMRnh1SUNCMFlXY3NYRzRnSUdSaGRHRXNYRzRnSUdOb2FXeGtjbVZ1TEZ4dUlDQnViM0p0WVd4cGVtRjBhVzl1Vkhsd1pTeGNiaUFnWVd4M1lYbHpUbTl5YldGc2FYcGxYRzRwSUh0Y2JpQWdhV1lnS0VGeWNtRjVMbWx6UVhKeVlYa29aR0YwWVNrZ2ZId2dhWE5RY21sdGFYUnBkbVVvWkdGMFlTa3BJSHRjYmlBZ0lDQnViM0p0WVd4cGVtRjBhVzl1Vkhsd1pTQTlJR05vYVd4a2NtVnVPMXh1SUNBZ0lHTm9hV3hrY21WdUlEMGdaR0YwWVR0Y2JpQWdJQ0JrWVhSaElEMGdkVzVrWldacGJtVmtPMXh1SUNCOVhHNGdJR2xtSUNoaGJIZGhlWE5PYjNKdFlXeHBlbVVwSUhzZ2JtOXliV0ZzYVhwaGRHbHZibFI1Y0dVZ1BTQkJURmRCV1ZOZlRrOVNUVUZNU1ZwRk95QjlYRzRnSUhKbGRIVnliaUJmWTNKbFlYUmxSV3hsYldWdWRDaGpiMjUwWlhoMExDQjBZV2NzSUdSaGRHRXNJR05vYVd4a2NtVnVMQ0J1YjNKdFlXeHBlbUYwYVc5dVZIbHdaU2xjYm4xY2JseHVablZ1WTNScGIyNGdYMk55WldGMFpVVnNaVzFsYm5RZ0tGeHVJQ0JqYjI1MFpYaDBMRnh1SUNCMFlXY3NYRzRnSUdSaGRHRXNYRzRnSUdOb2FXeGtjbVZ1TEZ4dUlDQnViM0p0WVd4cGVtRjBhVzl1Vkhsd1pWeHVLU0I3WEc0Z0lHbG1JQ2hrWVhSaElDWW1JR1JoZEdFdVgxOXZZbDlmS1NCN1hHNGdJQ0FnY0hKdlkyVnpjeTVsYm5ZdVRrOUVSVjlGVGxZZ0lUMDlJQ2R3Y205a2RXTjBhVzl1SnlBbUppQjNZWEp1S0Z4dUlDQWdJQ0FnWENKQmRtOXBaQ0IxYzJsdVp5QnZZbk5sY25abFpDQmtZWFJoSUc5aWFtVmpkQ0JoY3lCMmJtOWtaU0JrWVhSaE9pQmNJaUFySUNoS1UwOU9Mbk4wY21sdVoybG1lU2hrWVhSaEtTa2dLeUJjSWx4Y2Jsd2lJQ3RjYmlBZ0lDQWdJQ2RCYkhkaGVYTWdZM0psWVhSbElHWnlaWE5vSUhadWIyUmxJR1JoZEdFZ2IySnFaV04wY3lCcGJpQmxZV05vSUhKbGJtUmxjaUVuTEZ4dUlDQWdJQ0FnWTI5dWRHVjRkRnh1SUNBZ0lDazdYRzRnSUNBZ2NtVjBkWEp1SUdOeVpXRjBaVVZ0Y0hSNVZrNXZaR1VvS1Z4dUlDQjlYRzRnSUdsbUlDZ2hkR0ZuS1NCN1hHNGdJQ0FnTHk4Z2FXNGdZMkZ6WlNCdlppQmpiMjF3YjI1bGJuUWdPbWx6SUhObGRDQjBieUJtWVd4emVTQjJZV3gxWlZ4dUlDQWdJSEpsZEhWeWJpQmpjbVZoZEdWRmJYQjBlVlpPYjJSbEtDbGNiaUFnZlZ4dUlDQXZMeUJ6ZFhCd2IzSjBJSE5wYm1kc1pTQm1kVzVqZEdsdmJpQmphR2xzWkhKbGJpQmhjeUJrWldaaGRXeDBJSE5qYjNCbFpDQnpiRzkwWEc0Z0lHbG1JQ2hCY25KaGVTNXBjMEZ5Y21GNUtHTm9hV3hrY21WdUtTQW1KbHh1SUNBZ0lDQWdkSGx3Wlc5bUlHTm9hV3hrY21WdVd6QmRJRDA5UFNBblpuVnVZM1JwYjI0bktTQjdYRzRnSUNBZ1pHRjBZU0E5SUdSaGRHRWdmSHdnZTMwN1hHNGdJQ0FnWkdGMFlTNXpZMjl3WldSVGJHOTBjeUE5SUhzZ1pHVm1ZWFZzZERvZ1kyaHBiR1J5Wlc1Yk1GMGdmVHRjYmlBZ0lDQmphR2xzWkhKbGJpNXNaVzVuZEdnZ1BTQXdPMXh1SUNCOVhHNGdJR2xtSUNodWIzSnRZV3hwZW1GMGFXOXVWSGx3WlNBOVBUMGdRVXhYUVZsVFgwNVBVazFCVEVsYVJTa2dlMXh1SUNBZ0lHTm9hV3hrY21WdUlEMGdibTl5YldGc2FYcGxRMmhwYkdSeVpXNG9ZMmhwYkdSeVpXNHBPMXh1SUNCOUlHVnNjMlVnYVdZZ0tHNXZjbTFoYkdsNllYUnBiMjVVZVhCbElEMDlQU0JUU1UxUVRFVmZUazlTVFVGTVNWcEZLU0I3WEc0Z0lDQWdZMmhwYkdSeVpXNGdQU0J6YVcxd2JHVk9iM0p0WVd4cGVtVkRhR2xzWkhKbGJpaGphR2xzWkhKbGJpazdYRzRnSUgxY2JpQWdkbUZ5SUhadWIyUmxMQ0J1Y3p0Y2JpQWdhV1lnS0hSNWNHVnZaaUIwWVdjZ1BUMDlJQ2R6ZEhKcGJtY25LU0I3WEc0Z0lDQWdkbUZ5SUVOMGIzSTdYRzRnSUNBZ2JuTWdQU0JqYjI1bWFXY3VaMlYwVkdGblRtRnRaWE53WVdObEtIUmhaeWs3WEc0Z0lDQWdhV1lnS0dOdmJtWnBaeTVwYzFKbGMyVnlkbVZrVkdGbktIUmhaeWtwSUh0Y2JpQWdJQ0FnSUM4dklIQnNZWFJtYjNKdElHSjFhV3gwTFdsdUlHVnNaVzFsYm5SelhHNGdJQ0FnSUNCMmJtOWtaU0E5SUc1bGR5QldUbTlrWlNoY2JpQWdJQ0FnSUNBZ1kyOXVabWxuTG5CaGNuTmxVR3hoZEdadmNtMVVZV2RPWVcxbEtIUmhaeWtzSUdSaGRHRXNJR05vYVd4a2NtVnVMRnh1SUNBZ0lDQWdJQ0IxYm1SbFptbHVaV1FzSUhWdVpHVm1hVzVsWkN3Z1kyOXVkR1Y0ZEZ4dUlDQWdJQ0FnS1R0Y2JpQWdJQ0I5SUdWc2MyVWdhV1lnS0NoRGRHOXlJRDBnY21WemIyeDJaVUZ6YzJWMEtHTnZiblJsZUhRdUpHOXdkR2x2Ym5Nc0lDZGpiMjF3YjI1bGJuUnpKeXdnZEdGbktTa3BJSHRjYmlBZ0lDQWdJQzh2SUdOdmJYQnZibVZ1ZEZ4dUlDQWdJQ0FnZG01dlpHVWdQU0JqY21WaGRHVkRiMjF3YjI1bGJuUW9RM1J2Y2l3Z1pHRjBZU3dnWTI5dWRHVjRkQ3dnWTJocGJHUnlaVzRzSUhSaFp5azdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUM4dklIVnVhMjV2ZDI0Z2IzSWdkVzVzYVhOMFpXUWdibUZ0WlhOd1lXTmxaQ0JsYkdWdFpXNTBjMXh1SUNBZ0lDQWdMeThnWTJobFkyc2dZWFFnY25WdWRHbHRaU0JpWldOaGRYTmxJR2wwSUcxaGVTQm5aWFFnWVhOemFXZHVaV1FnWVNCdVlXMWxjM0JoWTJVZ2QyaGxiaUJwZEhOY2JpQWdJQ0FnSUM4dklIQmhjbVZ1ZENCdWIzSnRZV3hwZW1WeklHTm9hV3hrY21WdVhHNGdJQ0FnSUNCMmJtOWtaU0E5SUc1bGR5QldUbTlrWlNoY2JpQWdJQ0FnSUNBZ2RHRm5MQ0JrWVhSaExDQmphR2xzWkhKbGJpeGNiaUFnSUNBZ0lDQWdkVzVrWldacGJtVmtMQ0IxYm1SbFptbHVaV1FzSUdOdmJuUmxlSFJjYmlBZ0lDQWdJQ2s3WEc0Z0lDQWdmVnh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJQzh2SUdScGNtVmpkQ0JqYjIxd2IyNWxiblFnYjNCMGFXOXVjeUF2SUdOdmJuTjBjblZqZEc5eVhHNGdJQ0FnZG01dlpHVWdQU0JqY21WaGRHVkRiMjF3YjI1bGJuUW9kR0ZuTENCa1lYUmhMQ0JqYjI1MFpYaDBMQ0JqYUdsc1pISmxiaWs3WEc0Z0lIMWNiaUFnYVdZZ0tIWnViMlJsS1NCN1hHNGdJQ0FnYVdZZ0tHNXpLU0I3SUdGd2NHeDVUbE1vZG01dlpHVXNJRzV6S1RzZ2ZWeHVJQ0FnSUhKbGRIVnliaUIyYm05a1pWeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lISmxkSFZ5YmlCamNtVmhkR1ZGYlhCMGVWWk9iMlJsS0NsY2JpQWdmVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmhjSEJzZVU1VElDaDJibTlrWlN3Z2JuTXBJSHRjYmlBZ2RtNXZaR1V1Ym5NZ1BTQnVjenRjYmlBZ2FXWWdLSFp1YjJSbExuUmhaeUE5UFQwZ0oyWnZjbVZwWjI1UFltcGxZM1FuS1NCN1hHNGdJQ0FnTHk4Z2RYTmxJR1JsWm1GMWJIUWdibUZ0WlhOd1lXTmxJR2x1YzJsa1pTQm1iM0psYVdkdVQySnFaV04wWEc0Z0lDQWdjbVYwZFhKdVhHNGdJSDFjYmlBZ2FXWWdLSFp1YjJSbExtTm9hV3hrY21WdUtTQjdYRzRnSUNBZ1ptOXlJQ2gyWVhJZ2FTQTlJREFzSUd3Z1BTQjJibTlrWlM1amFHbHNaSEpsYmk1c1pXNW5kR2c3SUdrZ1BDQnNPeUJwS3lzcElIdGNiaUFnSUNBZ0lIWmhjaUJqYUdsc1pDQTlJSFp1YjJSbExtTm9hV3hrY21WdVcybGRPMXh1SUNBZ0lDQWdhV1lnS0dOb2FXeGtMblJoWnlBbUppQWhZMmhwYkdRdWJuTXBJSHRjYmlBZ0lDQWdJQ0FnWVhCd2JIbE9VeWhqYUdsc1pDd2dibk1wTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ2ZWeHVmVnh1WEc0dktpQWdLaTljYmx4dUx5b3FYRzRnS2lCU2RXNTBhVzFsSUdobGJIQmxjaUJtYjNJZ2NtVnVaR1Z5YVc1bklIWXRabTl5SUd4cGMzUnpMbHh1SUNvdlhHNW1kVzVqZEdsdmJpQnlaVzVrWlhKTWFYTjBJQ2hjYmlBZ2RtRnNMRnh1SUNCeVpXNWtaWEpjYmlrZ2UxeHVJQ0IyWVhJZ2NtVjBMQ0JwTENCc0xDQnJaWGx6TENCclpYazdYRzRnSUdsbUlDaEJjbkpoZVM1cGMwRnljbUY1S0haaGJDa2dmSHdnZEhsd1pXOW1JSFpoYkNBOVBUMGdKM04wY21sdVp5Y3BJSHRjYmlBZ0lDQnlaWFFnUFNCdVpYY2dRWEp5WVhrb2RtRnNMbXhsYm1kMGFDazdYRzRnSUNBZ1ptOXlJQ2hwSUQwZ01Dd2diQ0E5SUhaaGJDNXNaVzVuZEdnN0lHa2dQQ0JzT3lCcEt5c3BJSHRjYmlBZ0lDQWdJSEpsZEZ0cFhTQTlJSEpsYm1SbGNpaDJZV3hiYVYwc0lHa3BPMXh1SUNBZ0lIMWNiaUFnZlNCbGJITmxJR2xtSUNoMGVYQmxiMllnZG1Gc0lEMDlQU0FuYm5WdFltVnlKeWtnZTF4dUlDQWdJSEpsZENBOUlHNWxkeUJCY25KaGVTaDJZV3dwTzF4dUlDQWdJR1p2Y2lBb2FTQTlJREE3SUdrZ1BDQjJZV3c3SUdrckt5a2dlMXh1SUNBZ0lDQWdjbVYwVzJsZElEMGdjbVZ1WkdWeUtHa2dLeUF4TENCcEtUdGNiaUFnSUNCOVhHNGdJSDBnWld4elpTQnBaaUFvYVhOUFltcGxZM1FvZG1Gc0tTa2dlMXh1SUNBZ0lHdGxlWE1nUFNCUFltcGxZM1F1YTJWNWN5aDJZV3dwTzF4dUlDQWdJSEpsZENBOUlHNWxkeUJCY25KaGVTaHJaWGx6TG14bGJtZDBhQ2s3WEc0Z0lDQWdabTl5SUNocElEMGdNQ3dnYkNBOUlHdGxlWE11YkdWdVozUm9PeUJwSUR3Z2JEc2dhU3NyS1NCN1hHNGdJQ0FnSUNCclpYa2dQU0JyWlhselcybGRPMXh1SUNBZ0lDQWdjbVYwVzJsZElEMGdjbVZ1WkdWeUtIWmhiRnRyWlhsZExDQnJaWGtzSUdrcE8xeHVJQ0FnSUgxY2JpQWdmVnh1SUNCeVpYUjFjbTRnY21WMFhHNTlYRzVjYmk4cUlDQXFMMXh1WEc0dktpcGNiaUFxSUZKMWJuUnBiV1VnYUdWc2NHVnlJR1p2Y2lCeVpXNWtaWEpwYm1jZ1BITnNiM1ErWEc0Z0tpOWNibVoxYm1OMGFXOXVJSEpsYm1SbGNsTnNiM1FnS0Z4dUlDQnVZVzFsTEZ4dUlDQm1ZV3hzWW1GamF5eGNiaUFnY0hKdmNITXNYRzRnSUdKcGJtUlBZbXBsWTNSY2Jpa2dlMXh1SUNCMllYSWdjMk52Y0dWa1UyeHZkRVp1SUQwZ2RHaHBjeTRrYzJOdmNHVmtVMnh2ZEhOYmJtRnRaVjA3WEc0Z0lHbG1JQ2h6WTI5d1pXUlRiRzkwUm00cElIc2dMeThnYzJOdmNHVmtJSE5zYjNSY2JpQWdJQ0J3Y205d2N5QTlJSEJ5YjNCeklIeDhJSHQ5TzF4dUlDQWdJR2xtSUNoaWFXNWtUMkpxWldOMEtTQjdYRzRnSUNBZ0lDQmxlSFJsYm1Rb2NISnZjSE1zSUdKcGJtUlBZbXBsWTNRcE8xeHVJQ0FnSUgxY2JpQWdJQ0J5WlhSMWNtNGdjMk52Y0dWa1UyeHZkRVp1S0hCeWIzQnpLU0I4ZkNCbVlXeHNZbUZqYTF4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUhaaGNpQnpiRzkwVG05a1pYTWdQU0IwYUdsekxpUnpiRzkwYzF0dVlXMWxYVHRjYmlBZ0lDQXZMeUIzWVhKdUlHUjFjR3hwWTJGMFpTQnpiRzkwSUhWellXZGxYRzRnSUNBZ2FXWWdLSE5zYjNST2IyUmxjeUFtSmlCd2NtOWpaWE56TG1WdWRpNU9UMFJGWDBWT1ZpQWhQVDBnSjNCeWIyUjFZM1JwYjI0bktTQjdYRzRnSUNBZ0lDQnpiRzkwVG05a1pYTXVYM0psYm1SbGNtVmtJQ1ltSUhkaGNtNG9YRzRnSUNBZ0lDQWdJRndpUkhWd2JHbGpZWFJsSUhCeVpYTmxibU5sSUc5bUlITnNiM1FnWEZ4Y0lsd2lJQ3NnYm1GdFpTQXJJRndpWEZ4Y0lpQm1iM1Z1WkNCcGJpQjBhR1VnYzJGdFpTQnlaVzVrWlhJZ2RISmxaU0JjSWlBclhHNGdJQ0FnSUNBZ0lGd2lMU0IwYUdseklIZHBiR3dnYkdsclpXeDVJR05oZFhObElISmxibVJsY2lCbGNuSnZjbk11WENJc1hHNGdJQ0FnSUNBZ0lIUm9hWE5jYmlBZ0lDQWdJQ2s3WEc0Z0lDQWdJQ0J6Ykc5MFRtOWtaWE11WDNKbGJtUmxjbVZrSUQwZ2RISjFaVHRjYmlBZ0lDQjlYRzRnSUNBZ2NtVjBkWEp1SUhOc2IzUk9iMlJsY3lCOGZDQm1ZV3hzWW1GamExeHVJQ0I5WEc1OVhHNWNiaThxSUNBcUwxeHVYRzR2S2lwY2JpQXFJRkoxYm5ScGJXVWdhR1ZzY0dWeUlHWnZjaUJ5WlhOdmJIWnBibWNnWm1sc2RHVnljMXh1SUNvdlhHNW1kVzVqZEdsdmJpQnlaWE52YkhabFJtbHNkR1Z5SUNocFpDa2dlMXh1SUNCeVpYUjFjbTRnY21WemIyeDJaVUZ6YzJWMEtIUm9hWE11Skc5d2RHbHZibk1zSUNkbWFXeDBaWEp6Snl3Z2FXUXNJSFJ5ZFdVcElIeDhJR2xrWlc1MGFYUjVYRzU5WEc1Y2JpOHFJQ0FxTDF4dVhHNHZLaXBjYmlBcUlGSjFiblJwYldVZ2FHVnNjR1Z5SUdadmNpQmphR1ZqYTJsdVp5QnJaWGxEYjJSbGN5Qm1jbTl0SUdOdmJtWnBaeTVjYmlBcUwxeHVablZ1WTNScGIyNGdZMmhsWTJ0TFpYbERiMlJsY3lBb1hHNGdJR1YyWlc1MFMyVjVRMjlrWlN4Y2JpQWdhMlY1TEZ4dUlDQmlkV2xzZEVsdVFXeHBZWE5jYmlrZ2UxeHVJQ0IyWVhJZ2EyVjVRMjlrWlhNZ1BTQmpiMjVtYVdjdWEyVjVRMjlrWlhOYmEyVjVYU0I4ZkNCaWRXbHNkRWx1UVd4cFlYTTdYRzRnSUdsbUlDaEJjbkpoZVM1cGMwRnljbUY1S0d0bGVVTnZaR1Z6S1NrZ2UxeHVJQ0FnSUhKbGRIVnliaUJyWlhsRGIyUmxjeTVwYm1SbGVFOW1LR1YyWlc1MFMyVjVRMjlrWlNrZ1BUMDlJQzB4WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnY21WMGRYSnVJR3RsZVVOdlpHVnpJQ0U5UFNCbGRtVnVkRXRsZVVOdlpHVmNiaUFnZlZ4dWZWeHVYRzR2S2lBZ0tpOWNibHh1THlvcVhHNGdLaUJTZFc1MGFXMWxJR2hsYkhCbGNpQm1iM0lnYldWeVoybHVaeUIyTFdKcGJtUTlYQ0p2WW1wbFkzUmNJaUJwYm5SdklHRWdWazV2WkdVbmN5QmtZWFJoTGx4dUlDb3ZYRzVtZFc1amRHbHZiaUJpYVc1a1QySnFaV04wVUhKdmNITWdLRnh1SUNCa1lYUmhMRnh1SUNCMFlXY3NYRzRnSUhaaGJIVmxMRnh1SUNCaGMxQnliM0JjYmlrZ2UxeHVJQ0JwWmlBb2RtRnNkV1VwSUh0Y2JpQWdJQ0JwWmlBb0lXbHpUMkpxWldOMEtIWmhiSFZsS1NrZ2UxeHVJQ0FnSUNBZ2NISnZZMlZ6Y3k1bGJuWXVUazlFUlY5RlRsWWdJVDA5SUNkd2NtOWtkV04wYVc5dUp5QW1KaUIzWVhKdUtGeHVJQ0FnSUNBZ0lDQW5kaTFpYVc1a0lIZHBkR2h2ZFhRZ1lYSm5kVzFsYm5RZ1pYaHdaV04wY3lCaGJpQlBZbXBsWTNRZ2IzSWdRWEp5WVhrZ2RtRnNkV1VuTEZ4dUlDQWdJQ0FnSUNCMGFHbHpYRzRnSUNBZ0lDQXBPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCcFppQW9RWEp5WVhrdWFYTkJjbkpoZVNoMllXeDFaU2twSUh0Y2JpQWdJQ0FnSUNBZ2RtRnNkV1VnUFNCMGIwOWlhbVZqZENoMllXeDFaU2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0IyWVhJZ2FHRnphRHRjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJR3RsZVNCcGJpQjJZV3gxWlNrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvYTJWNUlEMDlQU0FuWTJ4aGMzTW5JSHg4SUd0bGVTQTlQVDBnSjNOMGVXeGxKeWtnZTF4dUlDQWdJQ0FnSUNBZ0lHaGhjMmdnUFNCa1lYUmhPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUhaaGNpQjBlWEJsSUQwZ1pHRjBZUzVoZEhSeWN5QW1KaUJrWVhSaExtRjBkSEp6TG5SNWNHVTdYRzRnSUNBZ0lDQWdJQ0FnYUdGemFDQTlJR0Z6VUhKdmNDQjhmQ0JqYjI1bWFXY3ViWFZ6ZEZWelpWQnliM0FvZEdGbkxDQjBlWEJsTENCclpYa3BYRzRnSUNBZ0lDQWdJQ0FnSUNBL0lHUmhkR0V1Wkc5dFVISnZjSE1nZkh3Z0tHUmhkR0V1Wkc5dFVISnZjSE1nUFNCN2ZTbGNiaUFnSUNBZ0lDQWdJQ0FnSURvZ1pHRjBZUzVoZEhSeWN5QjhmQ0FvWkdGMFlTNWhkSFJ5Y3lBOUlIdDlLVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCcFppQW9JU2hyWlhrZ2FXNGdhR0Z6YUNrcElIdGNiaUFnSUNBZ0lDQWdJQ0JvWVhOb1cydGxlVjBnUFNCMllXeDFaVnRyWlhsZE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCa1lYUmhYRzU5WEc1Y2JpOHFJQ0FxTDF4dVhHNHZLaXBjYmlBcUlGSjFiblJwYldVZ2FHVnNjR1Z5SUdadmNpQnlaVzVrWlhKcGJtY2djM1JoZEdsaklIUnlaV1Z6TGx4dUlDb3ZYRzVtZFc1amRHbHZiaUJ5Wlc1a1pYSlRkR0YwYVdNZ0tGeHVJQ0JwYm1SbGVDeGNiaUFnYVhOSmJrWnZjbHh1S1NCN1hHNGdJSFpoY2lCMGNtVmxJRDBnZEdocGN5NWZjM1JoZEdsalZISmxaWE5iYVc1a1pYaGRPMXh1SUNBdkx5QnBaaUJvWVhNZ1lXeHlaV0ZrZVMxeVpXNWtaWEpsWkNCemRHRjBhV01nZEhKbFpTQmhibVFnYm05MElHbHVjMmxrWlNCMkxXWnZjaXhjYmlBZ0x5OGdkMlVnWTJGdUlISmxkWE5sSUhSb1pTQnpZVzFsSUhSeVpXVWdZbmtnWkc5cGJtY2dZU0J6YUdGc2JHOTNJR05zYjI1bExseHVJQ0JwWmlBb2RISmxaU0FtSmlBaGFYTkpia1p2Y2lrZ2UxeHVJQ0FnSUhKbGRIVnliaUJCY25KaGVTNXBjMEZ5Y21GNUtIUnlaV1VwWEc0Z0lDQWdJQ0EvSUdOc2IyNWxWazV2WkdWektIUnlaV1VwWEc0Z0lDQWdJQ0E2SUdOc2IyNWxWazV2WkdVb2RISmxaU2xjYmlBZ2ZWeHVJQ0F2THlCdmRHaGxjbmRwYzJVc0lISmxibVJsY2lCaElHWnlaWE5vSUhSeVpXVXVYRzRnSUhSeVpXVWdQU0IwYUdsekxsOXpkR0YwYVdOVWNtVmxjMXRwYm1SbGVGMGdQVnh1SUNBZ0lIUm9hWE11Skc5d2RHbHZibk11YzNSaGRHbGpVbVZ1WkdWeVJtNXpXMmx1WkdWNFhTNWpZV3hzS0hSb2FYTXVYM0psYm1SbGNsQnliM2g1S1R0Y2JpQWdiV0Z5YTFOMFlYUnBZeWgwY21WbExDQW9YQ0pmWDNOMFlYUnBZMTlmWENJZ0t5QnBibVJsZUNrc0lHWmhiSE5sS1R0Y2JpQWdjbVYwZFhKdUlIUnlaV1ZjYm4xY2JseHVMeW9xWEc0Z0tpQlNkVzUwYVcxbElHaGxiSEJsY2lCbWIzSWdkaTF2Ym1ObExseHVJQ29nUldabVpXTjBhWFpsYkhrZ2FYUWdiV1ZoYm5NZ2JXRnlhMmx1WnlCMGFHVWdibTlrWlNCaGN5QnpkR0YwYVdNZ2QybDBhQ0JoSUhWdWFYRjFaU0JyWlhrdVhHNGdLaTljYm1aMWJtTjBhVzl1SUcxaGNtdFBibU5sSUNoY2JpQWdkSEpsWlN4Y2JpQWdhVzVrWlhnc1hHNGdJR3RsZVZ4dUtTQjdYRzRnSUcxaGNtdFRkR0YwYVdNb2RISmxaU3dnS0Z3aVgxOXZibU5sWDE5Y0lpQXJJR2x1WkdWNElDc2dLR3RsZVNBL0lDaGNJbDljSWlBcklHdGxlU2tnT2lCY0lsd2lLU2tzSUhSeWRXVXBPMXh1SUNCeVpYUjFjbTRnZEhKbFpWeHVmVnh1WEc1bWRXNWpkR2x2YmlCdFlYSnJVM1JoZEdsaklDaGNiaUFnZEhKbFpTeGNiaUFnYTJWNUxGeHVJQ0JwYzA5dVkyVmNiaWtnZTF4dUlDQnBaaUFvUVhKeVlYa3VhWE5CY25KaGVTaDBjbVZsS1NrZ2UxeHVJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2RISmxaUzVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ2FXWWdLSFJ5WldWYmFWMGdKaVlnZEhsd1pXOW1JSFJ5WldWYmFWMGdJVDA5SUNkemRISnBibWNuS1NCN1hHNGdJQ0FnSUNBZ0lHMWhjbXRUZEdGMGFXTk9iMlJsS0hSeVpXVmJhVjBzSUNoclpYa2dLeUJjSWw5Y0lpQXJJR2twTENCcGMwOXVZMlVwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0J0WVhKclUzUmhkR2xqVG05a1pTaDBjbVZsTENCclpYa3NJR2x6VDI1alpTazdYRzRnSUgxY2JuMWNibHh1Wm5WdVkzUnBiMjRnYldGeWExTjBZWFJwWTA1dlpHVWdLRzV2WkdVc0lHdGxlU3dnYVhOUGJtTmxLU0I3WEc0Z0lHNXZaR1V1YVhOVGRHRjBhV01nUFNCMGNuVmxPMXh1SUNCdWIyUmxMbXRsZVNBOUlHdGxlVHRjYmlBZ2JtOWtaUzVwYzA5dVkyVWdQU0JwYzA5dVkyVTdYRzU5WEc1Y2JpOHFJQ0FxTDF4dVhHNW1kVzVqZEdsdmJpQnBibWwwVW1WdVpHVnlJQ2gyYlNrZ2UxeHVJQ0IyYlM0a2RtNXZaR1VnUFNCdWRXeHNPeUF2THlCMGFHVWdjR3hoWTJWb2IyeGtaWElnYm05a1pTQnBiaUJ3WVhKbGJuUWdkSEpsWlZ4dUlDQjJiUzVmZG01dlpHVWdQU0J1ZFd4c095QXZMeUIwYUdVZ2NtOXZkQ0J2WmlCMGFHVWdZMmhwYkdRZ2RISmxaVnh1SUNCMmJTNWZjM1JoZEdsalZISmxaWE1nUFNCdWRXeHNPMXh1SUNCMllYSWdjR0Z5Wlc1MFZtNXZaR1VnUFNCMmJTNGtiM0IwYVc5dWN5NWZjR0Z5Wlc1MFZtNXZaR1U3WEc0Z0lIWmhjaUJ5Wlc1a1pYSkRiMjUwWlhoMElEMGdjR0Z5Wlc1MFZtNXZaR1VnSmlZZ2NHRnlaVzUwVm01dlpHVXVZMjl1ZEdWNGREdGNiaUFnZG0wdUpITnNiM1J6SUQwZ2NtVnpiMngyWlZOc2IzUnpLSFp0TGlSdmNIUnBiMjV6TGw5eVpXNWtaWEpEYUdsc1pISmxiaXdnY21WdVpHVnlRMjl1ZEdWNGRDazdYRzRnSUhadExpUnpZMjl3WldSVGJHOTBjeUE5SUdWdGNIUjVUMkpxWldOME8xeHVJQ0F2THlCaWFXNWtJSFJvWlNCamNtVmhkR1ZGYkdWdFpXNTBJR1p1SUhSdklIUm9hWE1nYVc1emRHRnVZMlZjYmlBZ0x5OGdjMjhnZEdoaGRDQjNaU0JuWlhRZ2NISnZjR1Z5SUhKbGJtUmxjaUJqYjI1MFpYaDBJR2x1YzJsa1pTQnBkQzVjYmlBZ0x5OGdZWEpuY3lCdmNtUmxjam9nZEdGbkxDQmtZWFJoTENCamFHbHNaSEpsYml3Z2JtOXliV0ZzYVhwaGRHbHZibFI1Y0dVc0lHRnNkMkY1YzA1dmNtMWhiR2w2WlZ4dUlDQXZMeUJwYm5SbGNtNWhiQ0IyWlhKemFXOXVJR2x6SUhWelpXUWdZbmtnY21WdVpHVnlJR1oxYm1OMGFXOXVjeUJqYjIxd2FXeGxaQ0JtY205dElIUmxiWEJzWVhSbGMxeHVJQ0IyYlM1Zll5QTlJR1oxYm1OMGFXOXVJQ2hoTENCaUxDQmpMQ0JrS1NCN0lISmxkSFZ5YmlCamNtVmhkR1ZGYkdWdFpXNTBLSFp0TENCaExDQmlMQ0JqTENCa0xDQm1ZV3h6WlNrN0lIMDdYRzRnSUM4dklHNXZjbTFoYkdsNllYUnBiMjRnYVhNZ1lXeDNZWGx6SUdGd2NHeHBaV1FnWm05eUlIUm9aU0J3ZFdKc2FXTWdkbVZ5YzJsdmJpd2dkWE5sWkNCcGJseHVJQ0F2THlCMWMyVnlMWGR5YVhSMFpXNGdjbVZ1WkdWeUlHWjFibU4wYVc5dWN5NWNiaUFnZG0wdUpHTnlaV0YwWlVWc1pXMWxiblFnUFNCbWRXNWpkR2x2YmlBb1lTd2dZaXdnWXl3Z1pDa2dleUJ5WlhSMWNtNGdZM0psWVhSbFJXeGxiV1Z1ZENoMmJTd2dZU3dnWWl3Z1l5d2daQ3dnZEhKMVpTazdJSDA3WEc1OVhHNWNibVoxYm1OMGFXOXVJSEpsYm1SbGNrMXBlR2x1SUNoV2RXVXBJSHRjYmlBZ1ZuVmxMbkJ5YjNSdmRIbHdaUzRrYm1WNGRGUnBZMnNnUFNCbWRXNWpkR2x2YmlBb1ptNHBJSHRjYmlBZ0lDQnlaWFIxY200Z2JtVjRkRlJwWTJzb1ptNHNJSFJvYVhNcFhHNGdJSDA3WEc1Y2JpQWdWblZsTG5CeWIzUnZkSGx3WlM1ZmNtVnVaR1Z5SUQwZ1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNBZ0lIWmhjaUIyYlNBOUlIUm9hWE03WEc0Z0lDQWdkbUZ5SUhKbFppQTlJSFp0TGlSdmNIUnBiMjV6TzF4dUlDQWdJSFpoY2lCeVpXNWtaWElnUFNCeVpXWXVjbVZ1WkdWeU8xeHVJQ0FnSUhaaGNpQnpkR0YwYVdOU1pXNWtaWEpHYm5NZ1BTQnlaV1l1YzNSaGRHbGpVbVZ1WkdWeVJtNXpPMXh1SUNBZ0lIWmhjaUJmY0dGeVpXNTBWbTV2WkdVZ1BTQnlaV1l1WDNCaGNtVnVkRlp1YjJSbE8xeHVYRzRnSUNBZ2FXWWdLSFp0TGw5cGMwMXZkVzUwWldRcElIdGNiaUFnSUNBZ0lDOHZJR05zYjI1bElITnNiM1FnYm05a1pYTWdiMjRnY21VdGNtVnVaR1Z5YzF4dUlDQWdJQ0FnWm05eUlDaDJZWElnYTJWNUlHbHVJSFp0TGlSemJHOTBjeWtnZTF4dUlDQWdJQ0FnSUNCMmJTNGtjMnh2ZEhOYmEyVjVYU0E5SUdOc2IyNWxWazV2WkdWektIWnRMaVJ6Ykc5MGMxdHJaWGxkS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0IyYlM0a2MyTnZjR1ZrVTJ4dmRITWdQU0FvWDNCaGNtVnVkRlp1YjJSbElDWW1JRjl3WVhKbGJuUldibTlrWlM1a1lYUmhMbk5qYjNCbFpGTnNiM1J6S1NCOGZDQmxiWEIwZVU5aWFtVmpkRHRjYmx4dUlDQWdJR2xtSUNoemRHRjBhV05TWlc1a1pYSkdibk1nSmlZZ0lYWnRMbDl6ZEdGMGFXTlVjbVZsY3lrZ2UxeHVJQ0FnSUNBZ2RtMHVYM04wWVhScFkxUnlaV1Z6SUQwZ1cxMDdYRzRnSUNBZ2ZWeHVJQ0FnSUM4dklITmxkQ0J3WVhKbGJuUWdkbTV2WkdVdUlIUm9hWE1nWVd4c2IzZHpJSEpsYm1SbGNpQm1kVzVqZEdsdmJuTWdkRzhnYUdGMlpTQmhZMk5sYzNOY2JpQWdJQ0F2THlCMGJ5QjBhR1VnWkdGMFlTQnZiaUIwYUdVZ2NHeGhZMlZvYjJ4a1pYSWdibTlrWlM1Y2JpQWdJQ0IyYlM0a2RtNXZaR1VnUFNCZmNHRnlaVzUwVm01dlpHVTdYRzRnSUNBZ0x5OGdjbVZ1WkdWeUlITmxiR1pjYmlBZ0lDQjJZWElnZG01dlpHVTdYRzRnSUNBZ2RISjVJSHRjYmlBZ0lDQWdJSFp1YjJSbElEMGdjbVZ1WkdWeUxtTmhiR3dvZG0wdVgzSmxibVJsY2xCeWIzaDVMQ0IyYlM0a1kzSmxZWFJsUld4bGJXVnVkQ2s3WEc0Z0lDQWdmU0JqWVhSamFDQW9aU2tnZTF4dUlDQWdJQ0FnYUdGdVpHeGxSWEp5YjNJb1pTd2dkbTBzSUZ3aWNtVnVaR1Z5SUdaMWJtTjBhVzl1WENJcE8xeHVJQ0FnSUNBZ0x5OGdjbVYwZFhKdUlHVnljbTl5SUhKbGJtUmxjaUJ5WlhOMWJIUXNYRzRnSUNBZ0lDQXZMeUJ2Y2lCd2NtVjJhVzkxY3lCMmJtOWtaU0IwYnlCd2NtVjJaVzUwSUhKbGJtUmxjaUJsY25KdmNpQmpZWFZ6YVc1bklHSnNZVzVySUdOdmJYQnZibVZ1ZEZ4dUlDQWdJQ0FnTHlvZ2FYTjBZVzVpZFd3Z2FXZHViM0psSUdWc2MyVWdLaTljYmlBZ0lDQWdJR2xtSUNod2NtOWpaWE56TG1WdWRpNU9UMFJGWDBWT1ZpQWhQVDBnSjNCeWIyUjFZM1JwYjI0bktTQjdYRzRnSUNBZ0lDQWdJSFp1YjJSbElEMGdkbTB1Skc5d2RHbHZibk11Y21WdVpHVnlSWEp5YjNKY2JpQWdJQ0FnSUNBZ0lDQS9JSFp0TGlSdmNIUnBiMjV6TG5KbGJtUmxja1Z5Y205eUxtTmhiR3dvZG0wdVgzSmxibVJsY2xCeWIzaDVMQ0IyYlM0a1kzSmxZWFJsUld4bGJXVnVkQ3dnWlNsY2JpQWdJQ0FnSUNBZ0lDQTZJSFp0TGw5MmJtOWtaVHRjYmlBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJSFp1YjJSbElEMGdkbTB1WDNadWIyUmxPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNiaUFnSUNBdkx5QnlaWFIxY200Z1pXMXdkSGtnZG01dlpHVWdhVzRnWTJGelpTQjBhR1VnY21WdVpHVnlJR1oxYm1OMGFXOXVJR1Z5Y205eVpXUWdiM1YwWEc0Z0lDQWdhV1lnS0NFb2RtNXZaR1VnYVc1emRHRnVZMlZ2WmlCV1RtOWtaU2twSUh0Y2JpQWdJQ0FnSUdsbUlDaHdjbTlqWlhOekxtVnVkaTVPVDBSRlgwVk9WaUFoUFQwZ0ozQnliMlIxWTNScGIyNG5JQ1ltSUVGeWNtRjVMbWx6UVhKeVlYa29kbTV2WkdVcEtTQjdYRzRnSUNBZ0lDQWdJSGRoY200b1hHNGdJQ0FnSUNBZ0lDQWdKMDExYkhScGNHeGxJSEp2YjNRZ2JtOWtaWE1nY21WMGRYSnVaV1FnWm5KdmJTQnlaVzVrWlhJZ1puVnVZM1JwYjI0dUlGSmxibVJsY2lCbWRXNWpkR2x2YmlBbklDdGNiaUFnSUNBZ0lDQWdJQ0FuYzJodmRXeGtJSEpsZEhWeWJpQmhJSE5wYm1kc1pTQnliMjkwSUc1dlpHVXVKeXhjYmlBZ0lDQWdJQ0FnSUNCMmJWeHVJQ0FnSUNBZ0lDQXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdkbTV2WkdVZ1BTQmpjbVZoZEdWRmJYQjBlVlpPYjJSbEtDazdYRzRnSUNBZ2ZWeHVJQ0FnSUM4dklITmxkQ0J3WVhKbGJuUmNiaUFnSUNCMmJtOWtaUzV3WVhKbGJuUWdQU0JmY0dGeVpXNTBWbTV2WkdVN1hHNGdJQ0FnY21WMGRYSnVJSFp1YjJSbFhHNGdJSDA3WEc1Y2JpQWdMeThnYVc1MFpYSnVZV3dnY21WdVpHVnlJR2hsYkhCbGNuTXVYRzRnSUM4dklIUm9aWE5sSUdGeVpTQmxlSEJ2YzJWa0lHOXVJSFJvWlNCcGJuTjBZVzVqWlNCd2NtOTBiM1I1Y0dVZ2RHOGdjbVZrZFdObElHZGxibVZ5WVhSbFpDQnlaVzVrWlhKY2JpQWdMeThnWTI5a1pTQnphWHBsTGx4dUlDQldkV1V1Y0hKdmRHOTBlWEJsTGw5dklEMGdiV0Z5YTA5dVkyVTdYRzRnSUZaMVpTNXdjbTkwYjNSNWNHVXVYMjRnUFNCMGIwNTFiV0psY2p0Y2JpQWdWblZsTG5CeWIzUnZkSGx3WlM1ZmN5QTlJRjkwYjFOMGNtbHVaenRjYmlBZ1ZuVmxMbkJ5YjNSdmRIbHdaUzVmYkNBOUlISmxibVJsY2t4cGMzUTdYRzRnSUZaMVpTNXdjbTkwYjNSNWNHVXVYM1FnUFNCeVpXNWtaWEpUYkc5ME8xeHVJQ0JXZFdVdWNISnZkRzkwZVhCbExsOXhJRDBnYkc5dmMyVkZjWFZoYkR0Y2JpQWdWblZsTG5CeWIzUnZkSGx3WlM1ZmFTQTlJR3h2YjNObFNXNWtaWGhQWmp0Y2JpQWdWblZsTG5CeWIzUnZkSGx3WlM1ZmJTQTlJSEpsYm1SbGNsTjBZWFJwWXp0Y2JpQWdWblZsTG5CeWIzUnZkSGx3WlM1ZlppQTlJSEpsYzI5c2RtVkdhV3gwWlhJN1hHNGdJRloxWlM1d2NtOTBiM1I1Y0dVdVgyc2dQU0JqYUdWamEwdGxlVU52WkdWek8xeHVJQ0JXZFdVdWNISnZkRzkwZVhCbExsOWlJRDBnWW1sdVpFOWlhbVZqZEZCeWIzQnpPMXh1SUNCV2RXVXVjSEp2ZEc5MGVYQmxMbDkySUQwZ1kzSmxZWFJsVkdWNGRGWk9iMlJsTzF4dUlDQldkV1V1Y0hKdmRHOTBlWEJsTGw5bElEMGdZM0psWVhSbFJXMXdkSGxXVG05a1pUdGNiaUFnVm5WbExuQnliM1J2ZEhsd1pTNWZkU0E5SUhKbGMyOXNkbVZUWTI5d1pXUlRiRzkwY3p0Y2JuMWNibHh1THlvZ0lDb3ZYRzVjYm1aMWJtTjBhVzl1SUdsdWFYUlFjbTkyYVdSbElDaDJiU2tnZTF4dUlDQjJZWElnY0hKdmRtbGtaU0E5SUhadExpUnZjSFJwYjI1ekxuQnliM1pwWkdVN1hHNGdJR2xtSUNod2NtOTJhV1JsS1NCN1hHNGdJQ0FnZG0wdVgzQnliM1pwWkdWa0lEMGdkSGx3Wlc5bUlIQnliM1pwWkdVZ1BUMDlJQ2RtZFc1amRHbHZiaWRjYmlBZ0lDQWdJRDhnY0hKdmRtbGtaUzVqWVd4c0tIWnRLVnh1SUNBZ0lDQWdPaUJ3Y205MmFXUmxPMXh1SUNCOVhHNTlYRzVjYm1aMWJtTjBhVzl1SUdsdWFYUkpibXBsWTNScGIyNXpJQ2gyYlNrZ2UxeHVJQ0IyWVhJZ2FXNXFaV04wSUQwZ2RtMHVKRzl3ZEdsdmJuTXVhVzVxWldOME8xeHVJQ0JwWmlBb2FXNXFaV04wS1NCN1hHNGdJQ0FnTHk4Z2FXNXFaV04wSUdseklEcGhibmtnWW1WallYVnpaU0JtYkc5M0lHbHpJRzV2ZENCemJXRnlkQ0JsYm05MVoyZ2dkRzhnWm1sbmRYSmxJRzkxZENCallXTm9aV1JjYmlBZ0lDQXZMeUJwYzBGeWNtRjVJR2hsY21WY2JpQWdJQ0IyWVhJZ2FYTkJjbkpoZVNBOUlFRnljbUY1TG1selFYSnlZWGtvYVc1cVpXTjBLVHRjYmlBZ0lDQjJZWElnYTJWNWN5QTlJR2x6UVhKeVlYbGNiaUFnSUNBZ0lEOGdhVzVxWldOMFhHNGdJQ0FnSUNBNklHaGhjMU41YldKdmJGeHVJQ0FnSUNBZ0lDQS9JRkpsWm14bFkzUXViM2R1UzJWNWN5aHBibXBsWTNRcFhHNGdJQ0FnSUNBZ0lEb2dUMkpxWldOMExtdGxlWE1vYVc1cVpXTjBLVHRjYmx4dUlDQWdJSFpoY2lCc2IyOXdJRDBnWm5WdVkzUnBiMjRnS0NCcElDa2dlMXh1SUNBZ0lDQWdkbUZ5SUd0bGVTQTlJR3RsZVhOYmFWMDdYRzRnSUNBZ0lDQjJZWElnY0hKdmRtbGtaVXRsZVNBOUlHbHpRWEp5WVhrZ1B5QnJaWGtnT2lCcGJtcGxZM1JiYTJWNVhUdGNiaUFnSUNBZ0lIWmhjaUJ6YjNWeVkyVWdQU0IyYlR0Y2JpQWdJQ0FnSUhkb2FXeGxJQ2h6YjNWeVkyVXBJSHRjYmlBZ0lDQWdJQ0FnYVdZZ0tITnZkWEpqWlM1ZmNISnZkbWxrWldRZ0ppWWdjSEp2ZG1sa1pVdGxlU0JwYmlCemIzVnlZMlV1WDNCeWIzWnBaR1ZrS1NCN1hHNGdJQ0FnSUNBZ0lDQWdMeW9nYVhOMFlXNWlkV3dnYVdkdWIzSmxJR1ZzYzJVZ0tpOWNiaUFnSUNBZ0lDQWdJQ0JwWmlBb2NISnZZMlZ6Y3k1bGJuWXVUazlFUlY5RlRsWWdJVDA5SUNkd2NtOWtkV04wYVc5dUp5a2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ1pHVm1hVzVsVW1WaFkzUnBkbVVrSkRFb2RtMHNJR3RsZVN3Z2MyOTFjbU5sTGw5d2NtOTJhV1JsWkZ0d2NtOTJhV1JsUzJWNVhTd2dablZ1WTNScGIyNGdLQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0IzWVhKdUtGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lGd2lRWFp2YVdRZ2JYVjBZWFJwYm1jZ1lXNGdhVzVxWldOMFpXUWdkbUZzZFdVZ1pHbHlaV04wYkhrZ2MybHVZMlVnZEdobElHTm9ZVzVuWlhNZ2QybHNiQ0JpWlNCY0lpQXJYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdYQ0p2ZG1WeWQzSnBkSFJsYmlCM2FHVnVaWFpsY2lCMGFHVWdjSEp2ZG1sa1pXUWdZMjl0Y0c5dVpXNTBJSEpsTFhKbGJtUmxjbk11SUZ3aUlDdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmNJbWx1YW1WamRHbHZiaUJpWldsdVp5QnRkWFJoZEdWa09pQmNYRndpWENJZ0t5QnJaWGtnS3lCY0lseGNYQ0pjSWl4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMmJWeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZlNrN1hHNGdJQ0FnSUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdSbFptbHVaVkpsWVdOMGFYWmxKQ1F4S0hadExDQnJaWGtzSUhOdmRYSmpaUzVmY0hKdmRtbGtaV1JiY0hKdmRtbGtaVXRsZVYwcE8xeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCaWNtVmhhMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUhOdmRYSmpaU0E5SUhOdmRYSmpaUzRrY0dGeVpXNTBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMDdYRzVjYmlBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR3RsZVhNdWJHVnVaM1JvT3lCcEt5c3BJR3h2YjNBb0lHa2dLVHRjYmlBZ2ZWeHVmVnh1WEc0dktpQWdLaTljYmx4dWRtRnlJSFZwWkNBOUlEQTdYRzVjYm1aMWJtTjBhVzl1SUdsdWFYUk5hWGhwYmlBb1ZuVmxLU0I3WEc0Z0lGWjFaUzV3Y205MGIzUjVjR1V1WDJsdWFYUWdQU0JtZFc1amRHbHZiaUFvYjNCMGFXOXVjeWtnZTF4dUlDQWdJSFpoY2lCMmJTQTlJSFJvYVhNN1hHNGdJQ0FnTHk4Z1lTQjFhV1JjYmlBZ0lDQjJiUzVmZFdsa0lEMGdkV2xrS3lzN1hHNWNiaUFnSUNCMllYSWdjM1JoY25SVVlXY3NJR1Z1WkZSaFp6dGNiaUFnSUNBdktpQnBjM1JoYm1KMWJDQnBaMjV2Y21VZ2FXWWdLaTljYmlBZ0lDQnBaaUFvY0hKdlkyVnpjeTVsYm5ZdVRrOUVSVjlGVGxZZ0lUMDlJQ2R3Y205a2RXTjBhVzl1SnlBbUppQmpiMjVtYVdjdWNHVnlabTl5YldGdVkyVWdKaVlnYldGeWF5a2dlMXh1SUNBZ0lDQWdjM1JoY25SVVlXY2dQU0JjSW5aMVpTMXdaWEptTFdsdWFYUTZYQ0lnS3lBb2RtMHVYM1ZwWkNrN1hHNGdJQ0FnSUNCbGJtUlVZV2NnUFNCY0luWjFaUzF3WlhKbUxXVnVaRHBjSWlBcklDaDJiUzVmZFdsa0tUdGNiaUFnSUNBZ0lHMWhjbXNvYzNSaGNuUlVZV2NwTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUdFZ1pteGhaeUIwYnlCaGRtOXBaQ0IwYUdseklHSmxhVzVuSUc5aWMyVnlkbVZrWEc0Z0lDQWdkbTB1WDJselZuVmxJRDBnZEhKMVpUdGNiaUFnSUNBdkx5QnRaWEpuWlNCdmNIUnBiMjV6WEc0Z0lDQWdhV1lnS0c5d2RHbHZibk1nSmlZZ2IzQjBhVzl1Y3k1ZmFYTkRiMjF3YjI1bGJuUXBJSHRjYmlBZ0lDQWdJQzh2SUc5d2RHbHRhWHBsSUdsdWRHVnlibUZzSUdOdmJYQnZibVZ1ZENCcGJuTjBZVzUwYVdGMGFXOXVYRzRnSUNBZ0lDQXZMeUJ6YVc1alpTQmtlVzVoYldsaklHOXdkR2x2Ym5NZ2JXVnlaMmx1WnlCcGN5QndjbVYwZEhrZ2MyeHZkeXdnWVc1a0lHNXZibVVnYjJZZ2RHaGxYRzRnSUNBZ0lDQXZMeUJwYm5SbGNtNWhiQ0JqYjIxd2IyNWxiblFnYjNCMGFXOXVjeUJ1WldWa2N5QnpjR1ZqYVdGc0lIUnlaV0YwYldWdWRDNWNiaUFnSUNBZ0lHbHVhWFJKYm5SbGNtNWhiRU52YlhCdmJtVnVkQ2gyYlN3Z2IzQjBhVzl1Y3lrN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJSFp0TGlSdmNIUnBiMjV6SUQwZ2JXVnlaMlZQY0hScGIyNXpLRnh1SUNBZ0lDQWdJQ0J5WlhOdmJIWmxRMjl1YzNSeWRXTjBiM0pQY0hScGIyNXpLSFp0TG1OdmJuTjBjblZqZEc5eUtTeGNiaUFnSUNBZ0lDQWdiM0IwYVc5dWN5QjhmQ0I3ZlN4Y2JpQWdJQ0FnSUNBZ2RtMWNiaUFnSUNBZ0lDazdYRzRnSUNBZ2ZWeHVJQ0FnSUM4cUlHbHpkR0Z1WW5Wc0lHbG5ibTl5WlNCbGJITmxJQ292WEc0Z0lDQWdhV1lnS0hCeWIyTmxjM011Wlc1MkxrNVBSRVZmUlU1V0lDRTlQU0FuY0hKdlpIVmpkR2x2YmljcElIdGNiaUFnSUNBZ0lHbHVhWFJRY205NGVTaDJiU2s3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lIWnRMbDl5Wlc1a1pYSlFjbTk0ZVNBOUlIWnRPMXh1SUNBZ0lIMWNiaUFnSUNBdkx5QmxlSEJ2YzJVZ2NtVmhiQ0J6Wld4bVhHNGdJQ0FnZG0wdVgzTmxiR1lnUFNCMmJUdGNiaUFnSUNCcGJtbDBUR2xtWldONVkyeGxLSFp0S1R0Y2JpQWdJQ0JwYm1sMFJYWmxiblJ6S0hadEtUdGNiaUFnSUNCcGJtbDBVbVZ1WkdWeUtIWnRLVHRjYmlBZ0lDQmpZV3hzU0c5dmF5aDJiU3dnSjJKbFptOXlaVU55WldGMFpTY3BPMXh1SUNBZ0lHbHVhWFJKYm1wbFkzUnBiMjV6S0hadEtUc2dMeThnY21WemIyeDJaU0JwYm1wbFkzUnBiMjV6SUdKbFptOXlaU0JrWVhSaEwzQnliM0J6WEc0Z0lDQWdhVzVwZEZOMFlYUmxLSFp0S1R0Y2JpQWdJQ0JwYm1sMFVISnZkbWxrWlNoMmJTazdJQzh2SUhKbGMyOXNkbVVnY0hKdmRtbGtaU0JoWm5SbGNpQmtZWFJoTDNCeWIzQnpYRzRnSUNBZ1kyRnNiRWh2YjJzb2RtMHNJQ2RqY21WaGRHVmtKeWs3WEc1Y2JpQWdJQ0F2S2lCcGMzUmhibUoxYkNCcFoyNXZjbVVnYVdZZ0tpOWNiaUFnSUNCcFppQW9jSEp2WTJWemN5NWxibll1VGs5RVJWOUZUbFlnSVQwOUlDZHdjbTlrZFdOMGFXOXVKeUFtSmlCamIyNW1hV2N1Y0dWeVptOXliV0Z1WTJVZ0ppWWdiV0Z5YXlrZ2UxeHVJQ0FnSUNBZ2RtMHVYMjVoYldVZ1BTQm1iM0p0WVhSRGIyMXdiMjVsYm5ST1lXMWxLSFp0TENCbVlXeHpaU2s3WEc0Z0lDQWdJQ0J0WVhKcktHVnVaRlJoWnlrN1hHNGdJQ0FnSUNCdFpXRnpkWEpsS0Nnb2RtMHVYMjVoYldVcElDc2dYQ0lnYVc1cGRGd2lLU3dnYzNSaGNuUlVZV2NzSUdWdVpGUmhaeWs3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdhV1lnS0hadExpUnZjSFJwYjI1ekxtVnNLU0I3WEc0Z0lDQWdJQ0IyYlM0a2JXOTFiblFvZG0wdUpHOXdkR2x2Ym5NdVpXd3BPMXh1SUNBZ0lIMWNiaUFnZlR0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnYVc1cGRFbHVkR1Z5Ym1Gc1EyOXRjRzl1Wlc1MElDaDJiU3dnYjNCMGFXOXVjeWtnZTF4dUlDQjJZWElnYjNCMGN5QTlJSFp0TGlSdmNIUnBiMjV6SUQwZ1QySnFaV04wTG1OeVpXRjBaU2gyYlM1amIyNXpkSEoxWTNSdmNpNXZjSFJwYjI1ektUdGNiaUFnTHk4Z1pHOXBibWNnZEdocGN5QmlaV05oZFhObElHbDBKM01nWm1GemRHVnlJSFJvWVc0Z1pIbHVZVzFwWXlCbGJuVnRaWEpoZEdsdmJpNWNiaUFnYjNCMGN5NXdZWEpsYm5RZ1BTQnZjSFJwYjI1ekxuQmhjbVZ1ZER0Y2JpQWdiM0IwY3k1d2NtOXdjMFJoZEdFZ1BTQnZjSFJwYjI1ekxuQnliM0J6UkdGMFlUdGNiaUFnYjNCMGN5NWZjR0Z5Wlc1MFZtNXZaR1VnUFNCdmNIUnBiMjV6TGw5d1lYSmxiblJXYm05a1pUdGNiaUFnYjNCMGN5NWZjR0Z5Wlc1MFRHbHpkR1Z1WlhKeklEMGdiM0IwYVc5dWN5NWZjR0Z5Wlc1MFRHbHpkR1Z1WlhKek8xeHVJQ0J2Y0hSekxsOXlaVzVrWlhKRGFHbHNaSEpsYmlBOUlHOXdkR2x2Ym5NdVgzSmxibVJsY2tOb2FXeGtjbVZ1TzF4dUlDQnZjSFJ6TGw5amIyMXdiMjVsYm5SVVlXY2dQU0J2Y0hScGIyNXpMbDlqYjIxd2IyNWxiblJVWVdjN1hHNGdJRzl3ZEhNdVgzQmhjbVZ1ZEVWc2JTQTlJRzl3ZEdsdmJuTXVYM0JoY21WdWRFVnNiVHRjYmlBZ2IzQjBjeTVmY21WbVJXeHRJRDBnYjNCMGFXOXVjeTVmY21WbVJXeHRPMXh1SUNCcFppQW9iM0IwYVc5dWN5NXlaVzVrWlhJcElIdGNiaUFnSUNCdmNIUnpMbkpsYm1SbGNpQTlJRzl3ZEdsdmJuTXVjbVZ1WkdWeU8xeHVJQ0FnSUc5d2RITXVjM1JoZEdsalVtVnVaR1Z5Um01eklEMGdiM0IwYVc5dWN5NXpkR0YwYVdOU1pXNWtaWEpHYm5NN1hHNGdJSDFjYm4xY2JseHVablZ1WTNScGIyNGdjbVZ6YjJ4MlpVTnZibk4wY25WamRHOXlUM0IwYVc5dWN5QW9RM1J2Y2lrZ2UxeHVJQ0IyWVhJZ2IzQjBhVzl1Y3lBOUlFTjBiM0l1YjNCMGFXOXVjenRjYmlBZ2FXWWdLRU4wYjNJdWMzVndaWElwSUh0Y2JpQWdJQ0IyWVhJZ2MzVndaWEpQY0hScGIyNXpJRDBnY21WemIyeDJaVU52Ym5OMGNuVmpkRzl5VDNCMGFXOXVjeWhEZEc5eUxuTjFjR1Z5S1R0Y2JpQWdJQ0IyWVhJZ1kyRmphR1ZrVTNWd1pYSlBjSFJwYjI1eklEMGdRM1J2Y2k1emRYQmxjazl3ZEdsdmJuTTdYRzRnSUNBZ2FXWWdLSE4xY0dWeVQzQjBhVzl1Y3lBaFBUMGdZMkZqYUdWa1UzVndaWEpQY0hScGIyNXpLU0I3WEc0Z0lDQWdJQ0F2THlCemRYQmxjaUJ2Y0hScGIyNGdZMmhoYm1kbFpDeGNiaUFnSUNBZ0lDOHZJRzVsWldRZ2RHOGdjbVZ6YjJ4MlpTQnVaWGNnYjNCMGFXOXVjeTVjYmlBZ0lDQWdJRU4wYjNJdWMzVndaWEpQY0hScGIyNXpJRDBnYzNWd1pYSlBjSFJwYjI1ek8xeHVJQ0FnSUNBZ0x5OGdZMmhsWTJzZ2FXWWdkR2hsY21VZ1lYSmxJR0Z1ZVNCc1lYUmxMVzF2WkdsbWFXVmtMMkYwZEdGamFHVmtJRzl3ZEdsdmJuTWdLQ00wT1RjMktWeHVJQ0FnSUNBZ2RtRnlJRzF2WkdsbWFXVmtUM0IwYVc5dWN5QTlJSEpsYzI5c2RtVk5iMlJwWm1sbFpFOXdkR2x2Ym5Nb1EzUnZjaWs3WEc0Z0lDQWdJQ0F2THlCMWNHUmhkR1VnWW1GelpTQmxlSFJsYm1RZ2IzQjBhVzl1YzF4dUlDQWdJQ0FnYVdZZ0tHMXZaR2xtYVdWa1QzQjBhVzl1Y3lrZ2UxeHVJQ0FnSUNBZ0lDQmxlSFJsYm1Rb1EzUnZjaTVsZUhSbGJtUlBjSFJwYjI1ekxDQnRiMlJwWm1sbFpFOXdkR2x2Ym5NcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2IzQjBhVzl1Y3lBOUlFTjBiM0l1YjNCMGFXOXVjeUE5SUcxbGNtZGxUM0IwYVc5dWN5aHpkWEJsY2s5d2RHbHZibk1zSUVOMGIzSXVaWGgwWlc1a1QzQjBhVzl1Y3lrN1hHNGdJQ0FnSUNCcFppQW9iM0IwYVc5dWN5NXVZVzFsS1NCN1hHNGdJQ0FnSUNBZ0lHOXdkR2x2Ym5NdVkyOXRjRzl1Wlc1MGMxdHZjSFJwYjI1ekxtNWhiV1ZkSUQwZ1EzUnZjanRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzRnSUgxY2JpQWdjbVYwZFhKdUlHOXdkR2x2Ym5OY2JuMWNibHh1Wm5WdVkzUnBiMjRnY21WemIyeDJaVTF2WkdsbWFXVmtUM0IwYVc5dWN5QW9RM1J2Y2lrZ2UxeHVJQ0IyWVhJZ2JXOWthV1pwWldRN1hHNGdJSFpoY2lCc1lYUmxjM1FnUFNCRGRHOXlMbTl3ZEdsdmJuTTdYRzRnSUhaaGNpQnpaV0ZzWldRZ1BTQkRkRzl5TG5ObFlXeGxaRTl3ZEdsdmJuTTdYRzRnSUdadmNpQW9kbUZ5SUd0bGVTQnBiaUJzWVhSbGMzUXBJSHRjYmlBZ0lDQnBaaUFvYkdGMFpYTjBXMnRsZVYwZ0lUMDlJSE5sWVd4bFpGdHJaWGxkS1NCN1hHNGdJQ0FnSUNCcFppQW9JVzF2WkdsbWFXVmtLU0I3SUcxdlpHbG1hV1ZrSUQwZ2UzMDdJSDFjYmlBZ0lDQWdJRzF2WkdsbWFXVmtXMnRsZVYwZ1BTQmtaV1IxY0dVb2JHRjBaWE4wVzJ0bGVWMHNJSE5sWVd4bFpGdHJaWGxkS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNiaUFnY21WMGRYSnVJRzF2WkdsbWFXVmtYRzU5WEc1Y2JtWjFibU4wYVc5dUlHUmxaSFZ3WlNBb2JHRjBaWE4wTENCelpXRnNaV1FwSUh0Y2JpQWdMeThnWTI5dGNHRnlaU0JzWVhSbGMzUWdZVzVrSUhObFlXeGxaQ0IwYnlCbGJuTjFjbVVnYkdsbVpXTjVZMnhsSUdodmIydHpJSGR2YmlkMElHSmxJR1IxY0d4cFkyRjBaV1JjYmlBZ0x5OGdZbVYwZDJWbGJpQnRaWEpuWlhOY2JpQWdhV1lnS0VGeWNtRjVMbWx6UVhKeVlYa29iR0YwWlhOMEtTa2dlMXh1SUNBZ0lIWmhjaUJ5WlhNZ1BTQmJYVHRjYmlBZ0lDQnpaV0ZzWldRZ1BTQkJjbkpoZVM1cGMwRnljbUY1S0hObFlXeGxaQ2tnUHlCelpXRnNaV1FnT2lCYmMyVmhiR1ZrWFR0Y2JpQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUd4aGRHVnpkQzVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ2FXWWdLSE5sWVd4bFpDNXBibVJsZUU5bUtHeGhkR1Z6ZEZ0cFhTa2dQQ0F3S1NCN1hHNGdJQ0FnSUNBZ0lISmxjeTV3ZFhOb0tHeGhkR1Z6ZEZ0cFhTazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGRIVnliaUJ5WlhOY2JpQWdmU0JsYkhObElIdGNiaUFnSUNCeVpYUjFjbTRnYkdGMFpYTjBYRzRnSUgxY2JuMWNibHh1Wm5WdVkzUnBiMjRnVm5WbEpESWdLRzl3ZEdsdmJuTXBJSHRjYmlBZ2FXWWdLSEJ5YjJObGMzTXVaVzUyTGs1UFJFVmZSVTVXSUNFOVBTQW5jSEp2WkhWamRHbHZiaWNnSmlaY2JpQWdJQ0FoS0hSb2FYTWdhVzV6ZEdGdVkyVnZaaUJXZFdVa01pa3BJSHRjYmlBZ0lDQjNZWEp1S0NkV2RXVWdhWE1nWVNCamIyNXpkSEoxWTNSdmNpQmhibVFnYzJodmRXeGtJR0psSUdOaGJHeGxaQ0IzYVhSb0lIUm9aU0JnYm1WM1lDQnJaWGwzYjNKa0p5azdYRzRnSUgxY2JpQWdkR2hwY3k1ZmFXNXBkQ2h2Y0hScGIyNXpLVHRjYm4xY2JseHVhVzVwZEUxcGVHbHVLRloxWlNReUtUdGNibk4wWVhSbFRXbDRhVzRvVm5WbEpESXBPMXh1WlhabGJuUnpUV2w0YVc0b1ZuVmxKRElwTzF4dWJHbG1aV041WTJ4bFRXbDRhVzRvVm5WbEpESXBPMXh1Y21WdVpHVnlUV2w0YVc0b1ZuVmxKRElwTzF4dVhHNHZLaUFnS2k5Y2JseHVablZ1WTNScGIyNGdhVzVwZEZWelpTQW9WblZsS1NCN1hHNGdJRloxWlM1MWMyVWdQU0JtZFc1amRHbHZiaUFvY0d4MVoybHVLU0I3WEc0Z0lDQWdMeW9nYVhOMFlXNWlkV3dnYVdkdWIzSmxJR2xtSUNvdlhHNGdJQ0FnYVdZZ0tIQnNkV2RwYmk1cGJuTjBZV3hzWldRcElIdGNiaUFnSUNBZ0lISmxkSFZ5Ymx4dUlDQWdJSDFjYmlBZ0lDQXZMeUJoWkdScGRHbHZibUZzSUhCaGNtRnRaWFJsY25OY2JpQWdJQ0IyWVhJZ1lYSm5jeUE5SUhSdlFYSnlZWGtvWVhKbmRXMWxiblJ6TENBeEtUdGNiaUFnSUNCaGNtZHpMblZ1YzJocFpuUW9kR2hwY3lrN1hHNGdJQ0FnYVdZZ0tIUjVjR1Z2WmlCd2JIVm5hVzR1YVc1emRHRnNiQ0E5UFQwZ0oyWjFibU4wYVc5dUp5a2dlMXh1SUNBZ0lDQWdjR3gxWjJsdUxtbHVjM1JoYkd3dVlYQndiSGtvY0d4MVoybHVMQ0JoY21kektUdGNiaUFnSUNCOUlHVnNjMlVnYVdZZ0tIUjVjR1Z2WmlCd2JIVm5hVzRnUFQwOUlDZG1kVzVqZEdsdmJpY3BJSHRjYmlBZ0lDQWdJSEJzZFdkcGJpNWhjSEJzZVNodWRXeHNMQ0JoY21kektUdGNiaUFnSUNCOVhHNGdJQ0FnY0d4MVoybHVMbWx1YzNSaGJHeGxaQ0E5SUhSeWRXVTdYRzRnSUNBZ2NtVjBkWEp1SUhSb2FYTmNiaUFnZlR0Y2JuMWNibHh1THlvZ0lDb3ZYRzVjYm1aMWJtTjBhVzl1SUdsdWFYUk5hWGhwYmlReElDaFdkV1VwSUh0Y2JpQWdWblZsTG0xcGVHbHVJRDBnWm5WdVkzUnBiMjRnS0cxcGVHbHVLU0I3WEc0Z0lDQWdkR2hwY3k1dmNIUnBiMjV6SUQwZ2JXVnlaMlZQY0hScGIyNXpLSFJvYVhNdWIzQjBhVzl1Y3l3Z2JXbDRhVzRwTzF4dUlDQjlPMXh1ZlZ4dVhHNHZLaUFnS2k5Y2JseHVablZ1WTNScGIyNGdhVzVwZEVWNGRHVnVaQ0FvVm5WbEtTQjdYRzRnSUM4cUtseHVJQ0FnS2lCRllXTm9JR2x1YzNSaGJtTmxJR052Ym5OMGNuVmpkRzl5TENCcGJtTnNkV1JwYm1jZ1ZuVmxMQ0JvWVhNZ1lTQjFibWx4ZFdWY2JpQWdJQ29nWTJsa0xpQlVhR2x6SUdWdVlXSnNaWE1nZFhNZ2RHOGdZM0psWVhSbElIZHlZWEJ3WldRZ1hDSmphR2xzWkZ4dUlDQWdLaUJqYjI1emRISjFZM1J2Y25OY0lpQm1iM0lnY0hKdmRHOTBlWEJoYkNCcGJtaGxjbWwwWVc1alpTQmhibVFnWTJGamFHVWdkR2hsYlM1Y2JpQWdJQ292WEc0Z0lGWjFaUzVqYVdRZ1BTQXdPMXh1SUNCMllYSWdZMmxrSUQwZ01UdGNibHh1SUNBdktpcGNiaUFnSUNvZ1EyeGhjM01nYVc1b1pYSnBkR0Z1WTJWY2JpQWdJQ292WEc0Z0lGWjFaUzVsZUhSbGJtUWdQU0JtZFc1amRHbHZiaUFvWlhoMFpXNWtUM0IwYVc5dWN5a2dlMXh1SUNBZ0lHVjRkR1Z1WkU5d2RHbHZibk1nUFNCbGVIUmxibVJQY0hScGIyNXpJSHg4SUh0OU8xeHVJQ0FnSUhaaGNpQlRkWEJsY2lBOUlIUm9hWE03WEc0Z0lDQWdkbUZ5SUZOMWNHVnlTV1FnUFNCVGRYQmxjaTVqYVdRN1hHNGdJQ0FnZG1GeUlHTmhZMmhsWkVOMGIzSnpJRDBnWlhoMFpXNWtUM0IwYVc5dWN5NWZRM1J2Y2lCOGZDQW9aWGgwWlc1a1QzQjBhVzl1Y3k1ZlEzUnZjaUE5SUh0OUtUdGNiaUFnSUNCcFppQW9ZMkZqYUdWa1EzUnZjbk5iVTNWd1pYSkpaRjBwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJqWVdOb1pXUkRkRzl5YzF0VGRYQmxja2xrWFZ4dUlDQWdJSDFjYmx4dUlDQWdJSFpoY2lCdVlXMWxJRDBnWlhoMFpXNWtUM0IwYVc5dWN5NXVZVzFsSUh4OElGTjFjR1Z5TG05d2RHbHZibk11Ym1GdFpUdGNiaUFnSUNCcFppQW9jSEp2WTJWemN5NWxibll1VGs5RVJWOUZUbFlnSVQwOUlDZHdjbTlrZFdOMGFXOXVKeWtnZTF4dUlDQWdJQ0FnYVdZZ0tDRXZYbHRoTFhwQkxWcGRXMXhjZHkxZEtpUXZMblJsYzNRb2JtRnRaU2twSUh0Y2JpQWdJQ0FnSUNBZ2QyRnliaWhjYmlBZ0lDQWdJQ0FnSUNBblNXNTJZV3hwWkNCamIyMXdiMjVsYm5RZ2JtRnRaVG9nWENJbklDc2dibUZ0WlNBcklDZGNJaTRnUTI5dGNHOXVaVzUwSUc1aGJXVnpJQ2NnSzF4dUlDQWdJQ0FnSUNBZ0lDZGpZVzRnYjI1c2VTQmpiMjUwWVdsdUlHRnNjR2hoYm5WdFpYSnBZeUJqYUdGeVlXTjBaWEp6SUdGdVpDQjBhR1VnYUhsd2FHVnVMQ0FuSUN0Y2JpQWdJQ0FnSUNBZ0lDQW5ZVzVrSUcxMWMzUWdjM1JoY25RZ2QybDBhQ0JoSUd4bGRIUmxjaTRuWEc0Z0lDQWdJQ0FnSUNrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dVhHNGdJQ0FnZG1GeUlGTjFZaUE5SUdaMWJtTjBhVzl1SUZaMVpVTnZiWEJ2Ym1WdWRDQW9iM0IwYVc5dWN5a2dlMXh1SUNBZ0lDQWdkR2hwY3k1ZmFXNXBkQ2h2Y0hScGIyNXpLVHRjYmlBZ0lDQjlPMXh1SUNBZ0lGTjFZaTV3Y205MGIzUjVjR1VnUFNCUFltcGxZM1F1WTNKbFlYUmxLRk4xY0dWeUxuQnliM1J2ZEhsd1pTazdYRzRnSUNBZ1UzVmlMbkJ5YjNSdmRIbHdaUzVqYjI1emRISjFZM1J2Y2lBOUlGTjFZanRjYmlBZ0lDQlRkV0l1WTJsa0lEMGdZMmxrS3lzN1hHNGdJQ0FnVTNWaUxtOXdkR2x2Ym5NZ1BTQnRaWEpuWlU5d2RHbHZibk1vWEc0Z0lDQWdJQ0JUZFhCbGNpNXZjSFJwYjI1ekxGeHVJQ0FnSUNBZ1pYaDBaVzVrVDNCMGFXOXVjMXh1SUNBZ0lDazdYRzRnSUNBZ1UzVmlXeWR6ZFhCbGNpZGRJRDBnVTNWd1pYSTdYRzVjYmlBZ0lDQXZMeUJHYjNJZ2NISnZjSE1nWVc1a0lHTnZiWEIxZEdWa0lIQnliM0JsY25ScFpYTXNJSGRsSUdSbFptbHVaU0IwYUdVZ2NISnZlSGtnWjJWMGRHVnljeUJ2Ymx4dUlDQWdJQzh2SUhSb1pTQldkV1VnYVc1emRHRnVZMlZ6SUdGMElHVjRkR1Z1YzJsdmJpQjBhVzFsTENCdmJpQjBhR1VnWlhoMFpXNWtaV1FnY0hKdmRHOTBlWEJsTGlCVWFHbHpYRzRnSUNBZ0x5OGdZWFp2YVdSeklFOWlhbVZqZEM1a1pXWnBibVZRY205d1pYSjBlU0JqWVd4c2N5Qm1iM0lnWldGamFDQnBibk4wWVc1alpTQmpjbVZoZEdWa0xseHVJQ0FnSUdsbUlDaFRkV0l1YjNCMGFXOXVjeTV3Y205d2N5a2dlMXh1SUNBZ0lDQWdhVzVwZEZCeWIzQnpKREVvVTNWaUtUdGNiaUFnSUNCOVhHNGdJQ0FnYVdZZ0tGTjFZaTV2Y0hScGIyNXpMbU52YlhCMWRHVmtLU0I3WEc0Z0lDQWdJQ0JwYm1sMFEyOXRjSFYwWldRa01TaFRkV0lwTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUdGc2JHOTNJR1oxY25Sb1pYSWdaWGgwWlc1emFXOXVMMjFwZUdsdUwzQnNkV2RwYmlCMWMyRm5aVnh1SUNBZ0lGTjFZaTVsZUhSbGJtUWdQU0JUZFhCbGNpNWxlSFJsYm1RN1hHNGdJQ0FnVTNWaUxtMXBlR2x1SUQwZ1UzVndaWEl1YldsNGFXNDdYRzRnSUNBZ1UzVmlMblZ6WlNBOUlGTjFjR1Z5TG5WelpUdGNibHh1SUNBZ0lDOHZJR055WldGMFpTQmhjM05sZENCeVpXZHBjM1JsY25Nc0lITnZJR1Y0ZEdWdVpHVmtJR05zWVhOelpYTmNiaUFnSUNBdkx5QmpZVzRnYUdGMlpTQjBhR1ZwY2lCd2NtbDJZWFJsSUdGemMyVjBjeUIwYjI4dVhHNGdJQ0FnWTI5dVptbG5MbDloYzNObGRGUjVjR1Z6TG1admNrVmhZMmdvWm5WdVkzUnBiMjRnS0hSNWNHVXBJSHRjYmlBZ0lDQWdJRk4xWWx0MGVYQmxYU0E5SUZOMWNHVnlXM1I1Y0dWZE8xeHVJQ0FnSUgwcE8xeHVJQ0FnSUM4dklHVnVZV0pzWlNCeVpXTjFjbk5wZG1VZ2MyVnNaaTFzYjI5cmRYQmNiaUFnSUNCcFppQW9ibUZ0WlNrZ2UxeHVJQ0FnSUNBZ1UzVmlMbTl3ZEdsdmJuTXVZMjl0Y0c5dVpXNTBjMXR1WVcxbFhTQTlJRk4xWWp0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCclpXVndJR0VnY21WbVpYSmxibU5sSUhSdklIUm9aU0J6ZFhCbGNpQnZjSFJwYjI1eklHRjBJR1Y0ZEdWdWMybHZiaUIwYVcxbExseHVJQ0FnSUM4dklHeGhkR1Z5SUdGMElHbHVjM1JoYm5ScFlYUnBiMjRnZDJVZ1kyRnVJR05vWldOcklHbG1JRk4xY0dWeUozTWdiM0IwYVc5dWN5Qm9ZWFpsWEc0Z0lDQWdMeThnWW1WbGJpQjFjR1JoZEdWa0xseHVJQ0FnSUZOMVlpNXpkWEJsY2s5d2RHbHZibk1nUFNCVGRYQmxjaTV2Y0hScGIyNXpPMXh1SUNBZ0lGTjFZaTVsZUhSbGJtUlBjSFJwYjI1eklEMGdaWGgwWlc1a1QzQjBhVzl1Y3p0Y2JpQWdJQ0JUZFdJdWMyVmhiR1ZrVDNCMGFXOXVjeUE5SUdWNGRHVnVaQ2g3ZlN3Z1UzVmlMbTl3ZEdsdmJuTXBPMXh1WEc0Z0lDQWdMeThnWTJGamFHVWdZMjl1YzNSeWRXTjBiM0pjYmlBZ0lDQmpZV05vWldSRGRHOXljMXRUZFhCbGNrbGtYU0E5SUZOMVlqdGNiaUFnSUNCeVpYUjFjbTRnVTNWaVhHNGdJSDA3WEc1OVhHNWNibVoxYm1OMGFXOXVJR2x1YVhSUWNtOXdjeVF4SUNoRGIyMXdLU0I3WEc0Z0lIWmhjaUJ3Y205d2N5QTlJRU52YlhBdWIzQjBhVzl1Y3k1d2NtOXdjenRjYmlBZ1ptOXlJQ2gyWVhJZ2EyVjVJR2x1SUhCeWIzQnpLU0I3WEc0Z0lDQWdjSEp2ZUhrb1EyOXRjQzV3Y205MGIzUjVjR1VzSUZ3aVgzQnliM0J6WENJc0lHdGxlU2s3WEc0Z0lIMWNibjFjYmx4dVpuVnVZM1JwYjI0Z2FXNXBkRU52YlhCMWRHVmtKREVnS0VOdmJYQXBJSHRjYmlBZ2RtRnlJR052YlhCMWRHVmtJRDBnUTI5dGNDNXZjSFJwYjI1ekxtTnZiWEIxZEdWa08xeHVJQ0JtYjNJZ0tIWmhjaUJyWlhrZ2FXNGdZMjl0Y0hWMFpXUXBJSHRjYmlBZ0lDQmtaV1pwYm1WRGIyMXdkWFJsWkNoRGIyMXdMbkJ5YjNSdmRIbHdaU3dnYTJWNUxDQmpiMjF3ZFhSbFpGdHJaWGxkS1R0Y2JpQWdmVnh1ZlZ4dVhHNHZLaUFnS2k5Y2JseHVablZ1WTNScGIyNGdhVzVwZEVGemMyVjBVbVZuYVhOMFpYSnpJQ2hXZFdVcElIdGNiaUFnTHlvcVhHNGdJQ0FxSUVOeVpXRjBaU0JoYzNObGRDQnlaV2RwYzNSeVlYUnBiMjRnYldWMGFHOWtjeTVjYmlBZ0lDb3ZYRzRnSUdOdmJtWnBaeTVmWVhOelpYUlVlWEJsY3k1bWIzSkZZV05vS0daMWJtTjBhVzl1SUNoMGVYQmxLU0I3WEc0Z0lDQWdWblZsVzNSNWNHVmRJRDBnWm5WdVkzUnBiMjRnS0Z4dUlDQWdJQ0FnYVdRc1hHNGdJQ0FnSUNCa1pXWnBibWwwYVc5dVhHNGdJQ0FnS1NCN1hHNGdJQ0FnSUNCcFppQW9JV1JsWm1sdWFYUnBiMjRwSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXViM0IwYVc5dWMxdDBlWEJsSUNzZ0ozTW5YVnRwWkYxY2JpQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUM4cUlHbHpkR0Z1WW5Wc0lHbG5ibTl5WlNCcFppQXFMMXh1SUNBZ0lDQWdJQ0JwWmlBb2NISnZZMlZ6Y3k1bGJuWXVUazlFUlY5RlRsWWdJVDA5SUNkd2NtOWtkV04wYVc5dUp5a2dlMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDaDBlWEJsSUQwOVBTQW5ZMjl0Y0c5dVpXNTBKeUFtSmlCamIyNW1hV2N1YVhOU1pYTmxjblpsWkZSaFp5aHBaQ2twSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSGRoY200b1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNkRWJ5QnViM1FnZFhObElHSjFhV3gwTFdsdUlHOXlJSEpsYzJWeWRtVmtJRWhVVFV3Z1pXeGxiV1Z1ZEhNZ1lYTWdZMjl0Y0c5dVpXNTBJQ2NnSzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FuYVdRNklDY2dLeUJwWkZ4dUlDQWdJQ0FnSUNBZ0lDQWdLVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdhV1lnS0hSNWNHVWdQVDA5SUNkamIyMXdiMjVsYm5RbklDWW1JR2x6VUd4aGFXNVBZbXBsWTNRb1pHVm1hVzVwZEdsdmJpa3BJSHRjYmlBZ0lDQWdJQ0FnSUNCa1pXWnBibWwwYVc5dUxtNWhiV1VnUFNCa1pXWnBibWwwYVc5dUxtNWhiV1VnZkh3Z2FXUTdYRzRnSUNBZ0lDQWdJQ0FnWkdWbWFXNXBkR2x2YmlBOUlIUm9hWE11YjNCMGFXOXVjeTVmWW1GelpTNWxlSFJsYm1Rb1pHVm1hVzVwZEdsdmJpazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnYVdZZ0tIUjVjR1VnUFQwOUlDZGthWEpsWTNScGRtVW5JQ1ltSUhSNWNHVnZaaUJrWldacGJtbDBhVzl1SUQwOVBTQW5ablZ1WTNScGIyNG5LU0I3WEc0Z0lDQWdJQ0FnSUNBZ1pHVm1hVzVwZEdsdmJpQTlJSHNnWW1sdVpEb2daR1ZtYVc1cGRHbHZiaXdnZFhCa1lYUmxPaUJrWldacGJtbDBhVzl1SUgwN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdkR2hwY3k1dmNIUnBiMjV6VzNSNWNHVWdLeUFuY3lkZFcybGtYU0E5SUdSbFptbHVhWFJwYjI0N1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCa1pXWnBibWwwYVc5dVhHNGdJQ0FnSUNCOVhHNGdJQ0FnZlR0Y2JpQWdmU2s3WEc1OVhHNWNiaThxSUNBcUwxeHVYRzUyWVhJZ2NHRjBkR1Z5YmxSNWNHVnpJRDBnVzFOMGNtbHVaeXdnVW1WblJYaHdYVHRjYmx4dVpuVnVZM1JwYjI0Z1oyVjBRMjl0Y0c5dVpXNTBUbUZ0WlNBb2IzQjBjeWtnZTF4dUlDQnlaWFIxY200Z2IzQjBjeUFtSmlBb2IzQjBjeTVEZEc5eUxtOXdkR2x2Ym5NdWJtRnRaU0I4ZkNCdmNIUnpMblJoWnlsY2JuMWNibHh1Wm5WdVkzUnBiMjRnYldGMFkyaGxjeUFvY0dGMGRHVnliaXdnYm1GdFpTa2dlMXh1SUNCcFppQW9kSGx3Wlc5bUlIQmhkSFJsY200Z1BUMDlJQ2R6ZEhKcGJtY25LU0I3WEc0Z0lDQWdjbVYwZFhKdUlIQmhkSFJsY200dWMzQnNhWFFvSnl3bktTNXBibVJsZUU5bUtHNWhiV1VwSUQ0Z0xURmNiaUFnZlNCbGJITmxJR2xtSUNod1lYUjBaWEp1SUdsdWMzUmhibU5sYjJZZ1VtVm5SWGh3S1NCN1hHNGdJQ0FnY21WMGRYSnVJSEJoZEhSbGNtNHVkR1Z6ZENodVlXMWxLVnh1SUNCOVhHNGdJQzhxSUdsemRHRnVZblZzSUdsbmJtOXlaU0J1WlhoMElDb3ZYRzRnSUhKbGRIVnliaUJtWVd4elpWeHVmVnh1WEc1bWRXNWpkR2x2YmlCd2NuVnVaVU5oWTJobElDaGpZV05vWlN3Z1ptbHNkR1Z5S1NCN1hHNGdJR1p2Y2lBb2RtRnlJR3RsZVNCcGJpQmpZV05vWlNrZ2UxeHVJQ0FnSUhaaGNpQmpZV05vWldST2IyUmxJRDBnWTJGamFHVmJhMlY1WFR0Y2JpQWdJQ0JwWmlBb1kyRmphR1ZrVG05a1pTa2dlMXh1SUNBZ0lDQWdkbUZ5SUc1aGJXVWdQU0JuWlhSRGIyMXdiMjVsYm5ST1lXMWxLR05oWTJobFpFNXZaR1V1WTI5dGNHOXVaVzUwVDNCMGFXOXVjeWs3WEc0Z0lDQWdJQ0JwWmlBb2JtRnRaU0FtSmlBaFptbHNkR1Z5S0c1aGJXVXBLU0I3WEc0Z0lDQWdJQ0FnSUhCeWRXNWxRMkZqYUdWRmJuUnllU2hqWVdOb1pXUk9iMlJsS1R0Y2JpQWdJQ0FnSUNBZ1kyRmphR1ZiYTJWNVhTQTlJRzUxYkd3N1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dUlDQjlYRzU5WEc1Y2JtWjFibU4wYVc5dUlIQnlkVzVsUTJGamFHVkZiblJ5ZVNBb2RtNXZaR1VwSUh0Y2JpQWdhV1lnS0hadWIyUmxLU0I3WEc0Z0lDQWdhV1lnS0NGMmJtOWtaUzVqYjIxd2IyNWxiblJKYm5OMFlXNWpaUzVmYVc1aFkzUnBkbVVwSUh0Y2JpQWdJQ0FnSUdOaGJHeEliMjlyS0hadWIyUmxMbU52YlhCdmJtVnVkRWx1YzNSaGJtTmxMQ0FuWkdWaFkzUnBkbUYwWldRbktUdGNiaUFnSUNCOVhHNGdJQ0FnZG01dlpHVXVZMjl0Y0c5dVpXNTBTVzV6ZEdGdVkyVXVKR1JsYzNSeWIza29LVHRjYmlBZ2ZWeHVmVnh1WEc1MllYSWdTMlZsY0VGc2FYWmxJRDBnZTF4dUlDQnVZVzFsT2lBbmEyVmxjQzFoYkdsMlpTY3NYRzRnSUdGaWMzUnlZV04wT2lCMGNuVmxMRnh1WEc0Z0lIQnliM0J6T2lCN1hHNGdJQ0FnYVc1amJIVmtaVG9nY0dGMGRHVnlibFI1Y0dWekxGeHVJQ0FnSUdWNFkyeDFaR1U2SUhCaGRIUmxjbTVVZVhCbGMxeHVJQ0I5TEZ4dVhHNGdJR055WldGMFpXUTZJR1oxYm1OMGFXOXVJR055WldGMFpXUWdLQ2tnZTF4dUlDQWdJSFJvYVhNdVkyRmphR1VnUFNCUFltcGxZM1F1WTNKbFlYUmxLRzUxYkd3cE8xeHVJQ0I5TEZ4dVhHNGdJR1JsYzNSeWIzbGxaRG9nWm5WdVkzUnBiMjRnWkdWemRISnZlV1ZrSUNncElIdGNiaUFnSUNCMllYSWdkR2hwY3lReElEMGdkR2hwY3p0Y2JseHVJQ0FnSUdadmNpQW9kbUZ5SUd0bGVTQnBiaUIwYUdsekpERXVZMkZqYUdVcElIdGNiaUFnSUNBZ0lIQnlkVzVsUTJGamFHVkZiblJ5ZVNoMGFHbHpKREV1WTJGamFHVmJhMlY1WFNrN1hHNGdJQ0FnZlZ4dUlDQjlMRnh1WEc0Z0lIZGhkR05vT2lCN1hHNGdJQ0FnYVc1amJIVmtaVG9nWm5WdVkzUnBiMjRnYVc1amJIVmtaU0FvZG1Gc0tTQjdYRzRnSUNBZ0lDQndjblZ1WlVOaFkyaGxLSFJvYVhNdVkyRmphR1VzSUdaMWJtTjBhVzl1SUNodVlXMWxLU0I3SUhKbGRIVnliaUJ0WVhSamFHVnpLSFpoYkN3Z2JtRnRaU2s3SUgwcE8xeHVJQ0FnSUgwc1hHNGdJQ0FnWlhoamJIVmtaVG9nWm5WdVkzUnBiMjRnWlhoamJIVmtaU0FvZG1Gc0tTQjdYRzRnSUNBZ0lDQndjblZ1WlVOaFkyaGxLSFJvYVhNdVkyRmphR1VzSUdaMWJtTjBhVzl1SUNodVlXMWxLU0I3SUhKbGRIVnliaUFoYldGMFkyaGxjeWgyWVd3c0lHNWhiV1VwT3lCOUtUdGNiaUFnSUNCOVhHNGdJSDBzWEc1Y2JpQWdjbVZ1WkdWeU9pQm1kVzVqZEdsdmJpQnlaVzVrWlhJZ0tDa2dlMXh1SUNBZ0lIWmhjaUIyYm05a1pTQTlJR2RsZEVacGNuTjBRMjl0Y0c5dVpXNTBRMmhwYkdRb2RHaHBjeTRrYzJ4dmRITXVaR1ZtWVhWc2RDazdYRzRnSUNBZ2RtRnlJR052YlhCdmJtVnVkRTl3ZEdsdmJuTWdQU0IyYm05a1pTQW1KaUIyYm05a1pTNWpiMjF3YjI1bGJuUlBjSFJwYjI1ek8xeHVJQ0FnSUdsbUlDaGpiMjF3YjI1bGJuUlBjSFJwYjI1ektTQjdYRzRnSUNBZ0lDQXZMeUJqYUdWamF5QndZWFIwWlhKdVhHNGdJQ0FnSUNCMllYSWdibUZ0WlNBOUlHZGxkRU52YlhCdmJtVnVkRTVoYldVb1kyOXRjRzl1Wlc1MFQzQjBhVzl1Y3lrN1hHNGdJQ0FnSUNCcFppQW9ibUZ0WlNBbUppQW9YRzRnSUNBZ0lDQWdJQ2gwYUdsekxtbHVZMngxWkdVZ0ppWWdJVzFoZEdOb1pYTW9kR2hwY3k1cGJtTnNkV1JsTENCdVlXMWxLU2tnZkh4Y2JpQWdJQ0FnSUNBZ0tIUm9hWE11WlhoamJIVmtaU0FtSmlCdFlYUmphR1Z6S0hSb2FYTXVaWGhqYkhWa1pTd2dibUZ0WlNrcFhHNGdJQ0FnSUNBcEtTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjJibTlrWlZ4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnZG1GeUlHdGxlU0E5SUhadWIyUmxMbXRsZVNBOVBTQnVkV3hzWEc0Z0lDQWdJQ0FnSUM4dklITmhiV1VnWTI5dWMzUnlkV04wYjNJZ2JXRjVJR2RsZENCeVpXZHBjM1JsY21Wa0lHRnpJR1JwWm1abGNtVnVkQ0JzYjJOaGJDQmpiMjF3YjI1bGJuUnpYRzRnSUNBZ0lDQWdJQzh2SUhOdklHTnBaQ0JoYkc5dVpTQnBjeUJ1YjNRZ1pXNXZkV2RvSUNnak16STJPU2xjYmlBZ0lDQWdJQ0FnUHlCamIyMXdiMjVsYm5SUGNIUnBiMjV6TGtOMGIzSXVZMmxrSUNzZ0tHTnZiWEJ2Ym1WdWRFOXdkR2x2Ym5NdWRHRm5JRDhnS0Z3aU9qcGNJaUFySUNoamIyMXdiMjVsYm5SUGNIUnBiMjV6TG5SaFp5a3BJRG9nSnljcFhHNGdJQ0FnSUNBZ0lEb2dkbTV2WkdVdWEyVjVPMXh1SUNBZ0lDQWdhV1lnS0hSb2FYTXVZMkZqYUdWYmEyVjVYU2tnZTF4dUlDQWdJQ0FnSUNCMmJtOWtaUzVqYjIxd2IyNWxiblJKYm5OMFlXNWpaU0E5SUhSb2FYTXVZMkZqYUdWYmEyVjVYUzVqYjIxd2IyNWxiblJKYm5OMFlXNWpaVHRjYmlBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdVkyRmphR1ZiYTJWNVhTQTlJSFp1YjJSbE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2RtNXZaR1V1WkdGMFlTNXJaV1Z3UVd4cGRtVWdQU0IwY25WbE8xeHVJQ0FnSUgxY2JpQWdJQ0J5WlhSMWNtNGdkbTV2WkdWY2JpQWdmVnh1ZlR0Y2JseHVkbUZ5SUdKMWFXeDBTVzVEYjIxd2IyNWxiblJ6SUQwZ2UxeHVJQ0JMWldWd1FXeHBkbVU2SUV0bFpYQkJiR2wyWlZ4dWZUdGNibHh1THlvZ0lDb3ZYRzVjYm1aMWJtTjBhVzl1SUdsdWFYUkhiRzlpWVd4QlVFa2dLRloxWlNrZ2UxeHVJQ0F2THlCamIyNW1hV2RjYmlBZ2RtRnlJR052Ym1acFowUmxaaUE5SUh0OU8xeHVJQ0JqYjI1bWFXZEVaV1l1WjJWMElEMGdablZ1WTNScGIyNGdLQ2tnZXlCeVpYUjFjbTRnWTI5dVptbG5PeUI5TzF4dUlDQnBaaUFvY0hKdlkyVnpjeTVsYm5ZdVRrOUVSVjlGVGxZZ0lUMDlJQ2R3Y205a2RXTjBhVzl1SnlrZ2UxeHVJQ0FnSUdOdmJtWnBaMFJsWmk1elpYUWdQU0JtZFc1amRHbHZiaUFvS1NCN1hHNGdJQ0FnSUNCM1lYSnVLRnh1SUNBZ0lDQWdJQ0FuUkc4Z2JtOTBJSEpsY0d4aFkyVWdkR2hsSUZaMVpTNWpiMjVtYVdjZ2IySnFaV04wTENCelpYUWdhVzVrYVhacFpIVmhiQ0JtYVdWc1pITWdhVzV6ZEdWaFpDNG5YRzRnSUNBZ0lDQXBPMXh1SUNBZ0lIMDdYRzRnSUgxY2JpQWdUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblI1S0ZaMVpTd2dKMk52Ym1acFp5Y3NJR052Ym1acFowUmxaaWs3WEc1Y2JpQWdMeThnWlhod2IzTmxaQ0IxZEdsc0lHMWxkR2h2WkhNdVhHNGdJQzh2SUU1UFZFVTZJSFJvWlhObElHRnlaU0J1YjNRZ1kyOXVjMmxrWlhKbFpDQndZWEowSUc5bUlIUm9aU0J3ZFdKc2FXTWdRVkJKSUMwZ1lYWnZhV1FnY21Wc2VXbHVaeUJ2Ymx4dUlDQXZMeUIwYUdWdElIVnViR1Z6Y3lCNWIzVWdZWEpsSUdGM1lYSmxJRzltSUhSb1pTQnlhWE5yTGx4dUlDQldkV1V1ZFhScGJDQTlJSHRjYmlBZ0lDQjNZWEp1T2lCM1lYSnVMRnh1SUNBZ0lHVjRkR1Z1WkRvZ1pYaDBaVzVrTEZ4dUlDQWdJRzFsY21kbFQzQjBhVzl1Y3pvZ2JXVnlaMlZQY0hScGIyNXpMRnh1SUNBZ0lHUmxabWx1WlZKbFlXTjBhWFpsT2lCa1pXWnBibVZTWldGamRHbDJaU1FrTVZ4dUlDQjlPMXh1WEc0Z0lGWjFaUzV6WlhRZ1BTQnpaWFE3WEc0Z0lGWjFaUzVrWld4bGRHVWdQU0JrWld3N1hHNGdJRloxWlM1dVpYaDBWR2xqYXlBOUlHNWxlSFJVYVdOck8xeHVYRzRnSUZaMVpTNXZjSFJwYjI1eklEMGdUMkpxWldOMExtTnlaV0YwWlNodWRXeHNLVHRjYmlBZ1kyOXVabWxuTGw5aGMzTmxkRlI1Y0dWekxtWnZja1ZoWTJnb1puVnVZM1JwYjI0Z0tIUjVjR1VwSUh0Y2JpQWdJQ0JXZFdVdWIzQjBhVzl1YzF0MGVYQmxJQ3NnSjNNblhTQTlJRTlpYW1WamRDNWpjbVZoZEdVb2JuVnNiQ2s3WEc0Z0lIMHBPMXh1WEc0Z0lDOHZJSFJvYVhNZ2FYTWdkWE5sWkNCMGJ5QnBaR1Z1ZEdsbWVTQjBhR1VnWENKaVlYTmxYQ0lnWTI5dWMzUnlkV04wYjNJZ2RHOGdaWGgwWlc1a0lHRnNiQ0J3YkdGcGJpMXZZbXBsWTNSY2JpQWdMeThnWTI5dGNHOXVaVzUwY3lCM2FYUm9JR2x1SUZkbFpYZ25jeUJ0ZFd4MGFTMXBibk4wWVc1alpTQnpZMlZ1WVhKcGIzTXVYRzRnSUZaMVpTNXZjSFJwYjI1ekxsOWlZWE5sSUQwZ1ZuVmxPMXh1WEc0Z0lHVjRkR1Z1WkNoV2RXVXViM0IwYVc5dWN5NWpiMjF3YjI1bGJuUnpMQ0JpZFdsc2RFbHVRMjl0Y0c5dVpXNTBjeWs3WEc1Y2JpQWdhVzVwZEZWelpTaFdkV1VwTzF4dUlDQnBibWwwVFdsNGFXNGtNU2hXZFdVcE8xeHVJQ0JwYm1sMFJYaDBaVzVrS0ZaMVpTazdYRzRnSUdsdWFYUkJjM05sZEZKbFoybHpkR1Z5Y3loV2RXVXBPMXh1ZlZ4dVhHNXBibWwwUjJ4dlltRnNRVkJKS0ZaMVpTUXlLVHRjYmx4dVQySnFaV04wTG1SbFptbHVaVkJ5YjNCbGNuUjVLRloxWlNReUxuQnliM1J2ZEhsd1pTd2dKeVJwYzFObGNuWmxjaWNzSUh0Y2JpQWdaMlYwT2lCcGMxTmxjblpsY2xKbGJtUmxjbWx1WjF4dWZTazdYRzVjYmxaMVpTUXlMblpsY25OcGIyNGdQU0FuTWk0eUxqWW5PMXh1WEc0dktpQWdLaTljYmx4dUx5OGdZWFIwY21saWRYUmxjeUIwYUdGMElITm9iM1ZzWkNCaVpTQjFjMmx1WnlCd2NtOXdjeUJtYjNJZ1ltbHVaR2x1WjF4dWRtRnlJR0ZqWTJWd2RGWmhiSFZsSUQwZ2JXRnJaVTFoY0NnbmFXNXdkWFFzZEdWNGRHRnlaV0VzYjNCMGFXOXVMSE5sYkdWamRDY3BPMXh1ZG1GeUlHMTFjM1JWYzJWUWNtOXdJRDBnWm5WdVkzUnBiMjRnS0hSaFp5d2dkSGx3WlN3Z1lYUjBjaWtnZTF4dUlDQnlaWFIxY200Z0tGeHVJQ0FnSUNoaGRIUnlJRDA5UFNBbmRtRnNkV1VuSUNZbUlHRmpZMlZ3ZEZaaGJIVmxLSFJoWnlrcElDWW1JSFI1Y0dVZ0lUMDlJQ2RpZFhSMGIyNG5JSHg4WEc0Z0lDQWdLR0YwZEhJZ1BUMDlJQ2R6Wld4bFkzUmxaQ2NnSmlZZ2RHRm5JRDA5UFNBbmIzQjBhVzl1SnlrZ2ZIeGNiaUFnSUNBb1lYUjBjaUE5UFQwZ0oyTm9aV05yWldRbklDWW1JSFJoWnlBOVBUMGdKMmx1Y0hWMEp5a2dmSHhjYmlBZ0lDQW9ZWFIwY2lBOVBUMGdKMjExZEdWa0p5QW1KaUIwWVdjZ1BUMDlJQ2QyYVdSbGJ5Y3BYRzRnSUNsY2JuMDdYRzVjYm5aaGNpQnBjMFZ1ZFcxbGNtRjBaV1JCZEhSeUlEMGdiV0ZyWlUxaGNDZ25ZMjl1ZEdWdWRHVmthWFJoWW14bExHUnlZV2RuWVdKc1pTeHpjR1ZzYkdOb1pXTnJKeWs3WEc1Y2JuWmhjaUJwYzBKdmIyeGxZVzVCZEhSeUlEMGdiV0ZyWlUxaGNDaGNiaUFnSjJGc2JHOTNablZzYkhOamNtVmxiaXhoYzNsdVl5eGhkWFJ2Wm05amRYTXNZWFYwYjNCc1lYa3NZMmhsWTJ0bFpDeGpiMjF3WVdOMExHTnZiblJ5YjJ4ekxHUmxZMnhoY21Vc0p5QXJYRzRnSUNka1pXWmhkV3gwTEdSbFptRjFiSFJqYUdWamEyVmtMR1JsWm1GMWJIUnRkWFJsWkN4a1pXWmhkV3gwYzJWc1pXTjBaV1FzWkdWbVpYSXNaR2x6WVdKc1pXUXNKeUFyWEc0Z0lDZGxibUZpYkdWa0xHWnZjbTF1YjNaaGJHbGtZWFJsTEdocFpHUmxiaXhwYm1SbGRHVnliV2x1WVhSbExHbHVaWEowTEdsemJXRndMR2wwWlcxelkyOXdaU3hzYjI5d0xHMTFiSFJwY0d4bExDY2dLMXh1SUNBbmJYVjBaV1FzYm05b2NtVm1MRzV2Y21WemFYcGxMRzV2YzJoaFpHVXNibTkyWVd4cFpHRjBaU3h1YjNkeVlYQXNiM0JsYml4d1lYVnpaVzl1WlhocGRDeHlaV0ZrYjI1c2VTd25JQ3RjYmlBZ0ozSmxjWFZwY21Wa0xISmxkbVZ5YzJWa0xITmpiM0JsWkN4elpXRnRiR1Z6Y3l4elpXeGxZM1JsWkN4emIzSjBZV0pzWlN4MGNtRnVjMnhoZEdVc0p5QXJYRzRnSUNkMGNuVmxjM0JsWldRc2RIbHdaVzExYzNSdFlYUmphQ3gyYVhOcFlteGxKMXh1S1R0Y2JseHVkbUZ5SUhoc2FXNXJUbE1nUFNBbmFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzk0YkdsdWF5YzdYRzVjYm5aaGNpQnBjMWhzYVc1cklEMGdablZ1WTNScGIyNGdLRzVoYldVcElIdGNiaUFnY21WMGRYSnVJRzVoYldVdVkyaGhja0YwS0RVcElEMDlQU0FuT2ljZ0ppWWdibUZ0WlM1emJHbGpaU2d3TENBMUtTQTlQVDBnSjNoc2FXNXJKMXh1ZlR0Y2JseHVkbUZ5SUdkbGRGaHNhVzVyVUhKdmNDQTlJR1oxYm1OMGFXOXVJQ2h1WVcxbEtTQjdYRzRnSUhKbGRIVnliaUJwYzFoc2FXNXJLRzVoYldVcElEOGdibUZ0WlM1emJHbGpaU2cyTENCdVlXMWxMbXhsYm1kMGFDa2dPaUFuSjF4dWZUdGNibHh1ZG1GeUlHbHpSbUZzYzNsQmRIUnlWbUZzZFdVZ1BTQm1kVzVqZEdsdmJpQW9kbUZzS1NCN1hHNGdJSEpsZEhWeWJpQjJZV3dnUFQwZ2JuVnNiQ0I4ZkNCMllXd2dQVDA5SUdaaGJITmxYRzU5TzF4dVhHNHZLaUFnS2k5Y2JseHVablZ1WTNScGIyNGdaMlZ1UTJ4aGMzTkdiM0pXYm05a1pTQW9kbTV2WkdVcElIdGNiaUFnZG1GeUlHUmhkR0VnUFNCMmJtOWtaUzVrWVhSaE8xeHVJQ0IyWVhJZ2NHRnlaVzUwVG05a1pTQTlJSFp1YjJSbE8xeHVJQ0IyWVhJZ1kyaHBiR1JPYjJSbElEMGdkbTV2WkdVN1hHNGdJSGRvYVd4bElDaGphR2xzWkU1dlpHVXVZMjl0Y0c5dVpXNTBTVzV6ZEdGdVkyVXBJSHRjYmlBZ0lDQmphR2xzWkU1dlpHVWdQU0JqYUdsc1pFNXZaR1V1WTI5dGNHOXVaVzUwU1c1emRHRnVZMlV1WDNadWIyUmxPMXh1SUNBZ0lHbG1JQ2hqYUdsc1pFNXZaR1V1WkdGMFlTa2dlMXh1SUNBZ0lDQWdaR0YwWVNBOUlHMWxjbWRsUTJ4aGMzTkVZWFJoS0dOb2FXeGtUbTlrWlM1a1lYUmhMQ0JrWVhSaEtUdGNiaUFnSUNCOVhHNGdJSDFjYmlBZ2QyaHBiR1VnS0Nod1lYSmxiblJPYjJSbElEMGdjR0Z5Wlc1MFRtOWtaUzV3WVhKbGJuUXBLU0I3WEc0Z0lDQWdhV1lnS0hCaGNtVnVkRTV2WkdVdVpHRjBZU2tnZTF4dUlDQWdJQ0FnWkdGMFlTQTlJRzFsY21kbFEyeGhjM05FWVhSaEtHUmhkR0VzSUhCaGNtVnVkRTV2WkdVdVpHRjBZU2s3WEc0Z0lDQWdmVnh1SUNCOVhHNGdJSEpsZEhWeWJpQm5aVzVEYkdGemMwWnliMjFFWVhSaEtHUmhkR0VwWEc1OVhHNWNibVoxYm1OMGFXOXVJRzFsY21kbFEyeGhjM05FWVhSaElDaGphR2xzWkN3Z2NHRnlaVzUwS1NCN1hHNGdJSEpsZEhWeWJpQjdYRzRnSUNBZ2MzUmhkR2xqUTJ4aGMzTTZJR052Ym1OaGRDaGphR2xzWkM1emRHRjBhV05EYkdGemN5d2djR0Z5Wlc1MExuTjBZWFJwWTBOc1lYTnpLU3hjYmlBZ0lDQmpiR0Z6Y3pvZ1kyaHBiR1F1WTJ4aGMzTmNiaUFnSUNBZ0lEOGdXMk5vYVd4a0xtTnNZWE56TENCd1lYSmxiblF1WTJ4aGMzTmRYRzRnSUNBZ0lDQTZJSEJoY21WdWRDNWpiR0Z6YzF4dUlDQjlYRzU5WEc1Y2JtWjFibU4wYVc5dUlHZGxia05zWVhOelJuSnZiVVJoZEdFZ0tHUmhkR0VwSUh0Y2JpQWdkbUZ5SUdSNWJtRnRhV05EYkdGemN5QTlJR1JoZEdFdVkyeGhjM003WEc0Z0lIWmhjaUJ6ZEdGMGFXTkRiR0Z6Y3lBOUlHUmhkR0V1YzNSaGRHbGpRMnhoYzNNN1hHNGdJR2xtSUNoemRHRjBhV05EYkdGemN5QjhmQ0JrZVc1aGJXbGpRMnhoYzNNcElIdGNiaUFnSUNCeVpYUjFjbTRnWTI5dVkyRjBLSE4wWVhScFkwTnNZWE56TENCemRISnBibWRwWm5sRGJHRnpjeWhrZVc1aGJXbGpRMnhoYzNNcEtWeHVJQ0I5WEc0Z0lDOHFJR2x6ZEdGdVluVnNJR2xuYm05eVpTQnVaWGgwSUNvdlhHNGdJSEpsZEhWeWJpQW5KMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmpiMjVqWVhRZ0tHRXNJR0lwSUh0Y2JpQWdjbVYwZFhKdUlHRWdQeUJpSUQ4Z0tHRWdLeUFuSUNjZ0t5QmlLU0E2SUdFZ09pQW9ZaUI4ZkNBbkp5bGNibjFjYmx4dVpuVnVZM1JwYjI0Z2MzUnlhVzVuYVdaNVEyeGhjM01nS0haaGJIVmxLU0I3WEc0Z0lIWmhjaUJ5WlhNZ1BTQW5KenRjYmlBZ2FXWWdLQ0YyWVd4MVpTa2dlMXh1SUNBZ0lISmxkSFZ5YmlCeVpYTmNiaUFnZlZ4dUlDQnBaaUFvZEhsd1pXOW1JSFpoYkhWbElEMDlQU0FuYzNSeWFXNW5KeWtnZTF4dUlDQWdJSEpsZEhWeWJpQjJZV3gxWlZ4dUlDQjlYRzRnSUdsbUlDaEJjbkpoZVM1cGMwRnljbUY1S0haaGJIVmxLU2tnZTF4dUlDQWdJSFpoY2lCemRISnBibWRwWm1sbFpEdGNiaUFnSUNCbWIzSWdLSFpoY2lCcElEMGdNQ3dnYkNBOUlIWmhiSFZsTG14bGJtZDBhRHNnYVNBOElHdzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ2FXWWdLSFpoYkhWbFcybGRLU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDZ29jM1J5YVc1bmFXWnBaV1FnUFNCemRISnBibWRwWm5sRGJHRnpjeWgyWVd4MVpWdHBYU2twS1NCN1hHNGdJQ0FnSUNBZ0lDQWdjbVZ6SUNzOUlITjBjbWx1WjJsbWFXVmtJQ3NnSnlBbk8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGRIVnliaUJ5WlhNdWMyeHBZMlVvTUN3Z0xURXBYRzRnSUgxY2JpQWdhV1lnS0dselQySnFaV04wS0haaGJIVmxLU2tnZTF4dUlDQWdJR1p2Y2lBb2RtRnlJR3RsZVNCcGJpQjJZV3gxWlNrZ2UxeHVJQ0FnSUNBZ2FXWWdLSFpoYkhWbFcydGxlVjBwSUhzZ2NtVnpJQ3M5SUd0bGVTQXJJQ2NnSnpzZ2ZWeHVJQ0FnSUgxY2JpQWdJQ0J5WlhSMWNtNGdjbVZ6TG5Oc2FXTmxLREFzSUMweEtWeHVJQ0I5WEc0Z0lDOHFJR2x6ZEdGdVluVnNJR2xuYm05eVpTQnVaWGgwSUNvdlhHNGdJSEpsZEhWeWJpQnlaWE5jYm4xY2JseHVMeW9nSUNvdlhHNWNiblpoY2lCdVlXMWxjM0JoWTJWTllYQWdQU0I3WEc0Z0lITjJaem9nSjJoMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSnl4Y2JpQWdiV0YwYURvZ0oyaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGd2VFdGMGFDOU5ZWFJvVFV3blhHNTlPMXh1WEc1MllYSWdhWE5JVkUxTVZHRm5JRDBnYldGclpVMWhjQ2hjYmlBZ0oyaDBiV3dzWW05a2VTeGlZWE5sTEdobFlXUXNiR2x1YXl4dFpYUmhMSE4wZVd4bExIUnBkR3hsTENjZ0sxeHVJQ0FuWVdSa2NtVnpjeXhoY25ScFkyeGxMR0Z6YVdSbExHWnZiM1JsY2l4b1pXRmtaWElzYURFc2FESXNhRE1zYURRc2FEVXNhRFlzYUdkeWIzVndMRzVoZGl4elpXTjBhVzl1TENjZ0sxeHVJQ0FuWkdsMkxHUmtMR1JzTEdSMExHWnBaMk5oY0hScGIyNHNabWxuZFhKbExHaHlMR2x0Wnl4c2FTeHRZV2x1TEc5c0xIQXNjSEpsTEhWc0xDY2dLMXh1SUNBbllTeGlMR0ZpWW5Jc1ltUnBMR0prYnl4aWNpeGphWFJsTEdOdlpHVXNaR0YwWVN4a1ptNHNaVzBzYVN4clltUXNiV0Z5YXl4eExISndMSEowTEhKMFl5eHlkV0o1TENjZ0sxeHVJQ0FuY3l4ellXMXdMSE50WVd4c0xITndZVzRzYzNSeWIyNW5MSE4xWWl4emRYQXNkR2x0WlN4MUxIWmhjaXgzWW5Jc1lYSmxZU3hoZFdScGJ5eHRZWEFzZEhKaFkyc3NkbWxrWlc4c0p5QXJYRzRnSUNkbGJXSmxaQ3h2WW1wbFkzUXNjR0Z5WVcwc2MyOTFjbU5sTEdOaGJuWmhjeXh6WTNKcGNIUXNibTl6WTNKcGNIUXNaR1ZzTEdsdWN5d25JQ3RjYmlBZ0oyTmhjSFJwYjI0c1kyOXNMR052YkdkeWIzVndMSFJoWW14bExIUm9aV0ZrTEhSaWIyUjVMSFJrTEhSb0xIUnlMQ2NnSzF4dUlDQW5ZblYwZEc5dUxHUmhkR0ZzYVhOMExHWnBaV3hrYzJWMExHWnZjbTBzYVc1d2RYUXNiR0ZpWld3c2JHVm5aVzVrTEcxbGRHVnlMRzl3ZEdkeWIzVndMRzl3ZEdsdmJpd25JQ3RjYmlBZ0oyOTFkSEIxZEN4d2NtOW5jbVZ6Y3l4elpXeGxZM1FzZEdWNGRHRnlaV0VzSnlBclhHNGdJQ2RrWlhSaGFXeHpMR1JwWVd4dlp5eHRaVzUxTEcxbGJuVnBkR1Z0TEhOMWJXMWhjbmtzSnlBclhHNGdJQ2RqYjI1MFpXNTBMR1ZzWlcxbGJuUXNjMmhoWkc5M0xIUmxiWEJzWVhSbEoxeHVLVHRjYmx4dUx5OGdkR2hwY3lCdFlYQWdhWE1nYVc1MFpXNTBhVzl1WVd4c2VTQnpaV3hsWTNScGRtVXNJRzl1YkhrZ1kyOTJaWEpwYm1jZ1UxWkhJR1ZzWlcxbGJuUnpJSFJvWVhRZ2JXRjVYRzR2THlCamIyNTBZV2x1SUdOb2FXeGtJR1ZzWlcxbGJuUnpMbHh1ZG1GeUlHbHpVMVpISUQwZ2JXRnJaVTFoY0NoY2JpQWdKM04yWnl4aGJtbHRZWFJsTEdOcGNtTnNaU3hqYkdsd2NHRjBhQ3hqZFhKemIzSXNaR1ZtY3l4a1pYTmpMR1ZzYkdsd2MyVXNabWxzZEdWeUxHWnZiblF0Wm1GalpTd25JQ3RjYmlBZ0oyWnZjbVZwWjI1UFltcGxZM1FzWnl4bmJIbHdhQ3hwYldGblpTeHNhVzVsTEcxaGNtdGxjaXh0WVhOckxHMXBjM05wYm1jdFoyeDVjR2dzY0dGMGFDeHdZWFIwWlhKdUxDY2dLMXh1SUNBbmNHOXNlV2R2Yml4d2IyeDViR2x1WlN4eVpXTjBMSE4zYVhSamFDeHplVzFpYjJ3c2RHVjRkQ3gwWlhoMGNHRjBhQ3gwYzNCaGJpeDFjMlVzZG1sbGR5Y3NYRzRnSUhSeWRXVmNiaWs3WEc1Y2JseHVYRzUyWVhJZ2FYTlNaWE5sY25abFpGUmhaeUE5SUdaMWJtTjBhVzl1SUNoMFlXY3BJSHRjYmlBZ2NtVjBkWEp1SUdselNGUk5URlJoWnloMFlXY3BJSHg4SUdselUxWkhLSFJoWnlsY2JuMDdYRzVjYm1aMWJtTjBhVzl1SUdkbGRGUmhaMDVoYldWemNHRmpaU0FvZEdGbktTQjdYRzRnSUdsbUlDaHBjMU5XUnloMFlXY3BLU0I3WEc0Z0lDQWdjbVYwZFhKdUlDZHpkbWNuWEc0Z0lIMWNiaUFnTHk4Z1ltRnphV01nYzNWd2NHOXlkQ0JtYjNJZ1RXRjBhRTFNWEc0Z0lDOHZJRzV2ZEdVZ2FYUWdaRzlsYzI0bmRDQnpkWEJ3YjNKMElHOTBhR1Z5SUUxaGRHaE5UQ0JsYkdWdFpXNTBjeUJpWldsdVp5QmpiMjF3YjI1bGJuUWdjbTl2ZEhOY2JpQWdhV1lnS0hSaFp5QTlQVDBnSjIxaGRHZ25LU0I3WEc0Z0lDQWdjbVYwZFhKdUlDZHRZWFJvSjF4dUlDQjlYRzU5WEc1Y2JuWmhjaUIxYm10dWIzZHVSV3hsYldWdWRFTmhZMmhsSUQwZ1QySnFaV04wTG1OeVpXRjBaU2h1ZFd4c0tUdGNibVoxYm1OMGFXOXVJR2x6Vlc1cmJtOTNia1ZzWlcxbGJuUWdLSFJoWnlrZ2UxeHVJQ0F2S2lCcGMzUmhibUoxYkNCcFoyNXZjbVVnYVdZZ0tpOWNiaUFnYVdZZ0tDRnBia0p5YjNkelpYSXBJSHRjYmlBZ0lDQnlaWFIxY200Z2RISjFaVnh1SUNCOVhHNGdJR2xtSUNocGMxSmxjMlZ5ZG1Wa1ZHRm5LSFJoWnlrcElIdGNiaUFnSUNCeVpYUjFjbTRnWm1Gc2MyVmNiaUFnZlZ4dUlDQjBZV2NnUFNCMFlXY3VkRzlNYjNkbGNrTmhjMlVvS1R0Y2JpQWdMeW9nYVhOMFlXNWlkV3dnYVdkdWIzSmxJR2xtSUNvdlhHNGdJR2xtSUNoMWJtdHViM2R1Uld4bGJXVnVkRU5oWTJobFczUmhaMTBnSVQwZ2JuVnNiQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQjFibXR1YjNkdVJXeGxiV1Z1ZEVOaFkyaGxXM1JoWjExY2JpQWdmVnh1SUNCMllYSWdaV3dnUFNCa2IyTjFiV1Z1ZEM1amNtVmhkR1ZGYkdWdFpXNTBLSFJoWnlrN1hHNGdJR2xtSUNoMFlXY3VhVzVrWlhoUFppZ25MU2NwSUQ0Z0xURXBJSHRjYmlBZ0lDQXZMeUJvZEhSd09pOHZjM1JoWTJ0dmRtVnlabXh2ZHk1amIyMHZZUzh5T0RJeE1ETTJOQzh4TURjd01qUTBYRzRnSUNBZ2NtVjBkWEp1SUNoMWJtdHViM2R1Uld4bGJXVnVkRU5oWTJobFczUmhaMTBnUFNBb1hHNGdJQ0FnSUNCbGJDNWpiMjV6ZEhKMVkzUnZjaUE5UFQwZ2QybHVaRzkzTGtoVVRVeFZibXR1YjNkdVJXeGxiV1Z1ZENCOGZGeHVJQ0FnSUNBZ1pXd3VZMjl1YzNSeWRXTjBiM0lnUFQwOUlIZHBibVJ2ZHk1SVZFMU1SV3hsYldWdWRGeHVJQ0FnSUNrcFhHNGdJSDBnWld4elpTQjdYRzRnSUNBZ2NtVjBkWEp1SUNoMWJtdHViM2R1Uld4bGJXVnVkRU5oWTJobFczUmhaMTBnUFNBdlNGUk5URlZ1YTI1dmQyNUZiR1Z0Wlc1MEx5NTBaWE4wS0dWc0xuUnZVM1J5YVc1bktDa3BLVnh1SUNCOVhHNTlYRzVjYmk4cUlDQXFMMXh1WEc0dktpcGNiaUFxSUZGMVpYSjVJR0Z1SUdWc1pXMWxiblFnYzJWc1pXTjBiM0lnYVdZZ2FYUW5jeUJ1YjNRZ1lXNGdaV3hsYldWdWRDQmhiSEpsWVdSNUxseHVJQ292WEc1bWRXNWpkR2x2YmlCeGRXVnllU0FvWld3cElIdGNiaUFnYVdZZ0tIUjVjR1Z2WmlCbGJDQTlQVDBnSjNOMGNtbHVaeWNwSUh0Y2JpQWdJQ0IyWVhJZ2MyVnNaV04wWldRZ1BTQmtiMk4xYldWdWRDNXhkV1Z5ZVZObGJHVmpkRzl5S0dWc0tUdGNiaUFnSUNCcFppQW9JWE5sYkdWamRHVmtLU0I3WEc0Z0lDQWdJQ0J3Y205alpYTnpMbVZ1ZGk1T1QwUkZYMFZPVmlBaFBUMGdKM0J5YjJSMVkzUnBiMjRuSUNZbUlIZGhjbTRvWEc0Z0lDQWdJQ0FnSUNkRFlXNXViM1FnWm1sdVpDQmxiR1Z0Wlc1ME9pQW5JQ3NnWld4Y2JpQWdJQ0FnSUNrN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWkc5amRXMWxiblF1WTNKbFlYUmxSV3hsYldWdWRDZ25aR2wySnlsY2JpQWdJQ0I5WEc0Z0lDQWdjbVYwZFhKdUlITmxiR1ZqZEdWa1hHNGdJSDBnWld4elpTQjdYRzRnSUNBZ2NtVjBkWEp1SUdWc1hHNGdJSDFjYm4xY2JseHVMeW9nSUNvdlhHNWNibVoxYm1OMGFXOXVJR055WldGMFpVVnNaVzFsYm5Ra01TQW9kR0ZuVG1GdFpTd2dkbTV2WkdVcElIdGNiaUFnZG1GeUlHVnNiU0E5SUdSdlkzVnRaVzUwTG1OeVpXRjBaVVZzWlcxbGJuUW9kR0ZuVG1GdFpTazdYRzRnSUdsbUlDaDBZV2RPWVcxbElDRTlQU0FuYzJWc1pXTjBKeWtnZTF4dUlDQWdJSEpsZEhWeWJpQmxiRzFjYmlBZ2ZWeHVJQ0F2THlCbVlXeHpaU0J2Y2lCdWRXeHNJSGRwYkd3Z2NtVnRiM1psSUhSb1pTQmhkSFJ5YVdKMWRHVWdZblYwSUhWdVpHVm1hVzVsWkNCM2FXeHNJRzV2ZEZ4dUlDQnBaaUFvZG01dlpHVXVaR0YwWVNBbUppQjJibTlrWlM1a1lYUmhMbUYwZEhKeklDWW1JSFp1YjJSbExtUmhkR0V1WVhSMGNuTXViWFZzZEdsd2JHVWdJVDA5SUhWdVpHVm1hVzVsWkNrZ2UxeHVJQ0FnSUdWc2JTNXpaWFJCZEhSeWFXSjFkR1VvSjIxMWJIUnBjR3hsSnl3Z0oyMTFiSFJwY0d4bEp5azdYRzRnSUgxY2JpQWdjbVYwZFhKdUlHVnNiVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmpjbVZoZEdWRmJHVnRaVzUwVGxNZ0tHNWhiV1Z6Y0dGalpTd2dkR0ZuVG1GdFpTa2dlMXh1SUNCeVpYUjFjbTRnWkc5amRXMWxiblF1WTNKbFlYUmxSV3hsYldWdWRFNVRLRzVoYldWemNHRmpaVTFoY0Z0dVlXMWxjM0JoWTJWZExDQjBZV2RPWVcxbEtWeHVmVnh1WEc1bWRXNWpkR2x2YmlCamNtVmhkR1ZVWlhoMFRtOWtaU0FvZEdWNGRDa2dlMXh1SUNCeVpYUjFjbTRnWkc5amRXMWxiblF1WTNKbFlYUmxWR1Y0ZEU1dlpHVW9kR1Y0ZENsY2JuMWNibHh1Wm5WdVkzUnBiMjRnWTNKbFlYUmxRMjl0YldWdWRDQW9kR1Y0ZENrZ2UxeHVJQ0J5WlhSMWNtNGdaRzlqZFcxbGJuUXVZM0psWVhSbFEyOXRiV1Z1ZENoMFpYaDBLVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQnBibk5sY25SQ1pXWnZjbVVnS0hCaGNtVnVkRTV2WkdVc0lHNWxkMDV2WkdVc0lISmxabVZ5Wlc1alpVNXZaR1VwSUh0Y2JpQWdjR0Z5Wlc1MFRtOWtaUzVwYm5ObGNuUkNaV1p2Y21Vb2JtVjNUbTlrWlN3Z2NtVm1aWEpsYm1ObFRtOWtaU2s3WEc1OVhHNWNibVoxYm1OMGFXOXVJSEpsYlc5MlpVTm9hV3hrSUNodWIyUmxMQ0JqYUdsc1pDa2dlMXh1SUNCdWIyUmxMbkpsYlc5MlpVTm9hV3hrS0dOb2FXeGtLVHRjYm4xY2JseHVablZ1WTNScGIyNGdZWEJ3Wlc1a1EyaHBiR1FnS0c1dlpHVXNJR05vYVd4a0tTQjdYRzRnSUc1dlpHVXVZWEJ3Wlc1a1EyaHBiR1FvWTJocGJHUXBPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQndZWEpsYm5ST2IyUmxJQ2h1YjJSbEtTQjdYRzRnSUhKbGRIVnliaUJ1YjJSbExuQmhjbVZ1ZEU1dlpHVmNibjFjYmx4dVpuVnVZM1JwYjI0Z2JtVjRkRk5wWW14cGJtY2dLRzV2WkdVcElIdGNiaUFnY21WMGRYSnVJRzV2WkdVdWJtVjRkRk5wWW14cGJtZGNibjFjYmx4dVpuVnVZM1JwYjI0Z2RHRm5UbUZ0WlNBb2JtOWtaU2tnZTF4dUlDQnlaWFIxY200Z2JtOWtaUzUwWVdkT1lXMWxYRzU5WEc1Y2JtWjFibU4wYVc5dUlITmxkRlJsZUhSRGIyNTBaVzUwSUNodWIyUmxMQ0IwWlhoMEtTQjdYRzRnSUc1dlpHVXVkR1Y0ZEVOdmJuUmxiblFnUFNCMFpYaDBPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQnpaWFJCZEhSeWFXSjFkR1VnS0c1dlpHVXNJR3RsZVN3Z2RtRnNLU0I3WEc0Z0lHNXZaR1V1YzJWMFFYUjBjbWxpZFhSbEtHdGxlU3dnZG1Gc0tUdGNibjFjYmx4dVhHNTJZWElnYm05a1pVOXdjeUE5SUU5aWFtVmpkQzVtY21WbGVtVW9lMXh1WEhSamNtVmhkR1ZGYkdWdFpXNTBPaUJqY21WaGRHVkZiR1Z0Wlc1MEpERXNYRzVjZEdOeVpXRjBaVVZzWlcxbGJuUk9Vem9nWTNKbFlYUmxSV3hsYldWdWRFNVRMRnh1WEhSamNtVmhkR1ZVWlhoMFRtOWtaVG9nWTNKbFlYUmxWR1Y0ZEU1dlpHVXNYRzVjZEdOeVpXRjBaVU52YlcxbGJuUTZJR055WldGMFpVTnZiVzFsYm5Rc1hHNWNkR2x1YzJWeWRFSmxabTl5WlRvZ2FXNXpaWEowUW1WbWIzSmxMRnh1WEhSeVpXMXZkbVZEYUdsc1pEb2djbVZ0YjNabFEyaHBiR1FzWEc1Y2RHRndjR1Z1WkVOb2FXeGtPaUJoY0hCbGJtUkRhR2xzWkN4Y2JseDBjR0Z5Wlc1MFRtOWtaVG9nY0dGeVpXNTBUbTlrWlN4Y2JseDBibVY0ZEZOcFlteHBibWM2SUc1bGVIUlRhV0pzYVc1bkxGeHVYSFIwWVdkT1lXMWxPaUIwWVdkT1lXMWxMRnh1WEhSelpYUlVaWGgwUTI5dWRHVnVkRG9nYzJWMFZHVjRkRU52Ym5SbGJuUXNYRzVjZEhObGRFRjBkSEpwWW5WMFpUb2djMlYwUVhSMGNtbGlkWFJsWEc1OUtUdGNibHh1THlvZ0lDb3ZYRzVjYm5aaGNpQnlaV1lnUFNCN1hHNGdJR055WldGMFpUb2dablZ1WTNScGIyNGdZM0psWVhSbElDaGZMQ0IyYm05a1pTa2dlMXh1SUNBZ0lISmxaMmx6ZEdWeVVtVm1LSFp1YjJSbEtUdGNiaUFnZlN4Y2JpQWdkWEJrWVhSbE9pQm1kVzVqZEdsdmJpQjFjR1JoZEdVZ0tHOXNaRlp1YjJSbExDQjJibTlrWlNrZ2UxeHVJQ0FnSUdsbUlDaHZiR1JXYm05a1pTNWtZWFJoTG5KbFppQWhQVDBnZG01dlpHVXVaR0YwWVM1eVpXWXBJSHRjYmlBZ0lDQWdJSEpsWjJsemRHVnlVbVZtS0c5c1pGWnViMlJsTENCMGNuVmxLVHRjYmlBZ0lDQWdJSEpsWjJsemRHVnlVbVZtS0hadWIyUmxLVHRjYmlBZ0lDQjlYRzRnSUgwc1hHNGdJR1JsYzNSeWIzazZJR1oxYm1OMGFXOXVJR1JsYzNSeWIza2dLSFp1YjJSbEtTQjdYRzRnSUNBZ2NtVm5hWE4wWlhKU1pXWW9kbTV2WkdVc0lIUnlkV1VwTzF4dUlDQjlYRzU5TzF4dVhHNW1kVzVqZEdsdmJpQnlaV2RwYzNSbGNsSmxaaUFvZG01dlpHVXNJR2x6VW1WdGIzWmhiQ2tnZTF4dUlDQjJZWElnYTJWNUlEMGdkbTV2WkdVdVpHRjBZUzV5WldZN1hHNGdJR2xtSUNnaGEyVjVLU0I3SUhKbGRIVnliaUI5WEc1Y2JpQWdkbUZ5SUhadElEMGdkbTV2WkdVdVkyOXVkR1Y0ZER0Y2JpQWdkbUZ5SUhKbFppQTlJSFp1YjJSbExtTnZiWEJ2Ym1WdWRFbHVjM1JoYm1ObElIeDhJSFp1YjJSbExtVnNiVHRjYmlBZ2RtRnlJSEpsWm5NZ1BTQjJiUzRrY21WbWN6dGNiaUFnYVdZZ0tHbHpVbVZ0YjNaaGJDa2dlMXh1SUNBZ0lHbG1JQ2hCY25KaGVTNXBjMEZ5Y21GNUtISmxabk5iYTJWNVhTa3BJSHRjYmlBZ0lDQWdJSEpsYlc5MlpTaHlaV1p6VzJ0bGVWMHNJSEpsWmlrN1hHNGdJQ0FnZlNCbGJITmxJR2xtSUNoeVpXWnpXMnRsZVYwZ1BUMDlJSEpsWmlrZ2UxeHVJQ0FnSUNBZ2NtVm1jMXRyWlhsZElEMGdkVzVrWldacGJtVmtPMXh1SUNBZ0lIMWNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQnBaaUFvZG01dlpHVXVaR0YwWVM1eVpXWkpia1p2Y2lrZ2UxeHVJQ0FnSUNBZ2FXWWdLRUZ5Y21GNUxtbHpRWEp5WVhrb2NtVm1jMXRyWlhsZEtTQW1KaUJ5WldaelcydGxlVjB1YVc1a1pYaFBaaWh5WldZcElEd2dNQ2tnZTF4dUlDQWdJQ0FnSUNCeVpXWnpXMnRsZVYwdWNIVnphQ2h5WldZcE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2NtVm1jMXRyWlhsZElEMGdXM0psWmwwN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJSEpsWm5OYmEyVjVYU0E5SUhKbFpqdGNiaUFnSUNCOVhHNGdJSDFjYm4xY2JseHVMeW9xWEc0Z0tpQldhWEowZFdGc0lFUlBUU0J3WVhSamFHbHVaeUJoYkdkdmNtbDBhRzBnWW1GelpXUWdiMjRnVTI1aFltSmtiMjBnWW5sY2JpQXFJRk5wYlc5dUlFWnlhV2x6SUZacGJtUjFiU0FvUUhCaGJHUmxjR2x1WkNsY2JpQXFJRXhwWTJWdWMyVmtJSFZ1WkdWeUlIUm9aU0JOU1ZRZ1RHbGpaVzV6WlZ4dUlDb2dhSFIwY0hNNkx5OW5hWFJvZFdJdVkyOXRMM0JoYkdSbGNHbHVaQzl6Ym1GaVltUnZiUzlpYkc5aUwyMWhjM1JsY2k5TVNVTkZUbE5GWEc0Z0tseHVJQ29nYlc5a2FXWnBaV1FnWW5rZ1JYWmhiaUJaYjNVZ0tFQjVlWGc1T1RBNE1ETXBYRzRnS2x4dVhHNHZLbHh1SUNvZ1RtOTBJSFI1Y0dVdFkyaGxZMnRwYm1jZ2RHaHBjeUJpWldOaGRYTmxJSFJvYVhNZ1ptbHNaU0JwY3lCd1pYSm1MV055YVhScFkyRnNJR0Z1WkNCMGFHVWdZMjl6ZEZ4dUlDb2diMllnYldGcmFXNW5JR1pzYjNjZ2RXNWtaWEp6ZEdGdVpDQnBkQ0JwY3lCdWIzUWdkMjl5ZEdnZ2FYUXVYRzRnS2k5Y2JseHVkbUZ5SUdWdGNIUjVUbTlrWlNBOUlHNWxkeUJXVG05a1pTZ25KeXdnZTMwc0lGdGRLVHRjYmx4dWRtRnlJR2h2YjJ0eklEMGdXeWRqY21WaGRHVW5MQ0FuWVdOMGFYWmhkR1VuTENBbmRYQmtZWFJsSnl3Z0ozSmxiVzkyWlNjc0lDZGtaWE4wY205NUoxMDdYRzVjYm1aMWJtTjBhVzl1SUdselZXNWtaV1lnS0hZcElIdGNiaUFnY21WMGRYSnVJSFlnUFQwOUlIVnVaR1ZtYVc1bFpDQjhmQ0IySUQwOVBTQnVkV3hzWEc1OVhHNWNibVoxYm1OMGFXOXVJR2x6UkdWbUlDaDJLU0I3WEc0Z0lISmxkSFZ5YmlCMklDRTlQU0IxYm1SbFptbHVaV1FnSmlZZ2RpQWhQVDBnYm5Wc2JGeHVmVnh1WEc1bWRXNWpkR2x2YmlCcGMxUnlkV1VnS0hZcElIdGNiaUFnY21WMGRYSnVJSFlnUFQwOUlIUnlkV1ZjYm4xY2JseHVablZ1WTNScGIyNGdjMkZ0WlZadWIyUmxJQ2hoTENCaUtTQjdYRzRnSUhKbGRIVnliaUFvWEc0Z0lDQWdZUzVyWlhrZ1BUMDlJR0l1YTJWNUlDWW1YRzRnSUNBZ1lTNTBZV2NnUFQwOUlHSXVkR0ZuSUNZbVhHNGdJQ0FnWVM1cGMwTnZiVzFsYm5RZ1BUMDlJR0l1YVhORGIyMXRaVzUwSUNZbVhHNGdJQ0FnYVhORVpXWW9ZUzVrWVhSaEtTQTlQVDBnYVhORVpXWW9ZaTVrWVhSaEtTQW1KbHh1SUNBZ0lITmhiV1ZKYm5CMWRGUjVjR1VvWVN3Z1lpbGNiaUFnS1Z4dWZWeHVYRzR2THlCVGIyMWxJR0p5YjNkelpYSnpJR1J2SUc1dmRDQnpkWEJ3YjNKMElHUjVibUZ0YVdOaGJHeDVJR05vWVc1bmFXNW5JSFI1Y0dVZ1ptOXlJRHhwYm5CMWRENWNiaTh2SUhOdklIUm9aWGtnYm1WbFpDQjBieUJpWlNCMGNtVmhkR1ZrSUdGeklHUnBabVpsY21WdWRDQnViMlJsYzF4dVpuVnVZM1JwYjI0Z2MyRnRaVWx1Y0hWMFZIbHdaU0FvWVN3Z1lpa2dlMXh1SUNCcFppQW9ZUzUwWVdjZ0lUMDlJQ2RwYm5CMWRDY3BJSHNnY21WMGRYSnVJSFJ5ZFdVZ2ZWeHVJQ0IyWVhJZ2FUdGNiaUFnZG1GeUlIUjVjR1ZCSUQwZ2FYTkVaV1lvYVNBOUlHRXVaR0YwWVNrZ0ppWWdhWE5FWldZb2FTQTlJR2t1WVhSMGNuTXBJQ1ltSUdrdWRIbHdaVHRjYmlBZ2RtRnlJSFI1Y0dWQ0lEMGdhWE5FWldZb2FTQTlJR0l1WkdGMFlTa2dKaVlnYVhORVpXWW9hU0E5SUdrdVlYUjBjbk1wSUNZbUlHa3VkSGx3WlR0Y2JpQWdjbVYwZFhKdUlIUjVjR1ZCSUQwOVBTQjBlWEJsUWx4dWZWeHVYRzVtZFc1amRHbHZiaUJqY21WaGRHVkxaWGxVYjA5c1pFbGtlQ0FvWTJocGJHUnlaVzRzSUdKbFoybHVTV1I0TENCbGJtUkpaSGdwSUh0Y2JpQWdkbUZ5SUdrc0lHdGxlVHRjYmlBZ2RtRnlJRzFoY0NBOUlIdDlPMXh1SUNCbWIzSWdLR2tnUFNCaVpXZHBia2xrZURzZ2FTQThQU0JsYm1SSlpIZzdJQ3NyYVNrZ2UxeHVJQ0FnSUd0bGVTQTlJR05vYVd4a2NtVnVXMmxkTG10bGVUdGNiaUFnSUNCcFppQW9hWE5FWldZb2EyVjVLU2tnZXlCdFlYQmJhMlY1WFNBOUlHazdJSDFjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdiV0Z3WEc1OVhHNWNibVoxYm1OMGFXOXVJR055WldGMFpWQmhkR05vUm5WdVkzUnBiMjRnS0dKaFkydGxibVFwSUh0Y2JpQWdkbUZ5SUdrc0lHbzdYRzRnSUhaaGNpQmpZbk1nUFNCN2ZUdGNibHh1SUNCMllYSWdiVzlrZFd4bGN5QTlJR0poWTJ0bGJtUXViVzlrZFd4bGN6dGNiaUFnZG1GeUlHNXZaR1ZQY0hNZ1BTQmlZV05yWlc1a0xtNXZaR1ZQY0hNN1hHNWNiaUFnWm05eUlDaHBJRDBnTURzZ2FTQThJR2h2YjJ0ekxteGxibWQwYURzZ0t5dHBLU0I3WEc0Z0lDQWdZMkp6VzJodmIydHpXMmxkWFNBOUlGdGRPMXh1SUNBZ0lHWnZjaUFvYWlBOUlEQTdJR29nUENCdGIyUjFiR1Z6TG14bGJtZDBhRHNnS3l0cUtTQjdYRzRnSUNBZ0lDQnBaaUFvYVhORVpXWW9iVzlrZFd4bGMxdHFYVnRvYjI5cmMxdHBYVjBwS1NCN1hHNGdJQ0FnSUNBZ0lHTmljMXRvYjI5cmMxdHBYVjB1Y0hWemFDaHRiMlIxYkdWelcycGRXMmh2YjJ0elcybGRYU2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnWm5WdVkzUnBiMjRnWlcxd2RIbE9iMlJsUVhRZ0tHVnNiU2tnZTF4dUlDQWdJSEpsZEhWeWJpQnVaWGNnVms1dlpHVW9ibTlrWlU5d2N5NTBZV2RPWVcxbEtHVnNiU2t1ZEc5TWIzZGxja05oYzJVb0tTd2dlMzBzSUZ0ZExDQjFibVJsWm1sdVpXUXNJR1ZzYlNsY2JpQWdmVnh1WEc0Z0lHWjFibU4wYVc5dUlHTnlaV0YwWlZKdFEySWdLR05vYVd4a1JXeHRMQ0JzYVhOMFpXNWxjbk1wSUh0Y2JpQWdJQ0JtZFc1amRHbHZiaUJ5WlcxdmRtVWtKREVnS0NrZ2UxeHVJQ0FnSUNBZ2FXWWdLQzB0Y21WdGIzWmxKQ1F4TG14cGMzUmxibVZ5Y3lBOVBUMGdNQ2tnZTF4dUlDQWdJQ0FnSUNCeVpXMXZkbVZPYjJSbEtHTm9hV3hrUld4dEtUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNGdJQ0FnY21WdGIzWmxKQ1F4TG14cGMzUmxibVZ5Y3lBOUlHeHBjM1JsYm1WeWN6dGNiaUFnSUNCeVpYUjFjbTRnY21WdGIzWmxKQ1F4WEc0Z0lIMWNibHh1SUNCbWRXNWpkR2x2YmlCeVpXMXZkbVZPYjJSbElDaGxiQ2tnZTF4dUlDQWdJSFpoY2lCd1lYSmxiblFnUFNCdWIyUmxUM0J6TG5CaGNtVnVkRTV2WkdVb1pXd3BPMXh1SUNBZ0lDOHZJR1ZzWlcxbGJuUWdiV0Y1SUdoaGRtVWdZV3h5WldGa2VTQmlaV1Z1SUhKbGJXOTJaV1FnWkhWbElIUnZJSFl0YUhSdGJDQXZJSFl0ZEdWNGRGeHVJQ0FnSUdsbUlDaHBjMFJsWmlod1lYSmxiblFwS1NCN1hHNGdJQ0FnSUNCdWIyUmxUM0J6TG5KbGJXOTJaVU5vYVd4a0tIQmhjbVZ1ZEN3Z1pXd3BPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSFpoY2lCcGJsQnlaU0E5SURBN1hHNGdJR1oxYm1OMGFXOXVJR055WldGMFpVVnNiU0FvZG01dlpHVXNJR2x1YzJWeWRHVmtWbTV2WkdWUmRXVjFaU3dnY0dGeVpXNTBSV3h0TENCeVpXWkZiRzBzSUc1bGMzUmxaQ2tnZTF4dUlDQWdJSFp1YjJSbExtbHpVbTl2ZEVsdWMyVnlkQ0E5SUNGdVpYTjBaV1E3SUM4dklHWnZjaUIwY21GdWMybDBhVzl1SUdWdWRHVnlJR05vWldOclhHNGdJQ0FnYVdZZ0tHTnlaV0YwWlVOdmJYQnZibVZ1ZENoMmJtOWtaU3dnYVc1elpYSjBaV1JXYm05a1pWRjFaWFZsTENCd1lYSmxiblJGYkcwc0lISmxaa1ZzYlNrcElIdGNiaUFnSUNBZ0lISmxkSFZ5Ymx4dUlDQWdJSDFjYmx4dUlDQWdJSFpoY2lCa1lYUmhJRDBnZG01dlpHVXVaR0YwWVR0Y2JpQWdJQ0IyWVhJZ1kyaHBiR1J5Wlc0Z1BTQjJibTlrWlM1amFHbHNaSEpsYmp0Y2JpQWdJQ0IyWVhJZ2RHRm5JRDBnZG01dlpHVXVkR0ZuTzF4dUlDQWdJR2xtSUNocGMwUmxaaWgwWVdjcEtTQjdYRzRnSUNBZ0lDQnBaaUFvY0hKdlkyVnpjeTVsYm5ZdVRrOUVSVjlGVGxZZ0lUMDlJQ2R3Y205a2RXTjBhVzl1SnlrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvWkdGMFlTQW1KaUJrWVhSaExuQnlaU2tnZTF4dUlDQWdJQ0FnSUNBZ0lHbHVVSEpsS3lzN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdhV1lnS0Z4dUlDQWdJQ0FnSUNBZ0lDRnBibEJ5WlNBbUpseHVJQ0FnSUNBZ0lDQWdJQ0YyYm05a1pTNXVjeUFtSmx4dUlDQWdJQ0FnSUNBZ0lDRW9ZMjl1Wm1sbkxtbG5ibTl5WldSRmJHVnRaVzUwY3k1c1pXNW5kR2dnSmlZZ1kyOXVabWxuTG1sbmJtOXlaV1JGYkdWdFpXNTBjeTVwYm1SbGVFOW1LSFJoWnlrZ1BpQXRNU2tnSmlaY2JpQWdJQ0FnSUNBZ0lDQmpiMjVtYVdjdWFYTlZibXR1YjNkdVJXeGxiV1Z1ZENoMFlXY3BYRzRnSUNBZ0lDQWdJQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lIZGhjbTRvWEc0Z0lDQWdJQ0FnSUNBZ0lDQW5WVzVyYm05M2JpQmpkWE4wYjIwZ1pXeGxiV1Z1ZERvZ1BDY2dLeUIwWVdjZ0t5QW5QaUF0SUdScFpDQjViM1VnSnlBclhHNGdJQ0FnSUNBZ0lDQWdJQ0FuY21WbmFYTjBaWElnZEdobElHTnZiWEJ2Ym1WdWRDQmpiM0p5WldOMGJIay9JRVp2Y2lCeVpXTjFjbk5wZG1VZ1kyOXRjRzl1Wlc1MGN5d2dKeUFyWEc0Z0lDQWdJQ0FnSUNBZ0lDQW5iV0ZyWlNCemRYSmxJSFJ2SUhCeWIzWnBaR1VnZEdobElGd2libUZ0WlZ3aUlHOXdkR2x2Ymk0bkxGeHVJQ0FnSUNBZ0lDQWdJQ0FnZG01dlpHVXVZMjl1ZEdWNGRGeHVJQ0FnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUhadWIyUmxMbVZzYlNBOUlIWnViMlJsTG01elhHNGdJQ0FnSUNBZ0lEOGdibTlrWlU5d2N5NWpjbVZoZEdWRmJHVnRaVzUwVGxNb2RtNXZaR1V1Ym5Nc0lIUmhaeWxjYmlBZ0lDQWdJQ0FnT2lCdWIyUmxUM0J6TG1OeVpXRjBaVVZzWlcxbGJuUW9kR0ZuTENCMmJtOWtaU2s3WEc0Z0lDQWdJQ0J6WlhSVFkyOXdaU2gyYm05a1pTazdYRzVjYmlBZ0lDQWdJQzhxSUdsemRHRnVZblZzSUdsbmJtOXlaU0JwWmlBcUwxeHVJQ0FnSUNBZ2UxeHVJQ0FnSUNBZ0lDQmpjbVZoZEdWRGFHbHNaSEpsYmloMmJtOWtaU3dnWTJocGJHUnlaVzRzSUdsdWMyVnlkR1ZrVm01dlpHVlJkV1YxWlNrN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hwYzBSbFppaGtZWFJoS1NrZ2UxeHVJQ0FnSUNBZ0lDQWdJR2x1ZG05clpVTnlaV0YwWlVodmIydHpLSFp1YjJSbExDQnBibk5sY25SbFpGWnViMlJsVVhWbGRXVXBPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUdsdWMyVnlkQ2h3WVhKbGJuUkZiRzBzSUhadWIyUmxMbVZzYlN3Z2NtVm1SV3h0S1R0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2FXWWdLSEJ5YjJObGMzTXVaVzUyTGs1UFJFVmZSVTVXSUNFOVBTQW5jSEp2WkhWamRHbHZiaWNnSmlZZ1pHRjBZU0FtSmlCa1lYUmhMbkJ5WlNrZ2UxeHVJQ0FnSUNBZ0lDQnBibEJ5WlMwdE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb2FYTlVjblZsS0hadWIyUmxMbWx6UTI5dGJXVnVkQ2twSUh0Y2JpQWdJQ0FnSUhadWIyUmxMbVZzYlNBOUlHNXZaR1ZQY0hNdVkzSmxZWFJsUTI5dGJXVnVkQ2gyYm05a1pTNTBaWGgwS1R0Y2JpQWdJQ0FnSUdsdWMyVnlkQ2h3WVhKbGJuUkZiRzBzSUhadWIyUmxMbVZzYlN3Z2NtVm1SV3h0S1R0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdkbTV2WkdVdVpXeHRJRDBnYm05a1pVOXdjeTVqY21WaGRHVlVaWGgwVG05a1pTaDJibTlrWlM1MFpYaDBLVHRjYmlBZ0lDQWdJR2x1YzJWeWRDaHdZWEpsYm5SRmJHMHNJSFp1YjJSbExtVnNiU3dnY21WbVJXeHRLVHRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0JtZFc1amRHbHZiaUJqY21WaGRHVkRiMjF3YjI1bGJuUWdLSFp1YjJSbExDQnBibk5sY25SbFpGWnViMlJsVVhWbGRXVXNJSEJoY21WdWRFVnNiU3dnY21WbVJXeHRLU0I3WEc0Z0lDQWdkbUZ5SUdrZ1BTQjJibTlrWlM1a1lYUmhPMXh1SUNBZ0lHbG1JQ2hwYzBSbFppaHBLU2tnZTF4dUlDQWdJQ0FnZG1GeUlHbHpVbVZoWTNScGRtRjBaV1FnUFNCcGMwUmxaaWgyYm05a1pTNWpiMjF3YjI1bGJuUkpibk4wWVc1alpTa2dKaVlnYVM1clpXVndRV3hwZG1VN1hHNGdJQ0FnSUNCcFppQW9hWE5FWldZb2FTQTlJR2t1YUc5dmF5a2dKaVlnYVhORVpXWW9hU0E5SUdrdWFXNXBkQ2twSUh0Y2JpQWdJQ0FnSUNBZ2FTaDJibTlrWlN3Z1ptRnNjMlVnTHlvZ2FIbGtjbUYwYVc1bklDb3ZMQ0J3WVhKbGJuUkZiRzBzSUhKbFprVnNiU2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0F2THlCaFpuUmxjaUJqWVd4c2FXNW5JSFJvWlNCcGJtbDBJR2h2YjJzc0lHbG1JSFJvWlNCMmJtOWtaU0JwY3lCaElHTm9hV3hrSUdOdmJYQnZibVZ1ZEZ4dUlDQWdJQ0FnTHk4Z2FYUWdjMmh2ZFd4a0ozWmxJR055WldGMFpXUWdZU0JqYUdsc1pDQnBibk4wWVc1alpTQmhibVFnYlc5MWJuUmxaQ0JwZEM0Z2RHaGxJR05vYVd4a1hHNGdJQ0FnSUNBdkx5QmpiMjF3YjI1bGJuUWdZV3h6YnlCb1lYTWdjMlYwSUhSb1pTQndiR0ZqWldodmJHUmxjaUIyYm05a1pTZHpJR1ZzYlM1Y2JpQWdJQ0FnSUM4dklHbHVJSFJvWVhRZ1kyRnpaU0IzWlNCallXNGdhblZ6ZENCeVpYUjFjbTRnZEdobElHVnNaVzFsYm5RZ1lXNWtJR0psSUdSdmJtVXVYRzRnSUNBZ0lDQnBaaUFvYVhORVpXWW9kbTV2WkdVdVkyOXRjRzl1Wlc1MFNXNXpkR0Z1WTJVcEtTQjdYRzRnSUNBZ0lDQWdJR2x1YVhSRGIyMXdiMjVsYm5Rb2RtNXZaR1VzSUdsdWMyVnlkR1ZrVm01dlpHVlJkV1YxWlNrN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hwYzFSeWRXVW9hWE5TWldGamRHbDJZWFJsWkNrcElIdGNiaUFnSUNBZ0lDQWdJQ0J5WldGamRHbDJZWFJsUTI5dGNHOXVaVzUwS0hadWIyUmxMQ0JwYm5ObGNuUmxaRlp1YjJSbFVYVmxkV1VzSUhCaGNtVnVkRVZzYlN3Z2NtVm1SV3h0S1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RISjFaVnh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJR1oxYm1OMGFXOXVJR2x1YVhSRGIyMXdiMjVsYm5RZ0tIWnViMlJsTENCcGJuTmxjblJsWkZadWIyUmxVWFZsZFdVcElIdGNiaUFnSUNCcFppQW9hWE5FWldZb2RtNXZaR1V1WkdGMFlTNXdaVzVrYVc1blNXNXpaWEowS1NrZ2UxeHVJQ0FnSUNBZ2FXNXpaWEowWldSV2JtOWtaVkYxWlhWbExuQjFjMmd1WVhCd2JIa29hVzV6WlhKMFpXUldibTlrWlZGMVpYVmxMQ0IyYm05a1pTNWtZWFJoTG5CbGJtUnBibWRKYm5ObGNuUXBPMXh1SUNBZ0lIMWNiaUFnSUNCMmJtOWtaUzVsYkcwZ1BTQjJibTlrWlM1amIyMXdiMjVsYm5SSmJuTjBZVzVqWlM0a1pXdzdYRzRnSUNBZ2FXWWdLR2x6VUdGMFkyaGhZbXhsS0hadWIyUmxLU2tnZTF4dUlDQWdJQ0FnYVc1MmIydGxRM0psWVhSbFNHOXZhM01vZG01dlpHVXNJR2x1YzJWeWRHVmtWbTV2WkdWUmRXVjFaU2s3WEc0Z0lDQWdJQ0J6WlhSVFkyOXdaU2gyYm05a1pTazdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUM4dklHVnRjSFI1SUdOdmJYQnZibVZ1ZENCeWIyOTBMbHh1SUNBZ0lDQWdMeThnYzJ0cGNDQmhiR3dnWld4bGJXVnVkQzF5Wld4aGRHVmtJRzF2WkhWc1pYTWdaWGhqWlhCMElHWnZjaUJ5WldZZ0tDTXpORFUxS1Z4dUlDQWdJQ0FnY21WbmFYTjBaWEpTWldZb2RtNXZaR1VwTzF4dUlDQWdJQ0FnTHk4Z2JXRnJaU0J6ZFhKbElIUnZJR2x1ZG05clpTQjBhR1VnYVc1elpYSjBJR2h2YjJ0Y2JpQWdJQ0FnSUdsdWMyVnlkR1ZrVm01dlpHVlJkV1YxWlM1d2RYTm9LSFp1YjJSbEtUdGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQm1kVzVqZEdsdmJpQnlaV0ZqZEdsMllYUmxRMjl0Y0c5dVpXNTBJQ2gyYm05a1pTd2dhVzV6WlhKMFpXUldibTlrWlZGMVpYVmxMQ0J3WVhKbGJuUkZiRzBzSUhKbFprVnNiU2tnZTF4dUlDQWdJSFpoY2lCcE8xeHVJQ0FnSUM4dklHaGhZMnNnWm05eUlDTTBNek01T2lCaElISmxZV04wYVhaaGRHVmtJR052YlhCdmJtVnVkQ0IzYVhSb0lHbHVibVZ5SUhSeVlXNXphWFJwYjI1Y2JpQWdJQ0F2THlCa2IyVnpJRzV2ZENCMGNtbG5aMlZ5SUdKbFkyRjFjMlVnZEdobElHbHVibVZ5SUc1dlpHVW5jeUJqY21WaGRHVmtJR2h2YjJ0eklHRnlaU0J1YjNRZ1kyRnNiR1ZrWEc0Z0lDQWdMeThnWVdkaGFXNHVJRWwwSjNNZ2JtOTBJR2xrWldGc0lIUnZJR2x1ZG05c2RtVWdiVzlrZFd4bExYTndaV05wWm1saklHeHZaMmxqSUdsdUlHaGxjbVVnWW5WMFhHNGdJQ0FnTHk4Z2RHaGxjbVVnWkc5bGMyNG5kQ0J6WldWdElIUnZJR0psSUdFZ1ltVjBkR1Z5SUhkaGVTQjBieUJrYnlCcGRDNWNiaUFnSUNCMllYSWdhVzV1WlhKT2IyUmxJRDBnZG01dlpHVTdYRzRnSUNBZ2QyaHBiR1VnS0dsdWJtVnlUbTlrWlM1amIyMXdiMjVsYm5SSmJuTjBZVzVqWlNrZ2UxeHVJQ0FnSUNBZ2FXNXVaWEpPYjJSbElEMGdhVzV1WlhKT2IyUmxMbU52YlhCdmJtVnVkRWx1YzNSaGJtTmxMbDkyYm05a1pUdGNiaUFnSUNBZ0lHbG1JQ2hwYzBSbFppaHBJRDBnYVc1dVpYSk9iMlJsTG1SaGRHRXBJQ1ltSUdselJHVm1LR2tnUFNCcExuUnlZVzV6YVhScGIyNHBLU0I3WEc0Z0lDQWdJQ0FnSUdadmNpQW9hU0E5SURBN0lHa2dQQ0JqWW5NdVlXTjBhWFpoZEdVdWJHVnVaM1JvT3lBcksya3BJSHRjYmlBZ0lDQWdJQ0FnSUNCalluTXVZV04wYVhaaGRHVmJhVjBvWlcxd2RIbE9iMlJsTENCcGJtNWxjazV2WkdVcE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJR2x1YzJWeWRHVmtWbTV2WkdWUmRXVjFaUzV3ZFhOb0tHbHVibVZ5VG05a1pTazdYRzRnSUNBZ0lDQWdJR0p5WldGclhHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dUlDQWdJQzh2SUhWdWJHbHJaU0JoSUc1bGQyeDVJR055WldGMFpXUWdZMjl0Y0c5dVpXNTBMRnh1SUNBZ0lDOHZJR0VnY21WaFkzUnBkbUYwWldRZ2EyVmxjQzFoYkdsMlpTQmpiMjF3YjI1bGJuUWdaRzlsYzI0bmRDQnBibk5sY25RZ2FYUnpaV3htWEc0Z0lDQWdhVzV6WlhKMEtIQmhjbVZ1ZEVWc2JTd2dkbTV2WkdVdVpXeHRMQ0J5WldaRmJHMHBPMXh1SUNCOVhHNWNiaUFnWm5WdVkzUnBiMjRnYVc1elpYSjBJQ2h3WVhKbGJuUXNJR1ZzYlN3Z2NtVm1LU0I3WEc0Z0lDQWdhV1lnS0dselJHVm1LSEJoY21WdWRDa3BJSHRjYmlBZ0lDQWdJR2xtSUNocGMwUmxaaWh5WldZcEtTQjdYRzRnSUNBZ0lDQWdJRzV2WkdWUGNITXVhVzV6WlhKMFFtVm1iM0psS0hCaGNtVnVkQ3dnWld4dExDQnlaV1lwTzF4dUlDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnYm05a1pVOXdjeTVoY0hCbGJtUkRhR2xzWkNod1lYSmxiblFzSUdWc2JTazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdablZ1WTNScGIyNGdZM0psWVhSbFEyaHBiR1J5Wlc0Z0tIWnViMlJsTENCamFHbHNaSEpsYml3Z2FXNXpaWEowWldSV2JtOWtaVkYxWlhWbEtTQjdYRzRnSUNBZ2FXWWdLRUZ5Y21GNUxtbHpRWEp5WVhrb1kyaHBiR1J5Wlc0cEtTQjdYRzRnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR05vYVd4a2NtVnVMbXhsYm1kMGFEc2dLeXRwS1NCN1hHNGdJQ0FnSUNBZ0lHTnlaV0YwWlVWc2JTaGphR2xzWkhKbGJsdHBYU3dnYVc1elpYSjBaV1JXYm05a1pWRjFaWFZsTENCMmJtOWtaUzVsYkcwc0lHNTFiR3dzSUhSeWRXVXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMGdaV3h6WlNCcFppQW9hWE5RY21sdGFYUnBkbVVvZG01dlpHVXVkR1Y0ZENrcElIdGNiaUFnSUNBZ0lHNXZaR1ZQY0hNdVlYQndaVzVrUTJocGJHUW9kbTV2WkdVdVpXeHRMQ0J1YjJSbFQzQnpMbU55WldGMFpWUmxlSFJPYjJSbEtIWnViMlJsTG5SbGVIUXBLVHRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0JtZFc1amRHbHZiaUJwYzFCaGRHTm9ZV0pzWlNBb2RtNXZaR1VwSUh0Y2JpQWdJQ0IzYUdsc1pTQW9kbTV2WkdVdVkyOXRjRzl1Wlc1MFNXNXpkR0Z1WTJVcElIdGNiaUFnSUNBZ0lIWnViMlJsSUQwZ2RtNXZaR1V1WTI5dGNHOXVaVzUwU1c1emRHRnVZMlV1WDNadWIyUmxPMXh1SUNBZ0lIMWNiaUFnSUNCeVpYUjFjbTRnYVhORVpXWW9kbTV2WkdVdWRHRm5LVnh1SUNCOVhHNWNiaUFnWm5WdVkzUnBiMjRnYVc1MmIydGxRM0psWVhSbFNHOXZhM01nS0hadWIyUmxMQ0JwYm5ObGNuUmxaRlp1YjJSbFVYVmxkV1VwSUh0Y2JpQWdJQ0JtYjNJZ0tIWmhjaUJwSkRFZ1BTQXdPeUJwSkRFZ1BDQmpZbk11WTNKbFlYUmxMbXhsYm1kMGFEc2dLeXRwSkRFcElIdGNiaUFnSUNBZ0lHTmljeTVqY21WaGRHVmJhU1F4WFNobGJYQjBlVTV2WkdVc0lIWnViMlJsS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdhU0E5SUhadWIyUmxMbVJoZEdFdWFHOXZhenNnTHk4Z1VtVjFjMlVnZG1GeWFXRmliR1ZjYmlBZ0lDQnBaaUFvYVhORVpXWW9hU2twSUh0Y2JpQWdJQ0FnSUdsbUlDaHBjMFJsWmlocExtTnlaV0YwWlNrcElIc2dhUzVqY21WaGRHVW9aVzF3ZEhsT2IyUmxMQ0IyYm05a1pTazdJSDFjYmlBZ0lDQWdJR2xtSUNocGMwUmxaaWhwTG1sdWMyVnlkQ2twSUhzZ2FXNXpaWEowWldSV2JtOWtaVkYxWlhWbExuQjFjMmdvZG01dlpHVXBPeUI5WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnTHk4Z2MyVjBJSE5qYjNCbElHbGtJR0YwZEhKcFluVjBaU0JtYjNJZ2MyTnZjR1ZrSUVOVFV5NWNiaUFnTHk4Z2RHaHBjeUJwY3lCcGJYQnNaVzFsYm5SbFpDQmhjeUJoSUhOd1pXTnBZV3dnWTJGelpTQjBieUJoZG05cFpDQjBhR1VnYjNabGNtaGxZV1JjYmlBZ0x5OGdiMllnWjI5cGJtY2dkR2h5YjNWbmFDQjBhR1VnYm05eWJXRnNJR0YwZEhKcFluVjBaU0J3WVhSamFHbHVaeUJ3Y205alpYTnpMbHh1SUNCbWRXNWpkR2x2YmlCelpYUlRZMjl3WlNBb2RtNXZaR1VwSUh0Y2JpQWdJQ0IyWVhJZ2FUdGNiaUFnSUNCMllYSWdZVzVqWlhOMGIzSWdQU0IyYm05a1pUdGNiaUFnSUNCM2FHbHNaU0FvWVc1alpYTjBiM0lwSUh0Y2JpQWdJQ0FnSUdsbUlDaHBjMFJsWmlocElEMGdZVzVqWlhOMGIzSXVZMjl1ZEdWNGRDa2dKaVlnYVhORVpXWW9hU0E5SUdrdUpHOXdkR2x2Ym5NdVgzTmpiM0JsU1dRcEtTQjdYRzRnSUNBZ0lDQWdJRzV2WkdWUGNITXVjMlYwUVhSMGNtbGlkWFJsS0hadWIyUmxMbVZzYlN3Z2FTd2dKeWNwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnWVc1alpYTjBiM0lnUFNCaGJtTmxjM1J2Y2k1d1lYSmxiblE3WEc0Z0lDQWdmVnh1SUNBZ0lDOHZJR1p2Y2lCemJHOTBJR052Ym5SbGJuUWdkR2hsZVNCemFHOTFiR1FnWVd4emJ5Qm5aWFFnZEdobElITmpiM0JsU1dRZ1puSnZiU0IwYUdVZ2FHOXpkQ0JwYm5OMFlXNWpaUzVjYmlBZ0lDQnBaaUFvYVhORVpXWW9hU0E5SUdGamRHbDJaVWx1YzNSaGJtTmxLU0FtSmx4dUlDQWdJQ0FnSUNCcElDRTlQU0IyYm05a1pTNWpiMjUwWlhoMElDWW1YRzRnSUNBZ0lDQWdJR2x6UkdWbUtHa2dQU0JwTGlSdmNIUnBiMjV6TGw5elkyOXdaVWxrS1NrZ2UxeHVJQ0FnSUNBZ2JtOWtaVTl3Y3k1elpYUkJkSFJ5YVdKMWRHVW9kbTV2WkdVdVpXeHRMQ0JwTENBbkp5azdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdablZ1WTNScGIyNGdZV1JrVm01dlpHVnpJQ2h3WVhKbGJuUkZiRzBzSUhKbFprVnNiU3dnZG01dlpHVnpMQ0J6ZEdGeWRFbGtlQ3dnWlc1a1NXUjRMQ0JwYm5ObGNuUmxaRlp1YjJSbFVYVmxkV1VwSUh0Y2JpQWdJQ0JtYjNJZ0tEc2djM1JoY25SSlpIZ2dQRDBnWlc1a1NXUjRPeUFySzNOMFlYSjBTV1I0S1NCN1hHNGdJQ0FnSUNCamNtVmhkR1ZGYkcwb2RtNXZaR1Z6VzNOMFlYSjBTV1I0WFN3Z2FXNXpaWEowWldSV2JtOWtaVkYxWlhWbExDQndZWEpsYm5SRmJHMHNJSEpsWmtWc2JTazdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdablZ1WTNScGIyNGdhVzUyYjJ0bFJHVnpkSEp2ZVVodmIyc2dLSFp1YjJSbEtTQjdYRzRnSUNBZ2RtRnlJR2tzSUdvN1hHNGdJQ0FnZG1GeUlHUmhkR0VnUFNCMmJtOWtaUzVrWVhSaE8xeHVJQ0FnSUdsbUlDaHBjMFJsWmloa1lYUmhLU2tnZTF4dUlDQWdJQ0FnYVdZZ0tHbHpSR1ZtS0drZ1BTQmtZWFJoTG1odmIyc3BJQ1ltSUdselJHVm1LR2tnUFNCcExtUmxjM1J5YjNrcEtTQjdJR2tvZG01dlpHVXBPeUI5WEc0Z0lDQWdJQ0JtYjNJZ0tHa2dQU0F3T3lCcElEd2dZMkp6TG1SbGMzUnliM2t1YkdWdVozUm9PeUFySzJrcElIc2dZMkp6TG1SbGMzUnliM2xiYVYwb2RtNXZaR1VwT3lCOVhHNGdJQ0FnZlZ4dUlDQWdJR2xtSUNocGMwUmxaaWhwSUQwZ2RtNXZaR1V1WTJocGJHUnlaVzRwS1NCN1hHNGdJQ0FnSUNCbWIzSWdLR29nUFNBd095QnFJRHdnZG01dlpHVXVZMmhwYkdSeVpXNHViR1Z1WjNSb095QXJLMm9wSUh0Y2JpQWdJQ0FnSUNBZ2FXNTJiMnRsUkdWemRISnZlVWh2YjJzb2RtNXZaR1V1WTJocGJHUnlaVzViYWwwcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lHWjFibU4wYVc5dUlISmxiVzkyWlZadWIyUmxjeUFvY0dGeVpXNTBSV3h0TENCMmJtOWtaWE1zSUhOMFlYSjBTV1I0TENCbGJtUkpaSGdwSUh0Y2JpQWdJQ0JtYjNJZ0tEc2djM1JoY25SSlpIZ2dQRDBnWlc1a1NXUjRPeUFySzNOMFlYSjBTV1I0S1NCN1hHNGdJQ0FnSUNCMllYSWdZMmdnUFNCMmJtOWtaWE5iYzNSaGNuUkpaSGhkTzF4dUlDQWdJQ0FnYVdZZ0tHbHpSR1ZtS0dOb0tTa2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb2FYTkVaV1lvWTJndWRHRm5LU2tnZTF4dUlDQWdJQ0FnSUNBZ0lISmxiVzkyWlVGdVpFbHVkbTlyWlZKbGJXOTJaVWh2YjJzb1kyZ3BPMXh1SUNBZ0lDQWdJQ0FnSUdsdWRtOXJaVVJsYzNSeWIzbEliMjlyS0dOb0tUdGNiaUFnSUNBZ0lDQWdmU0JsYkhObElIc2dMeThnVkdWNGRDQnViMlJsWEc0Z0lDQWdJQ0FnSUNBZ2NtVnRiM1psVG05a1pTaGphQzVsYkcwcE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdablZ1WTNScGIyNGdjbVZ0YjNabFFXNWtTVzUyYjJ0bFVtVnRiM1psU0c5dmF5QW9kbTV2WkdVc0lISnRLU0I3WEc0Z0lDQWdhV1lnS0dselJHVm1LSEp0S1NCOGZDQnBjMFJsWmloMmJtOWtaUzVrWVhSaEtTa2dlMXh1SUNBZ0lDQWdkbUZ5SUd4cGMzUmxibVZ5Y3lBOUlHTmljeTV5WlcxdmRtVXViR1Z1WjNSb0lDc2dNVHRjYmlBZ0lDQWdJR2xtSUNocGMwUmxaaWh5YlNrcElIdGNiaUFnSUNBZ0lDQWdMeThnZDJVZ2FHRjJaU0JoSUhKbFkzVnljMmwyWld4NUlIQmhjM05sWkNCa2IzZHVJSEp0SUdOaGJHeGlZV05yWEc0Z0lDQWdJQ0FnSUM4dklHbHVZM0psWVhObElIUm9aU0JzYVhOMFpXNWxjbk1nWTI5MWJuUmNiaUFnSUNBZ0lDQWdjbTB1YkdsemRHVnVaWEp6SUNzOUlHeHBjM1JsYm1WeWN6dGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDOHZJR1JwY21WamRHeDVJSEpsYlc5MmFXNW5YRzRnSUNBZ0lDQWdJSEp0SUQwZ1kzSmxZWFJsVW0xRFlpaDJibTlrWlM1bGJHMHNJR3hwYzNSbGJtVnljeWs3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0F2THlCeVpXTjFjbk5wZG1Wc2VTQnBiblp2YTJVZ2FHOXZhM01nYjI0Z1kyaHBiR1FnWTI5dGNHOXVaVzUwSUhKdmIzUWdibTlrWlZ4dUlDQWdJQ0FnYVdZZ0tHbHpSR1ZtS0drZ1BTQjJibTlrWlM1amIyMXdiMjVsYm5SSmJuTjBZVzVqWlNrZ0ppWWdhWE5FWldZb2FTQTlJR2t1WDNadWIyUmxLU0FtSmlCcGMwUmxaaWhwTG1SaGRHRXBLU0I3WEc0Z0lDQWdJQ0FnSUhKbGJXOTJaVUZ1WkVsdWRtOXJaVkpsYlc5MlpVaHZiMnNvYVN3Z2NtMHBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdabTl5SUNocElEMGdNRHNnYVNBOElHTmljeTV5WlcxdmRtVXViR1Z1WjNSb095QXJLMmtwSUh0Y2JpQWdJQ0FnSUNBZ1kySnpMbkpsYlc5MlpWdHBYU2gyYm05a1pTd2djbTBwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnYVdZZ0tHbHpSR1ZtS0drZ1BTQjJibTlrWlM1a1lYUmhMbWh2YjJzcElDWW1JR2x6UkdWbUtHa2dQU0JwTG5KbGJXOTJaU2twSUh0Y2JpQWdJQ0FnSUNBZ2FTaDJibTlrWlN3Z2NtMHBPMXh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdjbTBvS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdjbVZ0YjNabFRtOWtaU2gyYm05a1pTNWxiRzBwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUdaMWJtTjBhVzl1SUhWd1pHRjBaVU5vYVd4a2NtVnVJQ2h3WVhKbGJuUkZiRzBzSUc5c1pFTm9MQ0J1WlhkRGFDd2dhVzV6WlhKMFpXUldibTlrWlZGMVpYVmxMQ0J5WlcxdmRtVlBibXg1S1NCN1hHNGdJQ0FnZG1GeUlHOXNaRk4wWVhKMFNXUjRJRDBnTUR0Y2JpQWdJQ0IyWVhJZ2JtVjNVM1JoY25SSlpIZ2dQU0F3TzF4dUlDQWdJSFpoY2lCdmJHUkZibVJKWkhnZ1BTQnZiR1JEYUM1c1pXNW5kR2dnTFNBeE8xeHVJQ0FnSUhaaGNpQnZiR1JUZEdGeWRGWnViMlJsSUQwZ2IyeGtRMmhiTUYwN1hHNGdJQ0FnZG1GeUlHOXNaRVZ1WkZadWIyUmxJRDBnYjJ4a1EyaGJiMnhrUlc1a1NXUjRYVHRjYmlBZ0lDQjJZWElnYm1WM1JXNWtTV1I0SUQwZ2JtVjNRMmd1YkdWdVozUm9JQzBnTVR0Y2JpQWdJQ0IyWVhJZ2JtVjNVM1JoY25SV2JtOWtaU0E5SUc1bGQwTm9XekJkTzF4dUlDQWdJSFpoY2lCdVpYZEZibVJXYm05a1pTQTlJRzVsZDBOb1cyNWxkMFZ1WkVsa2VGMDdYRzRnSUNBZ2RtRnlJRzlzWkV0bGVWUnZTV1I0TENCcFpIaEpiazlzWkN3Z1pXeHRWRzlOYjNabExDQnlaV1pGYkcwN1hHNWNiaUFnSUNBdkx5QnlaVzF2ZG1WUGJteDVJR2x6SUdFZ2MzQmxZMmxoYkNCbWJHRm5JSFZ6WldRZ2IyNXNlU0JpZVNBOGRISmhibk5wZEdsdmJpMW5jbTkxY0Q1Y2JpQWdJQ0F2THlCMGJ5Qmxibk4xY21VZ2NtVnRiM1psWkNCbGJHVnRaVzUwY3lCemRHRjVJR2x1SUdOdmNuSmxZM1FnY21Wc1lYUnBkbVVnY0c5emFYUnBiMjV6WEc0Z0lDQWdMeThnWkhWeWFXNW5JR3hsWVhacGJtY2dkSEpoYm5OcGRHbHZibk5jYmlBZ0lDQjJZWElnWTJGdVRXOTJaU0E5SUNGeVpXMXZkbVZQYm14NU8xeHVYRzRnSUNBZ2QyaHBiR1VnS0c5c1pGTjBZWEowU1dSNElEdzlJRzlzWkVWdVpFbGtlQ0FtSmlCdVpYZFRkR0Z5ZEVsa2VDQThQU0J1WlhkRmJtUkpaSGdwSUh0Y2JpQWdJQ0FnSUdsbUlDaHBjMVZ1WkdWbUtHOXNaRk4wWVhKMFZtNXZaR1VwS1NCN1hHNGdJQ0FnSUNBZ0lHOXNaRk4wWVhKMFZtNXZaR1VnUFNCdmJHUkRhRnNySzI5c1pGTjBZWEowU1dSNFhUc2dMeThnVm01dlpHVWdhR0Z6SUdKbFpXNGdiVzkyWldRZ2JHVm1kRnh1SUNBZ0lDQWdmU0JsYkhObElHbG1JQ2hwYzFWdVpHVm1LRzlzWkVWdVpGWnViMlJsS1NrZ2UxeHVJQ0FnSUNBZ0lDQnZiR1JGYm1SV2JtOWtaU0E5SUc5c1pFTm9XeTB0YjJ4a1JXNWtTV1I0WFR0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2MyRnRaVlp1YjJSbEtHOXNaRk4wWVhKMFZtNXZaR1VzSUc1bGQxTjBZWEowVm01dlpHVXBLU0I3WEc0Z0lDQWdJQ0FnSUhCaGRHTm9WbTV2WkdVb2IyeGtVM1JoY25SV2JtOWtaU3dnYm1WM1UzUmhjblJXYm05a1pTd2dhVzV6WlhKMFpXUldibTlrWlZGMVpYVmxLVHRjYmlBZ0lDQWdJQ0FnYjJ4a1UzUmhjblJXYm05a1pTQTlJRzlzWkVOb1d5c3JiMnhrVTNSaGNuUkpaSGhkTzF4dUlDQWdJQ0FnSUNCdVpYZFRkR0Z5ZEZadWIyUmxJRDBnYm1WM1EyaGJLeXR1WlhkVGRHRnlkRWxrZUYwN1hHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tITmhiV1ZXYm05a1pTaHZiR1JGYm1SV2JtOWtaU3dnYm1WM1JXNWtWbTV2WkdVcEtTQjdYRzRnSUNBZ0lDQWdJSEJoZEdOb1ZtNXZaR1VvYjJ4a1JXNWtWbTV2WkdVc0lHNWxkMFZ1WkZadWIyUmxMQ0JwYm5ObGNuUmxaRlp1YjJSbFVYVmxkV1VwTzF4dUlDQWdJQ0FnSUNCdmJHUkZibVJXYm05a1pTQTlJRzlzWkVOb1d5MHRiMnhrUlc1a1NXUjRYVHRjYmlBZ0lDQWdJQ0FnYm1WM1JXNWtWbTV2WkdVZ1BTQnVaWGREYUZzdExXNWxkMFZ1WkVsa2VGMDdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLSE5oYldWV2JtOWtaU2h2YkdSVGRHRnlkRlp1YjJSbExDQnVaWGRGYm1SV2JtOWtaU2twSUhzZ0x5OGdWbTV2WkdVZ2JXOTJaV1FnY21sbmFIUmNiaUFnSUNBZ0lDQWdjR0YwWTJoV2JtOWtaU2h2YkdSVGRHRnlkRlp1YjJSbExDQnVaWGRGYm1SV2JtOWtaU3dnYVc1elpYSjBaV1JXYm05a1pWRjFaWFZsS1R0Y2JpQWdJQ0FnSUNBZ1kyRnVUVzkyWlNBbUppQnViMlJsVDNCekxtbHVjMlZ5ZEVKbFptOXlaU2h3WVhKbGJuUkZiRzBzSUc5c1pGTjBZWEowVm01dlpHVXVaV3h0TENCdWIyUmxUM0J6TG01bGVIUlRhV0pzYVc1bktHOXNaRVZ1WkZadWIyUmxMbVZzYlNrcE8xeHVJQ0FnSUNBZ0lDQnZiR1JUZEdGeWRGWnViMlJsSUQwZ2IyeGtRMmhiS3l0dmJHUlRkR0Z5ZEVsa2VGMDdYRzRnSUNBZ0lDQWdJRzVsZDBWdVpGWnViMlJsSUQwZ2JtVjNRMmhiTFMxdVpYZEZibVJKWkhoZE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaHpZVzFsVm01dlpHVW9iMnhrUlc1a1ZtNXZaR1VzSUc1bGQxTjBZWEowVm01dlpHVXBLU0I3SUM4dklGWnViMlJsSUcxdmRtVmtJR3hsWm5SY2JpQWdJQ0FnSUNBZ2NHRjBZMmhXYm05a1pTaHZiR1JGYm1SV2JtOWtaU3dnYm1WM1UzUmhjblJXYm05a1pTd2dhVzV6WlhKMFpXUldibTlrWlZGMVpYVmxLVHRjYmlBZ0lDQWdJQ0FnWTJGdVRXOTJaU0FtSmlCdWIyUmxUM0J6TG1sdWMyVnlkRUpsWm05eVpTaHdZWEpsYm5SRmJHMHNJRzlzWkVWdVpGWnViMlJsTG1Wc2JTd2diMnhrVTNSaGNuUldibTlrWlM1bGJHMHBPMXh1SUNBZ0lDQWdJQ0J2YkdSRmJtUldibTlrWlNBOUlHOXNaRU5vV3kwdGIyeGtSVzVrU1dSNFhUdGNiaUFnSUNBZ0lDQWdibVYzVTNSaGNuUldibTlrWlNBOUlHNWxkME5vV3lzcmJtVjNVM1JoY25SSlpIaGRPMXh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdhV1lnS0dselZXNWtaV1lvYjJ4a1MyVjVWRzlKWkhncEtTQjdJRzlzWkV0bGVWUnZTV1I0SUQwZ1kzSmxZWFJsUzJWNVZHOVBiR1JKWkhnb2IyeGtRMmdzSUc5c1pGTjBZWEowU1dSNExDQnZiR1JGYm1SSlpIZ3BPeUI5WEc0Z0lDQWdJQ0FnSUdsa2VFbHVUMnhrSUQwZ2FYTkVaV1lvYm1WM1UzUmhjblJXYm05a1pTNXJaWGtwSUQ4Z2IyeGtTMlY1Vkc5SlpIaGJibVYzVTNSaGNuUldibTlrWlM1clpYbGRJRG9nYm5Wc2JEdGNiaUFnSUNBZ0lDQWdhV1lnS0dselZXNWtaV1lvYVdSNFNXNVBiR1FwS1NCN0lDOHZJRTVsZHlCbGJHVnRaVzUwWEc0Z0lDQWdJQ0FnSUNBZ1kzSmxZWFJsUld4dEtHNWxkMU4wWVhKMFZtNXZaR1VzSUdsdWMyVnlkR1ZrVm01dlpHVlJkV1YxWlN3Z2NHRnlaVzUwUld4dExDQnZiR1JUZEdGeWRGWnViMlJsTG1Wc2JTazdYRzRnSUNBZ0lDQWdJQ0FnYm1WM1UzUmhjblJXYm05a1pTQTlJRzVsZDBOb1d5c3JibVYzVTNSaGNuUkpaSGhkTzF4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lHVnNiVlJ2VFc5MlpTQTlJRzlzWkVOb1cybGtlRWx1VDJ4a1hUdGNiaUFnSUNBZ0lDQWdJQ0F2S2lCcGMzUmhibUoxYkNCcFoyNXZjbVVnYVdZZ0tpOWNiaUFnSUNBZ0lDQWdJQ0JwWmlBb2NISnZZMlZ6Y3k1bGJuWXVUazlFUlY5RlRsWWdJVDA5SUNkd2NtOWtkV04wYVc5dUp5QW1KaUFoWld4dFZHOU5iM1psS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IzWVhKdUtGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBblNYUWdjMlZsYlhNZ2RHaGxjbVVnWVhKbElHUjFjR3hwWTJGMFpTQnJaWGx6SUhSb1lYUWdhWE1nWTJGMWMybHVaeUJoYmlCMWNHUmhkR1VnWlhKeWIzSXVJQ2NnSzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FuVFdGclpTQnpkWEpsSUdWaFkyZ2dkaTFtYjNJZ2FYUmxiU0JvWVhNZ1lTQjFibWx4ZFdVZ2EyVjVMaWRjYmlBZ0lDQWdJQ0FnSUNBZ0lDazdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2h6WVcxbFZtNXZaR1VvWld4dFZHOU5iM1psTENCdVpYZFRkR0Z5ZEZadWIyUmxLU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdjR0YwWTJoV2JtOWtaU2hsYkcxVWIwMXZkbVVzSUc1bGQxTjBZWEowVm01dlpHVXNJR2x1YzJWeWRHVmtWbTV2WkdWUmRXVjFaU2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnZiR1JEYUZ0cFpIaEpiazlzWkYwZ1BTQjFibVJsWm1sdVpXUTdYRzRnSUNBZ0lDQWdJQ0FnSUNCallXNU5iM1psSUNZbUlHNXZaR1ZQY0hNdWFXNXpaWEowUW1WbWIzSmxLSEJoY21WdWRFVnNiU3dnYm1WM1UzUmhjblJXYm05a1pTNWxiRzBzSUc5c1pGTjBZWEowVm01dlpHVXVaV3h0S1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJRzVsZDFOMFlYSjBWbTV2WkdVZ1BTQnVaWGREYUZzcksyNWxkMU4wWVhKMFNXUjRYVHRjYmlBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdMeThnYzJGdFpTQnJaWGtnWW5WMElHUnBabVpsY21WdWRDQmxiR1Z0Wlc1MExpQjBjbVZoZENCaGN5QnVaWGNnWld4bGJXVnVkRnh1SUNBZ0lDQWdJQ0FnSUNBZ1kzSmxZWFJsUld4dEtHNWxkMU4wWVhKMFZtNXZaR1VzSUdsdWMyVnlkR1ZrVm01dlpHVlJkV1YxWlN3Z2NHRnlaVzUwUld4dExDQnZiR1JUZEdGeWRGWnViMlJsTG1Wc2JTazdYRzRnSUNBZ0lDQWdJQ0FnSUNCdVpYZFRkR0Z5ZEZadWIyUmxJRDBnYm1WM1EyaGJLeXR1WlhkVGRHRnlkRWxrZUYwN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1SUNBZ0lHbG1JQ2h2YkdSVGRHRnlkRWxrZUNBK0lHOXNaRVZ1WkVsa2VDa2dlMXh1SUNBZ0lDQWdjbVZtUld4dElEMGdhWE5WYm1SbFppaHVaWGREYUZ0dVpYZEZibVJKWkhnZ0t5QXhYU2tnUHlCdWRXeHNJRG9nYm1WM1EyaGJibVYzUlc1a1NXUjRJQ3NnTVYwdVpXeHRPMXh1SUNBZ0lDQWdZV1JrVm01dlpHVnpLSEJoY21WdWRFVnNiU3dnY21WbVJXeHRMQ0J1WlhkRGFDd2dibVYzVTNSaGNuUkpaSGdzSUc1bGQwVnVaRWxrZUN3Z2FXNXpaWEowWldSV2JtOWtaVkYxWlhWbEtUdGNiaUFnSUNCOUlHVnNjMlVnYVdZZ0tHNWxkMU4wWVhKMFNXUjRJRDRnYm1WM1JXNWtTV1I0S1NCN1hHNGdJQ0FnSUNCeVpXMXZkbVZXYm05a1pYTW9jR0Z5Wlc1MFJXeHRMQ0J2YkdSRGFDd2diMnhrVTNSaGNuUkpaSGdzSUc5c1pFVnVaRWxrZUNrN1hHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ1puVnVZM1JwYjI0Z2NHRjBZMmhXYm05a1pTQW9iMnhrVm01dlpHVXNJSFp1YjJSbExDQnBibk5sY25SbFpGWnViMlJsVVhWbGRXVXNJSEpsYlc5MlpVOXViSGtwSUh0Y2JpQWdJQ0JwWmlBb2IyeGtWbTV2WkdVZ1BUMDlJSFp1YjJSbEtTQjdYRzRnSUNBZ0lDQnlaWFIxY201Y2JpQWdJQ0I5WEc0Z0lDQWdMeThnY21WMWMyVWdaV3hsYldWdWRDQm1iM0lnYzNSaGRHbGpJSFJ5WldWekxseHVJQ0FnSUM4dklHNXZkR1VnZDJVZ2IyNXNlU0JrYnlCMGFHbHpJR2xtSUhSb1pTQjJibTlrWlNCcGN5QmpiRzl1WldRZ0xWeHVJQ0FnSUM4dklHbG1JSFJvWlNCdVpYY2dibTlrWlNCcGN5QnViM1FnWTJ4dmJtVmtJR2wwSUcxbFlXNXpJSFJvWlNCeVpXNWtaWElnWm5WdVkzUnBiMjV6SUdoaGRtVWdZbVZsYmx4dUlDQWdJQzh2SUhKbGMyVjBJR0o1SUhSb1pTQm9iM1F0Y21Wc2IyRmtMV0Z3YVNCaGJtUWdkMlVnYm1WbFpDQjBieUJrYnlCaElIQnliM0JsY2lCeVpTMXlaVzVrWlhJdVhHNGdJQ0FnYVdZZ0tHbHpWSEoxWlNoMmJtOWtaUzVwYzFOMFlYUnBZeWtnSmlaY2JpQWdJQ0FnSUNBZ2FYTlVjblZsS0c5c1pGWnViMlJsTG1selUzUmhkR2xqS1NBbUpseHVJQ0FnSUNBZ0lDQjJibTlrWlM1clpYa2dQVDA5SUc5c1pGWnViMlJsTG10bGVTQW1KbHh1SUNBZ0lDQWdJQ0FvYVhOVWNuVmxLSFp1YjJSbExtbHpRMnh2Ym1Wa0tTQjhmQ0JwYzFSeWRXVW9kbTV2WkdVdWFYTlBibU5sS1NrcElIdGNiaUFnSUNBZ0lIWnViMlJsTG1Wc2JTQTlJRzlzWkZadWIyUmxMbVZzYlR0Y2JpQWdJQ0FnSUhadWIyUmxMbU52YlhCdmJtVnVkRWx1YzNSaGJtTmxJRDBnYjJ4a1ZtNXZaR1V1WTI5dGNHOXVaVzUwU1c1emRHRnVZMlU3WEc0Z0lDQWdJQ0J5WlhSMWNtNWNiaUFnSUNCOVhHNGdJQ0FnZG1GeUlHazdYRzRnSUNBZ2RtRnlJR1JoZEdFZ1BTQjJibTlrWlM1a1lYUmhPMXh1SUNBZ0lHbG1JQ2hwYzBSbFppaGtZWFJoS1NBbUppQnBjMFJsWmlocElEMGdaR0YwWVM1b2IyOXJLU0FtSmlCcGMwUmxaaWhwSUQwZ2FTNXdjbVZ3WVhSamFDa3BJSHRjYmlBZ0lDQWdJR2tvYjJ4a1ZtNXZaR1VzSUhadWIyUmxLVHRjYmlBZ0lDQjlYRzRnSUNBZ2RtRnlJR1ZzYlNBOUlIWnViMlJsTG1Wc2JTQTlJRzlzWkZadWIyUmxMbVZzYlR0Y2JpQWdJQ0IyWVhJZ2IyeGtRMmdnUFNCdmJHUldibTlrWlM1amFHbHNaSEpsYmp0Y2JpQWdJQ0IyWVhJZ1kyZ2dQU0IyYm05a1pTNWphR2xzWkhKbGJqdGNiaUFnSUNCcFppQW9hWE5FWldZb1pHRjBZU2tnSmlZZ2FYTlFZWFJqYUdGaWJHVW9kbTV2WkdVcEtTQjdYRzRnSUNBZ0lDQm1iM0lnS0drZ1BTQXdPeUJwSUR3Z1kySnpMblZ3WkdGMFpTNXNaVzVuZEdnN0lDc3JhU2tnZXlCalluTXVkWEJrWVhSbFcybGRLRzlzWkZadWIyUmxMQ0IyYm05a1pTazdJSDFjYmlBZ0lDQWdJR2xtSUNocGMwUmxaaWhwSUQwZ1pHRjBZUzVvYjI5cktTQW1KaUJwYzBSbFppaHBJRDBnYVM1MWNHUmhkR1VwS1NCN0lHa29iMnhrVm01dlpHVXNJSFp1YjJSbEtUc2dmVnh1SUNBZ0lIMWNiaUFnSUNCcFppQW9hWE5WYm1SbFppaDJibTlrWlM1MFpYaDBLU2tnZTF4dUlDQWdJQ0FnYVdZZ0tHbHpSR1ZtS0c5c1pFTm9LU0FtSmlCcGMwUmxaaWhqYUNrcElIdGNiaUFnSUNBZ0lDQWdhV1lnS0c5c1pFTm9JQ0U5UFNCamFDa2dleUIxY0dSaGRHVkRhR2xzWkhKbGJpaGxiRzBzSUc5c1pFTm9MQ0JqYUN3Z2FXNXpaWEowWldSV2JtOWtaVkYxWlhWbExDQnlaVzF2ZG1WUGJteDVLVHNnZlZ4dUlDQWdJQ0FnZlNCbGJITmxJR2xtSUNocGMwUmxaaWhqYUNrcElIdGNiaUFnSUNBZ0lDQWdhV1lnS0dselJHVm1LRzlzWkZadWIyUmxMblJsZUhRcEtTQjdJRzV2WkdWUGNITXVjMlYwVkdWNGRFTnZiblJsYm5Rb1pXeHRMQ0FuSnlrN0lIMWNiaUFnSUNBZ0lDQWdZV1JrVm01dlpHVnpLR1ZzYlN3Z2JuVnNiQ3dnWTJnc0lEQXNJR05vTG14bGJtZDBhQ0F0SURFc0lHbHVjMlZ5ZEdWa1ZtNXZaR1ZSZFdWMVpTazdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLR2x6UkdWbUtHOXNaRU5vS1NrZ2UxeHVJQ0FnSUNBZ0lDQnlaVzF2ZG1WV2JtOWtaWE1vWld4dExDQnZiR1JEYUN3Z01Dd2diMnhrUTJndWJHVnVaM1JvSUMwZ01TazdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLR2x6UkdWbUtHOXNaRlp1YjJSbExuUmxlSFFwS1NCN1hHNGdJQ0FnSUNBZ0lHNXZaR1ZQY0hNdWMyVjBWR1Y0ZEVOdmJuUmxiblFvWld4dExDQW5KeWs3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2h2YkdSV2JtOWtaUzUwWlhoMElDRTlQU0IyYm05a1pTNTBaWGgwS1NCN1hHNGdJQ0FnSUNCdWIyUmxUM0J6TG5ObGRGUmxlSFJEYjI1MFpXNTBLR1ZzYlN3Z2RtNXZaR1V1ZEdWNGRDazdYRzRnSUNBZ2ZWeHVJQ0FnSUdsbUlDaHBjMFJsWmloa1lYUmhLU2tnZTF4dUlDQWdJQ0FnYVdZZ0tHbHpSR1ZtS0drZ1BTQmtZWFJoTG1odmIyc3BJQ1ltSUdselJHVm1LR2tnUFNCcExuQnZjM1J3WVhSamFDa3BJSHNnYVNodmJHUldibTlrWlN3Z2RtNXZaR1VwT3lCOVhHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ1puVnVZM1JwYjI0Z2FXNTJiMnRsU1c1elpYSjBTRzl2YXlBb2RtNXZaR1VzSUhGMVpYVmxMQ0JwYm1sMGFXRnNLU0I3WEc0Z0lDQWdMeThnWkdWc1lYa2dhVzV6WlhKMElHaHZiMnR6SUdadmNpQmpiMjF3YjI1bGJuUWdjbTl2ZENCdWIyUmxjeXdnYVc1MmIydGxJSFJvWlcwZ1lXWjBaWElnZEdobFhHNGdJQ0FnTHk4Z1pXeGxiV1Z1ZENCcGN5QnlaV0ZzYkhrZ2FXNXpaWEowWldSY2JpQWdJQ0JwWmlBb2FYTlVjblZsS0dsdWFYUnBZV3dwSUNZbUlHbHpSR1ZtS0hadWIyUmxMbkJoY21WdWRDa3BJSHRjYmlBZ0lDQWdJSFp1YjJSbExuQmhjbVZ1ZEM1a1lYUmhMbkJsYm1ScGJtZEpibk5sY25RZ1BTQnhkV1YxWlR0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0J4ZFdWMVpTNXNaVzVuZEdnN0lDc3JhU2tnZTF4dUlDQWdJQ0FnSUNCeGRXVjFaVnRwWFM1a1lYUmhMbWh2YjJzdWFXNXpaWEowS0hGMVpYVmxXMmxkS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCMllYSWdZbUZwYkdWa0lEMGdabUZzYzJVN1hHNGdJQzh2SUd4cGMzUWdiMllnYlc5a2RXeGxjeUIwYUdGMElHTmhiaUJ6YTJsd0lHTnlaV0YwWlNCb2IyOXJJR1IxY21sdVp5Qm9lV1J5WVhScGIyNGdZbVZqWVhWelpTQjBhR1Y1WEc0Z0lDOHZJR0Z5WlNCaGJISmxZV1I1SUhKbGJtUmxjbVZrSUc5dUlIUm9aU0JqYkdsbGJuUWdiM0lnYUdGeklHNXZJRzVsWldRZ1ptOXlJR2x1YVhScFlXeHBlbUYwYVc5dVhHNGdJSFpoY2lCcGMxSmxibVJsY21Wa1RXOWtkV3hsSUQwZ2JXRnJaVTFoY0NnbllYUjBjbk1zYzNSNWJHVXNZMnhoYzNNc2MzUmhkR2xqUTJ4aGMzTXNjM1JoZEdsalUzUjViR1VzYTJWNUp5azdYRzVjYmlBZ0x5OGdUbTkwWlRvZ2RHaHBjeUJwY3lCaElHSnliM2R6WlhJdGIyNXNlU0JtZFc1amRHbHZiaUJ6YnlCM1pTQmpZVzRnWVhOemRXMWxJR1ZzYlhNZ1lYSmxJRVJQVFNCdWIyUmxjeTVjYmlBZ1puVnVZM1JwYjI0Z2FIbGtjbUYwWlNBb1pXeHRMQ0IyYm05a1pTd2dhVzV6WlhKMFpXUldibTlrWlZGMVpYVmxLU0I3WEc0Z0lDQWdhV1lnS0hCeWIyTmxjM011Wlc1MkxrNVBSRVZmUlU1V0lDRTlQU0FuY0hKdlpIVmpkR2x2YmljcElIdGNiaUFnSUNBZ0lHbG1JQ2doWVhOelpYSjBUbTlrWlUxaGRHTm9LR1ZzYlN3Z2RtNXZaR1VwS1NCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCbVlXeHpaVnh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNiaUFnSUNCMmJtOWtaUzVsYkcwZ1BTQmxiRzA3WEc0Z0lDQWdkbUZ5SUhSaFp5QTlJSFp1YjJSbExuUmhaenRjYmlBZ0lDQjJZWElnWkdGMFlTQTlJSFp1YjJSbExtUmhkR0U3WEc0Z0lDQWdkbUZ5SUdOb2FXeGtjbVZ1SUQwZ2RtNXZaR1V1WTJocGJHUnlaVzQ3WEc0Z0lDQWdhV1lnS0dselJHVm1LR1JoZEdFcEtTQjdYRzRnSUNBZ0lDQnBaaUFvYVhORVpXWW9hU0E5SUdSaGRHRXVhRzl2YXlrZ0ppWWdhWE5FWldZb2FTQTlJR2t1YVc1cGRDa3BJSHNnYVNoMmJtOWtaU3dnZEhKMVpTQXZLaUJvZVdSeVlYUnBibWNnS2k4cE95QjlYRzRnSUNBZ0lDQnBaaUFvYVhORVpXWW9hU0E5SUhadWIyUmxMbU52YlhCdmJtVnVkRWx1YzNSaGJtTmxLU2tnZTF4dUlDQWdJQ0FnSUNBdkx5QmphR2xzWkNCamIyMXdiMjVsYm5RdUlHbDBJSE5vYjNWc1pDQm9ZWFpsSUdoNVpISmhkR1ZrSUdsMGN5QnZkMjRnZEhKbFpTNWNiaUFnSUNBZ0lDQWdhVzVwZEVOdmJYQnZibVZ1ZENoMmJtOWtaU3dnYVc1elpYSjBaV1JXYm05a1pWRjFaWFZsS1R0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSeWRXVmNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNGdJQ0FnYVdZZ0tHbHpSR1ZtS0hSaFp5a3BJSHRjYmlBZ0lDQWdJR2xtSUNocGMwUmxaaWhqYUdsc1pISmxiaWtwSUh0Y2JpQWdJQ0FnSUNBZ0x5OGdaVzF3ZEhrZ1pXeGxiV1Z1ZEN3Z1lXeHNiM2NnWTJ4cFpXNTBJSFJ2SUhCcFkyc2dkWEFnWVc1a0lIQnZjSFZzWVhSbElHTm9hV3hrY21WdVhHNGdJQ0FnSUNBZ0lHbG1JQ2doWld4dExtaGhjME5vYVd4a1RtOWtaWE1vS1NrZ2UxeHVJQ0FnSUNBZ0lDQWdJR055WldGMFpVTm9hV3hrY21WdUtIWnViMlJsTENCamFHbHNaSEpsYml3Z2FXNXpaWEowWldSV2JtOWtaVkYxWlhWbEtUdGNiaUFnSUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdJQ0IyWVhJZ1kyaHBiR1J5Wlc1TllYUmphQ0E5SUhSeWRXVTdYRzRnSUNBZ0lDQWdJQ0FnZG1GeUlHTm9hV3hrVG05a1pTQTlJR1ZzYlM1bWFYSnpkRU5vYVd4a08xeHVJQ0FnSUNBZ0lDQWdJR1p2Y2lBb2RtRnlJR2trTVNBOUlEQTdJR2trTVNBOElHTm9hV3hrY21WdUxteGxibWQwYURzZ2FTUXhLeXNwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNnaFkyaHBiR1JPYjJSbElIeDhJQ0ZvZVdSeVlYUmxLR05vYVd4a1RtOWtaU3dnWTJocGJHUnlaVzViYVNReFhTd2dhVzV6WlhKMFpXUldibTlrWlZGMVpYVmxLU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JqYUdsc1pISmxiazFoZEdOb0lEMGdabUZzYzJVN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUdKeVpXRnJYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYUdsc1pFNXZaR1VnUFNCamFHbHNaRTV2WkdVdWJtVjRkRk5wWW14cGJtYzdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lDOHZJR2xtSUdOb2FXeGtUbTlrWlNCcGN5QnViM1FnYm5Wc2JDd2dhWFFnYldWaGJuTWdkR2hsSUdGamRIVmhiQ0JqYUdsc1pFNXZaR1Z6SUd4cGMzUWdhWE5jYmlBZ0lDQWdJQ0FnSUNBdkx5QnNiMjVuWlhJZ2RHaGhiaUIwYUdVZ2RtbHlkSFZoYkNCamFHbHNaSEpsYmlCc2FYTjBMbHh1SUNBZ0lDQWdJQ0FnSUdsbUlDZ2hZMmhwYkdSeVpXNU5ZWFJqYUNCOGZDQmphR2xzWkU1dlpHVXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2h3Y205alpYTnpMbVZ1ZGk1T1QwUkZYMFZPVmlBaFBUMGdKM0J5YjJSMVkzUnBiMjRuSUNZbVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RIbHdaVzltSUdOdmJuTnZiR1VnSVQwOUlDZDFibVJsWm1sdVpXUW5JQ1ltWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSVdKaGFXeGxaQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JpWVdsc1pXUWdQU0IwY25WbE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNXpiMnhsTG5kaGNtNG9KMUJoY21WdWREb2dKeXdnWld4dEtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjMjlzWlM1M1lYSnVLQ2ROYVhOdFlYUmphR2x1WnlCamFHbHNaRTV2WkdWeklIWnpMaUJXVG05a1pYTTZJQ2NzSUdWc2JTNWphR2xzWkU1dlpHVnpMQ0JqYUdsc1pISmxiaWs3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnWm1Gc2MyVmNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUdsbUlDaHBjMFJsWmloa1lYUmhLU2tnZTF4dUlDQWdJQ0FnSUNCbWIzSWdLSFpoY2lCclpYa2dhVzRnWkdGMFlTa2dlMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDZ2hhWE5TWlc1a1pYSmxaRTF2WkhWc1pTaHJaWGtwS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JwYm5admEyVkRjbVZoZEdWSWIyOXJjeWgyYm05a1pTd2dhVzV6WlhKMFpXUldibTlrWlZGMVpYVmxLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHSnlaV0ZyWEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZTQmxiSE5sSUdsbUlDaGxiRzB1WkdGMFlTQWhQVDBnZG01dlpHVXVkR1Y0ZENrZ2UxeHVJQ0FnSUNBZ1pXeHRMbVJoZEdFZ1BTQjJibTlrWlM1MFpYaDBPMXh1SUNBZ0lIMWNiaUFnSUNCeVpYUjFjbTRnZEhKMVpWeHVJQ0I5WEc1Y2JpQWdablZ1WTNScGIyNGdZWE56WlhKMFRtOWtaVTFoZEdOb0lDaHViMlJsTENCMmJtOWtaU2tnZTF4dUlDQWdJR2xtSUNocGMwUmxaaWgyYm05a1pTNTBZV2NwS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnS0Z4dUlDQWdJQ0FnSUNCMmJtOWtaUzUwWVdjdWFXNWtaWGhQWmlnbmRuVmxMV052YlhCdmJtVnVkQ2NwSUQwOVBTQXdJSHg4WEc0Z0lDQWdJQ0FnSUhadWIyUmxMblJoWnk1MGIweHZkMlZ5UTJGelpTZ3BJRDA5UFNBb2JtOWtaUzUwWVdkT1lXMWxJQ1ltSUc1dlpHVXVkR0ZuVG1GdFpTNTBiMHh2ZDJWeVEyRnpaU2dwS1Z4dUlDQWdJQ0FnS1Z4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z2JtOWtaUzV1YjJSbFZIbHdaU0E5UFQwZ0tIWnViMlJsTG1selEyOXRiV1Z1ZENBL0lEZ2dPaUF6S1Z4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJtZFc1amRHbHZiaUJ3WVhSamFDQW9iMnhrVm01dlpHVXNJSFp1YjJSbExDQm9lV1J5WVhScGJtY3NJSEpsYlc5MlpVOXViSGtzSUhCaGNtVnVkRVZzYlN3Z2NtVm1SV3h0S1NCN1hHNGdJQ0FnYVdZZ0tHbHpWVzVrWldZb2RtNXZaR1VwS1NCN1hHNGdJQ0FnSUNCcFppQW9hWE5FWldZb2IyeGtWbTV2WkdVcEtTQjdJR2x1ZG05clpVUmxjM1J5YjNsSWIyOXJLRzlzWkZadWIyUmxLVHNnZlZ4dUlDQWdJQ0FnY21WMGRYSnVYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2RtRnlJR2x6U1c1cGRHbGhiRkJoZEdOb0lEMGdabUZzYzJVN1hHNGdJQ0FnZG1GeUlHbHVjMlZ5ZEdWa1ZtNXZaR1ZSZFdWMVpTQTlJRnRkTzF4dVhHNGdJQ0FnYVdZZ0tHbHpWVzVrWldZb2IyeGtWbTV2WkdVcEtTQjdYRzRnSUNBZ0lDQXZMeUJsYlhCMGVTQnRiM1Z1ZENBb2JHbHJaV3g1SUdGeklHTnZiWEJ2Ym1WdWRDa3NJR055WldGMFpTQnVaWGNnY205dmRDQmxiR1Z0Wlc1MFhHNGdJQ0FnSUNCcGMwbHVhWFJwWVd4UVlYUmphQ0E5SUhSeWRXVTdYRzRnSUNBZ0lDQmpjbVZoZEdWRmJHMG9kbTV2WkdVc0lHbHVjMlZ5ZEdWa1ZtNXZaR1ZSZFdWMVpTd2djR0Z5Wlc1MFJXeHRMQ0J5WldaRmJHMHBPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCMllYSWdhWE5TWldGc1JXeGxiV1Z1ZENBOUlHbHpSR1ZtS0c5c1pGWnViMlJsTG01dlpHVlVlWEJsS1R0Y2JpQWdJQ0FnSUdsbUlDZ2hhWE5TWldGc1JXeGxiV1Z1ZENBbUppQnpZVzFsVm01dlpHVW9iMnhrVm01dlpHVXNJSFp1YjJSbEtTa2dlMXh1SUNBZ0lDQWdJQ0F2THlCd1lYUmphQ0JsZUdsemRHbHVaeUJ5YjI5MElHNXZaR1ZjYmlBZ0lDQWdJQ0FnY0dGMFkyaFdibTlrWlNodmJHUldibTlrWlN3Z2RtNXZaR1VzSUdsdWMyVnlkR1ZrVm01dlpHVlJkV1YxWlN3Z2NtVnRiM1psVDI1c2VTazdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvYVhOU1pXRnNSV3hsYldWdWRDa2dlMXh1SUNBZ0lDQWdJQ0FnSUM4dklHMXZkVzUwYVc1bklIUnZJR0VnY21WaGJDQmxiR1Z0Wlc1MFhHNGdJQ0FnSUNBZ0lDQWdMeThnWTJobFkyc2dhV1lnZEdocGN5QnBjeUJ6WlhKMlpYSXRjbVZ1WkdWeVpXUWdZMjl1ZEdWdWRDQmhibVFnYVdZZ2QyVWdZMkZ1SUhCbGNtWnZjbTFjYmlBZ0lDQWdJQ0FnSUNBdkx5QmhJSE4xWTJObGMzTm1kV3dnYUhsa2NtRjBhVzl1TGx4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2h2YkdSV2JtOWtaUzV1YjJSbFZIbHdaU0E5UFQwZ01TQW1KaUJ2YkdSV2JtOWtaUzVvWVhOQmRIUnlhV0oxZEdVb0ozTmxjblpsY2kxeVpXNWtaWEpsWkNjcEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCdmJHUldibTlrWlM1eVpXMXZkbVZCZEhSeWFXSjFkR1VvSjNObGNuWmxjaTF5Wlc1a1pYSmxaQ2NwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdhSGxrY21GMGFXNW5JRDBnZEhKMVpUdGNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLR2x6VkhKMVpTaG9lV1J5WVhScGJtY3BLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvYUhsa2NtRjBaU2h2YkdSV2JtOWtaU3dnZG01dlpHVXNJR2x1YzJWeWRHVmtWbTV2WkdWUmRXVjFaU2twSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnYVc1MmIydGxTVzV6WlhKMFNHOXZheWgyYm05a1pTd2dhVzV6WlhKMFpXUldibTlrWlZGMVpYVmxMQ0IwY25WbEtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUc5c1pGWnViMlJsWEc0Z0lDQWdJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLSEJ5YjJObGMzTXVaVzUyTGs1UFJFVmZSVTVXSUNFOVBTQW5jSEp2WkhWamRHbHZiaWNwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnZDJGeWJpaGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQW5WR2hsSUdOc2FXVnVkQzF6YVdSbElISmxibVJsY21Wa0lIWnBjblIxWVd3Z1JFOU5JSFJ5WldVZ2FYTWdibTkwSUcxaGRHTm9hVzVuSUNjZ0sxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDZHpaWEoyWlhJdGNtVnVaR1Z5WldRZ1kyOXVkR1Z1ZEM0Z1ZHaHBjeUJwY3lCc2FXdGxiSGtnWTJGMWMyVmtJR0o1SUdsdVkyOXljbVZqZENBbklDdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQW5TRlJOVENCdFlYSnJkWEFzSUdadmNpQmxlR0Z0Y0d4bElHNWxjM1JwYm1jZ1lteHZZMnN0YkdWMlpXd2daV3hsYldWdWRITWdhVzV6YVdSbElDY2dLMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ2M4Y0Q0c0lHOXlJRzFwYzNOcGJtY2dQSFJpYjJSNVBpNGdRbUZwYkdsdVp5Qm9lV1J5WVhScGIyNGdZVzVrSUhCbGNtWnZjbTFwYm1jZ0p5QXJYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdKMloxYkd3Z1kyeHBaVzUwTFhOcFpHVWdjbVZ1WkdWeUxpZGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0tUdGNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnTHk4Z1pXbDBhR1Z5SUc1dmRDQnpaWEoyWlhJdGNtVnVaR1Z5WldRc0lHOXlJR2g1WkhKaGRHbHZiaUJtWVdsc1pXUXVYRzRnSUNBZ0lDQWdJQ0FnTHk4Z1kzSmxZWFJsSUdGdUlHVnRjSFI1SUc1dlpHVWdZVzVrSUhKbGNHeGhZMlVnYVhSY2JpQWdJQ0FnSUNBZ0lDQnZiR1JXYm05a1pTQTlJR1Z0Y0hSNVRtOWtaVUYwS0c5c1pGWnViMlJsS1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQXZMeUJ5WlhCc1lXTnBibWNnWlhocGMzUnBibWNnWld4bGJXVnVkRnh1SUNBZ0lDQWdJQ0IyWVhJZ2IyeGtSV3h0SUQwZ2IyeGtWbTV2WkdVdVpXeHRPMXh1SUNBZ0lDQWdJQ0IyWVhJZ2NHRnlaVzUwUld4dEpERWdQU0J1YjJSbFQzQnpMbkJoY21WdWRFNXZaR1VvYjJ4a1JXeHRLVHRjYmlBZ0lDQWdJQ0FnWTNKbFlYUmxSV3h0S0Z4dUlDQWdJQ0FnSUNBZ0lIWnViMlJsTEZ4dUlDQWdJQ0FnSUNBZ0lHbHVjMlZ5ZEdWa1ZtNXZaR1ZSZFdWMVpTeGNiaUFnSUNBZ0lDQWdJQ0F2THlCbGVIUnlaVzFsYkhrZ2NtRnlaU0JsWkdkbElHTmhjMlU2SUdSdklHNXZkQ0JwYm5ObGNuUWdhV1lnYjJ4a0lHVnNaVzFsYm5RZ2FYTWdhVzRnWVZ4dUlDQWdJQ0FnSUNBZ0lDOHZJR3hsWVhacGJtY2dkSEpoYm5OcGRHbHZiaTRnVDI1c2VTQm9ZWEJ3Wlc1eklIZG9aVzRnWTI5dFltbHVhVzVuSUhSeVlXNXphWFJwYjI0Z0sxeHVJQ0FnSUNBZ0lDQWdJQzh2SUd0bFpYQXRZV3hwZG1VZ0t5QklUME56TGlBb0l6UTFPVEFwWEc0Z0lDQWdJQ0FnSUNBZ2IyeGtSV3h0TGw5c1pXRjJaVU5pSUQ4Z2JuVnNiQ0E2SUhCaGNtVnVkRVZzYlNReExGeHVJQ0FnSUNBZ0lDQWdJRzV2WkdWUGNITXVibVY0ZEZOcFlteHBibWNvYjJ4a1JXeHRLVnh1SUNBZ0lDQWdJQ0FwTzF4dVhHNGdJQ0FnSUNBZ0lHbG1JQ2hwYzBSbFppaDJibTlrWlM1d1lYSmxiblFwS1NCN1hHNGdJQ0FnSUNBZ0lDQWdMeThnWTI5dGNHOXVaVzUwSUhKdmIzUWdaV3hsYldWdWRDQnlaWEJzWVdObFpDNWNiaUFnSUNBZ0lDQWdJQ0F2THlCMWNHUmhkR1VnY0dGeVpXNTBJSEJzWVdObGFHOXNaR1Z5SUc1dlpHVWdaV3hsYldWdWRDd2djbVZqZFhKemFYWmxiSGxjYmlBZ0lDQWdJQ0FnSUNCMllYSWdZVzVqWlhOMGIzSWdQU0IyYm05a1pTNXdZWEpsYm5RN1hHNGdJQ0FnSUNBZ0lDQWdkMmhwYkdVZ0tHRnVZMlZ6ZEc5eUtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCaGJtTmxjM1J2Y2k1bGJHMGdQU0IyYm05a1pTNWxiRzA3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmhibU5sYzNSdmNpQTlJR0Z1WTJWemRHOXlMbkJoY21WdWREdGNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLR2x6VUdGMFkyaGhZbXhsS0hadWIyUmxLU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JqWW5NdVkzSmxZWFJsTG14bGJtZDBhRHNnS3l0cEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHTmljeTVqY21WaGRHVmJhVjBvWlcxd2RIbE9iMlJsTENCMmJtOWtaUzV3WVhKbGJuUXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lHbG1JQ2hwYzBSbFppaHdZWEpsYm5SRmJHMGtNU2twSUh0Y2JpQWdJQ0FnSUNBZ0lDQnlaVzF2ZG1WV2JtOWtaWE1vY0dGeVpXNTBSV3h0SkRFc0lGdHZiR1JXYm05a1pWMHNJREFzSURBcE8xeHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLR2x6UkdWbUtHOXNaRlp1YjJSbExuUmhaeWtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnBiblp2YTJWRVpYTjBjbTk1U0c5dmF5aHZiR1JXYm05a1pTazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQnBiblp2YTJWSmJuTmxjblJJYjI5cktIWnViMlJsTENCcGJuTmxjblJsWkZadWIyUmxVWFZsZFdVc0lHbHpTVzVwZEdsaGJGQmhkR05vS1R0Y2JpQWdJQ0J5WlhSMWNtNGdkbTV2WkdVdVpXeHRYRzRnSUgxY2JuMWNibHh1THlvZ0lDb3ZYRzVjYm5aaGNpQmthWEpsWTNScGRtVnpJRDBnZTF4dUlDQmpjbVZoZEdVNklIVndaR0YwWlVScGNtVmpkR2wyWlhNc1hHNGdJSFZ3WkdGMFpUb2dkWEJrWVhSbFJHbHlaV04wYVhabGN5eGNiaUFnWkdWemRISnZlVG9nWm5WdVkzUnBiMjRnZFc1aWFXNWtSR2x5WldOMGFYWmxjeUFvZG01dlpHVXBJSHRjYmlBZ0lDQjFjR1JoZEdWRWFYSmxZM1JwZG1WektIWnViMlJsTENCbGJYQjBlVTV2WkdVcE8xeHVJQ0I5WEc1OU8xeHVYRzVtZFc1amRHbHZiaUIxY0dSaGRHVkVhWEpsWTNScGRtVnpJQ2h2YkdSV2JtOWtaU3dnZG01dlpHVXBJSHRjYmlBZ2FXWWdLRzlzWkZadWIyUmxMbVJoZEdFdVpHbHlaV04wYVhabGN5QjhmQ0IyYm05a1pTNWtZWFJoTG1ScGNtVmpkR2wyWlhNcElIdGNiaUFnSUNCZmRYQmtZWFJsS0c5c1pGWnViMlJsTENCMmJtOWtaU2s3WEc0Z0lIMWNibjFjYmx4dVpuVnVZM1JwYjI0Z1gzVndaR0YwWlNBb2IyeGtWbTV2WkdVc0lIWnViMlJsS1NCN1hHNGdJSFpoY2lCcGMwTnlaV0YwWlNBOUlHOXNaRlp1YjJSbElEMDlQU0JsYlhCMGVVNXZaR1U3WEc0Z0lIWmhjaUJwYzBSbGMzUnliM2tnUFNCMmJtOWtaU0E5UFQwZ1pXMXdkSGxPYjJSbE8xeHVJQ0IyWVhJZ2IyeGtSR2x5Y3lBOUlHNXZjbTFoYkdsNlpVUnBjbVZqZEdsMlpYTWtNU2h2YkdSV2JtOWtaUzVrWVhSaExtUnBjbVZqZEdsMlpYTXNJRzlzWkZadWIyUmxMbU52Ym5SbGVIUXBPMXh1SUNCMllYSWdibVYzUkdseWN5QTlJRzV2Y20xaGJHbDZaVVJwY21WamRHbDJaWE1rTVNoMmJtOWtaUzVrWVhSaExtUnBjbVZqZEdsMlpYTXNJSFp1YjJSbExtTnZiblJsZUhRcE8xeHVYRzRnSUhaaGNpQmthWEp6VjJsMGFFbHVjMlZ5ZENBOUlGdGRPMXh1SUNCMllYSWdaR2x5YzFkcGRHaFFiM04wY0dGMFkyZ2dQU0JiWFR0Y2JseHVJQ0IyWVhJZ2EyVjVMQ0J2YkdSRWFYSXNJR1JwY2p0Y2JpQWdabTl5SUNoclpYa2dhVzRnYm1WM1JHbHljeWtnZTF4dUlDQWdJRzlzWkVScGNpQTlJRzlzWkVScGNuTmJhMlY1WFR0Y2JpQWdJQ0JrYVhJZ1BTQnVaWGRFYVhKelcydGxlVjA3WEc0Z0lDQWdhV1lnS0NGdmJHUkVhWElwSUh0Y2JpQWdJQ0FnSUM4dklHNWxkeUJrYVhKbFkzUnBkbVVzSUdKcGJtUmNiaUFnSUNBZ0lHTmhiR3hJYjI5ckpERW9aR2x5TENBblltbHVaQ2NzSUhadWIyUmxMQ0J2YkdSV2JtOWtaU2s3WEc0Z0lDQWdJQ0JwWmlBb1pHbHlMbVJsWmlBbUppQmthWEl1WkdWbUxtbHVjMlZ5ZEdWa0tTQjdYRzRnSUNBZ0lDQWdJR1JwY25OWGFYUm9TVzV6WlhKMExuQjFjMmdvWkdseUtUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnTHk4Z1pYaHBjM1JwYm1jZ1pHbHlaV04wYVhabExDQjFjR1JoZEdWY2JpQWdJQ0FnSUdScGNpNXZiR1JXWVd4MVpTQTlJRzlzWkVScGNpNTJZV3gxWlR0Y2JpQWdJQ0FnSUdOaGJHeEliMjlySkRFb1pHbHlMQ0FuZFhCa1lYUmxKeXdnZG01dlpHVXNJRzlzWkZadWIyUmxLVHRjYmlBZ0lDQWdJR2xtSUNoa2FYSXVaR1ZtSUNZbUlHUnBjaTVrWldZdVkyOXRjRzl1Wlc1MFZYQmtZWFJsWkNrZ2UxeHVJQ0FnSUNBZ0lDQmthWEp6VjJsMGFGQnZjM1J3WVhSamFDNXdkWE5vS0dScGNpazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdhV1lnS0dScGNuTlhhWFJvU1c1elpYSjBMbXhsYm1kMGFDa2dlMXh1SUNBZ0lIWmhjaUJqWVd4c1NXNXpaWEowSUQwZ1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNBZ0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JrYVhKelYybDBhRWx1YzJWeWRDNXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJQ0FnSUNCallXeHNTRzl2YXlReEtHUnBjbk5YYVhSb1NXNXpaWEowVzJsZExDQW5hVzV6WlhKMFpXUW5MQ0IyYm05a1pTd2diMnhrVm01dlpHVXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMDdYRzRnSUNBZ2FXWWdLR2x6UTNKbFlYUmxLU0I3WEc0Z0lDQWdJQ0J0WlhKblpWWk9iMlJsU0c5dmF5aDJibTlrWlM1a1lYUmhMbWh2YjJzZ2ZId2dLSFp1YjJSbExtUmhkR0V1YUc5dmF5QTlJSHQ5S1N3Z0oybHVjMlZ5ZENjc0lHTmhiR3hKYm5ObGNuUXBPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCallXeHNTVzV6WlhKMEtDazdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdhV1lnS0dScGNuTlhhWFJvVUc5emRIQmhkR05vTG14bGJtZDBhQ2tnZTF4dUlDQWdJRzFsY21kbFZrNXZaR1ZJYjI5cktIWnViMlJsTG1SaGRHRXVhRzl2YXlCOGZDQW9kbTV2WkdVdVpHRjBZUzVvYjI5cklEMGdlMzBwTENBbmNHOXpkSEJoZEdOb0p5d2dablZ1WTNScGIyNGdLQ2tnZTF4dUlDQWdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCa2FYSnpWMmwwYUZCdmMzUndZWFJqYUM1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lDQWdJQ0JqWVd4c1NHOXZheVF4S0dScGNuTlhhWFJvVUc5emRIQmhkR05vVzJsZExDQW5ZMjl0Y0c5dVpXNTBWWEJrWVhSbFpDY3NJSFp1YjJSbExDQnZiR1JXYm05a1pTazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZTazdYRzRnSUgxY2JseHVJQ0JwWmlBb0lXbHpRM0psWVhSbEtTQjdYRzRnSUNBZ1ptOXlJQ2hyWlhrZ2FXNGdiMnhrUkdseWN5a2dlMXh1SUNBZ0lDQWdhV1lnS0NGdVpYZEVhWEp6VzJ0bGVWMHBJSHRjYmlBZ0lDQWdJQ0FnTHk4Z2JtOGdiRzl1WjJWeUlIQnlaWE5sYm5Rc0lIVnVZbWx1WkZ4dUlDQWdJQ0FnSUNCallXeHNTRzl2YXlReEtHOXNaRVJwY25OYmEyVjVYU3dnSjNWdVltbHVaQ2NzSUc5c1pGWnViMlJsTENCdmJHUldibTlrWlN3Z2FYTkVaWE4wY205NUtUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNGdJSDFjYm4xY2JseHVkbUZ5SUdWdGNIUjVUVzlrYVdacFpYSnpJRDBnVDJKcVpXTjBMbU55WldGMFpTaHVkV3hzS1R0Y2JseHVablZ1WTNScGIyNGdibTl5YldGc2FYcGxSR2x5WldOMGFYWmxjeVF4SUNoY2JpQWdaR2x5Y3l4Y2JpQWdkbTFjYmlrZ2UxeHVJQ0IyWVhJZ2NtVnpJRDBnVDJKcVpXTjBMbU55WldGMFpTaHVkV3hzS1R0Y2JpQWdhV1lnS0NGa2FYSnpLU0I3WEc0Z0lDQWdjbVYwZFhKdUlISmxjMXh1SUNCOVhHNGdJSFpoY2lCcExDQmthWEk3WEc0Z0lHWnZjaUFvYVNBOUlEQTdJR2tnUENCa2FYSnpMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnWkdseUlEMGdaR2x5YzF0cFhUdGNiaUFnSUNCcFppQW9JV1JwY2k1dGIyUnBabWxsY25NcElIdGNiaUFnSUNBZ0lHUnBjaTV0YjJScFptbGxjbk1nUFNCbGJYQjBlVTF2WkdsbWFXVnljenRjYmlBZ0lDQjlYRzRnSUNBZ2NtVnpXMmRsZEZKaGQwUnBjazVoYldVb1pHbHlLVjBnUFNCa2FYSTdYRzRnSUNBZ1pHbHlMbVJsWmlBOUlISmxjMjlzZG1WQmMzTmxkQ2gyYlM0a2IzQjBhVzl1Y3l3Z0oyUnBjbVZqZEdsMlpYTW5MQ0JrYVhJdWJtRnRaU3dnZEhKMVpTazdYRzRnSUgxY2JpQWdjbVYwZFhKdUlISmxjMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQm5aWFJTWVhkRWFYSk9ZVzFsSUNoa2FYSXBJSHRjYmlBZ2NtVjBkWEp1SUdScGNpNXlZWGRPWVcxbElIeDhJQ2dvWkdseUxtNWhiV1VwSUNzZ1hDSXVYQ0lnS3lBb1QySnFaV04wTG10bGVYTW9aR2x5TG0xdlpHbG1hV1Z5Y3lCOGZDQjdmU2t1YW05cGJpZ25MaWNwS1NsY2JuMWNibHh1Wm5WdVkzUnBiMjRnWTJGc2JFaHZiMnNrTVNBb1pHbHlMQ0JvYjI5ckxDQjJibTlrWlN3Z2IyeGtWbTV2WkdVc0lHbHpSR1Z6ZEhKdmVTa2dlMXh1SUNCMllYSWdabTRnUFNCa2FYSXVaR1ZtSUNZbUlHUnBjaTVrWldaYmFHOXZhMTA3WEc0Z0lHbG1JQ2htYmlrZ2UxeHVJQ0FnSUdadUtIWnViMlJsTG1Wc2JTd2daR2x5TENCMmJtOWtaU3dnYjJ4a1ZtNXZaR1VzSUdselJHVnpkSEp2ZVNrN1hHNGdJSDFjYm4xY2JseHVkbUZ5SUdKaGMyVk5iMlIxYkdWeklEMGdXMXh1SUNCeVpXWXNYRzRnSUdScGNtVmpkR2wyWlhOY2JsMDdYRzVjYmk4cUlDQXFMMXh1WEc1bWRXNWpkR2x2YmlCMWNHUmhkR1ZCZEhSeWN5QW9iMnhrVm01dlpHVXNJSFp1YjJSbEtTQjdYRzRnSUdsbUlDZ2hiMnhrVm01dlpHVXVaR0YwWVM1aGRIUnljeUFtSmlBaGRtNXZaR1V1WkdGMFlTNWhkSFJ5Y3lrZ2UxeHVJQ0FnSUhKbGRIVnlibHh1SUNCOVhHNGdJSFpoY2lCclpYa3NJR04xY2l3Z2IyeGtPMXh1SUNCMllYSWdaV3h0SUQwZ2RtNXZaR1V1Wld4dE8xeHVJQ0IyWVhJZ2IyeGtRWFIwY25NZ1BTQnZiR1JXYm05a1pTNWtZWFJoTG1GMGRISnpJSHg4SUh0OU8xeHVJQ0IyWVhJZ1lYUjBjbk1nUFNCMmJtOWtaUzVrWVhSaExtRjBkSEp6SUh4OElIdDlPMXh1SUNBdkx5QmpiRzl1WlNCdlluTmxjblpsWkNCdlltcGxZM1J6TENCaGN5QjBhR1VnZFhObGNpQndjbTlpWVdKc2VTQjNZVzUwY3lCMGJ5QnRkWFJoZEdVZ2FYUmNiaUFnYVdZZ0tHRjBkSEp6TGw5ZmIySmZYeWtnZTF4dUlDQWdJR0YwZEhKeklEMGdkbTV2WkdVdVpHRjBZUzVoZEhSeWN5QTlJR1Y0ZEdWdVpDaDdmU3dnWVhSMGNuTXBPMXh1SUNCOVhHNWNiaUFnWm05eUlDaHJaWGtnYVc0Z1lYUjBjbk1wSUh0Y2JpQWdJQ0JqZFhJZ1BTQmhkSFJ5YzF0clpYbGRPMXh1SUNBZ0lHOXNaQ0E5SUc5c1pFRjBkSEp6VzJ0bGVWMDdYRzRnSUNBZ2FXWWdLRzlzWkNBaFBUMGdZM1Z5S1NCN1hHNGdJQ0FnSUNCelpYUkJkSFJ5S0dWc2JTd2dhMlY1TENCamRYSXBPMXh1SUNBZ0lIMWNiaUFnZlZ4dUlDQXZMeUFqTkRNNU1Ub2dhVzRnU1VVNUxDQnpaWFIwYVc1bklIUjVjR1VnWTJGdUlISmxjMlYwSUhaaGJIVmxJR1p2Y2lCcGJuQjFkRnQwZVhCbFBYSmhaR2x2WFZ4dUlDQXZLaUJwYzNSaGJtSjFiQ0JwWjI1dmNtVWdhV1lnS2k5Y2JpQWdhV1lnS0dselNVVTVJQ1ltSUdGMGRISnpMblpoYkhWbElDRTlQU0J2YkdSQmRIUnljeTUyWVd4MVpTa2dlMXh1SUNBZ0lITmxkRUYwZEhJb1pXeHRMQ0FuZG1Gc2RXVW5MQ0JoZEhSeWN5NTJZV3gxWlNrN1hHNGdJSDFjYmlBZ1ptOXlJQ2hyWlhrZ2FXNGdiMnhrUVhSMGNuTXBJSHRjYmlBZ0lDQnBaaUFvWVhSMGNuTmJhMlY1WFNBOVBTQnVkV3hzS1NCN1hHNGdJQ0FnSUNCcFppQW9hWE5ZYkdsdWF5aHJaWGtwS1NCN1hHNGdJQ0FnSUNBZ0lHVnNiUzV5WlcxdmRtVkJkSFJ5YVdKMWRHVk9VeWg0YkdsdWEwNVRMQ0JuWlhSWWJHbHVhMUJ5YjNBb2EyVjVLU2s3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0NGcGMwVnVkVzFsY21GMFpXUkJkSFJ5S0d0bGVTa3BJSHRjYmlBZ0lDQWdJQ0FnWld4dExuSmxiVzkyWlVGMGRISnBZblYwWlNoclpYa3BPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNiaUFnZlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJ6WlhSQmRIUnlJQ2hsYkN3Z2EyVjVMQ0IyWVd4MVpTa2dlMXh1SUNCcFppQW9hWE5DYjI5c1pXRnVRWFIwY2loclpYa3BLU0I3WEc0Z0lDQWdMeThnYzJWMElHRjBkSEpwWW5WMFpTQm1iM0lnWW14aGJtc2dkbUZzZFdWY2JpQWdJQ0F2THlCbExtY3VJRHh2Y0hScGIyNGdaR2x6WVdKc1pXUStVMlZzWldOMElHOXVaVHd2YjNCMGFXOXVQbHh1SUNBZ0lHbG1JQ2hwYzBaaGJITjVRWFIwY2xaaGJIVmxLSFpoYkhWbEtTa2dlMXh1SUNBZ0lDQWdaV3d1Y21WdGIzWmxRWFIwY21saWRYUmxLR3RsZVNrN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJR1ZzTG5ObGRFRjBkSEpwWW5WMFpTaHJaWGtzSUd0bGVTazdYRzRnSUNBZ2ZWeHVJQ0I5SUdWc2MyVWdhV1lnS0dselJXNTFiV1Z5WVhSbFpFRjBkSElvYTJWNUtTa2dlMXh1SUNBZ0lHVnNMbk5sZEVGMGRISnBZblYwWlNoclpYa3NJR2x6Um1Gc2MzbEJkSFJ5Vm1Gc2RXVW9kbUZzZFdVcElIeDhJSFpoYkhWbElEMDlQU0FuWm1Gc2MyVW5JRDhnSjJaaGJITmxKeUE2SUNkMGNuVmxKeWs3WEc0Z0lIMGdaV3h6WlNCcFppQW9hWE5ZYkdsdWF5aHJaWGtwS1NCN1hHNGdJQ0FnYVdZZ0tHbHpSbUZzYzNsQmRIUnlWbUZzZFdVb2RtRnNkV1VwS1NCN1hHNGdJQ0FnSUNCbGJDNXlaVzF2ZG1WQmRIUnlhV0oxZEdWT1V5aDRiR2x1YTA1VExDQm5aWFJZYkdsdWExQnliM0FvYTJWNUtTazdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUdWc0xuTmxkRUYwZEhKcFluVjBaVTVUS0hoc2FXNXJUbE1zSUd0bGVTd2dkbUZzZFdVcE8xeHVJQ0FnSUgxY2JpQWdmU0JsYkhObElIdGNiaUFnSUNCcFppQW9hWE5HWVd4emVVRjBkSEpXWVd4MVpTaDJZV3gxWlNrcElIdGNiaUFnSUNBZ0lHVnNMbkpsYlc5MlpVRjBkSEpwWW5WMFpTaHJaWGtwTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQmxiQzV6WlhSQmRIUnlhV0oxZEdVb2EyVjVMQ0IyWVd4MVpTazdYRzRnSUNBZ2ZWeHVJQ0I5WEc1OVhHNWNiblpoY2lCaGRIUnljeUE5SUh0Y2JpQWdZM0psWVhSbE9pQjFjR1JoZEdWQmRIUnljeXhjYmlBZ2RYQmtZWFJsT2lCMWNHUmhkR1ZCZEhSeWMxeHVmVHRjYmx4dUx5b2dJQ292WEc1Y2JtWjFibU4wYVc5dUlIVndaR0YwWlVOc1lYTnpJQ2h2YkdSV2JtOWtaU3dnZG01dlpHVXBJSHRjYmlBZ2RtRnlJR1ZzSUQwZ2RtNXZaR1V1Wld4dE8xeHVJQ0IyWVhJZ1pHRjBZU0E5SUhadWIyUmxMbVJoZEdFN1hHNGdJSFpoY2lCdmJHUkVZWFJoSUQwZ2IyeGtWbTV2WkdVdVpHRjBZVHRjYmlBZ2FXWWdLQ0ZrWVhSaExuTjBZWFJwWTBOc1lYTnpJQ1ltSUNGa1lYUmhMbU5zWVhOeklDWW1YRzRnSUNBZ0lDQW9JVzlzWkVSaGRHRWdmSHdnS0NGdmJHUkVZWFJoTG5OMFlYUnBZME5zWVhOeklDWW1JQ0Z2YkdSRVlYUmhMbU5zWVhOektTa3BJSHRjYmlBZ0lDQnlaWFIxY201Y2JpQWdmVnh1WEc0Z0lIWmhjaUJqYkhNZ1BTQm5aVzVEYkdGemMwWnZjbFp1YjJSbEtIWnViMlJsS1R0Y2JseHVJQ0F2THlCb1lXNWtiR1VnZEhKaGJuTnBkR2x2YmlCamJHRnpjMlZ6WEc0Z0lIWmhjaUIwY21GdWMybDBhVzl1UTJ4aGMzTWdQU0JsYkM1ZmRISmhibk5wZEdsdmJrTnNZWE56WlhNN1hHNGdJR2xtSUNoMGNtRnVjMmwwYVc5dVEyeGhjM01wSUh0Y2JpQWdJQ0JqYkhNZ1BTQmpiMjVqWVhRb1kyeHpMQ0J6ZEhKcGJtZHBabmxEYkdGemN5aDBjbUZ1YzJsMGFXOXVRMnhoYzNNcEtUdGNiaUFnZlZ4dVhHNGdJQzh2SUhObGRDQjBhR1VnWTJ4aGMzTmNiaUFnYVdZZ0tHTnNjeUFoUFQwZ1pXd3VYM0J5WlhaRGJHRnpjeWtnZTF4dUlDQWdJR1ZzTG5ObGRFRjBkSEpwWW5WMFpTZ25ZMnhoYzNNbkxDQmpiSE1wTzF4dUlDQWdJR1ZzTGw5d2NtVjJRMnhoYzNNZ1BTQmpiSE03WEc0Z0lIMWNibjFjYmx4dWRtRnlJR3RzWVhOeklEMGdlMXh1SUNCamNtVmhkR1U2SUhWd1pHRjBaVU5zWVhOekxGeHVJQ0IxY0dSaGRHVTZJSFZ3WkdGMFpVTnNZWE56WEc1OU8xeHVYRzR2S2lBZ0tpOWNibHh1ZG1GeUlIWmhiR2xrUkdsMmFYTnBiMjVEYUdGeVVrVWdQU0F2VzF4Y2R5a3VLMXhjTFY4a1hGeGRYUzg3WEc1Y2JseHVYRzVtZFc1amRHbHZiaUIzY21Gd1JtbHNkR1Z5SUNobGVIQXNJR1pwYkhSbGNpa2dlMXh1SUNCMllYSWdhU0E5SUdacGJIUmxjaTVwYm1SbGVFOW1LQ2NvSnlrN1hHNGdJR2xtSUNocElEd2dNQ2tnZTF4dUlDQWdJQzh2SUY5bU9pQnlaWE52YkhabFJtbHNkR1Z5WEc0Z0lDQWdjbVYwZFhKdUlDaGNJbDltS0Z4Y1hDSmNJaUFySUdacGJIUmxjaUFySUZ3aVhGeGNJaWtvWENJZ0t5QmxlSEFnS3lCY0lpbGNJaWxjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0IyWVhJZ2JtRnRaU0E5SUdacGJIUmxjaTV6YkdsalpTZ3dMQ0JwS1R0Y2JpQWdJQ0IyWVhJZ1lYSm5jeUE5SUdacGJIUmxjaTV6YkdsalpTaHBJQ3NnTVNrN1hHNGdJQ0FnY21WMGRYSnVJQ2hjSWw5bUtGeGNYQ0pjSWlBcklHNWhiV1VnS3lCY0lseGNYQ0lwS0Z3aUlDc2daWGh3SUNzZ1hDSXNYQ0lnS3lCaGNtZHpLVnh1SUNCOVhHNTlYRzVjYmk4cUlDQXFMMXh1WEc0dktpQWdLaTljYmx4dUx5b3FYRzRnS2lCRGNtOXpjeTF3YkdGMFptOXliU0JqYjJSbElHZGxibVZ5WVhScGIyNGdabTl5SUdOdmJYQnZibVZ1ZENCMkxXMXZaR1ZzWEc0Z0tpOWNibHh1WEc0dktpcGNiaUFxSUVOeWIzTnpMWEJzWVhSbWIzSnRJR052WkdWblpXNGdhR1ZzY0dWeUlHWnZjaUJuWlc1bGNtRjBhVzVuSUhZdGJXOWtaV3dnZG1Gc2RXVWdZWE56YVdkdWJXVnVkQ0JqYjJSbExseHVJQ292WEc1Y2JseHVMeW9xWEc0Z0tpQndZWEp6WlNCa2FYSmxZM1JwZG1VZ2JXOWtaV3dnZEc4Z1pHOGdkR2hsSUdGeWNtRjVJSFZ3WkdGMFpTQjBjbUZ1YzJadmNtMHVJR0ZiYVdSNFhTQTlJSFpoYkNBOVBpQWtKR0V1YzNCc2FXTmxLQ1FrYVdSNExDQXhMQ0IyWVd3cFhHNGdLbHh1SUNvZ1ptOXlJR3h2YjNBZ2NHOXpjMmxpYkdVZ1kyRnpaWE02WEc0Z0tseHVJQ29nTFNCMFpYTjBYRzRnS2lBdElIUmxjM1JiYVdSNFhWeHVJQ29nTFNCMFpYTjBXM1JsYzNReFcybGtlRjFkWEc0Z0tpQXRJSFJsYzNSYlhDSmhYQ0pkVzJsa2VGMWNiaUFxSUMwZ2VIaDRMblJsYzNSYllWdGhYUzUwWlhOME1WdHBaSGhkWFZ4dUlDb2dMU0IwWlhOMExuaDRlQzVoVzF3aVlYTmhYQ0pkVzNSbGMzUXhXMmxrZUYxZFhHNGdLbHh1SUNvdlhHNWNiblpoY2lCemRISTdYRzUyWVhJZ2FXNWtaWGdrTVR0Y2JseHVMeW9nSUNvdlhHNWNiaTh2SUdsdUlITnZiV1VnWTJGelpYTXNJSFJvWlNCbGRtVnVkQ0IxYzJWa0lHaGhjeUIwYnlCaVpTQmtaWFJsY20xcGJtVmtJR0YwSUhKMWJuUnBiV1ZjYmk4dklITnZJSGRsSUhWelpXUWdjMjl0WlNCeVpYTmxjblpsWkNCMGIydGxibk1nWkhWeWFXNW5JR052YlhCcGJHVXVYRzUyWVhJZ1VrRk9SMFZmVkU5TFJVNGdQU0FuWDE5eUp6dGNiblpoY2lCRFNFVkRTMEpQV0Y5U1FVUkpUMTlVVDB0RlRpQTlJQ2RmWDJNbk8xeHVYRzR2S2lBZ0tpOWNibHh1THk4Z2JtOXliV0ZzYVhwbElIWXRiVzlrWld3Z1pYWmxiblFnZEc5clpXNXpJSFJvWVhRZ1kyRnVJRzl1YkhrZ1ltVWdaR1YwWlhKdGFXNWxaQ0JoZENCeWRXNTBhVzFsTGx4dUx5OGdhWFFuY3lCcGJYQnZjblJoYm5RZ2RHOGdjR3hoWTJVZ2RHaGxJR1YyWlc1MElHRnpJSFJvWlNCbWFYSnpkQ0JwYmlCMGFHVWdZWEp5WVhrZ1ltVmpZWFZ6WlZ4dUx5OGdkR2hsSUhkb2IyeGxJSEJ2YVc1MElHbHpJR1Z1YzNWeWFXNW5JSFJvWlNCMkxXMXZaR1ZzSUdOaGJHeGlZV05ySUdkbGRITWdZMkZzYkdWa0lHSmxabTl5WlZ4dUx5OGdkWE5sY2kxaGRIUmhZMmhsWkNCb1lXNWtiR1Z5Y3k1Y2JtWjFibU4wYVc5dUlHNXZjbTFoYkdsNlpVVjJaVzUwY3lBb2IyNHBJSHRjYmlBZ2RtRnlJR1YyWlc1ME8xeHVJQ0F2S2lCcGMzUmhibUoxYkNCcFoyNXZjbVVnYVdZZ0tpOWNiaUFnYVdZZ0tHOXVXMUpCVGtkRlgxUlBTMFZPWFNrZ2UxeHVJQ0FnSUM4dklFbEZJR2x1Y0hWMFczUjVjR1U5Y21GdVoyVmRJRzl1YkhrZ2MzVndjRzl5ZEhNZ1lHTm9ZVzVuWldBZ1pYWmxiblJjYmlBZ0lDQmxkbVZ1ZENBOUlHbHpTVVVnUHlBblkyaGhibWRsSnlBNklDZHBibkIxZENjN1hHNGdJQ0FnYjI1YlpYWmxiblJkSUQwZ1cxMHVZMjl1WTJGMEtHOXVXMUpCVGtkRlgxUlBTMFZPWFN3Z2IyNWJaWFpsYm5SZElIeDhJRnRkS1R0Y2JpQWdJQ0JrWld4bGRHVWdiMjViVWtGT1IwVmZWRTlMUlU1ZE8xeHVJQ0I5WEc0Z0lHbG1JQ2h2Ymx0RFNFVkRTMEpQV0Y5U1FVUkpUMTlVVDB0RlRsMHBJSHRjYmlBZ0lDQXZMeUJEYUhKdmJXVWdabWx5WlhNZ2JXbGpjbTkwWVhOcmN5QnBiaUJpWlhSM1pXVnVJR05zYVdOckwyTm9ZVzVuWlN3Z2JHVmhaSE1nZEc4Z0l6UTFNakZjYmlBZ0lDQmxkbVZ1ZENBOUlHbHpRMmh5YjIxbElEOGdKMk5zYVdOckp5QTZJQ2RqYUdGdVoyVW5PMXh1SUNBZ0lHOXVXMlYyWlc1MFhTQTlJRnRkTG1OdmJtTmhkQ2h2Ymx0RFNFVkRTMEpQV0Y5U1FVUkpUMTlVVDB0RlRsMHNJRzl1VzJWMlpXNTBYU0I4ZkNCYlhTazdYRzRnSUNBZ1pHVnNaWFJsSUc5dVcwTklSVU5MUWs5WVgxSkJSRWxQWDFSUFMwVk9YVHRjYmlBZ2ZWeHVmVnh1WEc1MllYSWdkR0Z5WjJWMEpERTdYRzVjYm1aMWJtTjBhVzl1SUdGa1pDUXhJQ2hjYmlBZ1pYWmxiblFzWEc0Z0lHaGhibVJzWlhJc1hHNGdJRzl1WTJVc1hHNGdJR05oY0hSMWNtVmNiaWtnZTF4dUlDQnBaaUFvYjI1alpTa2dlMXh1SUNBZ0lIWmhjaUJ2YkdSSVlXNWtiR1Z5SUQwZ2FHRnVaR3hsY2p0Y2JpQWdJQ0IyWVhJZ1gzUmhjbWRsZENBOUlIUmhjbWRsZENReE95QXZMeUJ6WVhabElHTjFjbkpsYm5RZ2RHRnlaMlYwSUdWc1pXMWxiblFnYVc0Z1kyeHZjM1Z5WlZ4dUlDQWdJR2hoYm1Sc1pYSWdQU0JtZFc1amRHbHZiaUFvWlhZcElIdGNiaUFnSUNBZ0lIWmhjaUJ5WlhNZ1BTQmhjbWQxYldWdWRITXViR1Z1WjNSb0lEMDlQU0F4WEc0Z0lDQWdJQ0FnSUQ4Z2IyeGtTR0Z1Wkd4bGNpaGxkaWxjYmlBZ0lDQWdJQ0FnT2lCdmJHUklZVzVrYkdWeUxtRndjR3g1S0c1MWJHd3NJR0Z5WjNWdFpXNTBjeWs3WEc0Z0lDQWdJQ0JwWmlBb2NtVnpJQ0U5UFNCdWRXeHNLU0I3WEc0Z0lDQWdJQ0FnSUhKbGJXOTJaU1F5S0dWMlpXNTBMQ0JvWVc1a2JHVnlMQ0JqWVhCMGRYSmxMQ0JmZEdGeVoyVjBLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlPMXh1SUNCOVhHNGdJSFJoY21kbGRDUXhMbUZrWkVWMlpXNTBUR2x6ZEdWdVpYSW9aWFpsYm5Rc0lHaGhibVJzWlhJc0lHTmhjSFIxY21VcE8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCeVpXMXZkbVVrTWlBb1hHNGdJR1YyWlc1MExGeHVJQ0JvWVc1a2JHVnlMRnh1SUNCallYQjBkWEpsTEZ4dUlDQmZkR0Z5WjJWMFhHNHBJSHRjYmlBZ0tGOTBZWEpuWlhRZ2ZId2dkR0Z5WjJWMEpERXBMbkpsYlc5MlpVVjJaVzUwVEdsemRHVnVaWElvWlhabGJuUXNJR2hoYm1Sc1pYSXNJR05oY0hSMWNtVXBPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQjFjR1JoZEdWRVQwMU1hWE4wWlc1bGNuTWdLRzlzWkZadWIyUmxMQ0IyYm05a1pTa2dlMXh1SUNCcFppQW9JVzlzWkZadWIyUmxMbVJoZEdFdWIyNGdKaVlnSVhadWIyUmxMbVJoZEdFdWIyNHBJSHRjYmlBZ0lDQnlaWFIxY201Y2JpQWdmVnh1SUNCMllYSWdiMjRnUFNCMmJtOWtaUzVrWVhSaExtOXVJSHg4SUh0OU8xeHVJQ0IyWVhJZ2IyeGtUMjRnUFNCdmJHUldibTlrWlM1a1lYUmhMbTl1SUh4OElIdDlPMXh1SUNCMFlYSm5aWFFrTVNBOUlIWnViMlJsTG1Wc2JUdGNiaUFnYm05eWJXRnNhWHBsUlhabGJuUnpLRzl1S1R0Y2JpQWdkWEJrWVhSbFRHbHpkR1Z1WlhKektHOXVMQ0J2YkdSUGJpd2dZV1JrSkRFc0lISmxiVzkyWlNReUxDQjJibTlrWlM1amIyNTBaWGgwS1R0Y2JuMWNibHh1ZG1GeUlHVjJaVzUwY3lBOUlIdGNiaUFnWTNKbFlYUmxPaUIxY0dSaGRHVkVUMDFNYVhOMFpXNWxjbk1zWEc0Z0lIVndaR0YwWlRvZ2RYQmtZWFJsUkU5TlRHbHpkR1Z1WlhKelhHNTlPMXh1WEc0dktpQWdLaTljYmx4dVpuVnVZM1JwYjI0Z2RYQmtZWFJsUkU5TlVISnZjSE1nS0c5c1pGWnViMlJsTENCMmJtOWtaU2tnZTF4dUlDQnBaaUFvSVc5c1pGWnViMlJsTG1SaGRHRXVaRzl0VUhKdmNITWdKaVlnSVhadWIyUmxMbVJoZEdFdVpHOXRVSEp2Y0hNcElIdGNiaUFnSUNCeVpYUjFjbTVjYmlBZ2ZWeHVJQ0IyWVhJZ2EyVjVMQ0JqZFhJN1hHNGdJSFpoY2lCbGJHMGdQU0IyYm05a1pTNWxiRzA3WEc0Z0lIWmhjaUJ2YkdSUWNtOXdjeUE5SUc5c1pGWnViMlJsTG1SaGRHRXVaRzl0VUhKdmNITWdmSHdnZTMwN1hHNGdJSFpoY2lCd2NtOXdjeUE5SUhadWIyUmxMbVJoZEdFdVpHOXRVSEp2Y0hNZ2ZId2dlMzA3WEc0Z0lDOHZJR05zYjI1bElHOWljMlZ5ZG1Wa0lHOWlhbVZqZEhNc0lHRnpJSFJvWlNCMWMyVnlJSEJ5YjJKaFlteDVJSGRoYm5SeklIUnZJRzExZEdGMFpTQnBkRnh1SUNCcFppQW9jSEp2Y0hNdVgxOXZZbDlmS1NCN1hHNGdJQ0FnY0hKdmNITWdQU0IyYm05a1pTNWtZWFJoTG1SdmJWQnliM0J6SUQwZ1pYaDBaVzVrS0h0OUxDQndjbTl3Y3lrN1hHNGdJSDFjYmx4dUlDQm1iM0lnS0d0bGVTQnBiaUJ2YkdSUWNtOXdjeWtnZTF4dUlDQWdJR2xtSUNod2NtOXdjMXRyWlhsZElEMDlJRzUxYkd3cElIdGNiaUFnSUNBZ0lHVnNiVnRyWlhsZElEMGdKeWM3WEc0Z0lDQWdmVnh1SUNCOVhHNGdJR1p2Y2lBb2EyVjVJR2x1SUhCeWIzQnpLU0I3WEc0Z0lDQWdZM1Z5SUQwZ2NISnZjSE5iYTJWNVhUdGNiaUFnSUNBdkx5QnBaMjV2Y21VZ1kyaHBiR1J5Wlc0Z2FXWWdkR2hsSUc1dlpHVWdhR0Z6SUhSbGVIUkRiMjUwWlc1MElHOXlJR2x1Ym1WeVNGUk5UQ3hjYmlBZ0lDQXZMeUJoY3lCMGFHVnpaU0IzYVd4c0lIUm9jbTkzSUdGM1lYa2daWGhwYzNScGJtY2dSRTlOSUc1dlpHVnpJR0Z1WkNCallYVnpaU0J5WlcxdmRtRnNJR1Z5Y205eWMxeHVJQ0FnSUM4dklHOXVJSE4xWW5ObGNYVmxiblFnY0dGMFkyaGxjeUFvSXpNek5qQXBYRzRnSUNBZ2FXWWdLR3RsZVNBOVBUMGdKM1JsZUhSRGIyNTBaVzUwSnlCOGZDQnJaWGtnUFQwOUlDZHBibTVsY2toVVRVd25LU0I3WEc0Z0lDQWdJQ0JwWmlBb2RtNXZaR1V1WTJocGJHUnlaVzRwSUhzZ2RtNXZaR1V1WTJocGJHUnlaVzR1YkdWdVozUm9JRDBnTURzZ2ZWeHVJQ0FnSUNBZ2FXWWdLR04xY2lBOVBUMGdiMnhrVUhKdmNITmJhMlY1WFNrZ2V5QmpiMjUwYVc1MVpTQjlYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLR3RsZVNBOVBUMGdKM1poYkhWbEp5a2dlMXh1SUNBZ0lDQWdMeThnYzNSdmNtVWdkbUZzZFdVZ1lYTWdYM1poYkhWbElHRnpJSGRsYkd3Z2MybHVZMlZjYmlBZ0lDQWdJQzh2SUc1dmJpMXpkSEpwYm1jZ2RtRnNkV1Z6SUhkcGJHd2dZbVVnYzNSeWFXNW5hV1pwWldSY2JpQWdJQ0FnSUdWc2JTNWZkbUZzZFdVZ1BTQmpkWEk3WEc0Z0lDQWdJQ0F2THlCaGRtOXBaQ0J5WlhObGRIUnBibWNnWTNWeWMyOXlJSEJ2YzJsMGFXOXVJSGRvWlc0Z2RtRnNkV1VnYVhNZ2RHaGxJSE5oYldWY2JpQWdJQ0FnSUhaaGNpQnpkSEpEZFhJZ1BTQmpkWElnUFQwZ2JuVnNiQ0EvSUNjbklEb2dVM1J5YVc1bktHTjFjaWs3WEc0Z0lDQWdJQ0JwWmlBb2MyaHZkV3hrVlhCa1lYUmxWbUZzZFdVb1pXeHRMQ0IyYm05a1pTd2djM1J5UTNWeUtTa2dlMXh1SUNBZ0lDQWdJQ0JsYkcwdWRtRnNkV1VnUFNCemRISkRkWEk3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lHVnNiVnRyWlhsZElEMGdZM1Z5TzF4dUlDQWdJSDFjYmlBZ2ZWeHVmVnh1WEc0dkx5QmphR1ZqYXlCd2JHRjBabTl5YlhNdmQyVmlMM1YwYVd3dllYUjBjbk11YW5NZ1lXTmpaWEIwVm1Gc2RXVmNibHh1WEc1bWRXNWpkR2x2YmlCemFHOTFiR1JWY0dSaGRHVldZV3gxWlNBb1hHNGdJR1ZzYlN4Y2JpQWdkbTV2WkdVc1hHNGdJR05vWldOclZtRnNYRzRwSUh0Y2JpQWdjbVYwZFhKdUlDZ2haV3h0TG1OdmJYQnZjMmx1WnlBbUppQW9YRzRnSUNBZ2RtNXZaR1V1ZEdGbklEMDlQU0FuYjNCMGFXOXVKeUI4ZkZ4dUlDQWdJR2x6UkdseWRIa29aV3h0TENCamFHVmphMVpoYkNrZ2ZIeGNiaUFnSUNCcGMwbHVjSFYwUTJoaGJtZGxaQ2hsYkcwc0lHTm9aV05yVm1Gc0tWeHVJQ0FwS1Z4dWZWeHVYRzVtZFc1amRHbHZiaUJwYzBScGNuUjVJQ2hsYkcwc0lHTm9aV05yVm1Gc0tTQjdYRzRnSUM4dklISmxkSFZ5YmlCMGNuVmxJSGRvWlc0Z2RHVjRkR0p2ZUNBb0xtNTFiV0psY2lCaGJtUWdMblJ5YVcwcElHeHZjMlZ6SUdadlkzVnpJR0Z1WkNCcGRITWdkbUZzZFdVZ2FYTWdibTkwSUdWeGRXRnNJSFJ2SUhSb1pTQjFjR1JoZEdWa0lIWmhiSFZsWEc0Z0lISmxkSFZ5YmlCa2IyTjFiV1Z1ZEM1aFkzUnBkbVZGYkdWdFpXNTBJQ0U5UFNCbGJHMGdKaVlnWld4dExuWmhiSFZsSUNFOVBTQmphR1ZqYTFaaGJGeHVmVnh1WEc1bWRXNWpkR2x2YmlCcGMwbHVjSFYwUTJoaGJtZGxaQ0FvWld4dExDQnVaWGRXWVd3cElIdGNiaUFnZG1GeUlIWmhiSFZsSUQwZ1pXeHRMblpoYkhWbE8xeHVJQ0IyWVhJZ2JXOWthV1pwWlhKeklEMGdaV3h0TGw5MlRXOWthV1pwWlhKek95QXZMeUJwYm1wbFkzUmxaQ0JpZVNCMkxXMXZaR1ZzSUhKMWJuUnBiV1ZjYmlBZ2FXWWdLQ2h0YjJScFptbGxjbk1nSmlZZ2JXOWthV1pwWlhKekxtNTFiV0psY2lrZ2ZId2daV3h0TG5SNWNHVWdQVDA5SUNkdWRXMWlaWEluS1NCN1hHNGdJQ0FnY21WMGRYSnVJSFJ2VG5WdFltVnlLSFpoYkhWbEtTQWhQVDBnZEc5T2RXMWlaWElvYm1WM1ZtRnNLVnh1SUNCOVhHNGdJR2xtSUNodGIyUnBabWxsY25NZ0ppWWdiVzlrYVdacFpYSnpMblJ5YVcwcElIdGNiaUFnSUNCeVpYUjFjbTRnZG1Gc2RXVXVkSEpwYlNncElDRTlQU0J1WlhkV1lXd3VkSEpwYlNncFhHNGdJSDFjYmlBZ2NtVjBkWEp1SUhaaGJIVmxJQ0U5UFNCdVpYZFdZV3hjYm4xY2JseHVkbUZ5SUdSdmJWQnliM0J6SUQwZ2UxeHVJQ0JqY21WaGRHVTZJSFZ3WkdGMFpVUlBUVkJ5YjNCekxGeHVJQ0IxY0dSaGRHVTZJSFZ3WkdGMFpVUlBUVkJ5YjNCelhHNTlPMXh1WEc0dktpQWdLaTljYmx4dWRtRnlJSEJoY25ObFUzUjViR1ZVWlhoMElEMGdZMkZqYUdWa0tHWjFibU4wYVc5dUlDaGpjM05VWlhoMEtTQjdYRzRnSUhaaGNpQnlaWE1nUFNCN2ZUdGNiaUFnZG1GeUlHeHBjM1JFWld4cGJXbDBaWElnUFNBdk95Zy9JVnRlS0YwcVhGd3BLUzluTzF4dUlDQjJZWElnY0hKdmNHVnlkSGxFWld4cGJXbDBaWElnUFNBdk9pZ3VLeWt2TzF4dUlDQmpjM05VWlhoMExuTndiR2wwS0d4cGMzUkVaV3hwYldsMFpYSXBMbVp2Y2tWaFkyZ29ablZ1WTNScGIyNGdLR2wwWlcwcElIdGNiaUFnSUNCcFppQW9hWFJsYlNrZ2UxeHVJQ0FnSUNBZ2RtRnlJSFJ0Y0NBOUlHbDBaVzB1YzNCc2FYUW9jSEp2Y0dWeWRIbEVaV3hwYldsMFpYSXBPMXh1SUNBZ0lDQWdkRzF3TG14bGJtZDBhQ0ErSURFZ0ppWWdLSEpsYzF0MGJYQmJNRjB1ZEhKcGJTZ3BYU0E5SUhSdGNGc3hYUzUwY21sdEtDa3BPMXh1SUNBZ0lIMWNiaUFnZlNrN1hHNGdJSEpsZEhWeWJpQnlaWE5jYm4wcE8xeHVYRzR2THlCdFpYSm5aU0J6ZEdGMGFXTWdZVzVrSUdSNWJtRnRhV01nYzNSNWJHVWdaR0YwWVNCdmJpQjBhR1VnYzJGdFpTQjJibTlrWlZ4dVpuVnVZM1JwYjI0Z2JtOXliV0ZzYVhwbFUzUjViR1ZFWVhSaElDaGtZWFJoS1NCN1hHNGdJSFpoY2lCemRIbHNaU0E5SUc1dmNtMWhiR2w2WlZOMGVXeGxRbWx1WkdsdVp5aGtZWFJoTG5OMGVXeGxLVHRjYmlBZ0x5OGdjM1JoZEdsaklITjBlV3hsSUdseklIQnlaUzF3Y205alpYTnpaV1FnYVc1MGJ5QmhiaUJ2WW1wbFkzUWdaSFZ5YVc1bklHTnZiWEJwYkdGMGFXOXVYRzRnSUM4dklHRnVaQ0JwY3lCaGJIZGhlWE1nWVNCbWNtVnphQ0J2WW1wbFkzUXNJSE52SUdsMEozTWdjMkZtWlNCMGJ5QnRaWEpuWlNCcGJuUnZJR2wwWEc0Z0lISmxkSFZ5YmlCa1lYUmhMbk4wWVhScFkxTjBlV3hsWEc0Z0lDQWdQeUJsZUhSbGJtUW9aR0YwWVM1emRHRjBhV05UZEhsc1pTd2djM1I1YkdVcFhHNGdJQ0FnT2lCemRIbHNaVnh1ZlZ4dVhHNHZMeUJ1YjNKdFlXeHBlbVVnY0c5emMybGliR1VnWVhKeVlYa2dMeUJ6ZEhKcGJtY2dkbUZzZFdWeklHbHVkRzhnVDJKcVpXTjBYRzVtZFc1amRHbHZiaUJ1YjNKdFlXeHBlbVZUZEhsc1pVSnBibVJwYm1jZ0tHSnBibVJwYm1kVGRIbHNaU2tnZTF4dUlDQnBaaUFvUVhKeVlYa3VhWE5CY25KaGVTaGlhVzVrYVc1blUzUjViR1VwS1NCN1hHNGdJQ0FnY21WMGRYSnVJSFJ2VDJKcVpXTjBLR0pwYm1ScGJtZFRkSGxzWlNsY2JpQWdmVnh1SUNCcFppQW9kSGx3Wlc5bUlHSnBibVJwYm1kVGRIbHNaU0E5UFQwZ0ozTjBjbWx1WnljcElIdGNiaUFnSUNCeVpYUjFjbTRnY0dGeWMyVlRkSGxzWlZSbGVIUW9ZbWx1WkdsdVoxTjBlV3hsS1Z4dUlDQjlYRzRnSUhKbGRIVnliaUJpYVc1a2FXNW5VM1I1YkdWY2JuMWNibHh1THlvcVhHNGdLaUJ3WVhKbGJuUWdZMjl0Y0c5dVpXNTBJSE4wZVd4bElITm9iM1ZzWkNCaVpTQmhablJsY2lCamFHbHNaQ2R6WEc0Z0tpQnpieUIwYUdGMElIQmhjbVZ1ZENCamIyMXdiMjVsYm5RbmN5QnpkSGxzWlNCamIzVnNaQ0J2ZG1WeWNtbGtaU0JwZEZ4dUlDb3ZYRzVtZFc1amRHbHZiaUJuWlhSVGRIbHNaU0FvZG01dlpHVXNJR05vWldOclEyaHBiR1FwSUh0Y2JpQWdkbUZ5SUhKbGN5QTlJSHQ5TzF4dUlDQjJZWElnYzNSNWJHVkVZWFJoTzF4dVhHNGdJR2xtSUNoamFHVmphME5vYVd4a0tTQjdYRzRnSUNBZ2RtRnlJR05vYVd4a1RtOWtaU0E5SUhadWIyUmxPMXh1SUNBZ0lIZG9hV3hsSUNoamFHbHNaRTV2WkdVdVkyOXRjRzl1Wlc1MFNXNXpkR0Z1WTJVcElIdGNiaUFnSUNBZ0lHTm9hV3hrVG05a1pTQTlJR05vYVd4a1RtOWtaUzVqYjIxd2IyNWxiblJKYm5OMFlXNWpaUzVmZG01dlpHVTdYRzRnSUNBZ0lDQnBaaUFvWTJocGJHUk9iMlJsTG1SaGRHRWdKaVlnS0hOMGVXeGxSR0YwWVNBOUlHNXZjbTFoYkdsNlpWTjBlV3hsUkdGMFlTaGphR2xzWkU1dlpHVXVaR0YwWVNrcEtTQjdYRzRnSUNBZ0lDQWdJR1Y0ZEdWdVpDaHlaWE1zSUhOMGVXeGxSR0YwWVNrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ2FXWWdLQ2h6ZEhsc1pVUmhkR0VnUFNCdWIzSnRZV3hwZW1WVGRIbHNaVVJoZEdFb2RtNXZaR1V1WkdGMFlTa3BLU0I3WEc0Z0lDQWdaWGgwWlc1a0tISmxjeXdnYzNSNWJHVkVZWFJoS1R0Y2JpQWdmVnh1WEc0Z0lIWmhjaUJ3WVhKbGJuUk9iMlJsSUQwZ2RtNXZaR1U3WEc0Z0lIZG9hV3hsSUNnb2NHRnlaVzUwVG05a1pTQTlJSEJoY21WdWRFNXZaR1V1Y0dGeVpXNTBLU2tnZTF4dUlDQWdJR2xtSUNod1lYSmxiblJPYjJSbExtUmhkR0VnSmlZZ0tITjBlV3hsUkdGMFlTQTlJRzV2Y20xaGJHbDZaVk4wZVd4bFJHRjBZU2h3WVhKbGJuUk9iMlJsTG1SaGRHRXBLU2tnZTF4dUlDQWdJQ0FnWlhoMFpXNWtLSEpsY3l3Z2MzUjViR1ZFWVhSaEtUdGNiaUFnSUNCOVhHNGdJSDFjYmlBZ2NtVjBkWEp1SUhKbGMxeHVmVnh1WEc0dktpQWdLaTljYmx4dWRtRnlJR056YzFaaGNsSkZJRDBnTDE0dExTODdYRzUyWVhJZ2FXMXdiM0owWVc1MFVrVWdQU0F2WEZ4ektpRnBiWEJ2Y25SaGJuUWtMenRjYm5aaGNpQnpaWFJRY205d0lEMGdablZ1WTNScGIyNGdLR1ZzTENCdVlXMWxMQ0IyWVd3cElIdGNiaUFnTHlvZ2FYTjBZVzVpZFd3Z2FXZHViM0psSUdsbUlDb3ZYRzRnSUdsbUlDaGpjM05XWVhKU1JTNTBaWE4wS0c1aGJXVXBLU0I3WEc0Z0lDQWdaV3d1YzNSNWJHVXVjMlYwVUhKdmNHVnlkSGtvYm1GdFpTd2dkbUZzS1R0Y2JpQWdmU0JsYkhObElHbG1JQ2hwYlhCdmNuUmhiblJTUlM1MFpYTjBLSFpoYkNrcElIdGNiaUFnSUNCbGJDNXpkSGxzWlM1elpYUlFjbTl3WlhKMGVTaHVZVzFsTENCMllXd3VjbVZ3YkdGalpTaHBiWEJ2Y25SaGJuUlNSU3dnSnljcExDQW5hVzF3YjNKMFlXNTBKeWs3WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnWld3dWMzUjViR1ZiYm05eWJXRnNhWHBsS0c1aGJXVXBYU0E5SUhaaGJEdGNiaUFnZlZ4dWZUdGNibHh1ZG1GeUlIQnlaV1pwZUdWeklEMGdXeWRYWldKcmFYUW5MQ0FuVFc5Nkp5d2dKMjF6SjEwN1hHNWNiblpoY2lCMFpYTjBSV3c3WEc1MllYSWdibTl5YldGc2FYcGxJRDBnWTJGamFHVmtLR1oxYm1OMGFXOXVJQ2h3Y205d0tTQjdYRzRnSUhSbGMzUkZiQ0E5SUhSbGMzUkZiQ0I4ZkNCa2IyTjFiV1Z1ZEM1amNtVmhkR1ZGYkdWdFpXNTBLQ2RrYVhZbktUdGNiaUFnY0hKdmNDQTlJR05oYldWc2FYcGxLSEJ5YjNBcE8xeHVJQ0JwWmlBb2NISnZjQ0FoUFQwZ0oyWnBiSFJsY2ljZ0ppWWdLSEJ5YjNBZ2FXNGdkR1Z6ZEVWc0xuTjBlV3hsS1NrZ2UxeHVJQ0FnSUhKbGRIVnliaUJ3Y205d1hHNGdJSDFjYmlBZ2RtRnlJSFZ3Y0dWeUlEMGdjSEp2Y0M1amFHRnlRWFFvTUNrdWRHOVZjSEJsY2tOaGMyVW9LU0FySUhCeWIzQXVjMnhwWTJVb01TazdYRzRnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2NISmxabWw0WlhNdWJHVnVaM1JvT3lCcEt5c3BJSHRjYmlBZ0lDQjJZWElnY0hKbFptbDRaV1FnUFNCd2NtVm1hWGhsYzF0cFhTQXJJSFZ3Y0dWeU8xeHVJQ0FnSUdsbUlDaHdjbVZtYVhobFpDQnBiaUIwWlhOMFJXd3VjM1I1YkdVcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCd2NtVm1hWGhsWkZ4dUlDQWdJSDFjYmlBZ2ZWeHVmU2s3WEc1Y2JtWjFibU4wYVc5dUlIVndaR0YwWlZOMGVXeGxJQ2h2YkdSV2JtOWtaU3dnZG01dlpHVXBJSHRjYmlBZ2RtRnlJR1JoZEdFZ1BTQjJibTlrWlM1a1lYUmhPMXh1SUNCMllYSWdiMnhrUkdGMFlTQTlJRzlzWkZadWIyUmxMbVJoZEdFN1hHNWNiaUFnYVdZZ0tDRmtZWFJoTG5OMFlYUnBZMU4wZVd4bElDWW1JQ0ZrWVhSaExuTjBlV3hsSUNZbVhHNGdJQ0FnSUNBaGIyeGtSR0YwWVM1emRHRjBhV05UZEhsc1pTQW1KaUFoYjJ4a1JHRjBZUzV6ZEhsc1pTa2dlMXh1SUNBZ0lISmxkSFZ5Ymx4dUlDQjlYRzVjYmlBZ2RtRnlJR04xY2l3Z2JtRnRaVHRjYmlBZ2RtRnlJR1ZzSUQwZ2RtNXZaR1V1Wld4dE8xeHVJQ0IyWVhJZ2IyeGtVM1JoZEdsalUzUjViR1VnUFNCdmJHUldibTlrWlM1a1lYUmhMbk4wWVhScFkxTjBlV3hsTzF4dUlDQjJZWElnYjJ4a1UzUjViR1ZDYVc1a2FXNW5JRDBnYjJ4a1ZtNXZaR1V1WkdGMFlTNXpkSGxzWlNCOGZDQjdmVHRjYmx4dUlDQXZMeUJwWmlCemRHRjBhV01nYzNSNWJHVWdaWGhwYzNSekxDQnpkSGxzWldKcGJtUnBibWNnWVd4eVpXRmtlU0J0WlhKblpXUWdhVzUwYnlCcGRDQjNhR1Z1SUdSdmFXNW5JRzV2Y20xaGJHbDZaVk4wZVd4bFJHRjBZVnh1SUNCMllYSWdiMnhrVTNSNWJHVWdQU0J2YkdSVGRHRjBhV05UZEhsc1pTQjhmQ0J2YkdSVGRIbHNaVUpwYm1ScGJtYzdYRzVjYmlBZ2RtRnlJSE4wZVd4bElEMGdibTl5YldGc2FYcGxVM1I1YkdWQ2FXNWthVzVuS0hadWIyUmxMbVJoZEdFdWMzUjViR1VwSUh4OElIdDlPMXh1WEc0Z0lIWnViMlJsTG1SaGRHRXVjM1I1YkdVZ1BTQnpkSGxzWlM1ZlgyOWlYMThnUHlCbGVIUmxibVFvZTMwc0lITjBlV3hsS1NBNklITjBlV3hsTzF4dVhHNGdJSFpoY2lCdVpYZFRkSGxzWlNBOUlHZGxkRk4wZVd4bEtIWnViMlJsTENCMGNuVmxLVHRjYmx4dUlDQm1iM0lnS0c1aGJXVWdhVzRnYjJ4a1UzUjViR1VwSUh0Y2JpQWdJQ0JwWmlBb2JtVjNVM1I1YkdWYmJtRnRaVjBnUFQwZ2JuVnNiQ2tnZTF4dUlDQWdJQ0FnYzJWMFVISnZjQ2hsYkN3Z2JtRnRaU3dnSnljcE8xeHVJQ0FnSUgxY2JpQWdmVnh1SUNCbWIzSWdLRzVoYldVZ2FXNGdibVYzVTNSNWJHVXBJSHRjYmlBZ0lDQmpkWElnUFNCdVpYZFRkSGxzWlZ0dVlXMWxYVHRjYmlBZ0lDQnBaaUFvWTNWeUlDRTlQU0J2YkdSVGRIbHNaVnR1WVcxbFhTa2dlMXh1SUNBZ0lDQWdMeThnYVdVNUlITmxkSFJwYm1jZ2RHOGdiblZzYkNCb1lYTWdibThnWldabVpXTjBMQ0J0ZFhOMElIVnpaU0JsYlhCMGVTQnpkSEpwYm1kY2JpQWdJQ0FnSUhObGRGQnliM0FvWld3c0lHNWhiV1VzSUdOMWNpQTlQU0J1ZFd4c0lEOGdKeWNnT2lCamRYSXBPMXh1SUNBZ0lIMWNiaUFnZlZ4dWZWeHVYRzUyWVhJZ2MzUjViR1VnUFNCN1hHNGdJR055WldGMFpUb2dkWEJrWVhSbFUzUjViR1VzWEc0Z0lIVndaR0YwWlRvZ2RYQmtZWFJsVTNSNWJHVmNibjA3WEc1Y2JpOHFJQ0FxTDF4dVhHNHZLaXBjYmlBcUlFRmtaQ0JqYkdGemN5QjNhWFJvSUdOdmJYQmhkR2xpYVd4cGRIa2dabTl5SUZOV1J5QnphVzVqWlNCamJHRnpjMHhwYzNRZ2FYTWdibTkwSUhOMWNIQnZjblJsWkNCdmJseHVJQ29nVTFaSElHVnNaVzFsYm5SeklHbHVJRWxGWEc0Z0tpOWNibVoxYm1OMGFXOXVJR0ZrWkVOc1lYTnpJQ2hsYkN3Z1kyeHpLU0I3WEc0Z0lDOHFJR2x6ZEdGdVluVnNJR2xuYm05eVpTQnBaaUFxTDF4dUlDQnBaaUFvSVdOc2N5QjhmQ0FoS0dOc2N5QTlJR05zY3k1MGNtbHRLQ2twS1NCN1hHNGdJQ0FnY21WMGRYSnVYRzRnSUgxY2JseHVJQ0F2S2lCcGMzUmhibUoxYkNCcFoyNXZjbVVnWld4elpTQXFMMXh1SUNCcFppQW9aV3d1WTJ4aGMzTk1hWE4wS1NCN1hHNGdJQ0FnYVdZZ0tHTnNjeTVwYm1SbGVFOW1LQ2NnSnlrZ1BpQXRNU2tnZTF4dUlDQWdJQ0FnWTJ4ekxuTndiR2wwS0M5Y1hITXJMeWt1Wm05eVJXRmphQ2htZFc1amRHbHZiaUFvWXlrZ2V5QnlaWFIxY200Z1pXd3VZMnhoYzNOTWFYTjBMbUZrWkNoaktUc2dmU2s3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lHVnNMbU5zWVhOelRHbHpkQzVoWkdRb1kyeHpLVHRjYmlBZ0lDQjlYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdkbUZ5SUdOMWNpQTlJRndpSUZ3aUlDc2dLR1ZzTG1kbGRFRjBkSEpwWW5WMFpTZ25ZMnhoYzNNbktTQjhmQ0FuSnlrZ0t5QmNJaUJjSWp0Y2JpQWdJQ0JwWmlBb1kzVnlMbWx1WkdWNFQyWW9KeUFuSUNzZ1kyeHpJQ3NnSnlBbktTQThJREFwSUh0Y2JpQWdJQ0FnSUdWc0xuTmxkRUYwZEhKcFluVjBaU2duWTJ4aGMzTW5MQ0FvWTNWeUlDc2dZMnh6S1M1MGNtbHRLQ2twTzF4dUlDQWdJSDFjYmlBZ2ZWeHVmVnh1WEc0dktpcGNiaUFxSUZKbGJXOTJaU0JqYkdGemN5QjNhWFJvSUdOdmJYQmhkR2xpYVd4cGRIa2dabTl5SUZOV1J5QnphVzVqWlNCamJHRnpjMHhwYzNRZ2FYTWdibTkwSUhOMWNIQnZjblJsWkNCdmJseHVJQ29nVTFaSElHVnNaVzFsYm5SeklHbHVJRWxGWEc0Z0tpOWNibVoxYm1OMGFXOXVJSEpsYlc5MlpVTnNZWE56SUNobGJDd2dZMnh6S1NCN1hHNGdJQzhxSUdsemRHRnVZblZzSUdsbmJtOXlaU0JwWmlBcUwxeHVJQ0JwWmlBb0lXTnNjeUI4ZkNBaEtHTnNjeUE5SUdOc2N5NTBjbWx0S0NrcEtTQjdYRzRnSUNBZ2NtVjBkWEp1WEc0Z0lIMWNibHh1SUNBdktpQnBjM1JoYm1KMWJDQnBaMjV2Y21VZ1pXeHpaU0FxTDF4dUlDQnBaaUFvWld3dVkyeGhjM05NYVhOMEtTQjdYRzRnSUNBZ2FXWWdLR05zY3k1cGJtUmxlRTltS0NjZ0p5a2dQaUF0TVNrZ2UxeHVJQ0FnSUNBZ1kyeHpMbk53YkdsMEtDOWNYSE1yTHlrdVptOXlSV0ZqYUNobWRXNWpkR2x2YmlBb1l5a2dleUJ5WlhSMWNtNGdaV3d1WTJ4aGMzTk1hWE4wTG5KbGJXOTJaU2hqS1RzZ2ZTazdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUdWc0xtTnNZWE56VEdsemRDNXlaVzF2ZG1Vb1kyeHpLVHRjYmlBZ0lDQjlYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdkbUZ5SUdOMWNpQTlJRndpSUZ3aUlDc2dLR1ZzTG1kbGRFRjBkSEpwWW5WMFpTZ25ZMnhoYzNNbktTQjhmQ0FuSnlrZ0t5QmNJaUJjSWp0Y2JpQWdJQ0IyWVhJZ2RHRnlJRDBnSnlBbklDc2dZMnh6SUNzZ0p5QW5PMXh1SUNBZ0lIZG9hV3hsSUNoamRYSXVhVzVrWlhoUFppaDBZWElwSUQ0OUlEQXBJSHRjYmlBZ0lDQWdJR04xY2lBOUlHTjFjaTV5WlhCc1lXTmxLSFJoY2l3Z0p5QW5LVHRjYmlBZ0lDQjlYRzRnSUNBZ1pXd3VjMlYwUVhSMGNtbGlkWFJsS0NkamJHRnpjeWNzSUdOMWNpNTBjbWx0S0NrcE8xeHVJQ0I5WEc1OVhHNWNiaThxSUNBcUwxeHVYRzVtZFc1amRHbHZiaUJ5WlhOdmJIWmxWSEpoYm5OcGRHbHZiaUFvWkdWbUpDUXhLU0I3WEc0Z0lHbG1JQ2doWkdWbUpDUXhLU0I3WEc0Z0lDQWdjbVYwZFhKdVhHNGdJSDFjYmlBZ0x5b2dhWE4wWVc1aWRXd2dhV2R1YjNKbElHVnNjMlVnS2k5Y2JpQWdhV1lnS0hSNWNHVnZaaUJrWldZa0pERWdQVDA5SUNkdlltcGxZM1FuS1NCN1hHNGdJQ0FnZG1GeUlISmxjeUE5SUh0OU8xeHVJQ0FnSUdsbUlDaGtaV1lrSkRFdVkzTnpJQ0U5UFNCbVlXeHpaU2tnZTF4dUlDQWdJQ0FnWlhoMFpXNWtLSEpsY3l3Z1lYVjBiME56YzFSeVlXNXphWFJwYjI0b1pHVm1KQ1F4TG01aGJXVWdmSHdnSjNZbktTazdYRzRnSUNBZ2ZWeHVJQ0FnSUdWNGRHVnVaQ2h5WlhNc0lHUmxaaVFrTVNrN1hHNGdJQ0FnY21WMGRYSnVJSEpsYzF4dUlDQjlJR1ZzYzJVZ2FXWWdLSFI1Y0dWdlppQmtaV1lrSkRFZ1BUMDlJQ2R6ZEhKcGJtY25LU0I3WEc0Z0lDQWdjbVYwZFhKdUlHRjFkRzlEYzNOVWNtRnVjMmwwYVc5dUtHUmxaaVFrTVNsY2JpQWdmVnh1ZlZ4dVhHNTJZWElnWVhWMGIwTnpjMVJ5WVc1emFYUnBiMjRnUFNCallXTm9aV1FvWm5WdVkzUnBiMjRnS0c1aGJXVXBJSHRjYmlBZ2NtVjBkWEp1SUh0Y2JpQWdJQ0JsYm5SbGNrTnNZWE56T2lBb2JtRnRaU0FySUZ3aUxXVnVkR1Z5WENJcExGeHVJQ0FnSUdWdWRHVnlWRzlEYkdGemN6b2dLRzVoYldVZ0t5QmNJaTFsYm5SbGNpMTBiMXdpS1N4Y2JpQWdJQ0JsYm5SbGNrRmpkR2wyWlVOc1lYTnpPaUFvYm1GdFpTQXJJRndpTFdWdWRHVnlMV0ZqZEdsMlpWd2lLU3hjYmlBZ0lDQnNaV0YyWlVOc1lYTnpPaUFvYm1GdFpTQXJJRndpTFd4bFlYWmxYQ0lwTEZ4dUlDQWdJR3hsWVhabFZHOURiR0Z6Y3pvZ0tHNWhiV1VnS3lCY0lpMXNaV0YyWlMxMGIxd2lLU3hjYmlBZ0lDQnNaV0YyWlVGamRHbDJaVU5zWVhOek9pQW9ibUZ0WlNBcklGd2lMV3hsWVhabExXRmpkR2wyWlZ3aUtWeHVJQ0I5WEc1OUtUdGNibHh1ZG1GeUlHaGhjMVJ5WVc1emFYUnBiMjRnUFNCcGJrSnliM2R6WlhJZ0ppWWdJV2x6U1VVNU8xeHVkbUZ5SUZSU1FVNVRTVlJKVDA0Z1BTQW5kSEpoYm5OcGRHbHZiaWM3WEc1MllYSWdRVTVKVFVGVVNVOU9JRDBnSjJGdWFXMWhkR2x2YmljN1hHNWNiaTh2SUZSeVlXNXphWFJwYjI0Z2NISnZjR1Z5ZEhrdlpYWmxiblFnYzI1cFptWnBibWRjYm5aaGNpQjBjbUZ1YzJsMGFXOXVVSEp2Y0NBOUlDZDBjbUZ1YzJsMGFXOXVKenRjYm5aaGNpQjBjbUZ1YzJsMGFXOXVSVzVrUlhabGJuUWdQU0FuZEhKaGJuTnBkR2x2Ym1WdVpDYzdYRzUyWVhJZ1lXNXBiV0YwYVc5dVVISnZjQ0E5SUNkaGJtbHRZWFJwYjI0bk8xeHVkbUZ5SUdGdWFXMWhkR2x2YmtWdVpFVjJaVzUwSUQwZ0oyRnVhVzFoZEdsdmJtVnVaQ2M3WEc1cFppQW9hR0Z6VkhKaGJuTnBkR2x2YmlrZ2UxeHVJQ0F2S2lCcGMzUmhibUoxYkNCcFoyNXZjbVVnYVdZZ0tpOWNiaUFnYVdZZ0tIZHBibVJ2ZHk1dmJuUnlZVzV6YVhScGIyNWxibVFnUFQwOUlIVnVaR1ZtYVc1bFpDQW1KbHh1SUNBZ0lIZHBibVJ2ZHk1dmJuZGxZbXRwZEhSeVlXNXphWFJwYjI1bGJtUWdJVDA5SUhWdVpHVm1hVzVsWkNrZ2UxeHVJQ0FnSUhSeVlXNXphWFJwYjI1UWNtOXdJRDBnSjFkbFltdHBkRlJ5WVc1emFYUnBiMjRuTzF4dUlDQWdJSFJ5WVc1emFYUnBiMjVGYm1SRmRtVnVkQ0E5SUNkM1pXSnJhWFJVY21GdWMybDBhVzl1Ulc1a0p6dGNiaUFnZlZ4dUlDQnBaaUFvZDJsdVpHOTNMbTl1WVc1cGJXRjBhVzl1Wlc1a0lEMDlQU0IxYm1SbFptbHVaV1FnSmlaY2JpQWdJQ0IzYVc1a2IzY3ViMjUzWldKcmFYUmhibWx0WVhScGIyNWxibVFnSVQwOUlIVnVaR1ZtYVc1bFpDa2dlMXh1SUNBZ0lHRnVhVzFoZEdsdmJsQnliM0FnUFNBblYyVmlhMmwwUVc1cGJXRjBhVzl1Snp0Y2JpQWdJQ0JoYm1sdFlYUnBiMjVGYm1SRmRtVnVkQ0E5SUNkM1pXSnJhWFJCYm1sdFlYUnBiMjVGYm1Rbk8xeHVJQ0I5WEc1OVhHNWNiaTh2SUdKcGJtUnBibWNnZEc4Z2QybHVaRzkzSUdseklHNWxZMlZ6YzJGeWVTQjBieUJ0WVd0bElHaHZkQ0J5Wld4dllXUWdkMjl5YXlCcGJpQkpSU0JwYmlCemRISnBZM1FnYlc5a1pWeHVkbUZ5SUhKaFppQTlJR2x1UW5KdmQzTmxjaUFtSmlCM2FXNWtiM2N1Y21WeGRXVnpkRUZ1YVcxaGRHbHZia1p5WVcxbFhHNGdJRDhnZDJsdVpHOTNMbkpsY1hWbGMzUkJibWx0WVhScGIyNUdjbUZ0WlM1aWFXNWtLSGRwYm1SdmR5bGNiaUFnT2lCelpYUlVhVzFsYjNWME8xeHVYRzVtZFc1amRHbHZiaUJ1WlhoMFJuSmhiV1VnS0dadUtTQjdYRzRnSUhKaFppaG1kVzVqZEdsdmJpQW9LU0I3WEc0Z0lDQWdjbUZtS0dadUtUdGNiaUFnZlNrN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUdGa1pGUnlZVzV6YVhScGIyNURiR0Z6Y3lBb1pXd3NJR05zY3lrZ2UxeHVJQ0FvWld3dVgzUnlZVzV6YVhScGIyNURiR0Z6YzJWeklIeDhJQ2hsYkM1ZmRISmhibk5wZEdsdmJrTnNZWE56WlhNZ1BTQmJYU2twTG5CMWMyZ29ZMnh6S1R0Y2JpQWdZV1JrUTJ4aGMzTW9aV3dzSUdOc2N5azdYRzU5WEc1Y2JtWjFibU4wYVc5dUlISmxiVzkyWlZSeVlXNXphWFJwYjI1RGJHRnpjeUFvWld3c0lHTnNjeWtnZTF4dUlDQnBaaUFvWld3dVgzUnlZVzV6YVhScGIyNURiR0Z6YzJWektTQjdYRzRnSUNBZ2NtVnRiM1psS0dWc0xsOTBjbUZ1YzJsMGFXOXVRMnhoYzNObGN5d2dZMnh6S1R0Y2JpQWdmVnh1SUNCeVpXMXZkbVZEYkdGemN5aGxiQ3dnWTJ4ektUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z2QyaGxibFJ5WVc1emFYUnBiMjVGYm1SeklDaGNiaUFnWld3c1hHNGdJR1Y0Y0dWamRHVmtWSGx3WlN4Y2JpQWdZMkpjYmlrZ2UxeHVJQ0IyWVhJZ2NtVm1JRDBnWjJWMFZISmhibk5wZEdsdmJrbHVabThvWld3c0lHVjRjR1ZqZEdWa1ZIbHdaU2s3WEc0Z0lIWmhjaUIwZVhCbElEMGdjbVZtTG5SNWNHVTdYRzRnSUhaaGNpQjBhVzFsYjNWMElEMGdjbVZtTG5ScGJXVnZkWFE3WEc0Z0lIWmhjaUJ3Y205d1EyOTFiblFnUFNCeVpXWXVjSEp2Y0VOdmRXNTBPMXh1SUNCcFppQW9JWFI1Y0dVcElIc2djbVYwZFhKdUlHTmlLQ2tnZlZ4dUlDQjJZWElnWlhabGJuUWdQU0IwZVhCbElEMDlQU0JVVWtGT1UwbFVTVTlPSUQ4Z2RISmhibk5wZEdsdmJrVnVaRVYyWlc1MElEb2dZVzVwYldGMGFXOXVSVzVrUlhabGJuUTdYRzRnSUhaaGNpQmxibVJsWkNBOUlEQTdYRzRnSUhaaGNpQmxibVFnUFNCbWRXNWpkR2x2YmlBb0tTQjdYRzRnSUNBZ1pXd3VjbVZ0YjNabFJYWmxiblJNYVhOMFpXNWxjaWhsZG1WdWRDd2diMjVGYm1RcE8xeHVJQ0FnSUdOaUtDazdYRzRnSUgwN1hHNGdJSFpoY2lCdmJrVnVaQ0E5SUdaMWJtTjBhVzl1SUNobEtTQjdYRzRnSUNBZ2FXWWdLR1V1ZEdGeVoyVjBJRDA5UFNCbGJDa2dlMXh1SUNBZ0lDQWdhV1lnS0NzclpXNWtaV1FnUGowZ2NISnZjRU52ZFc1MEtTQjdYRzRnSUNBZ0lDQWdJR1Z1WkNncE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdmVHRjYmlBZ2MyVjBWR2x0Wlc5MWRDaG1kVzVqZEdsdmJpQW9LU0I3WEc0Z0lDQWdhV1lnS0dWdVpHVmtJRHdnY0hKdmNFTnZkVzUwS1NCN1hHNGdJQ0FnSUNCbGJtUW9LVHRjYmlBZ0lDQjlYRzRnSUgwc0lIUnBiV1Z2ZFhRZ0t5QXhLVHRjYmlBZ1pXd3VZV1JrUlhabGJuUk1hWE4wWlc1bGNpaGxkbVZ1ZEN3Z2IyNUZibVFwTzF4dWZWeHVYRzUyWVhJZ2RISmhibk5tYjNKdFVrVWdQU0F2WEZ4aUtIUnlZVzV6Wm05eWJYeGhiR3dwS0N4OEpDa3ZPMXh1WEc1bWRXNWpkR2x2YmlCblpYUlVjbUZ1YzJsMGFXOXVTVzVtYnlBb1pXd3NJR1Y0Y0dWamRHVmtWSGx3WlNrZ2UxeHVJQ0IyWVhJZ2MzUjViR1Z6SUQwZ2QybHVaRzkzTG1kbGRFTnZiWEIxZEdWa1UzUjViR1VvWld3cE8xeHVJQ0IyWVhJZ2RISmhibk5wZEdsdmJrUmxiR0Y1Y3lBOUlITjBlV3hsYzF0MGNtRnVjMmwwYVc5dVVISnZjQ0FySUNkRVpXeGhlU2RkTG5Od2JHbDBLQ2NzSUNjcE8xeHVJQ0IyWVhJZ2RISmhibk5wZEdsdmJrUjFjbUYwYVc5dWN5QTlJSE4wZVd4bGMxdDBjbUZ1YzJsMGFXOXVVSEp2Y0NBcklDZEVkWEpoZEdsdmJpZGRMbk53YkdsMEtDY3NJQ2NwTzF4dUlDQjJZWElnZEhKaGJuTnBkR2x2YmxScGJXVnZkWFFnUFNCblpYUlVhVzFsYjNWMEtIUnlZVzV6YVhScGIyNUVaV3hoZVhNc0lIUnlZVzV6YVhScGIyNUVkWEpoZEdsdmJuTXBPMXh1SUNCMllYSWdZVzVwYldGMGFXOXVSR1ZzWVhseklEMGdjM1I1YkdWelcyRnVhVzFoZEdsdmJsQnliM0FnS3lBblJHVnNZWGtuWFM1emNHeHBkQ2duTENBbktUdGNiaUFnZG1GeUlHRnVhVzFoZEdsdmJrUjFjbUYwYVc5dWN5QTlJSE4wZVd4bGMxdGhibWx0WVhScGIyNVFjbTl3SUNzZ0owUjFjbUYwYVc5dUoxMHVjM0JzYVhRb0p5d2dKeWs3WEc0Z0lIWmhjaUJoYm1sdFlYUnBiMjVVYVcxbGIzVjBJRDBnWjJWMFZHbHRaVzkxZENoaGJtbHRZWFJwYjI1RVpXeGhlWE1zSUdGdWFXMWhkR2x2YmtSMWNtRjBhVzl1Y3lrN1hHNWNiaUFnZG1GeUlIUjVjR1U3WEc0Z0lIWmhjaUIwYVcxbGIzVjBJRDBnTUR0Y2JpQWdkbUZ5SUhCeWIzQkRiM1Z1ZENBOUlEQTdYRzRnSUM4cUlHbHpkR0Z1WW5Wc0lHbG5ibTl5WlNCcFppQXFMMXh1SUNCcFppQW9aWGh3WldOMFpXUlVlWEJsSUQwOVBTQlVVa0ZPVTBsVVNVOU9LU0I3WEc0Z0lDQWdhV1lnS0hSeVlXNXphWFJwYjI1VWFXMWxiM1YwSUQ0Z01Da2dlMXh1SUNBZ0lDQWdkSGx3WlNBOUlGUlNRVTVUU1ZSSlQwNDdYRzRnSUNBZ0lDQjBhVzFsYjNWMElEMGdkSEpoYm5OcGRHbHZibFJwYldWdmRYUTdYRzRnSUNBZ0lDQndjbTl3UTI5MWJuUWdQU0IwY21GdWMybDBhVzl1UkhWeVlYUnBiMjV6TG14bGJtZDBhRHRjYmlBZ0lDQjlYRzRnSUgwZ1pXeHpaU0JwWmlBb1pYaHdaV04wWldSVWVYQmxJRDA5UFNCQlRrbE5RVlJKVDA0cElIdGNiaUFnSUNCcFppQW9ZVzVwYldGMGFXOXVWR2x0Wlc5MWRDQStJREFwSUh0Y2JpQWdJQ0FnSUhSNWNHVWdQU0JCVGtsTlFWUkpUMDQ3WEc0Z0lDQWdJQ0IwYVcxbGIzVjBJRDBnWVc1cGJXRjBhVzl1VkdsdFpXOTFkRHRjYmlBZ0lDQWdJSEJ5YjNCRGIzVnVkQ0E5SUdGdWFXMWhkR2x2YmtSMWNtRjBhVzl1Y3k1c1pXNW5kR2c3WEc0Z0lDQWdmVnh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJSFJwYldWdmRYUWdQU0JOWVhSb0xtMWhlQ2gwY21GdWMybDBhVzl1VkdsdFpXOTFkQ3dnWVc1cGJXRjBhVzl1VkdsdFpXOTFkQ2s3WEc0Z0lDQWdkSGx3WlNBOUlIUnBiV1Z2ZFhRZ1BpQXdYRzRnSUNBZ0lDQS9JSFJ5WVc1emFYUnBiMjVVYVcxbGIzVjBJRDRnWVc1cGJXRjBhVzl1VkdsdFpXOTFkRnh1SUNBZ0lDQWdJQ0EvSUZSU1FVNVRTVlJKVDA1Y2JpQWdJQ0FnSUNBZ09pQkJUa2xOUVZSSlQwNWNiaUFnSUNBZ0lEb2diblZzYkR0Y2JpQWdJQ0J3Y205d1EyOTFiblFnUFNCMGVYQmxYRzRnSUNBZ0lDQS9JSFI1Y0dVZ1BUMDlJRlJTUVU1VFNWUkpUMDVjYmlBZ0lDQWdJQ0FnUHlCMGNtRnVjMmwwYVc5dVJIVnlZWFJwYjI1ekxteGxibWQwYUZ4dUlDQWdJQ0FnSUNBNklHRnVhVzFoZEdsdmJrUjFjbUYwYVc5dWN5NXNaVzVuZEdoY2JpQWdJQ0FnSURvZ01EdGNiaUFnZlZ4dUlDQjJZWElnYUdGelZISmhibk5tYjNKdElEMWNiaUFnSUNCMGVYQmxJRDA5UFNCVVVrRk9VMGxVU1U5T0lDWW1YRzRnSUNBZ2RISmhibk5tYjNKdFVrVXVkR1Z6ZENoemRIbHNaWE5iZEhKaGJuTnBkR2x2YmxCeWIzQWdLeUFuVUhKdmNHVnlkSGtuWFNrN1hHNGdJSEpsZEhWeWJpQjdYRzRnSUNBZ2RIbHdaVG9nZEhsd1pTeGNiaUFnSUNCMGFXMWxiM1YwT2lCMGFXMWxiM1YwTEZ4dUlDQWdJSEJ5YjNCRGIzVnVkRG9nY0hKdmNFTnZkVzUwTEZ4dUlDQWdJR2hoYzFSeVlXNXpabTl5YlRvZ2FHRnpWSEpoYm5ObWIzSnRYRzRnSUgxY2JuMWNibHh1Wm5WdVkzUnBiMjRnWjJWMFZHbHRaVzkxZENBb1pHVnNZWGx6TENCa2RYSmhkR2x2Ym5NcElIdGNiaUFnTHlvZ2FYTjBZVzVpZFd3Z2FXZHViM0psSUc1bGVIUWdLaTljYmlBZ2QyaHBiR1VnS0dSbGJHRjVjeTVzWlc1bmRHZ2dQQ0JrZFhKaGRHbHZibk11YkdWdVozUm9LU0I3WEc0Z0lDQWdaR1ZzWVhseklEMGdaR1ZzWVhsekxtTnZibU5oZENoa1pXeGhlWE1wTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUUxaGRHZ3ViV0Y0TG1Gd2NHeDVLRzUxYkd3c0lHUjFjbUYwYVc5dWN5NXRZWEFvWm5WdVkzUnBiMjRnS0dRc0lHa3BJSHRjYmlBZ0lDQnlaWFIxY200Z2RHOU5jeWhrS1NBcklIUnZUWE1vWkdWc1lYbHpXMmxkS1Z4dUlDQjlLU2xjYm4xY2JseHVablZ1WTNScGIyNGdkRzlOY3lBb2N5a2dlMXh1SUNCeVpYUjFjbTRnVG5WdFltVnlLSE11YzJ4cFkyVW9NQ3dnTFRFcEtTQXFJREV3TURCY2JuMWNibHh1THlvZ0lDb3ZYRzVjYm1aMWJtTjBhVzl1SUdWdWRHVnlJQ2gyYm05a1pTd2dkRzluWjJ4bFJHbHpjR3hoZVNrZ2UxeHVJQ0IyWVhJZ1pXd2dQU0IyYm05a1pTNWxiRzA3WEc1Y2JpQWdMeThnWTJGc2JDQnNaV0YyWlNCallXeHNZbUZqYXlCdWIzZGNiaUFnYVdZZ0tHVnNMbDlzWldGMlpVTmlLU0I3WEc0Z0lDQWdaV3d1WDJ4bFlYWmxRMkl1WTJGdVkyVnNiR1ZrSUQwZ2RISjFaVHRjYmlBZ0lDQmxiQzVmYkdWaGRtVkRZaWdwTzF4dUlDQjlYRzVjYmlBZ2RtRnlJR1JoZEdFZ1BTQnlaWE52YkhabFZISmhibk5wZEdsdmJpaDJibTlrWlM1a1lYUmhMblJ5WVc1emFYUnBiMjRwTzF4dUlDQnBaaUFvSVdSaGRHRXBJSHRjYmlBZ0lDQnlaWFIxY201Y2JpQWdmVnh1WEc0Z0lDOHFJR2x6ZEdGdVluVnNJR2xuYm05eVpTQnBaaUFxTDF4dUlDQnBaaUFvWld3dVgyVnVkR1Z5UTJJZ2ZId2daV3d1Ym05a1pWUjVjR1VnSVQwOUlERXBJSHRjYmlBZ0lDQnlaWFIxY201Y2JpQWdmVnh1WEc0Z0lIWmhjaUJqYzNNZ1BTQmtZWFJoTG1OemN6dGNiaUFnZG1GeUlIUjVjR1VnUFNCa1lYUmhMblI1Y0dVN1hHNGdJSFpoY2lCbGJuUmxja05zWVhOeklEMGdaR0YwWVM1bGJuUmxja05zWVhOek8xeHVJQ0IyWVhJZ1pXNTBaWEpVYjBOc1lYTnpJRDBnWkdGMFlTNWxiblJsY2xSdlEyeGhjM003WEc0Z0lIWmhjaUJsYm5SbGNrRmpkR2wyWlVOc1lYTnpJRDBnWkdGMFlTNWxiblJsY2tGamRHbDJaVU5zWVhOek8xeHVJQ0IyWVhJZ1lYQndaV0Z5UTJ4aGMzTWdQU0JrWVhSaExtRndjR1ZoY2tOc1lYTnpPMXh1SUNCMllYSWdZWEJ3WldGeVZHOURiR0Z6Y3lBOUlHUmhkR0V1WVhCd1pXRnlWRzlEYkdGemN6dGNiaUFnZG1GeUlHRndjR1ZoY2tGamRHbDJaVU5zWVhOeklEMGdaR0YwWVM1aGNIQmxZWEpCWTNScGRtVkRiR0Z6Y3p0Y2JpQWdkbUZ5SUdKbFptOXlaVVZ1ZEdWeUlEMGdaR0YwWVM1aVpXWnZjbVZGYm5SbGNqdGNiaUFnZG1GeUlHVnVkR1Z5SUQwZ1pHRjBZUzVsYm5SbGNqdGNiaUFnZG1GeUlHRm1kR1Z5Ulc1MFpYSWdQU0JrWVhSaExtRm1kR1Z5Ulc1MFpYSTdYRzRnSUhaaGNpQmxiblJsY2tOaGJtTmxiR3hsWkNBOUlHUmhkR0V1Wlc1MFpYSkRZVzVqWld4c1pXUTdYRzRnSUhaaGNpQmlaV1p2Y21WQmNIQmxZWElnUFNCa1lYUmhMbUpsWm05eVpVRndjR1ZoY2p0Y2JpQWdkbUZ5SUdGd2NHVmhjaUE5SUdSaGRHRXVZWEJ3WldGeU8xeHVJQ0IyWVhJZ1lXWjBaWEpCY0hCbFlYSWdQU0JrWVhSaExtRm1kR1Z5UVhCd1pXRnlPMXh1SUNCMllYSWdZWEJ3WldGeVEyRnVZMlZzYkdWa0lEMGdaR0YwWVM1aGNIQmxZWEpEWVc1alpXeHNaV1E3WEc0Z0lIWmhjaUJrZFhKaGRHbHZiaUE5SUdSaGRHRXVaSFZ5WVhScGIyNDdYRzVjYmlBZ0x5OGdZV04wYVhabFNXNXpkR0Z1WTJVZ2QybHNiQ0JoYkhkaGVYTWdZbVVnZEdobElEeDBjbUZ1YzJsMGFXOXVQaUJqYjIxd2IyNWxiblFnYldGdVlXZHBibWNnZEdocGMxeHVJQ0F2THlCMGNtRnVjMmwwYVc5dUxpQlBibVVnWldSblpTQmpZWE5sSUhSdklHTm9aV05ySUdseklIZG9aVzRnZEdobElEeDBjbUZ1YzJsMGFXOXVQaUJwY3lCd2JHRmpaV1JjYmlBZ0x5OGdZWE1nZEdobElISnZiM1FnYm05a1pTQnZaaUJoSUdOb2FXeGtJR052YlhCdmJtVnVkQzRnU1c0Z2RHaGhkQ0JqWVhObElIZGxJRzVsWldRZ2RHOGdZMmhsWTJ0Y2JpQWdMeThnUEhSeVlXNXphWFJwYjI0K0ozTWdjR0Z5Wlc1MElHWnZjaUJoY0hCbFlYSWdZMmhsWTJzdVhHNGdJSFpoY2lCamIyNTBaWGgwSUQwZ1lXTjBhWFpsU1c1emRHRnVZMlU3WEc0Z0lIWmhjaUIwY21GdWMybDBhVzl1VG05a1pTQTlJR0ZqZEdsMlpVbHVjM1JoYm1ObExpUjJibTlrWlR0Y2JpQWdkMmhwYkdVZ0tIUnlZVzV6YVhScGIyNU9iMlJsSUNZbUlIUnlZVzV6YVhScGIyNU9iMlJsTG5CaGNtVnVkQ2tnZTF4dUlDQWdJSFJ5WVc1emFYUnBiMjVPYjJSbElEMGdkSEpoYm5OcGRHbHZiazV2WkdVdWNHRnlaVzUwTzF4dUlDQWdJR052Ym5SbGVIUWdQU0IwY21GdWMybDBhVzl1VG05a1pTNWpiMjUwWlhoME8xeHVJQ0I5WEc1Y2JpQWdkbUZ5SUdselFYQndaV0Z5SUQwZ0lXTnZiblJsZUhRdVgybHpUVzkxYm5SbFpDQjhmQ0FoZG01dlpHVXVhWE5TYjI5MFNXNXpaWEowTzF4dVhHNGdJR2xtSUNocGMwRndjR1ZoY2lBbUppQWhZWEJ3WldGeUlDWW1JR0Z3Y0dWaGNpQWhQVDBnSnljcElIdGNiaUFnSUNCeVpYUjFjbTVjYmlBZ2ZWeHVYRzRnSUhaaGNpQnpkR0Z5ZEVOc1lYTnpJRDBnYVhOQmNIQmxZWElnSmlZZ1lYQndaV0Z5UTJ4aGMzTmNiaUFnSUNBL0lHRndjR1ZoY2tOc1lYTnpYRzRnSUNBZ09pQmxiblJsY2tOc1lYTnpPMXh1SUNCMllYSWdZV04wYVhabFEyeGhjM01nUFNCcGMwRndjR1ZoY2lBbUppQmhjSEJsWVhKQlkzUnBkbVZEYkdGemMxeHVJQ0FnSUQ4Z1lYQndaV0Z5UVdOMGFYWmxRMnhoYzNOY2JpQWdJQ0E2SUdWdWRHVnlRV04wYVhabFEyeGhjM003WEc0Z0lIWmhjaUIwYjBOc1lYTnpJRDBnYVhOQmNIQmxZWElnSmlZZ1lYQndaV0Z5Vkc5RGJHRnpjMXh1SUNBZ0lEOGdZWEJ3WldGeVZHOURiR0Z6YzF4dUlDQWdJRG9nWlc1MFpYSlViME5zWVhOek8xeHVYRzRnSUhaaGNpQmlaV1p2Y21WRmJuUmxja2h2YjJzZ1BTQnBjMEZ3Y0dWaGNseHVJQ0FnSUQ4Z0tHSmxabTl5WlVGd2NHVmhjaUI4ZkNCaVpXWnZjbVZGYm5SbGNpbGNiaUFnSUNBNklHSmxabTl5WlVWdWRHVnlPMXh1SUNCMllYSWdaVzUwWlhKSWIyOXJJRDBnYVhOQmNIQmxZWEpjYmlBZ0lDQS9JQ2gwZVhCbGIyWWdZWEJ3WldGeUlEMDlQU0FuWm5WdVkzUnBiMjRuSUQ4Z1lYQndaV0Z5SURvZ1pXNTBaWElwWEc0Z0lDQWdPaUJsYm5SbGNqdGNiaUFnZG1GeUlHRm1kR1Z5Ulc1MFpYSkliMjlySUQwZ2FYTkJjSEJsWVhKY2JpQWdJQ0EvSUNoaFpuUmxja0Z3Y0dWaGNpQjhmQ0JoWm5SbGNrVnVkR1Z5S1Z4dUlDQWdJRG9nWVdaMFpYSkZiblJsY2p0Y2JpQWdkbUZ5SUdWdWRHVnlRMkZ1WTJWc2JHVmtTRzl2YXlBOUlHbHpRWEJ3WldGeVhHNGdJQ0FnUHlBb1lYQndaV0Z5UTJGdVkyVnNiR1ZrSUh4OElHVnVkR1Z5UTJGdVkyVnNiR1ZrS1Z4dUlDQWdJRG9nWlc1MFpYSkRZVzVqWld4c1pXUTdYRzVjYmlBZ2RtRnlJR1Y0Y0d4cFkybDBSVzUwWlhKRWRYSmhkR2x2YmlBOUlIUnZUblZ0WW1WeUtGeHVJQ0FnSUdselQySnFaV04wS0dSMWNtRjBhVzl1S1Z4dUlDQWdJQ0FnUHlCa2RYSmhkR2x2Ymk1bGJuUmxjbHh1SUNBZ0lDQWdPaUJrZFhKaGRHbHZibHh1SUNBcE8xeHVYRzRnSUdsbUlDaHdjbTlqWlhOekxtVnVkaTVPVDBSRlgwVk9WaUFoUFQwZ0ozQnliMlIxWTNScGIyNG5JQ1ltSUdWNGNHeHBZMmwwUlc1MFpYSkVkWEpoZEdsdmJpQWhQU0J1ZFd4c0tTQjdYRzRnSUNBZ1kyaGxZMnRFZFhKaGRHbHZiaWhsZUhCc2FXTnBkRVZ1ZEdWeVJIVnlZWFJwYjI0c0lDZGxiblJsY2ljc0lIWnViMlJsS1R0Y2JpQWdmVnh1WEc0Z0lIWmhjaUJsZUhCbFkzUnpRMU5USUQwZ1kzTnpJQ0U5UFNCbVlXeHpaU0FtSmlBaGFYTkpSVGs3WEc0Z0lIWmhjaUIxYzJWeVYyRnVkSE5EYjI1MGNtOXNJRDBnWjJWMFNHOXZhMEZ5WjNWdFpXNTBjMHhsYm1kMGFDaGxiblJsY2todmIyc3BPMXh1WEc0Z0lIWmhjaUJqWWlBOUlHVnNMbDlsYm5SbGNrTmlJRDBnYjI1alpTaG1kVzVqZEdsdmJpQW9LU0I3WEc0Z0lDQWdhV1lnS0dWNGNHVmpkSE5EVTFNcElIdGNiaUFnSUNBZ0lISmxiVzkyWlZSeVlXNXphWFJwYjI1RGJHRnpjeWhsYkN3Z2RHOURiR0Z6Y3lrN1hHNGdJQ0FnSUNCeVpXMXZkbVZVY21GdWMybDBhVzl1UTJ4aGMzTW9aV3dzSUdGamRHbDJaVU5zWVhOektUdGNiaUFnSUNCOVhHNGdJQ0FnYVdZZ0tHTmlMbU5oYm1ObGJHeGxaQ2tnZTF4dUlDQWdJQ0FnYVdZZ0tHVjRjR1ZqZEhORFUxTXBJSHRjYmlBZ0lDQWdJQ0FnY21WdGIzWmxWSEpoYm5OcGRHbHZia05zWVhOektHVnNMQ0J6ZEdGeWRFTnNZWE56S1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUdWdWRHVnlRMkZ1WTJWc2JHVmtTRzl2YXlBbUppQmxiblJsY2tOaGJtTmxiR3hsWkVodmIyc29aV3dwTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQmhablJsY2tWdWRHVnlTRzl2YXlBbUppQmhablJsY2tWdWRHVnlTRzl2YXlobGJDazdYRzRnSUNBZ2ZWeHVJQ0FnSUdWc0xsOWxiblJsY2tOaUlEMGdiblZzYkR0Y2JpQWdmU2s3WEc1Y2JpQWdhV1lnS0NGMmJtOWtaUzVrWVhSaExuTm9iM2NwSUh0Y2JpQWdJQ0F2THlCeVpXMXZkbVVnY0dWdVpHbHVaeUJzWldGMlpTQmxiR1Z0Wlc1MElHOXVJR1Z1ZEdWeUlHSjVJR2x1YW1WamRHbHVaeUJoYmlCcGJuTmxjblFnYUc5dmExeHVJQ0FnSUcxbGNtZGxWazV2WkdWSWIyOXJLSFp1YjJSbExtUmhkR0V1YUc5dmF5QjhmQ0FvZG01dlpHVXVaR0YwWVM1b2IyOXJJRDBnZTMwcExDQW5hVzV6WlhKMEp5d2dablZ1WTNScGIyNGdLQ2tnZTF4dUlDQWdJQ0FnZG1GeUlIQmhjbVZ1ZENBOUlHVnNMbkJoY21WdWRFNXZaR1U3WEc0Z0lDQWdJQ0IyWVhJZ2NHVnVaR2x1WjA1dlpHVWdQU0J3WVhKbGJuUWdKaVlnY0dGeVpXNTBMbDl3Wlc1a2FXNW5JQ1ltSUhCaGNtVnVkQzVmY0dWdVpHbHVaMXQyYm05a1pTNXJaWGxkTzF4dUlDQWdJQ0FnYVdZZ0tIQmxibVJwYm1kT2IyUmxJQ1ltWEc0Z0lDQWdJQ0FnSUNBZ2NHVnVaR2x1WjA1dlpHVXVkR0ZuSUQwOVBTQjJibTlrWlM1MFlXY2dKaVpjYmlBZ0lDQWdJQ0FnSUNCd1pXNWthVzVuVG05a1pTNWxiRzB1WDJ4bFlYWmxRMklwSUh0Y2JpQWdJQ0FnSUNBZ2NHVnVaR2x1WjA1dlpHVXVaV3h0TGw5c1pXRjJaVU5pS0NrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNCbGJuUmxja2h2YjJzZ0ppWWdaVzUwWlhKSWIyOXJLR1ZzTENCallpazdYRzRnSUNBZ2ZTazdYRzRnSUgxY2JseHVJQ0F2THlCemRHRnlkQ0JsYm5SbGNpQjBjbUZ1YzJsMGFXOXVYRzRnSUdKbFptOXlaVVZ1ZEdWeVNHOXZheUFtSmlCaVpXWnZjbVZGYm5SbGNraHZiMnNvWld3cE8xeHVJQ0JwWmlBb1pYaHdaV04wYzBOVFV5a2dlMXh1SUNBZ0lHRmtaRlJ5WVc1emFYUnBiMjVEYkdGemN5aGxiQ3dnYzNSaGNuUkRiR0Z6Y3lrN1hHNGdJQ0FnWVdSa1ZISmhibk5wZEdsdmJrTnNZWE56S0dWc0xDQmhZM1JwZG1WRGJHRnpjeWs3WEc0Z0lDQWdibVY0ZEVaeVlXMWxLR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdJQ0FnSUdGa1pGUnlZVzV6YVhScGIyNURiR0Z6Y3lobGJDd2dkRzlEYkdGemN5azdYRzRnSUNBZ0lDQnlaVzF2ZG1WVWNtRnVjMmwwYVc5dVEyeGhjM01vWld3c0lITjBZWEowUTJ4aGMzTXBPMXh1SUNBZ0lDQWdhV1lnS0NGallpNWpZVzVqWld4c1pXUWdKaVlnSVhWelpYSlhZVzUwYzBOdmJuUnliMndwSUh0Y2JpQWdJQ0FnSUNBZ2FXWWdLR2x6Vm1Gc2FXUkVkWEpoZEdsdmJpaGxlSEJzYVdOcGRFVnVkR1Z5UkhWeVlYUnBiMjRwS1NCN1hHNGdJQ0FnSUNBZ0lDQWdjMlYwVkdsdFpXOTFkQ2hqWWl3Z1pYaHdiR2xqYVhSRmJuUmxja1IxY21GMGFXOXVLVHRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNCM2FHVnVWSEpoYm5OcGRHbHZia1Z1WkhNb1pXd3NJSFI1Y0dVc0lHTmlLVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dUlDQWdJSDBwTzF4dUlDQjlYRzVjYmlBZ2FXWWdLSFp1YjJSbExtUmhkR0V1YzJodmR5a2dlMXh1SUNBZ0lIUnZaMmRzWlVScGMzQnNZWGtnSmlZZ2RHOW5aMnhsUkdsemNHeGhlU2dwTzF4dUlDQWdJR1Z1ZEdWeVNHOXZheUFtSmlCbGJuUmxja2h2YjJzb1pXd3NJR05pS1R0Y2JpQWdmVnh1WEc0Z0lHbG1JQ2doWlhod1pXTjBjME5UVXlBbUppQWhkWE5sY2xkaGJuUnpRMjl1ZEhKdmJDa2dlMXh1SUNBZ0lHTmlLQ2s3WEc0Z0lIMWNibjFjYmx4dVpuVnVZM1JwYjI0Z2JHVmhkbVVnS0hadWIyUmxMQ0J5YlNrZ2UxeHVJQ0IyWVhJZ1pXd2dQU0IyYm05a1pTNWxiRzA3WEc1Y2JpQWdMeThnWTJGc2JDQmxiblJsY2lCallXeHNZbUZqYXlCdWIzZGNiaUFnYVdZZ0tHVnNMbDlsYm5SbGNrTmlLU0I3WEc0Z0lDQWdaV3d1WDJWdWRHVnlRMkl1WTJGdVkyVnNiR1ZrSUQwZ2RISjFaVHRjYmlBZ0lDQmxiQzVmWlc1MFpYSkRZaWdwTzF4dUlDQjlYRzVjYmlBZ2RtRnlJR1JoZEdFZ1BTQnlaWE52YkhabFZISmhibk5wZEdsdmJpaDJibTlrWlM1a1lYUmhMblJ5WVc1emFYUnBiMjRwTzF4dUlDQnBaaUFvSVdSaGRHRXBJSHRjYmlBZ0lDQnlaWFIxY200Z2NtMG9LVnh1SUNCOVhHNWNiaUFnTHlvZ2FYTjBZVzVpZFd3Z2FXZHViM0psSUdsbUlDb3ZYRzRnSUdsbUlDaGxiQzVmYkdWaGRtVkRZaUI4ZkNCbGJDNXViMlJsVkhsd1pTQWhQVDBnTVNrZ2UxeHVJQ0FnSUhKbGRIVnlibHh1SUNCOVhHNWNiaUFnZG1GeUlHTnpjeUE5SUdSaGRHRXVZM056TzF4dUlDQjJZWElnZEhsd1pTQTlJR1JoZEdFdWRIbHdaVHRjYmlBZ2RtRnlJR3hsWVhabFEyeGhjM01nUFNCa1lYUmhMbXhsWVhabFEyeGhjM003WEc0Z0lIWmhjaUJzWldGMlpWUnZRMnhoYzNNZ1BTQmtZWFJoTG14bFlYWmxWRzlEYkdGemN6dGNiaUFnZG1GeUlHeGxZWFpsUVdOMGFYWmxRMnhoYzNNZ1BTQmtZWFJoTG14bFlYWmxRV04wYVhabFEyeGhjM003WEc0Z0lIWmhjaUJpWldadmNtVk1aV0YyWlNBOUlHUmhkR0V1WW1WbWIzSmxUR1ZoZG1VN1hHNGdJSFpoY2lCc1pXRjJaU0E5SUdSaGRHRXViR1ZoZG1VN1hHNGdJSFpoY2lCaFpuUmxja3hsWVhabElEMGdaR0YwWVM1aFpuUmxja3hsWVhabE8xeHVJQ0IyWVhJZ2JHVmhkbVZEWVc1alpXeHNaV1FnUFNCa1lYUmhMbXhsWVhabFEyRnVZMlZzYkdWa08xeHVJQ0IyWVhJZ1pHVnNZWGxNWldGMlpTQTlJR1JoZEdFdVpHVnNZWGxNWldGMlpUdGNiaUFnZG1GeUlHUjFjbUYwYVc5dUlEMGdaR0YwWVM1a2RYSmhkR2x2Ymp0Y2JseHVJQ0IyWVhJZ1pYaHdaV04wYzBOVFV5QTlJR056Y3lBaFBUMGdabUZzYzJVZ0ppWWdJV2x6U1VVNU8xeHVJQ0IyWVhJZ2RYTmxjbGRoYm5SelEyOXVkSEp2YkNBOUlHZGxkRWh2YjJ0QmNtZDFiV1Z1ZEhOTVpXNW5kR2dvYkdWaGRtVXBPMXh1WEc0Z0lIWmhjaUJsZUhCc2FXTnBkRXhsWVhabFJIVnlZWFJwYjI0Z1BTQjBiMDUxYldKbGNpaGNiaUFnSUNCcGMwOWlhbVZqZENoa2RYSmhkR2x2YmlsY2JpQWdJQ0FnSUQ4Z1pIVnlZWFJwYjI0dWJHVmhkbVZjYmlBZ0lDQWdJRG9nWkhWeVlYUnBiMjVjYmlBZ0tUdGNibHh1SUNCcFppQW9jSEp2WTJWemN5NWxibll1VGs5RVJWOUZUbFlnSVQwOUlDZHdjbTlrZFdOMGFXOXVKeUFtSmlCbGVIQnNhV05wZEV4bFlYWmxSSFZ5WVhScGIyNGdJVDBnYm5Wc2JDa2dlMXh1SUNBZ0lHTm9aV05yUkhWeVlYUnBiMjRvWlhod2JHbGphWFJNWldGMlpVUjFjbUYwYVc5dUxDQW5iR1ZoZG1VbkxDQjJibTlrWlNrN1hHNGdJSDFjYmx4dUlDQjJZWElnWTJJZ1BTQmxiQzVmYkdWaGRtVkRZaUE5SUc5dVkyVW9ablZ1WTNScGIyNGdLQ2tnZTF4dUlDQWdJR2xtSUNobGJDNXdZWEpsYm5ST2IyUmxJQ1ltSUdWc0xuQmhjbVZ1ZEU1dlpHVXVYM0JsYm1ScGJtY3BJSHRjYmlBZ0lDQWdJR1ZzTG5CaGNtVnVkRTV2WkdVdVgzQmxibVJwYm1kYmRtNXZaR1V1YTJWNVhTQTlJRzUxYkd3N1hHNGdJQ0FnZlZ4dUlDQWdJR2xtSUNobGVIQmxZM1J6UTFOVEtTQjdYRzRnSUNBZ0lDQnlaVzF2ZG1WVWNtRnVjMmwwYVc5dVEyeGhjM01vWld3c0lHeGxZWFpsVkc5RGJHRnpjeWs3WEc0Z0lDQWdJQ0J5WlcxdmRtVlVjbUZ1YzJsMGFXOXVRMnhoYzNNb1pXd3NJR3hsWVhabFFXTjBhWFpsUTJ4aGMzTXBPMXh1SUNBZ0lIMWNiaUFnSUNCcFppQW9ZMkl1WTJGdVkyVnNiR1ZrS1NCN1hHNGdJQ0FnSUNCcFppQW9aWGh3WldOMGMwTlRVeWtnZTF4dUlDQWdJQ0FnSUNCeVpXMXZkbVZVY21GdWMybDBhVzl1UTJ4aGMzTW9aV3dzSUd4bFlYWmxRMnhoYzNNcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2JHVmhkbVZEWVc1alpXeHNaV1FnSmlZZ2JHVmhkbVZEWVc1alpXeHNaV1FvWld3cE8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0J5YlNncE8xeHVJQ0FnSUNBZ1lXWjBaWEpNWldGMlpTQW1KaUJoWm5SbGNreGxZWFpsS0dWc0tUdGNiaUFnSUNCOVhHNGdJQ0FnWld3dVgyeGxZWFpsUTJJZ1BTQnVkV3hzTzF4dUlDQjlLVHRjYmx4dUlDQnBaaUFvWkdWc1lYbE1aV0YyWlNrZ2UxeHVJQ0FnSUdSbGJHRjVUR1ZoZG1Vb2NHVnlabTl5YlV4bFlYWmxLVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0J3WlhKbWIzSnRUR1ZoZG1Vb0tUdGNiaUFnZlZ4dVhHNGdJR1oxYm1OMGFXOXVJSEJsY21admNtMU1aV0YyWlNBb0tTQjdYRzRnSUNBZ0x5OGdkR2hsSUdSbGJHRjVaV1FnYkdWaGRtVWdiV0Y1SUdoaGRtVWdZV3h5WldGa2VTQmlaV1Z1SUdOaGJtTmxiR3hsWkZ4dUlDQWdJR2xtSUNoallpNWpZVzVqWld4c1pXUXBJSHRjYmlBZ0lDQWdJSEpsZEhWeWJseHVJQ0FnSUgxY2JpQWdJQ0F2THlCeVpXTnZjbVFnYkdWaGRtbHVaeUJsYkdWdFpXNTBYRzRnSUNBZ2FXWWdLQ0YyYm05a1pTNWtZWFJoTG5Ob2IzY3BJSHRjYmlBZ0lDQWdJQ2hsYkM1d1lYSmxiblJPYjJSbExsOXdaVzVrYVc1bklIeDhJQ2hsYkM1d1lYSmxiblJPYjJSbExsOXdaVzVrYVc1bklEMGdlMzBwS1Z0MmJtOWtaUzVyWlhsZElEMGdkbTV2WkdVN1hHNGdJQ0FnZlZ4dUlDQWdJR0psWm05eVpVeGxZWFpsSUNZbUlHSmxabTl5WlV4bFlYWmxLR1ZzS1R0Y2JpQWdJQ0JwWmlBb1pYaHdaV04wYzBOVFV5a2dlMXh1SUNBZ0lDQWdZV1JrVkhKaGJuTnBkR2x2YmtOc1lYTnpLR1ZzTENCc1pXRjJaVU5zWVhOektUdGNiaUFnSUNBZ0lHRmtaRlJ5WVc1emFYUnBiMjVEYkdGemN5aGxiQ3dnYkdWaGRtVkJZM1JwZG1WRGJHRnpjeWs3WEc0Z0lDQWdJQ0J1WlhoMFJuSmhiV1VvWm5WdVkzUnBiMjRnS0NrZ2UxeHVJQ0FnSUNBZ0lDQmhaR1JVY21GdWMybDBhVzl1UTJ4aGMzTW9aV3dzSUd4bFlYWmxWRzlEYkdGemN5azdYRzRnSUNBZ0lDQWdJSEpsYlc5MlpWUnlZVzV6YVhScGIyNURiR0Z6Y3lobGJDd2diR1ZoZG1WRGJHRnpjeWs3WEc0Z0lDQWdJQ0FnSUdsbUlDZ2hZMkl1WTJGdVkyVnNiR1ZrSUNZbUlDRjFjMlZ5VjJGdWRITkRiMjUwY205c0tTQjdYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tHbHpWbUZzYVdSRWRYSmhkR2x2YmlobGVIQnNhV05wZEV4bFlYWmxSSFZ5WVhScGIyNHBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnpaWFJVYVcxbGIzVjBLR05pTENCbGVIQnNhV05wZEV4bFlYWmxSSFZ5WVhScGIyNHBPMXh1SUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjNhR1Z1VkhKaGJuTnBkR2x2YmtWdVpITW9aV3dzSUhSNWNHVXNJR05pS1R0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDBwTzF4dUlDQWdJSDFjYmlBZ0lDQnNaV0YyWlNBbUppQnNaV0YyWlNobGJDd2dZMklwTzF4dUlDQWdJR2xtSUNnaFpYaHdaV04wYzBOVFV5QW1KaUFoZFhObGNsZGhiblJ6UTI5dWRISnZiQ2tnZTF4dUlDQWdJQ0FnWTJJb0tUdGNiaUFnSUNCOVhHNGdJSDFjYm4xY2JseHVMeThnYjI1c2VTQjFjMlZrSUdsdUlHUmxkaUJ0YjJSbFhHNW1kVzVqZEdsdmJpQmphR1ZqYTBSMWNtRjBhVzl1SUNoMllXd3NJRzVoYldVc0lIWnViMlJsS1NCN1hHNGdJR2xtSUNoMGVYQmxiMllnZG1Gc0lDRTlQU0FuYm5WdFltVnlKeWtnZTF4dUlDQWdJSGRoY200b1hHNGdJQ0FnSUNCY0lqeDBjbUZ1YzJsMGFXOXVQaUJsZUhCc2FXTnBkQ0JjSWlBcklHNWhiV1VnS3lCY0lpQmtkWEpoZEdsdmJpQnBjeUJ1YjNRZ1lTQjJZV3hwWkNCdWRXMWlaWElnTFNCY0lpQXJYRzRnSUNBZ0lDQmNJbWR2ZENCY0lpQXJJQ2hLVTA5T0xuTjBjbWx1WjJsbWVTaDJZV3dwS1NBcklGd2lMbHdpTEZ4dUlDQWdJQ0FnZG01dlpHVXVZMjl1ZEdWNGRGeHVJQ0FnSUNrN1hHNGdJSDBnWld4elpTQnBaaUFvYVhOT1lVNG9kbUZzS1NrZ2UxeHVJQ0FnSUhkaGNtNG9YRzRnSUNBZ0lDQmNJangwY21GdWMybDBhVzl1UGlCbGVIQnNhV05wZENCY0lpQXJJRzVoYldVZ0t5QmNJaUJrZFhKaGRHbHZiaUJwY3lCT1lVNGdMU0JjSWlBclhHNGdJQ0FnSUNBbmRHaGxJR1IxY21GMGFXOXVJR1Y0Y0hKbGMzTnBiMjRnYldsbmFIUWdZbVVnYVc1amIzSnlaV04wTGljc1hHNGdJQ0FnSUNCMmJtOWtaUzVqYjI1MFpYaDBYRzRnSUNBZ0tUdGNiaUFnZlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJwYzFaaGJHbGtSSFZ5WVhScGIyNGdLSFpoYkNrZ2UxeHVJQ0J5WlhSMWNtNGdkSGx3Wlc5bUlIWmhiQ0E5UFQwZ0oyNTFiV0psY2ljZ0ppWWdJV2x6VG1GT0tIWmhiQ2xjYm4xY2JseHVMeW9xWEc0Z0tpQk9iM0p0WVd4cGVtVWdZU0IwY21GdWMybDBhVzl1SUdodmIyc25jeUJoY21kMWJXVnVkQ0JzWlc1bmRHZ3VJRlJvWlNCb2IyOXJJRzFoZVNCaVpUcGNiaUFxSUMwZ1lTQnRaWEpuWldRZ2FHOXZheUFvYVc1MmIydGxjaWtnZDJsMGFDQjBhR1VnYjNKcFoybHVZV3dnYVc0Z0xtWnVjMXh1SUNvZ0xTQmhJSGR5WVhCd1pXUWdZMjl0Y0c5dVpXNTBJRzFsZEdodlpDQW9ZMmhsWTJzZ0xsOXNaVzVuZEdncFhHNGdLaUF0SUdFZ2NHeGhhVzRnWm5WdVkzUnBiMjRnS0M1c1pXNW5kR2dwWEc0Z0tpOWNibVoxYm1OMGFXOXVJR2RsZEVodmIydEJjbWQxYldWdWRITk1aVzVuZEdnZ0tHWnVLU0I3WEc0Z0lHbG1JQ2doWm00cElIc2djbVYwZFhKdUlHWmhiSE5sSUgxY2JpQWdkbUZ5SUdsdWRtOXJaWEpHYm5NZ1BTQm1iaTVtYm5NN1hHNGdJR2xtSUNocGJuWnZhMlZ5Um01ektTQjdYRzRnSUNBZ0x5OGdhVzUyYjJ0bGNseHVJQ0FnSUhKbGRIVnliaUJuWlhSSWIyOXJRWEpuZFcxbGJuUnpUR1Z1WjNSb0tGeHVJQ0FnSUNBZ1FYSnlZWGt1YVhOQmNuSmhlU2hwYm5admEyVnlSbTV6S1Z4dUlDQWdJQ0FnSUNBL0lHbHVkbTlyWlhKR2JuTmJNRjFjYmlBZ0lDQWdJQ0FnT2lCcGJuWnZhMlZ5Um01elhHNGdJQ0FnS1Z4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUhKbGRIVnliaUFvWm00dVgyeGxibWQwYUNCOGZDQm1iaTVzWlc1bmRHZ3BJRDRnTVZ4dUlDQjlYRzU5WEc1Y2JtWjFibU4wYVc5dUlGOWxiblJsY2lBb1h5d2dkbTV2WkdVcElIdGNiaUFnYVdZZ0tDRjJibTlrWlM1a1lYUmhMbk5vYjNjcElIdGNiaUFnSUNCbGJuUmxjaWgyYm05a1pTazdYRzRnSUgxY2JuMWNibHh1ZG1GeUlIUnlZVzV6YVhScGIyNGdQU0JwYmtKeWIzZHpaWElnUHlCN1hHNGdJR055WldGMFpUb2dYMlZ1ZEdWeUxGeHVJQ0JoWTNScGRtRjBaVG9nWDJWdWRHVnlMRnh1SUNCeVpXMXZkbVU2SUdaMWJtTjBhVzl1SUhKbGJXOTJaU1FrTVNBb2RtNXZaR1VzSUhKdEtTQjdYRzRnSUNBZ0x5b2dhWE4wWVc1aWRXd2dhV2R1YjNKbElHVnNjMlVnS2k5Y2JpQWdJQ0JwWmlBb0lYWnViMlJsTG1SaGRHRXVjMmh2ZHlrZ2UxeHVJQ0FnSUNBZ2JHVmhkbVVvZG01dlpHVXNJSEp0S1R0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdjbTBvS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNibjBnT2lCN2ZUdGNibHh1ZG1GeUlIQnNZWFJtYjNKdFRXOWtkV3hsY3lBOUlGdGNiaUFnWVhSMGNuTXNYRzRnSUd0c1lYTnpMRnh1SUNCbGRtVnVkSE1zWEc0Z0lHUnZiVkJ5YjNCekxGeHVJQ0J6ZEhsc1pTeGNiaUFnZEhKaGJuTnBkR2x2Ymx4dVhUdGNibHh1THlvZ0lDb3ZYRzVjYmk4dklIUm9aU0JrYVhKbFkzUnBkbVVnYlc5a2RXeGxJSE5vYjNWc1pDQmlaU0JoY0hCc2FXVmtJR3hoYzNRc0lHRm1kR1Z5SUdGc2JGeHVMeThnWW5WcGJIUXRhVzRnYlc5a2RXeGxjeUJvWVhabElHSmxaVzRnWVhCd2JHbGxaQzVjYm5aaGNpQnRiMlIxYkdWeklEMGdjR3hoZEdadmNtMU5iMlIxYkdWekxtTnZibU5oZENoaVlYTmxUVzlrZFd4bGN5azdYRzVjYm5aaGNpQndZWFJqYUNBOUlHTnlaV0YwWlZCaGRHTm9SblZ1WTNScGIyNG9leUJ1YjJSbFQzQnpPaUJ1YjJSbFQzQnpMQ0J0YjJSMWJHVnpPaUJ0YjJSMWJHVnpJSDBwTzF4dVhHNHZLaXBjYmlBcUlFNXZkQ0IwZVhCbElHTm9aV05yYVc1bklIUm9hWE1nWm1sc1pTQmlaV05oZFhObElHWnNiM2NnWkc5bGMyNG5kQ0JzYVd0bElHRjBkR0ZqYUdsdVoxeHVJQ29nY0hKdmNHVnlkR2xsY3lCMGJ5QkZiR1Z0Wlc1MGN5NWNiaUFxTDF4dVhHNHZLaUJwYzNSaGJtSjFiQ0JwWjI1dmNtVWdhV1lnS2k5Y2JtbG1JQ2hwYzBsRk9Ta2dlMXh1SUNBdkx5Qm9kSFJ3T2k4dmQzZDNMbTFoZEhSek5ERXhMbU52YlM5d2IzTjBMMmx1ZEdWeWJtVjBMV1Y0Y0d4dmNtVnlMVGt0YjI1cGJuQjFkQzljYmlBZ1pHOWpkVzFsYm5RdVlXUmtSWFpsYm5STWFYTjBaVzVsY2lnbmMyVnNaV04wYVc5dVkyaGhibWRsSnl3Z1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNBZ0lIWmhjaUJsYkNBOUlHUnZZM1Z0Wlc1MExtRmpkR2wyWlVWc1pXMWxiblE3WEc0Z0lDQWdhV1lnS0dWc0lDWW1JR1ZzTG5adGIyUmxiQ2tnZTF4dUlDQWdJQ0FnZEhKcFoyZGxjaWhsYkN3Z0oybHVjSFYwSnlrN1hHNGdJQ0FnZlZ4dUlDQjlLVHRjYm4xY2JseHVkbUZ5SUcxdlpHVnNKREVnUFNCN1hHNGdJR2x1YzJWeWRHVmtPaUJtZFc1amRHbHZiaUJwYm5ObGNuUmxaQ0FvWld3c0lHSnBibVJwYm1jc0lIWnViMlJsS1NCN1hHNGdJQ0FnYVdZZ0tIWnViMlJsTG5SaFp5QTlQVDBnSjNObGJHVmpkQ2NwSUh0Y2JpQWdJQ0FnSUhaaGNpQmpZaUE5SUdaMWJtTjBhVzl1SUNncElIdGNiaUFnSUNBZ0lDQWdjMlYwVTJWc1pXTjBaV1FvWld3c0lHSnBibVJwYm1jc0lIWnViMlJsTG1OdmJuUmxlSFFwTzF4dUlDQWdJQ0FnZlR0Y2JpQWdJQ0FnSUdOaUtDazdYRzRnSUNBZ0lDQXZLaUJwYzNSaGJtSjFiQ0JwWjI1dmNtVWdhV1lnS2k5Y2JpQWdJQ0FnSUdsbUlDaHBjMGxGSUh4OElHbHpSV1JuWlNrZ2UxeHVJQ0FnSUNBZ0lDQnpaWFJVYVcxbGIzVjBLR05pTENBd0tUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOUlHVnNjMlVnYVdZZ0tIWnViMlJsTG5SaFp5QTlQVDBnSjNSbGVIUmhjbVZoSnlCOGZDQmxiQzUwZVhCbElEMDlQU0FuZEdWNGRDY2dmSHdnWld3dWRIbHdaU0E5UFQwZ0ozQmhjM04zYjNKa0p5a2dlMXh1SUNBZ0lDQWdaV3d1WDNaTmIyUnBabWxsY25NZ1BTQmlhVzVrYVc1bkxtMXZaR2xtYVdWeWN6dGNiaUFnSUNBZ0lHbG1JQ2doWW1sdVpHbHVaeTV0YjJScFptbGxjbk11YkdGNmVTa2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb0lXbHpRVzVrY205cFpDa2dlMXh1SUNBZ0lDQWdJQ0FnSUdWc0xtRmtaRVYyWlc1MFRHbHpkR1Z1WlhJb0oyTnZiWEJ2YzJsMGFXOXVjM1JoY25RbkxDQnZia052YlhCdmMybDBhVzl1VTNSaGNuUXBPMXh1SUNBZ0lDQWdJQ0FnSUdWc0xtRmtaRVYyWlc1MFRHbHpkR1Z1WlhJb0oyTnZiWEJ2YzJsMGFXOXVaVzVrSnl3Z2IyNURiMjF3YjNOcGRHbHZia1Z1WkNrN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdMeW9nYVhOMFlXNWlkV3dnYVdkdWIzSmxJR2xtSUNvdlhHNGdJQ0FnSUNBZ0lHbG1JQ2hwYzBsRk9Ta2dlMXh1SUNBZ0lDQWdJQ0FnSUdWc0xuWnRiMlJsYkNBOUlIUnlkV1U3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc0Z0lIMHNYRzRnSUdOdmJYQnZibVZ1ZEZWd1pHRjBaV1E2SUdaMWJtTjBhVzl1SUdOdmJYQnZibVZ1ZEZWd1pHRjBaV1FnS0dWc0xDQmlhVzVrYVc1bkxDQjJibTlrWlNrZ2UxeHVJQ0FnSUdsbUlDaDJibTlrWlM1MFlXY2dQVDA5SUNkelpXeGxZM1FuS1NCN1hHNGdJQ0FnSUNCelpYUlRaV3hsWTNSbFpDaGxiQ3dnWW1sdVpHbHVaeXdnZG01dlpHVXVZMjl1ZEdWNGRDazdYRzRnSUNBZ0lDQXZMeUJwYmlCallYTmxJSFJvWlNCdmNIUnBiMjV6SUhKbGJtUmxjbVZrSUdKNUlIWXRabTl5SUdoaGRtVWdZMmhoYm1kbFpDeGNiaUFnSUNBZ0lDOHZJR2wwSjNNZ2NHOXpjMmxpYkdVZ2RHaGhkQ0IwYUdVZ2RtRnNkV1VnYVhNZ2IzVjBMVzltTFhONWJtTWdkMmwwYUNCMGFHVWdjbVZ1WkdWeVpXUWdiM0IwYVc5dWN5NWNiaUFnSUNBZ0lDOHZJR1JsZEdWamRDQnpkV05vSUdOaGMyVnpJR0Z1WkNCbWFXeDBaWElnYjNWMElIWmhiSFZsY3lCMGFHRjBJRzV2SUd4dmJtZGxjaUJvWVhNZ1lTQnRZWFJqYUdsdVoxeHVJQ0FnSUNBZ0x5OGdiM0IwYVc5dUlHbHVJSFJvWlNCRVQwMHVYRzRnSUNBZ0lDQjJZWElnYm1WbFpGSmxjMlYwSUQwZ1pXd3ViWFZzZEdsd2JHVmNiaUFnSUNBZ0lDQWdQeUJpYVc1a2FXNW5MblpoYkhWbExuTnZiV1VvWm5WdVkzUnBiMjRnS0hZcElIc2djbVYwZFhKdUlHaGhjMDV2VFdGMFkyaHBibWRQY0hScGIyNG9kaXdnWld3dWIzQjBhVzl1Y3lrN0lIMHBYRzRnSUNBZ0lDQWdJRG9nWW1sdVpHbHVaeTUyWVd4MVpTQWhQVDBnWW1sdVpHbHVaeTV2YkdSV1lXeDFaU0FtSmlCb1lYTk9iMDFoZEdOb2FXNW5UM0IwYVc5dUtHSnBibVJwYm1jdWRtRnNkV1VzSUdWc0xtOXdkR2x2Ym5NcE8xeHVJQ0FnSUNBZ2FXWWdLRzVsWldSU1pYTmxkQ2tnZTF4dUlDQWdJQ0FnSUNCMGNtbG5aMlZ5S0dWc0xDQW5ZMmhoYm1kbEp5azdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVJQ0I5WEc1OU8xeHVYRzVtZFc1amRHbHZiaUJ6WlhSVFpXeGxZM1JsWkNBb1pXd3NJR0pwYm1ScGJtY3NJSFp0S1NCN1hHNGdJSFpoY2lCMllXeDFaU0E5SUdKcGJtUnBibWN1ZG1Gc2RXVTdYRzRnSUhaaGNpQnBjMDExYkhScGNHeGxJRDBnWld3dWJYVnNkR2x3YkdVN1hHNGdJR2xtSUNocGMwMTFiSFJwY0d4bElDWW1JQ0ZCY25KaGVTNXBjMEZ5Y21GNUtIWmhiSFZsS1NrZ2UxeHVJQ0FnSUhCeWIyTmxjM011Wlc1MkxrNVBSRVZmUlU1V0lDRTlQU0FuY0hKdlpIVmpkR2x2YmljZ0ppWWdkMkZ5YmloY2JpQWdJQ0FnSUZ3aVBITmxiR1ZqZENCdGRXeDBhWEJzWlNCMkxXMXZaR1ZzUFZ4Y1hDSmNJaUFySUNoaWFXNWthVzVuTG1WNGNISmxjM05wYjI0cElDc2dYQ0pjWEZ3aVBpQmNJaUFyWEc0Z0lDQWdJQ0JjSW1WNGNHVmpkSE1nWVc0Z1FYSnlZWGtnZG1Gc2RXVWdabTl5SUdsMGN5QmlhVzVrYVc1bkxDQmlkWFFnWjI5MElGd2lJQ3NnS0U5aWFtVmpkQzV3Y205MGIzUjVjR1V1ZEc5VGRISnBibWN1WTJGc2JDaDJZV3gxWlNrdWMyeHBZMlVvT0N3Z0xURXBLU3hjYmlBZ0lDQWdJSFp0WEc0Z0lDQWdLVHRjYmlBZ0lDQnlaWFIxY201Y2JpQWdmVnh1SUNCMllYSWdjMlZzWldOMFpXUXNJRzl3ZEdsdmJqdGNiaUFnWm05eUlDaDJZWElnYVNBOUlEQXNJR3dnUFNCbGJDNXZjSFJwYjI1ekxteGxibWQwYURzZ2FTQThJR3c3SUdrckt5a2dlMXh1SUNBZ0lHOXdkR2x2YmlBOUlHVnNMbTl3ZEdsdmJuTmJhVjA3WEc0Z0lDQWdhV1lnS0dselRYVnNkR2x3YkdVcElIdGNiaUFnSUNBZ0lITmxiR1ZqZEdWa0lEMGdiRzl2YzJWSmJtUmxlRTltS0haaGJIVmxMQ0JuWlhSV1lXeDFaU2h2Y0hScGIyNHBLU0ErSUMweE8xeHVJQ0FnSUNBZ2FXWWdLRzl3ZEdsdmJpNXpaV3hsWTNSbFpDQWhQVDBnYzJWc1pXTjBaV1FwSUh0Y2JpQWdJQ0FnSUNBZ2IzQjBhVzl1TG5ObGJHVmpkR1ZrSUQwZ2MyVnNaV04wWldRN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJR2xtSUNoc2IyOXpaVVZ4ZFdGc0tHZGxkRlpoYkhWbEtHOXdkR2x2Ymlrc0lIWmhiSFZsS1NrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvWld3dWMyVnNaV04wWldSSmJtUmxlQ0FoUFQwZ2FTa2dlMXh1SUNBZ0lDQWdJQ0FnSUdWc0xuTmxiR1ZqZEdWa1NXNWtaWGdnUFNCcE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJSEpsZEhWeWJseHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdmVnh1SUNCcFppQW9JV2x6VFhWc2RHbHdiR1VwSUh0Y2JpQWdJQ0JsYkM1elpXeGxZM1JsWkVsdVpHVjRJRDBnTFRFN1hHNGdJSDFjYm4xY2JseHVablZ1WTNScGIyNGdhR0Z6VG05TllYUmphR2x1WjA5d2RHbHZiaUFvZG1Gc2RXVXNJRzl3ZEdsdmJuTXBJSHRjYmlBZ1ptOXlJQ2gyWVhJZ2FTQTlJREFzSUd3Z1BTQnZjSFJwYjI1ekxteGxibWQwYURzZ2FTQThJR3c3SUdrckt5a2dlMXh1SUNBZ0lHbG1JQ2hzYjI5elpVVnhkV0ZzS0dkbGRGWmhiSFZsS0c5d2RHbHZibk5iYVYwcExDQjJZV3gxWlNrcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCbVlXeHpaVnh1SUNBZ0lIMWNiaUFnZlZ4dUlDQnlaWFIxY200Z2RISjFaVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQm5aWFJXWVd4MVpTQW9iM0IwYVc5dUtTQjdYRzRnSUhKbGRIVnliaUFuWDNaaGJIVmxKeUJwYmlCdmNIUnBiMjVjYmlBZ0lDQS9JRzl3ZEdsdmJpNWZkbUZzZFdWY2JpQWdJQ0E2SUc5d2RHbHZiaTUyWVd4MVpWeHVmVnh1WEc1bWRXNWpkR2x2YmlCdmJrTnZiWEJ2YzJsMGFXOXVVM1JoY25RZ0tHVXBJSHRjYmlBZ1pTNTBZWEpuWlhRdVkyOXRjRzl6YVc1bklEMGdkSEoxWlR0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnYjI1RGIyMXdiM05wZEdsdmJrVnVaQ0FvWlNrZ2UxeHVJQ0JsTG5SaGNtZGxkQzVqYjIxd2IzTnBibWNnUFNCbVlXeHpaVHRjYmlBZ2RISnBaMmRsY2lobExuUmhjbWRsZEN3Z0oybHVjSFYwSnlrN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUhSeWFXZG5aWElnS0dWc0xDQjBlWEJsS1NCN1hHNGdJSFpoY2lCbElEMGdaRzlqZFcxbGJuUXVZM0psWVhSbFJYWmxiblFvSjBoVVRVeEZkbVZ1ZEhNbktUdGNiaUFnWlM1cGJtbDBSWFpsYm5Rb2RIbHdaU3dnZEhKMVpTd2dkSEoxWlNrN1hHNGdJR1ZzTG1ScGMzQmhkR05vUlhabGJuUW9aU2s3WEc1OVhHNWNiaThxSUNBcUwxeHVYRzR2THlCeVpXTjFjbk5wZG1Wc2VTQnpaV0Z5WTJnZ1ptOXlJSEJ2YzNOcFlteGxJSFJ5WVc1emFYUnBiMjRnWkdWbWFXNWxaQ0JwYm5OcFpHVWdkR2hsSUdOdmJYQnZibVZ1ZENCeWIyOTBYRzVtZFc1amRHbHZiaUJzYjJOaGRHVk9iMlJsSUNoMmJtOWtaU2tnZTF4dUlDQnlaWFIxY200Z2RtNXZaR1V1WTI5dGNHOXVaVzUwU1c1emRHRnVZMlVnSmlZZ0tDRjJibTlrWlM1a1lYUmhJSHg4SUNGMmJtOWtaUzVrWVhSaExuUnlZVzV6YVhScGIyNHBYRzRnSUNBZ1B5QnNiMk5oZEdWT2IyUmxLSFp1YjJSbExtTnZiWEJ2Ym1WdWRFbHVjM1JoYm1ObExsOTJibTlrWlNsY2JpQWdJQ0E2SUhadWIyUmxYRzU5WEc1Y2JuWmhjaUJ6YUc5M0lEMGdlMXh1SUNCaWFXNWtPaUJtZFc1amRHbHZiaUJpYVc1a0lDaGxiQ3dnY21WbUxDQjJibTlrWlNrZ2UxeHVJQ0FnSUhaaGNpQjJZV3gxWlNBOUlISmxaaTUyWVd4MVpUdGNibHh1SUNBZ0lIWnViMlJsSUQwZ2JHOWpZWFJsVG05a1pTaDJibTlrWlNrN1hHNGdJQ0FnZG1GeUlIUnlZVzV6YVhScGIyNGdQU0IyYm05a1pTNWtZWFJoSUNZbUlIWnViMlJsTG1SaGRHRXVkSEpoYm5OcGRHbHZianRjYmlBZ0lDQjJZWElnYjNKcFoybHVZV3hFYVhOd2JHRjVJRDBnWld3dVgxOTJUM0pwWjJsdVlXeEVhWE53YkdGNUlEMWNiaUFnSUNBZ0lHVnNMbk4wZVd4bExtUnBjM0JzWVhrZ1BUMDlJQ2R1YjI1bEp5QS9JQ2NuSURvZ1pXd3VjM1I1YkdVdVpHbHpjR3hoZVR0Y2JpQWdJQ0JwWmlBb2RtRnNkV1VnSmlZZ2RISmhibk5wZEdsdmJpQW1KaUFoYVhOSlJUa3BJSHRjYmlBZ0lDQWdJSFp1YjJSbExtUmhkR0V1YzJodmR5QTlJSFJ5ZFdVN1hHNGdJQ0FnSUNCbGJuUmxjaWgyYm05a1pTd2dablZ1WTNScGIyNGdLQ2tnZTF4dUlDQWdJQ0FnSUNCbGJDNXpkSGxzWlM1a2FYTndiR0Y1SUQwZ2IzSnBaMmx1WVd4RWFYTndiR0Y1TzF4dUlDQWdJQ0FnZlNrN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJR1ZzTG5OMGVXeGxMbVJwYzNCc1lYa2dQU0IyWVd4MVpTQS9JRzl5YVdkcGJtRnNSR2x6Y0d4aGVTQTZJQ2R1YjI1bEp6dGNiaUFnSUNCOVhHNGdJSDBzWEc1Y2JpQWdkWEJrWVhSbE9pQm1kVzVqZEdsdmJpQjFjR1JoZEdVZ0tHVnNMQ0J5WldZc0lIWnViMlJsS1NCN1hHNGdJQ0FnZG1GeUlIWmhiSFZsSUQwZ2NtVm1MblpoYkhWbE8xeHVJQ0FnSUhaaGNpQnZiR1JXWVd4MVpTQTlJSEpsWmk1dmJHUldZV3gxWlR0Y2JseHVJQ0FnSUM4cUlHbHpkR0Z1WW5Wc0lHbG5ibTl5WlNCcFppQXFMMXh1SUNBZ0lHbG1JQ2gyWVd4MVpTQTlQVDBnYjJ4a1ZtRnNkV1VwSUhzZ2NtVjBkWEp1SUgxY2JpQWdJQ0IyYm05a1pTQTlJR3h2WTJGMFpVNXZaR1VvZG01dlpHVXBPMXh1SUNBZ0lIWmhjaUIwY21GdWMybDBhVzl1SUQwZ2RtNXZaR1V1WkdGMFlTQW1KaUIyYm05a1pTNWtZWFJoTG5SeVlXNXphWFJwYjI0N1hHNGdJQ0FnYVdZZ0tIUnlZVzV6YVhScGIyNGdKaVlnSVdselNVVTVLU0I3WEc0Z0lDQWdJQ0IyYm05a1pTNWtZWFJoTG5Ob2IzY2dQU0IwY25WbE8xeHVJQ0FnSUNBZ2FXWWdLSFpoYkhWbEtTQjdYRzRnSUNBZ0lDQWdJR1Z1ZEdWeUtIWnViMlJsTENCbWRXNWpkR2x2YmlBb0tTQjdYRzRnSUNBZ0lDQWdJQ0FnWld3dWMzUjViR1V1WkdsemNHeGhlU0E5SUdWc0xsOWZkazl5YVdkcGJtRnNSR2x6Y0d4aGVUdGNiaUFnSUNBZ0lDQWdmU2s3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0JzWldGMlpTaDJibTlrWlN3Z1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNBZ0lDQWdJQ0FnSUdWc0xuTjBlV3hsTG1ScGMzQnNZWGtnUFNBbmJtOXVaU2M3WEc0Z0lDQWdJQ0FnSUgwcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0JsYkM1emRIbHNaUzVrYVhOd2JHRjVJRDBnZG1Gc2RXVWdQeUJsYkM1ZlgzWlBjbWxuYVc1aGJFUnBjM0JzWVhrZ09pQW5ibTl1WlNjN1hHNGdJQ0FnZlZ4dUlDQjlMRnh1WEc0Z0lIVnVZbWx1WkRvZ1puVnVZM1JwYjI0Z2RXNWlhVzVrSUNoY2JpQWdJQ0JsYkN4Y2JpQWdJQ0JpYVc1a2FXNW5MRnh1SUNBZ0lIWnViMlJsTEZ4dUlDQWdJRzlzWkZadWIyUmxMRnh1SUNBZ0lHbHpSR1Z6ZEhKdmVWeHVJQ0FwSUh0Y2JpQWdJQ0JwWmlBb0lXbHpSR1Z6ZEhKdmVTa2dlMXh1SUNBZ0lDQWdaV3d1YzNSNWJHVXVaR2x6Y0d4aGVTQTlJR1ZzTGw5ZmRrOXlhV2RwYm1Gc1JHbHpjR3hoZVR0Y2JpQWdJQ0I5WEc0Z0lIMWNibjA3WEc1Y2JuWmhjaUJ3YkdGMFptOXliVVJwY21WamRHbDJaWE1nUFNCN1hHNGdJRzF2WkdWc09pQnRiMlJsYkNReExGeHVJQ0J6YUc5M09pQnphRzkzWEc1OU8xeHVYRzR2S2lBZ0tpOWNibHh1THk4Z1VISnZkbWxrWlhNZ2RISmhibk5wZEdsdmJpQnpkWEJ3YjNKMElHWnZjaUJoSUhOcGJtZHNaU0JsYkdWdFpXNTBMMk52YlhCdmJtVnVkQzVjYmk4dklITjFjSEJ2Y25SeklIUnlZVzV6YVhScGIyNGdiVzlrWlNBb2IzVjBMV2x1SUM4Z2FXNHRiM1YwS1Z4dVhHNTJZWElnZEhKaGJuTnBkR2x2YmxCeWIzQnpJRDBnZTF4dUlDQnVZVzFsT2lCVGRISnBibWNzWEc0Z0lHRndjR1ZoY2pvZ1FtOXZiR1ZoYml4Y2JpQWdZM056T2lCQ2IyOXNaV0Z1TEZ4dUlDQnRiMlJsT2lCVGRISnBibWNzWEc0Z0lIUjVjR1U2SUZOMGNtbHVaeXhjYmlBZ1pXNTBaWEpEYkdGemN6b2dVM1J5YVc1bkxGeHVJQ0JzWldGMlpVTnNZWE56T2lCVGRISnBibWNzWEc0Z0lHVnVkR1Z5Vkc5RGJHRnpjem9nVTNSeWFXNW5MRnh1SUNCc1pXRjJaVlJ2UTJ4aGMzTTZJRk4wY21sdVp5eGNiaUFnWlc1MFpYSkJZM1JwZG1WRGJHRnpjem9nVTNSeWFXNW5MRnh1SUNCc1pXRjJaVUZqZEdsMlpVTnNZWE56T2lCVGRISnBibWNzWEc0Z0lHRndjR1ZoY2tOc1lYTnpPaUJUZEhKcGJtY3NYRzRnSUdGd2NHVmhja0ZqZEdsMlpVTnNZWE56T2lCVGRISnBibWNzWEc0Z0lHRndjR1ZoY2xSdlEyeGhjM002SUZOMGNtbHVaeXhjYmlBZ1pIVnlZWFJwYjI0NklGdE9kVzFpWlhJc0lGTjBjbWx1Wnl3Z1QySnFaV04wWFZ4dWZUdGNibHh1THk4Z2FXNGdZMkZ6WlNCMGFHVWdZMmhwYkdRZ2FYTWdZV3h6YnlCaGJpQmhZbk4wY21GamRDQmpiMjF3YjI1bGJuUXNJR1V1Wnk0Z1BHdGxaWEF0WVd4cGRtVStYRzR2THlCM1pTQjNZVzUwSUhSdklISmxZM1Z5YzJsMlpXeDVJSEpsZEhKcFpYWmxJSFJvWlNCeVpXRnNJR052YlhCdmJtVnVkQ0IwYnlCaVpTQnlaVzVrWlhKbFpGeHVablZ1WTNScGIyNGdaMlYwVW1WaGJFTm9hV3hrSUNoMmJtOWtaU2tnZTF4dUlDQjJZWElnWTI5dGNFOXdkR2x2Ym5NZ1BTQjJibTlrWlNBbUppQjJibTlrWlM1amIyMXdiMjVsYm5SUGNIUnBiMjV6TzF4dUlDQnBaaUFvWTI5dGNFOXdkR2x2Ym5NZ0ppWWdZMjl0Y0U5d2RHbHZibk11UTNSdmNpNXZjSFJwYjI1ekxtRmljM1J5WVdOMEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUdkbGRGSmxZV3hEYUdsc1pDaG5aWFJHYVhKemRFTnZiWEJ2Ym1WdWRFTm9hV3hrS0dOdmJYQlBjSFJwYjI1ekxtTm9hV3hrY21WdUtTbGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQnlaWFIxY200Z2RtNXZaR1ZjYmlBZ2ZWeHVmVnh1WEc1bWRXNWpkR2x2YmlCbGVIUnlZV04wVkhKaGJuTnBkR2x2YmtSaGRHRWdLR052YlhBcElIdGNiaUFnZG1GeUlHUmhkR0VnUFNCN2ZUdGNiaUFnZG1GeUlHOXdkR2x2Ym5NZ1BTQmpiMjF3TGlSdmNIUnBiMjV6TzF4dUlDQXZMeUJ3Y205d2MxeHVJQ0JtYjNJZ0tIWmhjaUJyWlhrZ2FXNGdiM0IwYVc5dWN5NXdjbTl3YzBSaGRHRXBJSHRjYmlBZ0lDQmtZWFJoVzJ0bGVWMGdQU0JqYjIxd1cydGxlVjA3WEc0Z0lIMWNiaUFnTHk4Z1pYWmxiblJ6TGx4dUlDQXZMeUJsZUhSeVlXTjBJR3hwYzNSbGJtVnljeUJoYm1RZ2NHRnpjeUIwYUdWdElHUnBjbVZqZEd4NUlIUnZJSFJvWlNCMGNtRnVjMmwwYVc5dUlHMWxkR2h2WkhOY2JpQWdkbUZ5SUd4cGMzUmxibVZ5Y3lBOUlHOXdkR2x2Ym5NdVgzQmhjbVZ1ZEV4cGMzUmxibVZ5Y3p0Y2JpQWdabTl5SUNoMllYSWdhMlY1SkRFZ2FXNGdiR2x6ZEdWdVpYSnpLU0I3WEc0Z0lDQWdaR0YwWVZ0allXMWxiR2w2WlNoclpYa2tNU2xkSUQwZ2JHbHpkR1Z1WlhKelcydGxlU1F4WFR0Y2JpQWdmVnh1SUNCeVpYUjFjbTRnWkdGMFlWeHVmVnh1WEc1bWRXNWpkR2x2YmlCd2JHRmpaV2h2YkdSbGNpQW9hQ3dnY21GM1EyaHBiR1FwSUh0Y2JpQWdjbVYwZFhKdUlDOWNYR1F0YTJWbGNDMWhiR2wyWlNRdkxuUmxjM1FvY21GM1EyaHBiR1F1ZEdGbktWeHVJQ0FnSUQ4Z2FDZ25hMlZsY0MxaGJHbDJaU2NwWEc0Z0lDQWdPaUJ1ZFd4c1hHNTlYRzVjYm1aMWJtTjBhVzl1SUdoaGMxQmhjbVZ1ZEZSeVlXNXphWFJwYjI0Z0tIWnViMlJsS1NCN1hHNGdJSGRvYVd4bElDZ29kbTV2WkdVZ1BTQjJibTlrWlM1d1lYSmxiblFwS1NCN1hHNGdJQ0FnYVdZZ0tIWnViMlJsTG1SaGRHRXVkSEpoYm5OcGRHbHZiaWtnZTF4dUlDQWdJQ0FnY21WMGRYSnVJSFJ5ZFdWY2JpQWdJQ0I5WEc0Z0lIMWNibjFjYmx4dVpuVnVZM1JwYjI0Z2FYTlRZVzFsUTJocGJHUWdLR05vYVd4a0xDQnZiR1JEYUdsc1pDa2dlMXh1SUNCeVpYUjFjbTRnYjJ4a1EyaHBiR1F1YTJWNUlEMDlQU0JqYUdsc1pDNXJaWGtnSmlZZ2IyeGtRMmhwYkdRdWRHRm5JRDA5UFNCamFHbHNaQzUwWVdkY2JuMWNibHh1ZG1GeUlGUnlZVzV6YVhScGIyNGdQU0I3WEc0Z0lHNWhiV1U2SUNkMGNtRnVjMmwwYVc5dUp5eGNiaUFnY0hKdmNITTZJSFJ5WVc1emFYUnBiMjVRY205d2N5eGNiaUFnWVdKemRISmhZM1E2SUhSeWRXVXNYRzVjYmlBZ2NtVnVaR1Z5T2lCbWRXNWpkR2x2YmlCeVpXNWtaWElnS0dncElIdGNiaUFnSUNCMllYSWdkR2hwY3lReElEMGdkR2hwY3p0Y2JseHVJQ0FnSUhaaGNpQmphR2xzWkhKbGJpQTlJSFJvYVhNdUpITnNiM1J6TG1SbFptRjFiSFE3WEc0Z0lDQWdhV1lnS0NGamFHbHNaSEpsYmlrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnWm1sc2RHVnlJRzkxZENCMFpYaDBJRzV2WkdWeklDaHdiM056YVdKc1pTQjNhR2wwWlhOd1lXTmxjeWxjYmlBZ0lDQmphR2xzWkhKbGJpQTlJR05vYVd4a2NtVnVMbVpwYkhSbGNpaG1kVzVqZEdsdmJpQW9ZeWtnZXlCeVpYUjFjbTRnWXk1MFlXYzdJSDBwTzF4dUlDQWdJQzhxSUdsemRHRnVZblZzSUdsbmJtOXlaU0JwWmlBcUwxeHVJQ0FnSUdsbUlDZ2hZMmhwYkdSeVpXNHViR1Z1WjNSb0tTQjdYRzRnSUNBZ0lDQnlaWFIxY201Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCM1lYSnVJRzExYkhScGNHeGxJR1ZzWlcxbGJuUnpYRzRnSUNBZ2FXWWdLSEJ5YjJObGMzTXVaVzUyTGs1UFJFVmZSVTVXSUNFOVBTQW5jSEp2WkhWamRHbHZiaWNnSmlZZ1kyaHBiR1J5Wlc0dWJHVnVaM1JvSUQ0Z01Ta2dlMXh1SUNBZ0lDQWdkMkZ5YmloY2JpQWdJQ0FnSUNBZ0p6eDBjbUZ1YzJsMGFXOXVQaUJqWVc0Z2IyNXNlU0JpWlNCMWMyVmtJRzl1SUdFZ2MybHVaMnhsSUdWc1pXMWxiblF1SUZWelpTQW5JQ3RjYmlBZ0lDQWdJQ0FnSnp4MGNtRnVjMmwwYVc5dUxXZHliM1Z3UGlCbWIzSWdiR2x6ZEhNdUp5eGNiaUFnSUNBZ0lDQWdkR2hwY3k0a2NHRnlaVzUwWEc0Z0lDQWdJQ0FwTzF4dUlDQWdJSDFjYmx4dUlDQWdJSFpoY2lCdGIyUmxJRDBnZEdocGN5NXRiMlJsTzF4dVhHNGdJQ0FnTHk4Z2QyRnliaUJwYm5aaGJHbGtJRzF2WkdWY2JpQWdJQ0JwWmlBb2NISnZZMlZ6Y3k1bGJuWXVUazlFUlY5RlRsWWdJVDA5SUNkd2NtOWtkV04wYVc5dUp5QW1KbHh1SUNBZ0lDQWdJQ0J0YjJSbElDWW1JRzF2WkdVZ0lUMDlJQ2RwYmkxdmRYUW5JQ1ltSUcxdlpHVWdJVDA5SUNkdmRYUXRhVzRuS1NCN1hHNGdJQ0FnSUNCM1lYSnVLRnh1SUNBZ0lDQWdJQ0FuYVc1MllXeHBaQ0E4ZEhKaGJuTnBkR2x2Ymo0Z2JXOWtaVG9nSnlBcklHMXZaR1VzWEc0Z0lDQWdJQ0FnSUhSb2FYTXVKSEJoY21WdWRGeHVJQ0FnSUNBZ0tUdGNiaUFnSUNCOVhHNWNiaUFnSUNCMllYSWdjbUYzUTJocGJHUWdQU0JqYUdsc1pISmxibHN3WFR0Y2JseHVJQ0FnSUM4dklHbG1JSFJvYVhNZ2FYTWdZU0JqYjIxd2IyNWxiblFnY205dmRDQnViMlJsSUdGdVpDQjBhR1VnWTI5dGNHOXVaVzUwSjNOY2JpQWdJQ0F2THlCd1lYSmxiblFnWTI5dWRHRnBibVZ5SUc1dlpHVWdZV3h6YnlCb1lYTWdkSEpoYm5OcGRHbHZiaXdnYzJ0cGNDNWNiaUFnSUNCcFppQW9hR0Z6VUdGeVpXNTBWSEpoYm5OcGRHbHZiaWgwYUdsekxpUjJibTlrWlNrcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCeVlYZERhR2xzWkZ4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUdGd2NHeDVJSFJ5WVc1emFYUnBiMjRnWkdGMFlTQjBieUJqYUdsc1pGeHVJQ0FnSUM4dklIVnpaU0JuWlhSU1pXRnNRMmhwYkdRb0tTQjBieUJwWjI1dmNtVWdZV0p6ZEhKaFkzUWdZMjl0Y0c5dVpXNTBjeUJsTG1jdUlHdGxaWEF0WVd4cGRtVmNiaUFnSUNCMllYSWdZMmhwYkdRZ1BTQm5aWFJTWldGc1EyaHBiR1FvY21GM1EyaHBiR1FwTzF4dUlDQWdJQzhxSUdsemRHRnVZblZzSUdsbmJtOXlaU0JwWmlBcUwxeHVJQ0FnSUdsbUlDZ2hZMmhwYkdRcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCeVlYZERhR2xzWkZ4dUlDQWdJSDFjYmx4dUlDQWdJR2xtSUNoMGFHbHpMbDlzWldGMmFXNW5LU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdjR3hoWTJWb2IyeGtaWElvYUN3Z2NtRjNRMmhwYkdRcFhHNGdJQ0FnZlZ4dVhHNGdJQ0FnTHk4Z1pXNXpkWEpsSUdFZ2EyVjVJSFJvWVhRZ2FYTWdkVzVwY1hWbElIUnZJSFJvWlNCMmJtOWtaU0IwZVhCbElHRnVaQ0IwYnlCMGFHbHpJSFJ5WVc1emFYUnBiMjVjYmlBZ0lDQXZMeUJqYjIxd2IyNWxiblFnYVc1emRHRnVZMlV1SUZSb2FYTWdhMlY1SUhkcGJHd2dZbVVnZFhObFpDQjBieUJ5WlcxdmRtVWdjR1Z1WkdsdVp5QnNaV0YyYVc1bklHNXZaR1Z6WEc0Z0lDQWdMeThnWkhWeWFXNW5JR1Z1ZEdWeWFXNW5MbHh1SUNBZ0lIWmhjaUJwWkNBOUlGd2lYMTkwY21GdWMybDBhVzl1TFZ3aUlDc2dLSFJvYVhNdVgzVnBaQ2tnS3lCY0lpMWNJanRjYmlBZ0lDQmphR2xzWkM1clpYa2dQU0JqYUdsc1pDNXJaWGtnUFQwZ2JuVnNiRnh1SUNBZ0lDQWdQeUJwWkNBcklHTm9hV3hrTG5SaFoxeHVJQ0FnSUNBZ09pQnBjMUJ5YVcxcGRHbDJaU2hqYUdsc1pDNXJaWGtwWEc0Z0lDQWdJQ0FnSUQ4Z0tGTjBjbWx1WnloamFHbHNaQzVyWlhrcExtbHVaR1Y0VDJZb2FXUXBJRDA5UFNBd0lEOGdZMmhwYkdRdWEyVjVJRG9nYVdRZ0t5QmphR2xzWkM1clpYa3BYRzRnSUNBZ0lDQWdJRG9nWTJocGJHUXVhMlY1TzF4dVhHNGdJQ0FnZG1GeUlHUmhkR0VnUFNBb1kyaHBiR1F1WkdGMFlTQjhmQ0FvWTJocGJHUXVaR0YwWVNBOUlIdDlLU2t1ZEhKaGJuTnBkR2x2YmlBOUlHVjRkSEpoWTNSVWNtRnVjMmwwYVc5dVJHRjBZU2gwYUdsektUdGNiaUFnSUNCMllYSWdiMnhrVW1GM1EyaHBiR1FnUFNCMGFHbHpMbDkyYm05a1pUdGNiaUFnSUNCMllYSWdiMnhrUTJocGJHUWdQU0JuWlhSU1pXRnNRMmhwYkdRb2IyeGtVbUYzUTJocGJHUXBPMXh1WEc0Z0lDQWdMeThnYldGeWF5QjJMWE5vYjNkY2JpQWdJQ0F2THlCemJ5QjBhR0YwSUhSb1pTQjBjbUZ1YzJsMGFXOXVJRzF2WkhWc1pTQmpZVzRnYUdGdVpDQnZkbVZ5SUhSb1pTQmpiMjUwY205c0lIUnZJSFJvWlNCa2FYSmxZM1JwZG1WY2JpQWdJQ0JwWmlBb1kyaHBiR1F1WkdGMFlTNWthWEpsWTNScGRtVnpJQ1ltSUdOb2FXeGtMbVJoZEdFdVpHbHlaV04wYVhabGN5NXpiMjFsS0daMWJtTjBhVzl1SUNoa0tTQjdJSEpsZEhWeWJpQmtMbTVoYldVZ1BUMDlJQ2R6YUc5M0p6c2dmU2twSUh0Y2JpQWdJQ0FnSUdOb2FXeGtMbVJoZEdFdWMyaHZkeUE5SUhSeWRXVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLRzlzWkVOb2FXeGtJQ1ltSUc5c1pFTm9hV3hrTG1SaGRHRWdKaVlnSVdselUyRnRaVU5vYVd4a0tHTm9hV3hrTENCdmJHUkRhR2xzWkNrcElIdGNiaUFnSUNBZ0lDOHZJSEpsY0d4aFkyVWdiMnhrSUdOb2FXeGtJSFJ5WVc1emFYUnBiMjRnWkdGMFlTQjNhWFJvSUdaeVpYTm9JRzl1WlZ4dUlDQWdJQ0FnTHk4Z2FXMXdiM0owWVc1MElHWnZjaUJrZVc1aGJXbGpJSFJ5WVc1emFYUnBiMjV6SVZ4dUlDQWdJQ0FnZG1GeUlHOXNaRVJoZEdFZ1BTQnZiR1JEYUdsc1pDQW1KaUFvYjJ4a1EyaHBiR1F1WkdGMFlTNTBjbUZ1YzJsMGFXOXVJRDBnWlhoMFpXNWtLSHQ5TENCa1lYUmhLU2s3WEc0Z0lDQWdJQ0F2THlCb1lXNWtiR1VnZEhKaGJuTnBkR2x2YmlCdGIyUmxYRzRnSUNBZ0lDQnBaaUFvYlc5a1pTQTlQVDBnSjI5MWRDMXBiaWNwSUh0Y2JpQWdJQ0FnSUNBZ0x5OGdjbVYwZFhKdUlIQnNZV05sYUc5c1pHVnlJRzV2WkdVZ1lXNWtJSEYxWlhWbElIVndaR0YwWlNCM2FHVnVJR3hsWVhabElHWnBibWx6YUdWelhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJ4bFlYWnBibWNnUFNCMGNuVmxPMXh1SUNBZ0lDQWdJQ0J0WlhKblpWWk9iMlJsU0c5dmF5aHZiR1JFWVhSaExDQW5ZV1owWlhKTVpXRjJaU2NzSUdaMWJtTjBhVzl1SUNncElIdGNiaUFnSUNBZ0lDQWdJQ0IwYUdsekpERXVYMnhsWVhacGJtY2dQU0JtWVd4elpUdGNiaUFnSUNBZ0lDQWdJQ0IwYUdsekpERXVKR1p2Y21ObFZYQmtZWFJsS0NrN1hHNGdJQ0FnSUNBZ0lIMHBPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdjR3hoWTJWb2IyeGtaWElvYUN3Z2NtRjNRMmhwYkdRcFhHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tHMXZaR1VnUFQwOUlDZHBiaTF2ZFhRbktTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCa1pXeGhlV1ZrVEdWaGRtVTdYRzRnSUNBZ0lDQWdJSFpoY2lCd1pYSm1iM0p0VEdWaGRtVWdQU0JtZFc1amRHbHZiaUFvS1NCN0lHUmxiR0Y1WldSTVpXRjJaU2dwT3lCOU8xeHVJQ0FnSUNBZ0lDQnRaWEpuWlZaT2IyUmxTRzl2YXloa1lYUmhMQ0FuWVdaMFpYSkZiblJsY2ljc0lIQmxjbVp2Y20xTVpXRjJaU2s3WEc0Z0lDQWdJQ0FnSUcxbGNtZGxWazV2WkdWSWIyOXJLR1JoZEdFc0lDZGxiblJsY2tOaGJtTmxiR3hsWkNjc0lIQmxjbVp2Y20xTVpXRjJaU2s3WEc0Z0lDQWdJQ0FnSUcxbGNtZGxWazV2WkdWSWIyOXJLRzlzWkVSaGRHRXNJQ2RrWld4aGVVeGxZWFpsSnl3Z1puVnVZM1JwYjI0Z0tHeGxZWFpsS1NCN0lHUmxiR0Y1WldSTVpXRjJaU0E5SUd4bFlYWmxPeUI5S1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0J5WlhSMWNtNGdjbUYzUTJocGJHUmNiaUFnZlZ4dWZUdGNibHh1THlvZ0lDb3ZYRzVjYmk4dklGQnliM1pwWkdWeklIUnlZVzV6YVhScGIyNGdjM1Z3Y0c5eWRDQm1iM0lnYkdsemRDQnBkR1Z0Y3k1Y2JpOHZJSE4xY0hCdmNuUnpJRzF2ZG1VZ2RISmhibk5wZEdsdmJuTWdkWE5wYm1jZ2RHaGxJRVpNU1ZBZ2RHVmphRzVwY1hWbExseHVYRzR2THlCQ1pXTmhkWE5sSUhSb1pTQjJaRzl0SjNNZ1kyaHBiR1J5Wlc0Z2RYQmtZWFJsSUdGc1oyOXlhWFJvYlNCcGN5QmNJblZ1YzNSaFlteGxYQ0lnTFNCcExtVXVYRzR2THlCcGRDQmtiMlZ6YmlkMElHZDFZWEpoYm5SbFpTQjBhR1VnY21Wc1lYUnBkbVVnY0c5emFYUnBiMjVwYm1jZ2IyWWdjbVZ0YjNabFpDQmxiR1Z0Wlc1MGN5eGNiaTh2SUhkbElHWnZjbU5sSUhSeVlXNXphWFJwYjI0dFozSnZkWEFnZEc4Z2RYQmtZWFJsSUdsMGN5QmphR2xzWkhKbGJpQnBiblJ2SUhSM2J5QndZWE56WlhNNlhHNHZMeUJwYmlCMGFHVWdabWx5YzNRZ2NHRnpjeXdnZDJVZ2NtVnRiM1psSUdGc2JDQnViMlJsY3lCMGFHRjBJRzVsWldRZ2RHOGdZbVVnY21WdGIzWmxaQ3hjYmk4dklIUnlhV2RuWlhKcGJtY2dkR2hsYVhJZ2JHVmhkbWx1WnlCMGNtRnVjMmwwYVc5dU95QnBiaUIwYUdVZ2MyVmpiMjVrSUhCaGMzTXNJSGRsSUdsdWMyVnlkQzl0YjNabFhHNHZMeUJwYm5SdklIUm9aU0JtYVc1aGJDQmtaWE5wY21Wa0lITjBZWFJsTGlCVWFHbHpJSGRoZVNCcGJpQjBhR1VnYzJWamIyNWtJSEJoYzNNZ2NtVnRiM1psWkZ4dUx5OGdibTlrWlhNZ2QybHNiQ0J5WlcxaGFXNGdkMmhsY21VZ2RHaGxlU0J6YUc5MWJHUWdZbVV1WEc1Y2JuWmhjaUJ3Y205d2N5QTlJR1Y0ZEdWdVpDaDdYRzRnSUhSaFp6b2dVM1J5YVc1bkxGeHVJQ0J0YjNabFEyeGhjM002SUZOMGNtbHVaMXh1ZlN3Z2RISmhibk5wZEdsdmJsQnliM0J6S1R0Y2JseHVaR1ZzWlhSbElIQnliM0J6TG0xdlpHVTdYRzVjYm5aaGNpQlVjbUZ1YzJsMGFXOXVSM0p2ZFhBZ1BTQjdYRzRnSUhCeWIzQnpPaUJ3Y205d2N5eGNibHh1SUNCeVpXNWtaWEk2SUdaMWJtTjBhVzl1SUhKbGJtUmxjaUFvYUNrZ2UxeHVJQ0FnSUhaaGNpQjBZV2NnUFNCMGFHbHpMblJoWnlCOGZDQjBhR2x6TGlSMmJtOWtaUzVrWVhSaExuUmhaeUI4ZkNBbmMzQmhiaWM3WEc0Z0lDQWdkbUZ5SUcxaGNDQTlJRTlpYW1WamRDNWpjbVZoZEdVb2JuVnNiQ2s3WEc0Z0lDQWdkbUZ5SUhCeVpYWkRhR2xzWkhKbGJpQTlJSFJvYVhNdWNISmxka05vYVd4a2NtVnVJRDBnZEdocGN5NWphR2xzWkhKbGJqdGNiaUFnSUNCMllYSWdjbUYzUTJocGJHUnlaVzRnUFNCMGFHbHpMaVJ6Ykc5MGN5NWtaV1poZFd4MElIeDhJRnRkTzF4dUlDQWdJSFpoY2lCamFHbHNaSEpsYmlBOUlIUm9hWE11WTJocGJHUnlaVzRnUFNCYlhUdGNiaUFnSUNCMllYSWdkSEpoYm5OcGRHbHZia1JoZEdFZ1BTQmxlSFJ5WVdOMFZISmhibk5wZEdsdmJrUmhkR0VvZEdocGN5azdYRzVjYmlBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJSEpoZDBOb2FXeGtjbVZ1TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQjJZWElnWXlBOUlISmhkME5vYVd4a2NtVnVXMmxkTzF4dUlDQWdJQ0FnYVdZZ0tHTXVkR0ZuS1NCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hqTG10bGVTQWhQU0J1ZFd4c0lDWW1JRk4wY21sdVp5aGpMbXRsZVNrdWFXNWtaWGhQWmlnblgxOTJiR2x6ZENjcElDRTlQU0F3S1NCN1hHNGdJQ0FnSUNBZ0lDQWdZMmhwYkdSeVpXNHVjSFZ6YUNoaktUdGNiaUFnSUNBZ0lDQWdJQ0J0WVhCYll5NXJaWGxkSUQwZ1kxeHVJQ0FnSUNBZ0lDQWdJRHNvWXk1a1lYUmhJSHg4SUNoakxtUmhkR0VnUFNCN2ZTa3BMblJ5WVc1emFYUnBiMjRnUFNCMGNtRnVjMmwwYVc5dVJHRjBZVHRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNod2NtOWpaWE56TG1WdWRpNU9UMFJGWDBWT1ZpQWhQVDBnSjNCeWIyUjFZM1JwYjI0bktTQjdYRzRnSUNBZ0lDQWdJQ0FnZG1GeUlHOXdkSE1nUFNCakxtTnZiWEJ2Ym1WdWRFOXdkR2x2Ym5NN1hHNGdJQ0FnSUNBZ0lDQWdkbUZ5SUc1aGJXVWdQU0J2Y0hSeklEOGdLRzl3ZEhNdVEzUnZjaTV2Y0hScGIyNXpMbTVoYldVZ2ZId2diM0IwY3k1MFlXY2dmSHdnSnljcElEb2dZeTUwWVdjN1hHNGdJQ0FnSUNBZ0lDQWdkMkZ5Ymlnb1hDSThkSEpoYm5OcGRHbHZiaTFuY205MWNENGdZMmhwYkdSeVpXNGdiWFZ6ZENCaVpTQnJaWGxsWkRvZ1BGd2lJQ3NnYm1GdFpTQXJJRndpUGx3aUtTazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQnBaaUFvY0hKbGRrTm9hV3hrY21WdUtTQjdYRzRnSUNBZ0lDQjJZWElnYTJWd2RDQTlJRnRkTzF4dUlDQWdJQ0FnZG1GeUlISmxiVzkyWldRZ1BTQmJYVHRjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJR2trTVNBOUlEQTdJR2trTVNBOElIQnlaWFpEYUdsc1pISmxiaTVzWlc1bmRHZzdJR2trTVNzcktTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCakpERWdQU0J3Y21WMlEyaHBiR1J5Wlc1YmFTUXhYVHRjYmlBZ0lDQWdJQ0FnWXlReExtUmhkR0V1ZEhKaGJuTnBkR2x2YmlBOUlIUnlZVzV6YVhScGIyNUVZWFJoTzF4dUlDQWdJQ0FnSUNCakpERXVaR0YwWVM1d2IzTWdQU0JqSkRFdVpXeHRMbWRsZEVKdmRXNWthVzVuUTJ4cFpXNTBVbVZqZENncE8xeHVJQ0FnSUNBZ0lDQnBaaUFvYldGd1cyTWtNUzVyWlhsZEtTQjdYRzRnSUNBZ0lDQWdJQ0FnYTJWd2RDNXdkWE5vS0dNa01TazdYRzRnSUNBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQ0FnY21WdGIzWmxaQzV3ZFhOb0tHTWtNU2s3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUhSb2FYTXVhMlZ3ZENBOUlHZ29kR0ZuTENCdWRXeHNMQ0JyWlhCMEtUdGNiaUFnSUNBZ0lIUm9hWE11Y21WdGIzWmxaQ0E5SUhKbGJXOTJaV1E3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjbVYwZFhKdUlHZ29kR0ZuTENCdWRXeHNMQ0JqYUdsc1pISmxiaWxjYmlBZ2ZTeGNibHh1SUNCaVpXWnZjbVZWY0dSaGRHVTZJR1oxYm1OMGFXOXVJR0psWm05eVpWVndaR0YwWlNBb0tTQjdYRzRnSUNBZ0x5OGdabTl5WTJVZ2NtVnRiM1pwYm1jZ2NHRnpjMXh1SUNBZ0lIUm9hWE11WDE5d1lYUmphRjlmS0Z4dUlDQWdJQ0FnZEdocGN5NWZkbTV2WkdVc1hHNGdJQ0FnSUNCMGFHbHpMbXRsY0hRc1hHNGdJQ0FnSUNCbVlXeHpaU3dnTHk4Z2FIbGtjbUYwYVc1blhHNGdJQ0FnSUNCMGNuVmxJQzh2SUhKbGJXOTJaVTl1YkhrZ0tDRnBiWEJ2Y25SaGJuUXNJR0YyYjJsa2N5QjFibTVsWTJWemMyRnllU0J0YjNabGN5bGNiaUFnSUNBcE8xeHVJQ0FnSUhSb2FYTXVYM1p1YjJSbElEMGdkR2hwY3k1clpYQjBPMXh1SUNCOUxGeHVYRzRnSUhWd1pHRjBaV1E2SUdaMWJtTjBhVzl1SUhWd1pHRjBaV1FnS0NrZ2UxeHVJQ0FnSUhaaGNpQmphR2xzWkhKbGJpQTlJSFJvYVhNdWNISmxka05vYVd4a2NtVnVPMXh1SUNBZ0lIWmhjaUJ0YjNabFEyeGhjM01nUFNCMGFHbHpMbTF2ZG1WRGJHRnpjeUI4ZkNBb0tIUm9hWE11Ym1GdFpTQjhmQ0FuZGljcElDc2dKeTF0YjNabEp5azdYRzRnSUNBZ2FXWWdLQ0ZqYUdsc1pISmxiaTVzWlc1bmRHZ2dmSHdnSVhSb2FYTXVhR0Z6VFc5MlpTaGphR2xzWkhKbGJsc3dYUzVsYkcwc0lHMXZkbVZEYkdGemN5a3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJseHVJQ0FnSUgxY2JseHVJQ0FnSUM4dklIZGxJR1JwZG1sa1pTQjBhR1VnZDI5eWF5QnBiblJ2SUhSb2NtVmxJR3h2YjNCeklIUnZJR0YyYjJsa0lHMXBlR2x1WnlCRVQwMGdjbVZoWkhNZ1lXNWtJSGR5YVhSbGMxeHVJQ0FnSUM4dklHbHVJR1ZoWTJnZ2FYUmxjbUYwYVc5dUlDMGdkMmhwWTJnZ2FHVnNjSE1nY0hKbGRtVnVkQ0JzWVhsdmRYUWdkR2h5WVhOb2FXNW5MbHh1SUNBZ0lHTm9hV3hrY21WdUxtWnZja1ZoWTJnb1kyRnNiRkJsYm1ScGJtZERZbk1wTzF4dUlDQWdJR05vYVd4a2NtVnVMbVp2Y2tWaFkyZ29jbVZqYjNKa1VHOXphWFJwYjI0cE8xeHVJQ0FnSUdOb2FXeGtjbVZ1TG1admNrVmhZMmdvWVhCd2JIbFVjbUZ1YzJ4aGRHbHZiaWs3WEc1Y2JpQWdJQ0F2THlCbWIzSmpaU0J5Wldac2IzY2dkRzhnY0hWMElHVjJaWEo1ZEdocGJtY2dhVzRnY0c5emFYUnBiMjVjYmlBZ0lDQjJZWElnWW05a2VTQTlJR1J2WTNWdFpXNTBMbUp2WkhrN1hHNGdJQ0FnZG1GeUlHWWdQU0JpYjJSNUxtOW1abk5sZEVobGFXZG9kRHNnTHk4Z1pYTnNhVzUwTFdScGMyRmliR1V0YkdsdVpWeHVYRzRnSUNBZ1kyaHBiR1J5Wlc0dVptOXlSV0ZqYUNobWRXNWpkR2x2YmlBb1l5a2dlMXh1SUNBZ0lDQWdhV1lnS0dNdVpHRjBZUzV0YjNabFpDa2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ1pXd2dQU0JqTG1Wc2JUdGNiaUFnSUNBZ0lDQWdkbUZ5SUhNZ1BTQmxiQzV6ZEhsc1pUdGNiaUFnSUNBZ0lDQWdZV1JrVkhKaGJuTnBkR2x2YmtOc1lYTnpLR1ZzTENCdGIzWmxRMnhoYzNNcE8xeHVJQ0FnSUNBZ0lDQnpMblJ5WVc1elptOXliU0E5SUhNdVYyVmlhMmwwVkhKaGJuTm1iM0p0SUQwZ2N5NTBjbUZ1YzJsMGFXOXVSSFZ5WVhScGIyNGdQU0FuSnp0Y2JpQWdJQ0FnSUNBZ1pXd3VZV1JrUlhabGJuUk1hWE4wWlc1bGNpaDBjbUZ1YzJsMGFXOXVSVzVrUlhabGJuUXNJR1ZzTGw5dGIzWmxRMklnUFNCbWRXNWpkR2x2YmlCallpQW9aU2tnZTF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2doWlNCOGZDQXZkSEpoYm5ObWIzSnRKQzh1ZEdWemRDaGxMbkJ5YjNCbGNuUjVUbUZ0WlNrcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdWc0xuSmxiVzkyWlVWMlpXNTBUR2x6ZEdWdVpYSW9kSEpoYm5OcGRHbHZia1Z1WkVWMlpXNTBMQ0JqWWlrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JsYkM1ZmJXOTJaVU5pSUQwZ2JuVnNiRHRjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxiVzkyWlZSeVlXNXphWFJwYjI1RGJHRnpjeWhsYkN3Z2JXOTJaVU5zWVhOektUdGNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUgwcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgwcE8xeHVJQ0I5TEZ4dVhHNGdJRzFsZEdodlpITTZJSHRjYmlBZ0lDQm9ZWE5OYjNabE9pQm1kVzVqZEdsdmJpQm9ZWE5OYjNabElDaGxiQ3dnYlc5MlpVTnNZWE56S1NCN1hHNGdJQ0FnSUNBdktpQnBjM1JoYm1KMWJDQnBaMjV2Y21VZ2FXWWdLaTljYmlBZ0lDQWdJR2xtSUNnaGFHRnpWSEpoYm5OcGRHbHZiaWtnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnWm1Gc2MyVmNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lHbG1JQ2gwYUdsekxsOW9ZWE5OYjNabElDRTlJRzUxYkd3cElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11WDJoaGMwMXZkbVZjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJQzh2SUVSbGRHVmpkQ0IzYUdWMGFHVnlJR0Z1SUdWc1pXMWxiblFnZDJsMGFDQjBhR1VnYlc5MlpTQmpiR0Z6Y3lCaGNIQnNhV1ZrSUdoaGMxeHVJQ0FnSUNBZ0x5OGdRMU5USUhSeVlXNXphWFJwYjI1ekxpQlRhVzVqWlNCMGFHVWdaV3hsYldWdWRDQnRZWGtnWW1VZ2FXNXphV1JsSUdGdUlHVnVkR1Z5YVc1blhHNGdJQ0FnSUNBdkx5QjBjbUZ1YzJsMGFXOXVJR0YwSUhSb2FYTWdkbVZ5ZVNCdGIyMWxiblFzSUhkbElHMWhhMlVnWVNCamJHOXVaU0J2WmlCcGRDQmhibVFnY21WdGIzWmxYRzRnSUNBZ0lDQXZMeUJoYkd3Z2IzUm9aWElnZEhKaGJuTnBkR2x2YmlCamJHRnpjMlZ6SUdGd2NHeHBaV1FnZEc4Z1pXNXpkWEpsSUc5dWJIa2dkR2hsSUcxdmRtVWdZMnhoYzNOY2JpQWdJQ0FnSUM4dklHbHpJR0Z3Y0d4cFpXUXVYRzRnSUNBZ0lDQjJZWElnWTJ4dmJtVWdQU0JsYkM1amJHOXVaVTV2WkdVb0tUdGNiaUFnSUNBZ0lHbG1JQ2hsYkM1ZmRISmhibk5wZEdsdmJrTnNZWE56WlhNcElIdGNiaUFnSUNBZ0lDQWdaV3d1WDNSeVlXNXphWFJwYjI1RGJHRnpjMlZ6TG1admNrVmhZMmdvWm5WdVkzUnBiMjRnS0dOc2N5a2dleUJ5WlcxdmRtVkRiR0Z6Y3loamJHOXVaU3dnWTJ4ektUc2dmU2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0JoWkdSRGJHRnpjeWhqYkc5dVpTd2diVzkyWlVOc1lYTnpLVHRjYmlBZ0lDQWdJR05zYjI1bExuTjBlV3hsTG1ScGMzQnNZWGtnUFNBbmJtOXVaU2M3WEc0Z0lDQWdJQ0IwYUdsekxpUmxiQzVoY0hCbGJtUkRhR2xzWkNoamJHOXVaU2s3WEc0Z0lDQWdJQ0IyWVhJZ2FXNW1ieUE5SUdkbGRGUnlZVzV6YVhScGIyNUpibVp2S0dOc2IyNWxLVHRjYmlBZ0lDQWdJSFJvYVhNdUpHVnNMbkpsYlc5MlpVTm9hV3hrS0dOc2IyNWxLVHRjYmlBZ0lDQWdJSEpsZEhWeWJpQW9kR2hwY3k1ZmFHRnpUVzkyWlNBOUlHbHVabTh1YUdGelZISmhibk5tYjNKdEtWeHVJQ0FnSUgxY2JpQWdmVnh1ZlR0Y2JseHVablZ1WTNScGIyNGdZMkZzYkZCbGJtUnBibWREWW5NZ0tHTXBJSHRjYmlBZ0x5b2dhWE4wWVc1aWRXd2dhV2R1YjNKbElHbG1JQ292WEc0Z0lHbG1JQ2hqTG1Wc2JTNWZiVzkyWlVOaUtTQjdYRzRnSUNBZ1l5NWxiRzB1WDIxdmRtVkRZaWdwTzF4dUlDQjlYRzRnSUM4cUlHbHpkR0Z1WW5Wc0lHbG5ibTl5WlNCcFppQXFMMXh1SUNCcFppQW9ZeTVsYkcwdVgyVnVkR1Z5UTJJcElIdGNiaUFnSUNCakxtVnNiUzVmWlc1MFpYSkRZaWdwTzF4dUlDQjlYRzU5WEc1Y2JtWjFibU4wYVc5dUlISmxZMjl5WkZCdmMybDBhVzl1SUNoaktTQjdYRzRnSUdNdVpHRjBZUzV1WlhkUWIzTWdQU0JqTG1Wc2JTNW5aWFJDYjNWdVpHbHVaME5zYVdWdWRGSmxZM1FvS1R0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnWVhCd2JIbFVjbUZ1YzJ4aGRHbHZiaUFvWXlrZ2UxeHVJQ0IyWVhJZ2IyeGtVRzl6SUQwZ1l5NWtZWFJoTG5CdmN6dGNiaUFnZG1GeUlHNWxkMUJ2Y3lBOUlHTXVaR0YwWVM1dVpYZFFiM003WEc0Z0lIWmhjaUJrZUNBOUlHOXNaRkJ2Y3k1c1pXWjBJQzBnYm1WM1VHOXpMbXhsWm5RN1hHNGdJSFpoY2lCa2VTQTlJRzlzWkZCdmN5NTBiM0FnTFNCdVpYZFFiM011ZEc5d08xeHVJQ0JwWmlBb1pIZ2dmSHdnWkhrcElIdGNiaUFnSUNCakxtUmhkR0V1Ylc5MlpXUWdQU0IwY25WbE8xeHVJQ0FnSUhaaGNpQnpJRDBnWXk1bGJHMHVjM1I1YkdVN1hHNGdJQ0FnY3k1MGNtRnVjMlp2Y20wZ1BTQnpMbGRsWW10cGRGUnlZVzV6Wm05eWJTQTlJRndpZEhKaGJuTnNZWFJsS0Z3aUlDc2daSGdnS3lCY0luQjRMRndpSUNzZ1pIa2dLeUJjSW5CNEtWd2lPMXh1SUNBZ0lITXVkSEpoYm5OcGRHbHZia1IxY21GMGFXOXVJRDBnSnpCekp6dGNiaUFnZlZ4dWZWeHVYRzUyWVhJZ2NHeGhkR1p2Y20xRGIyMXdiMjVsYm5SeklEMGdlMXh1SUNCVWNtRnVjMmwwYVc5dU9pQlVjbUZ1YzJsMGFXOXVMRnh1SUNCVWNtRnVjMmwwYVc5dVIzSnZkWEE2SUZSeVlXNXphWFJwYjI1SGNtOTFjRnh1ZlR0Y2JseHVMeW9nSUNvdlhHNWNiaTh2SUdsdWMzUmhiR3dnY0d4aGRHWnZjbTBnYzNCbFkybG1hV01nZFhScGJITmNibFoxWlNReUxtTnZibVpwWnk1dGRYTjBWWE5sVUhKdmNDQTlJRzExYzNSVmMyVlFjbTl3TzF4dVZuVmxKREl1WTI5dVptbG5MbWx6VW1WelpYSjJaV1JVWVdjZ1BTQnBjMUpsYzJWeWRtVmtWR0ZuTzF4dVZuVmxKREl1WTI5dVptbG5MbWRsZEZSaFowNWhiV1Z6Y0dGalpTQTlJR2RsZEZSaFowNWhiV1Z6Y0dGalpUdGNibFoxWlNReUxtTnZibVpwWnk1cGMxVnVhMjV2ZDI1RmJHVnRaVzUwSUQwZ2FYTlZibXR1YjNkdVJXeGxiV1Z1ZER0Y2JseHVMeThnYVc1emRHRnNiQ0J3YkdGMFptOXliU0J5ZFc1MGFXMWxJR1JwY21WamRHbDJaWE1nSmlCamIyMXdiMjVsYm5SelhHNWxlSFJsYm1Rb1ZuVmxKREl1YjNCMGFXOXVjeTVrYVhKbFkzUnBkbVZ6TENCd2JHRjBabTl5YlVScGNtVmpkR2wyWlhNcE8xeHVaWGgwWlc1a0tGWjFaU1F5TG05d2RHbHZibk11WTI5dGNHOXVaVzUwY3l3Z2NHeGhkR1p2Y20xRGIyMXdiMjVsYm5SektUdGNibHh1THk4Z2FXNXpkR0ZzYkNCd2JHRjBabTl5YlNCd1lYUmphQ0JtZFc1amRHbHZibHh1Vm5WbEpESXVjSEp2ZEc5MGVYQmxMbDlmY0dGMFkyaGZYeUE5SUdsdVFuSnZkM05sY2lBL0lIQmhkR05vSURvZ2JtOXZjRHRjYmx4dUx5OGdjSFZpYkdsaklHMXZkVzUwSUcxbGRHaHZaRnh1Vm5WbEpESXVjSEp2ZEc5MGVYQmxMaVJ0YjNWdWRDQTlJR1oxYm1OMGFXOXVJQ2hjYmlBZ1pXd3NYRzRnSUdoNVpISmhkR2x1WjF4dUtTQjdYRzRnSUdWc0lEMGdaV3dnSmlZZ2FXNUNjbTkzYzJWeUlEOGdjWFZsY25rb1pXd3BJRG9nZFc1a1pXWnBibVZrTzF4dUlDQnlaWFIxY200Z2JXOTFiblJEYjIxd2IyNWxiblFvZEdocGN5d2daV3dzSUdoNVpISmhkR2x1WnlsY2JuMDdYRzVjYmk4dklHUmxkblJ2YjJ4eklHZHNiMkpoYkNCb2IyOXJYRzR2S2lCcGMzUmhibUoxYkNCcFoyNXZjbVVnYm1WNGRDQXFMMXh1YzJWMFZHbHRaVzkxZENobWRXNWpkR2x2YmlBb0tTQjdYRzRnSUdsbUlDaGpiMjVtYVdjdVpHVjJkRzl2YkhNcElIdGNiaUFnSUNCcFppQW9aR1YyZEc5dmJITXBJSHRjYmlBZ0lDQWdJR1JsZG5SdmIyeHpMbVZ0YVhRb0oybHVhWFFuTENCV2RXVWtNaWs3WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2h3Y205alpYTnpMbVZ1ZGk1T1QwUkZYMFZPVmlBaFBUMGdKM0J5YjJSMVkzUnBiMjRuSUNZbUlHbHpRMmh5YjIxbEtTQjdYRzRnSUNBZ0lDQmpiMjV6YjJ4bFcyTnZibk52YkdVdWFXNW1ieUEvSUNkcGJtWnZKeUE2SUNkc2IyY25YU2hjYmlBZ0lDQWdJQ0FnSjBSdmQyNXNiMkZrSUhSb1pTQldkV1VnUkdWMmRHOXZiSE1nWlhoMFpXNXphVzl1SUdadmNpQmhJR0psZEhSbGNpQmtaWFpsYkc5d2JXVnVkQ0JsZUhCbGNtbGxibU5sT2x4Y2JpY2dLMXh1SUNBZ0lDQWdJQ0FuYUhSMGNITTZMeTluYVhSb2RXSXVZMjl0TDNaMVpXcHpMM1oxWlMxa1pYWjBiMjlzY3lkY2JpQWdJQ0FnSUNrN1hHNGdJQ0FnZlZ4dUlDQjlYRzRnSUdsbUlDaHdjbTlqWlhOekxtVnVkaTVPVDBSRlgwVk9WaUFoUFQwZ0ozQnliMlIxWTNScGIyNG5JQ1ltWEc0Z0lDQWdJQ0JqYjI1bWFXY3VjSEp2WkhWamRHbHZibFJwY0NBaFBUMGdabUZzYzJVZ0ppWmNiaUFnSUNBZ0lHbHVRbkp2ZDNObGNpQW1KaUIwZVhCbGIyWWdZMjl1YzI5c1pTQWhQVDBnSjNWdVpHVm1hVzVsWkNjcElIdGNiaUFnSUNCamIyNXpiMnhsVzJOdmJuTnZiR1V1YVc1bWJ5QS9JQ2RwYm1adkp5QTZJQ2RzYjJjblhTaGNiaUFnSUNBZ0lGd2lXVzkxSUdGeVpTQnlkVzV1YVc1bklGWjFaU0JwYmlCa1pYWmxiRzl3YldWdWRDQnRiMlJsTGx4Y2Jsd2lJQ3RjYmlBZ0lDQWdJRndpVFdGclpTQnpkWEpsSUhSdklIUjFjbTRnYjI0Z2NISnZaSFZqZEdsdmJpQnRiMlJsSUhkb1pXNGdaR1Z3Ykc5NWFXNW5JR1p2Y2lCd2NtOWtkV04wYVc5dUxseGNibHdpSUN0Y2JpQWdJQ0FnSUZ3aVUyVmxJRzF2Y21VZ2RHbHdjeUJoZENCb2RIUndjem92TDNaMVpXcHpMbTl5Wnk5bmRXbGtaUzlrWlhCc2IzbHRaVzUwTG1oMGJXeGNJbHh1SUNBZ0lDazdYRzRnSUgxY2JuMHNJREFwTzF4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCV2RXVWtNanRjYmx4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTh1WDNaMVpVQXlMakl1TmtCMmRXVXZaR2x6ZEM5MmRXVXVjblZ1ZEdsdFpTNWxjMjB1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURSY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJbDBzSW5OdmRYSmpaVkp2YjNRaU9pSWlmUT09XCIpO1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFxcXCJfX2VzTW9kdWxlXFxcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19tYWluX2Nzc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19tYWluX2Nzc19fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19tYWluX2Nzc19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX192dWVfdnVlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3Z1ZV92dWVfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdnVlX3Z1ZV9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX3Z1ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcXG52YXIgZ3JlZXRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxubmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl92dWVfX1tcXFwiYVxcXCIgLyogZGVmYXVsdCAqL10oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX192dWVfdnVlX19fZGVmYXVsdC5hKTtcXHJcXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpLmFwcGVuZENoaWxkKGdyZWV0ZXIoKSk7XFxyXFxuY29uc29sZS5sb2coXFxcImRkZGRkZGRkZGRkZGRkZGRkLS0tLS1kZGQgLS1zc3Nzc3Nzc3Nzc3NzLS0tLS1cXFwiKTsvLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbmRsWW5CaFkyczZMeTh2TGk5aGNIQXZiV0ZwYmk1cWN6ODJZVFJpSWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3T3pzN08wRkJRVUU3UVVGQlFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CSWl3aVptbHNaU0k2SWpVdWFuTWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUoyWVhJZ1ozSmxaWFJsY2lBOUlISmxjWFZwY21Vb0p5NHZSM0psWlhSbGNpNXFjeWNwTzF4eVhHNWNjbHh1YVcxd2IzSjBJQ2N1TDIxaGFXNHVZM056SjF4eVhHNWNjbHh1YVcxd2IzSjBJR0Z3Y0NCbWNtOXRJQ2N1TDNaMVpTNTJkV1VuWEhKY2JtbHRjRzl5ZENCV2RXVWdabkp2YlNBbmRuVmxKMXh5WEc1dVpYY2dWblZsS0dGd2NDazdYSEpjYm1SdlkzVnRaVzUwTG1kbGRFVnNaVzFsYm5SQ2VVbGtLQ2R5YjI5MEp5a3VZWEJ3Wlc1a1EyaHBiR1FvWjNKbFpYUmxjaWdwS1R0Y2NseHVZMjl1YzI5c1pTNXNiMmNvWENKa1pHUmtaR1JrWkdSa1pHUmtaR1JrWkMwdExTMHRaR1JrSUMwdGMzTnpjM056YzNOemMzTnpjeTB0TFMwdFhDSXBPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dllYQndMMjFoYVc0dWFuTmNiaTh2SUcxdlpIVnNaU0JwWkNBOUlEVmNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWwwc0luTnZkWEpqWlZKdmIzUWlPaUlpZlE9PVwiKTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19lc01vZHVsZVxcXCIsIHsgdmFsdWU6IHRydWUgfSk7XFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcblxcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcXFwiZGVmYXVsdFxcXCJdID0gKHtcXG4gICAgZWw6ICcjYXBwJyxcXG4gICAgbmFtZTogJ2FwcCcsXFxuICAgIGRhdGEoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIG1zZzogJ1dlbGNvbWUgdG8gWW91ciBWdWUuanMgQXBwJ1xcbiAgICAgICAgfTtcXG4gICAgfVxcbn0pOy8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluZGxZbkJoWTJzNkx5OHZkblZsTG5aMVpUOWxPVGRtSWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3T3pzN096czdPenM3UVVGVFFUdFJRVVZCTzFWQlEwRTdWMEZEUVRzN2FVSkJSMEU3UVVGR1FUdEJRVWRCTzBGQlVFRWlMQ0ptYVd4bElqb2lOaTVxY3lJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklseHlYRzQ4ZEdWdGNHeGhkR1UrWEhKY2JpQWdJQ0E4WkdsMklHbGtQVndpWVhCd1hDSStYSEpjYmlBZ0lDQWdJQ0FnUEdneFBudDdJRzF6WnlCOWZUd3ZhREUrWEhKY2JseHlYRzRnSUNBZ1BDOWthWFkrWEhKY2Jqd3ZkR1Z0Y0d4aGRHVStYSEpjYmx4eVhHNDhjMk55YVhCMFBseHlYRzRnSUNBZ1pYaHdiM0owSUdSbFptRjFiSFFnZTF4eVhHNGdJQ0FnSUNBZ0lHVnNPaUFuSTJGd2NDY3NYSEpjYmlBZ0lDQWdJQ0FnYm1GdFpUb2dKMkZ3Y0Njc1hISmNiaUFnSUNBZ0lDQWdaR0YwWVNBb0tTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnRjMmM2SUNkWFpXeGpiMjFsSUhSdklGbHZkWElnVm5WbExtcHpJRUZ3Y0NkY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lIMWNjbHh1UEM5elkzSnBjSFErWEhKY2JseHlYRzVjYmx4dVhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVpQXZMMXh1THk4Z2RuVmxMbloxWlQ4eVpEZzBZVGs0T0NKZExDSnpiM1Z5WTJWU2IyOTBJam9pSW4wPVwiKTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKHVuZGVmaW5lZCk7XFxuLy8gaW1wb3J0c1xcblxcblxcbi8vIG1vZHVsZVxcbmV4cG9ydHMucHVzaChbbW9kdWxlLmksIFxcXCJodG1sIHtcXFxcclxcXFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXFxyXFxcXG4gIC1tcy10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xcXFxyXFxcXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTtcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuKiwgKjpiZWZvcmUsICo6YWZ0ZXIge1xcXFxyXFxcXG4gIGJveC1zaXppbmc6IGluaGVyaXQ7XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbmJvZHkge1xcXFxyXFxcXG4gIG1hcmdpbjogMDtcXFxcclxcXFxuICBmb250LWZhbWlseTogJ0hlbHZldGljYSBOZXVlJywgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuaDEsIGgyLCBoMywgaDQsIGg1LCBoNiwgcCwgdWwge1xcXFxyXFxcXG4gIG1hcmdpbjogMDtcXFxcclxcXFxuICBwYWRkaW5nOiAwO1xcXFxyXFxcXG59XFxcIiwgXFxcIlxcXCJdKTtcXG5cXG4vLyBleHBvcnRzXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5kbFluQmhZMnM2THk4dkxpOWhjSEF2YldGcGJpNWpjM00vWkdWbVlpSmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaVFVRkJRVHRCUVVOQk96czdRVUZIUVR0QlFVTkJMQ3RDUVVGblF5dzJRa0ZCTmtJc2FVTkJRV2xETEhGRFFVRnhReXhMUVVGTExEaENRVUU0UWl3d1FrRkJNRUlzUzBGQlN5eGpRVUZqTEdkQ1FVRm5RaXhyUlVGQmEwVXNTMEZCU3l4MVEwRkJkVU1zWjBKQlFXZENMR2xDUVVGcFFpeExRVUZMT3p0QlFVVjJXQ0lzSW1acGJHVWlPaUkzTG1weklpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2laWGh3YjNKMGN5QTlJRzF2WkhWc1pTNWxlSEJ2Y25SeklEMGdjbVZ4ZFdseVpTaGNJaTR1TDI1dlpHVmZiVzlrZFd4bGN5OHVYMk56Y3kxc2IyRmtaWEpBTUM0eU9DNHdRR056Y3kxc2IyRmtaWEl2YkdsaUwyTnpjeTFpWVhObExtcHpYQ0lwS0hWdVpHVm1hVzVsWkNrN1hHNHZMeUJwYlhCdmNuUnpYRzVjYmx4dUx5OGdiVzlrZFd4bFhHNWxlSEJ2Y25SekxuQjFjMmdvVzIxdlpIVnNaUzVwWkN3Z1hDSm9kRzFzSUh0Y1hISmNYRzRnSUdKdmVDMXphWHBwYm1jNklHSnZjbVJsY2kxaWIzZzdYRnh5WEZ4dUlDQXRiWE10ZEdWNGRDMXphWHBsTFdGa2FuVnpkRG9nTVRBd0pUdGNYSEpjWEc0Z0lDMTNaV0pyYVhRdGRHVjRkQzF6YVhwbExXRmthblZ6ZERvZ01UQXdKVHRjWEhKY1hHNTlYRnh5WEZ4dVhGeHlYRnh1S2l3Z0tqcGlaV1p2Y21Vc0lDbzZZV1owWlhJZ2UxeGNjbHhjYmlBZ1ltOTRMWE5wZW1sdVp6b2dhVzVvWlhKcGREdGNYSEpjWEc1OVhGeHlYRnh1WEZ4eVhGeHVZbTlrZVNCN1hGeHlYRnh1SUNCdFlYSm5hVzQ2SURBN1hGeHlYRnh1SUNCbWIyNTBMV1poYldsc2VUb2dKMGhsYkhabGRHbGpZU0JPWlhWbEp5d2dTR1ZzZG1WMGFXTmhMQ0JCY21saGJDd2djMkZ1Y3kxelpYSnBaanRjWEhKY1hHNTlYRnh5WEZ4dVhGeHlYRnh1YURFc0lHZ3lMQ0JvTXl3Z2FEUXNJR2cxTENCb05pd2djQ3dnZFd3Z2UxeGNjbHhjYmlBZ2JXRnlaMmx1T2lBd08xeGNjbHhjYmlBZ2NHRmtaR2x1WnpvZ01EdGNYSEpjWEc1OVhDSXNJRndpWENKZEtUdGNibHh1THk4Z1pYaHdiM0owYzF4dVhHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTHk1ZlkzTnpMV3h2WVdSbGNrQXdMakk0TGpCQVkzTnpMV3h2WVdSbGNqOXRiMlIxYkdWeklTNHZZWEJ3TDIxaGFXNHVZM056WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0EzWEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSmRMQ0p6YjNWeVkyVlNiMjkwSWpvaUluMD1cIik7XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKEJ1ZmZlcikgey8qXFxuXFx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcXG5cXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXFxuKi9cXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XFxuXFx0dmFyIGxpc3QgPSBbXTtcXG5cXG5cXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXFxuXFx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xcblxcdFxcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xcblxcdFxcdFxcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xcblxcdFxcdFxcdGlmKGl0ZW1bMl0pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gXFxcIkBtZWRpYSBcXFwiICsgaXRlbVsyXSArIFxcXCJ7XFxcIiArIGNvbnRlbnQgKyBcXFwifVxcXCI7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY29udGVudDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSkuam9pbihcXFwiXFxcIik7XFxuXFx0fTtcXG5cXG5cXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxcblxcdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcXG5cXHRcXHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXFxcInN0cmluZ1xcXCIpXFxuXFx0XFx0XFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXFxcIlxcXCJdXTtcXG5cXHRcXHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xcblxcdFxcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0dmFyIGlkID0gdGhpc1tpXVswXTtcXG5cXHRcXHRcXHRpZih0eXBlb2YgaWQgPT09IFxcXCJudW1iZXJcXFwiKVxcblxcdFxcdFxcdFxcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcXG5cXHRcXHRcXHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXFxuXFx0XFx0XFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcXG5cXHRcXHRcXHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxcblxcdFxcdFxcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXFxuXFx0XFx0XFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFxcXCJudW1iZXJcXFwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XFxuXFx0XFx0XFx0XFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xcblxcdFxcdFxcdFxcdFxcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XFxuXFx0XFx0XFx0XFx0XFx0aXRlbVsyXSA9IFxcXCIoXFxcIiArIGl0ZW1bMl0gKyBcXFwiKSBhbmQgKFxcXCIgKyBtZWRpYVF1ZXJ5ICsgXFxcIilcXFwiO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRsaXN0LnB1c2goaXRlbSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcblxcdHJldHVybiBsaXN0O1xcbn07XFxuXFxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcXG5cXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XFxuXFx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xcblxcdGlmICghY3NzTWFwcGluZykge1xcblxcdFxcdHJldHVybiBjb250ZW50O1xcblxcdH1cXG5cXG5cXHRpZiAodXNlU291cmNlTWFwKSB7XFxuXFx0XFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XFxuXFx0XFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcXG5cXHRcXHRcXHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxcXG4nKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXFxcbicpO1xcbn1cXG5cXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXFxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xcbiAgdmFyIGJhc2U2NCA9IG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xcbiAgdmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcXG5cXG4gIHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XFxufVxcblxcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KS5CdWZmZXIpKS8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluZGxZbkJoWTJzNkx5OHZMaTkrTHk1ZlkzTnpMV3h2WVdSbGNrQXdMakk0TGpCQVkzTnpMV3h2WVdSbGNpOXNhV0l2WTNOekxXSmhjMlV1YW5NL1lqY3daU0pkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYlVOQlFXMURMR2RDUVVGblFqdEJRVU51UkN4SlFVRkpPMEZCUTBvN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzWjBKQlFXZENMR2xDUVVGcFFqdEJRVU5xUXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGbEJRVmtzYjBKQlFXOUNPMEZCUTJoRE8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPenRCUVVWSU8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHhSRUZCY1VRc1kwRkJZenM3UVVGRmJrVTdRVUZEUVNJc0ltWnBiR1VpT2lJNExtcHpJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpTHlwY2JseDBUVWxVSUV4cFkyVnVjMlVnYUhSMGNEb3ZMM2QzZHk1dmNHVnVjMjkxY21ObExtOXlaeTlzYVdObGJuTmxjeTl0YVhRdGJHbGpaVzV6WlM1d2FIQmNibHgwUVhWMGFHOXlJRlJ2WW1saGN5QkxiM0J3WlhKeklFQnpiMnR5WVZ4dUtpOWNiaTh2SUdOemN5QmlZWE5sSUdOdlpHVXNJR2x1YW1WamRHVmtJR0o1SUhSb1pTQmpjM010Ykc5aFpHVnlYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLSFZ6WlZOdmRYSmpaVTFoY0NrZ2UxeHVYSFIyWVhJZ2JHbHpkQ0E5SUZ0ZE8xeHVYRzVjZEM4dklISmxkSFZ5YmlCMGFHVWdiR2x6ZENCdlppQnRiMlIxYkdWeklHRnpJR056Y3lCemRISnBibWRjYmx4MGJHbHpkQzUwYjFOMGNtbHVaeUE5SUdaMWJtTjBhVzl1SUhSdlUzUnlhVzVuS0NrZ2UxeHVYSFJjZEhKbGRIVnliaUIwYUdsekxtMWhjQ2htZFc1amRHbHZiaUFvYVhSbGJTa2dlMXh1WEhSY2RGeDBkbUZ5SUdOdmJuUmxiblFnUFNCamMzTlhhWFJvVFdGd2NHbHVaMVJ2VTNSeWFXNW5LR2wwWlcwc0lIVnpaVk52ZFhKalpVMWhjQ2s3WEc1Y2RGeDBYSFJwWmlocGRHVnRXekpkS1NCN1hHNWNkRngwWEhSY2RISmxkSFZ5YmlCY0lrQnRaV1JwWVNCY0lpQXJJR2wwWlcxYk1sMGdLeUJjSW50Y0lpQXJJR052Ym5SbGJuUWdLeUJjSW4xY0lqdGNibHgwWEhSY2RIMGdaV3h6WlNCN1hHNWNkRngwWEhSY2RISmxkSFZ5YmlCamIyNTBaVzUwTzF4dVhIUmNkRngwZlZ4dVhIUmNkSDBwTG1wdmFXNG9YQ0pjSWlrN1hHNWNkSDA3WEc1Y2JseDBMeThnYVcxd2IzSjBJR0VnYkdsemRDQnZaaUJ0YjJSMWJHVnpJR2x1ZEc4Z2RHaGxJR3hwYzNSY2JseDBiR2x6ZEM1cElEMGdablZ1WTNScGIyNG9iVzlrZFd4bGN5d2diV1ZrYVdGUmRXVnllU2tnZTF4dVhIUmNkR2xtS0hSNWNHVnZaaUJ0YjJSMWJHVnpJRDA5UFNCY0luTjBjbWx1WjF3aUtWeHVYSFJjZEZ4MGJXOWtkV3hsY3lBOUlGdGJiblZzYkN3Z2JXOWtkV3hsY3l3Z1hDSmNJbDFkTzF4dVhIUmNkSFpoY2lCaGJISmxZV1I1U1cxd2IzSjBaV1JOYjJSMWJHVnpJRDBnZTMwN1hHNWNkRngwWm05eUtIWmhjaUJwSUQwZ01Ec2dhU0E4SUhSb2FYTXViR1Z1WjNSb095QnBLeXNwSUh0Y2JseDBYSFJjZEhaaGNpQnBaQ0E5SUhSb2FYTmJhVjFiTUYwN1hHNWNkRngwWEhScFppaDBlWEJsYjJZZ2FXUWdQVDA5SUZ3aWJuVnRZbVZ5WENJcFhHNWNkRngwWEhSY2RHRnNjbVZoWkhsSmJYQnZjblJsWkUxdlpIVnNaWE5iYVdSZElEMGdkSEoxWlR0Y2JseDBYSFI5WEc1Y2RGeDBabTl5S0drZ1BTQXdPeUJwSUR3Z2JXOWtkV3hsY3k1c1pXNW5kR2c3SUdrckt5a2dlMXh1WEhSY2RGeDBkbUZ5SUdsMFpXMGdQU0J0YjJSMWJHVnpXMmxkTzF4dVhIUmNkRngwTHk4Z2MydHBjQ0JoYkhKbFlXUjVJR2x0Y0c5eWRHVmtJRzF2WkhWc1pWeHVYSFJjZEZ4MEx5OGdkR2hwY3lCcGJYQnNaVzFsYm5SaGRHbHZiaUJwY3lCdWIzUWdNVEF3SlNCd1pYSm1aV04wSUdadmNpQjNaV2x5WkNCdFpXUnBZU0J4ZFdWeWVTQmpiMjFpYVc1aGRHbHZibk5jYmx4MFhIUmNkQzh2SUNCM2FHVnVJR0VnYlc5a2RXeGxJR2x6SUdsdGNHOXlkR1ZrSUcxMWJIUnBjR3hsSUhScGJXVnpJSGRwZEdnZ1pHbG1abVZ5Wlc1MElHMWxaR2xoSUhGMVpYSnBaWE11WEc1Y2RGeDBYSFF2THlBZ1NTQm9iM0JsSUhSb2FYTWdkMmxzYkNCdVpYWmxjaUJ2WTJOMWNpQW9TR1Y1SUhSb2FYTWdkMkY1SUhkbElHaGhkbVVnYzIxaGJHeGxjaUJpZFc1a2JHVnpLVnh1WEhSY2RGeDBhV1lvZEhsd1pXOW1JR2wwWlcxYk1GMGdJVDA5SUZ3aWJuVnRZbVZ5WENJZ2ZId2dJV0ZzY21WaFpIbEpiWEJ2Y25SbFpFMXZaSFZzWlhOYmFYUmxiVnN3WFYwcElIdGNibHgwWEhSY2RGeDBhV1lvYldWa2FXRlJkV1Z5ZVNBbUppQWhhWFJsYlZzeVhTa2dlMXh1WEhSY2RGeDBYSFJjZEdsMFpXMWJNbDBnUFNCdFpXUnBZVkYxWlhKNU8xeHVYSFJjZEZ4MFhIUjlJR1ZzYzJVZ2FXWW9iV1ZrYVdGUmRXVnllU2tnZTF4dVhIUmNkRngwWEhSY2RHbDBaVzFiTWwwZ1BTQmNJaWhjSWlBcklHbDBaVzFiTWwwZ0t5QmNJaWtnWVc1a0lDaGNJaUFySUcxbFpHbGhVWFZsY25rZ0t5QmNJaWxjSWp0Y2JseDBYSFJjZEZ4MGZWeHVYSFJjZEZ4MFhIUnNhWE4wTG5CMWMyZ29hWFJsYlNrN1hHNWNkRngwWEhSOVhHNWNkRngwZlZ4dVhIUjlPMXh1WEhSeVpYUjFjbTRnYkdsemREdGNibjA3WEc1Y2JtWjFibU4wYVc5dUlHTnpjMWRwZEdoTllYQndhVzVuVkc5VGRISnBibWNvYVhSbGJTd2dkWE5sVTI5MWNtTmxUV0Z3S1NCN1hHNWNkSFpoY2lCamIyNTBaVzUwSUQwZ2FYUmxiVnN4WFNCOGZDQW5KenRjYmx4MGRtRnlJR056YzAxaGNIQnBibWNnUFNCcGRHVnRXek5kTzF4dVhIUnBaaUFvSVdOemMwMWhjSEJwYm1jcElIdGNibHgwWEhSeVpYUjFjbTRnWTI5dWRHVnVkRHRjYmx4MGZWeHVYRzVjZEdsbUlDaDFjMlZUYjNWeVkyVk5ZWEFwSUh0Y2JseDBYSFIyWVhJZ2MyOTFjbU5sVFdGd2NHbHVaeUE5SUhSdlEyOXRiV1Z1ZENoamMzTk5ZWEJ3YVc1bktUdGNibHgwWEhSMllYSWdjMjkxY21ObFZWSk1jeUE5SUdOemMwMWhjSEJwYm1jdWMyOTFjbU5sY3k1dFlYQW9ablZ1WTNScGIyNGdLSE52ZFhKalpTa2dlMXh1WEhSY2RGeDBjbVYwZFhKdUlDY3ZLaU1nYzI5MWNtTmxWVkpNUFNjZ0t5QmpjM05OWVhCd2FXNW5Mbk52ZFhKalpWSnZiM1FnS3lCemIzVnlZMlVnS3lBbklDb3ZKMXh1WEhSY2RIMHBPMXh1WEc1Y2RGeDBjbVYwZFhKdUlGdGpiMjUwWlc1MFhTNWpiMjVqWVhRb2MyOTFjbU5sVlZKTWN5a3VZMjl1WTJGMEtGdHpiM1Z5WTJWTllYQndhVzVuWFNrdWFtOXBiaWduWEZ4dUp5azdYRzVjZEgxY2JseHVYSFJ5WlhSMWNtNGdXMk52Ym5SbGJuUmRMbXB2YVc0b0oxeGNiaWNwTzF4dWZWeHVYRzR2THlCQlpHRndkR1ZrSUdaeWIyMGdZMjl1ZG1WeWRDMXpiM1Z5WTJVdGJXRndJQ2hOU1ZRcFhHNW1kVzVqZEdsdmJpQjBiME52YlcxbGJuUW9jMjkxY21ObFRXRndLU0I3WEc0Z0lIWmhjaUJpWVhObE5qUWdQU0J1WlhjZ1FuVm1abVZ5S0VwVFQwNHVjM1J5YVc1bmFXWjVLSE52ZFhKalpVMWhjQ2twTG5SdlUzUnlhVzVuS0NkaVlYTmxOalFuS1R0Y2JpQWdkbUZ5SUdSaGRHRWdQU0FuYzI5MWNtTmxUV0Z3Y0dsdVoxVlNURDFrWVhSaE9tRndjR3hwWTJGMGFXOXVMMnB6YjI0N1kyaGhjbk5sZEQxMWRHWXRPRHRpWVhObE5qUXNKeUFySUdKaGMyVTJORHRjYmx4dUlDQnlaWFIxY200Z0p5OHFJeUFuSUNzZ1pHRjBZU0FySUNjZ0tpOG5PMXh1ZlZ4dVhHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTHk1ZlkzTnpMV3h2WVdSbGNrQXdMakk0TGpCQVkzTnpMV3h2WVdSbGNpOXNhV0l2WTNOekxXSmhjMlV1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURoY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJbDBzSW5OdmRYSmpaVkp2YjNRaU9pSWlmUT09XCIpO1xuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIm1vZHVsZS5leHBvcnRzID0ge1xcblxcdFxcXCJncmVldFRleHRcXFwiOiBcXFwiSGkgdGhlcmUgYW5kIGdyZWV0aW5ncyBmcm9tIEpTT04hXFxcIlxcbn07Ly8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5kbFluQmhZMnM2THk4dkxpOWhjSEF2WTI5dVptbG5MbXB6YjI0L016QXlaU0pkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lRVUZCUVR0QlFVTkJPMEZCUTBFaUxDSm1hV3hsSWpvaU9TNXFjeUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSW0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnZTF4dVhIUmNJbWR5WldWMFZHVjRkRndpT2lCY0lraHBJSFJvWlhKbElHRnVaQ0JuY21WbGRHbHVaM01nWm5KdmJTQktVMDlPSVZ3aVhHNTlPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dllYQndMMk52Ym1acFp5NXFjMjl1WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0E1WEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSmRMQ0p6YjNWeVkyVlNiMjkwSWpvaUluMD1cIik7XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIi8qXFxuXFx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcXG5cXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXFxuKi9cXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcXG5cXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcXG5cXHRcXHR2YXIgbWVtbztcXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGlmICh0eXBlb2YgbWVtbyA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdHJldHVybiBtZW1vO1xcblxcdFxcdH07XFxuXFx0fSxcXG5cXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcXG5cXHRcXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xcblxcdFxcdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcXG5cXHRcXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyIFxcblxcdFxcdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xcblxcdFxcdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xcblxcdFxcdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcXG5cXHR9KSxcXG5cXHRnZXRFbGVtZW50ID0gKGZ1bmN0aW9uKGZuKSB7XFxuXFx0XFx0dmFyIG1lbW8gPSB7fTtcXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcXG5cXHRcXHRcXHRpZiAodHlwZW9mIG1lbW9bc2VsZWN0b3JdID09PSBcXFwidW5kZWZpbmVkXFxcIikge1xcblxcdFxcdFxcdFxcdG1lbW9bc2VsZWN0b3JdID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxcblxcdFxcdH07XFxuXFx0fSkoZnVuY3Rpb24gKHN0eWxlVGFyZ2V0KSB7XFxuXFx0XFx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc3R5bGVUYXJnZXQpXFxuXFx0fSksXFxuXFx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXFxuXFx0c2luZ2xldG9uQ291bnRlciA9IDAsXFxuXFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXSxcXG5cXHRmaXhVcmxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XFxuXFx0aWYodHlwZW9mIERFQlVHICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBERUJVRykge1xcblxcdFxcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXFxcIm9iamVjdFxcXCIpIHRocm93IG5ldyBFcnJvcihcXFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XFxcIik7XFxuXFx0fVxcblxcblxcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXFxcIm9iamVjdFxcXCIgPyBvcHRpb25zLmF0dHJzIDoge307XFxuXFxuXFx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XFxuXFx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxcblxcdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFxcXCJ1bmRlZmluZWRcXFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcXG5cXG5cXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxcblxcdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRJbnRvID09PSBcXFwidW5kZWZpbmVkXFxcIikgb3B0aW9ucy5pbnNlcnRJbnRvID0gXFxcImhlYWRcXFwiO1xcblxcblxcdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XFxuXFx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcXFwidW5kZWZpbmVkXFxcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFxcXCJib3R0b21cXFwiO1xcblxcblxcdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XFxuXFx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcXG5cXG5cXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcXG5cXHRcXHR2YXIgbWF5UmVtb3ZlID0gW107XFxuXFx0XFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xcblxcdFxcdFxcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xcblxcdFxcdFxcdGRvbVN0eWxlLnJlZnMtLTtcXG5cXHRcXHRcXHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XFxuXFx0XFx0fVxcblxcdFxcdGlmKG5ld0xpc3QpIHtcXG5cXHRcXHRcXHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xcblxcdFxcdFxcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XFxuXFx0XFx0fVxcblxcdFxcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XFxuXFx0XFx0XFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xcblxcdFxcdFxcdFxcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcXG5cXHRcXHRcXHRcXHRcXHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xcblxcdFxcdFxcdFxcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcbn07XFxuXFxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XFxuXFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xcblxcdFxcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xcblxcdFxcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xcblxcdFxcdGlmKGRvbVN0eWxlKSB7XFxuXFx0XFx0XFx0ZG9tU3R5bGUucmVmcysrO1xcblxcdFxcdFxcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xcblxcdFxcdFxcdFxcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xcblxcdFxcdFxcdFxcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHZhciBwYXJ0cyA9IFtdO1xcblxcdFxcdFxcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XFxuXFx0XFx0XFx0XFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xcblxcdFxcdH1cXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XFxuXFx0dmFyIHN0eWxlcyA9IFtdO1xcblxcdHZhciBuZXdTdHlsZXMgPSB7fTtcXG5cXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcblxcdFxcdHZhciBpdGVtID0gbGlzdFtpXTtcXG5cXHRcXHR2YXIgaWQgPSBpdGVtWzBdO1xcblxcdFxcdHZhciBjc3MgPSBpdGVtWzFdO1xcblxcdFxcdHZhciBtZWRpYSA9IGl0ZW1bMl07XFxuXFx0XFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XFxuXFx0XFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xcblxcdFxcdGlmKCFuZXdTdHlsZXNbaWRdKVxcblxcdFxcdFxcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XFxuXFx0XFx0ZWxzZVxcblxcdFxcdFxcdG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcXG5cXHR9XFxuXFx0cmV0dXJuIHN0eWxlcztcXG59XFxuXFxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xcblxcdHZhciBzdHlsZVRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxcblxcdGlmICghc3R5bGVUYXJnZXQpIHtcXG5cXHRcXHR0aHJvdyBuZXcgRXJyb3IoXFxcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXFxcIik7XFxuXFx0fVxcblxcdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xcblxcdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcXFwidG9wXFxcIikge1xcblxcdFxcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xcblxcdFxcdFxcdHN0eWxlVGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIHN0eWxlVGFyZ2V0LmZpcnN0Q2hpbGQpO1xcblxcdFxcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xcblxcdFxcdFxcdHN0eWxlVGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHN0eWxlVGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XFxuXFx0XFx0fVxcblxcdFxcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcXG5cXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFxcXCJib3R0b21cXFwiKSB7XFxuXFx0XFx0c3R5bGVUYXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdHRocm93IG5ldyBFcnJvcihcXFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXFxcIik7XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XFxuXFx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcXG5cXHR2YXIgaWR4ID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZUVsZW1lbnQpO1xcblxcdGlmKGlkeCA+PSAwKSB7XFxuXFx0XFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xcblxcdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJzdHlsZVxcXCIpO1xcblxcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFxcXCJ0ZXh0L2Nzc1xcXCI7XFxuXFxuXFx0YXR0YWNoVGFnQXR0cnMoc3R5bGVFbGVtZW50LCBvcHRpb25zLmF0dHJzKTtcXG5cXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KTtcXG5cXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKSB7XFxuXFx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwibGlua1xcXCIpO1xcblxcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFxcXCJ0ZXh0L2Nzc1xcXCI7XFxuXFx0b3B0aW9ucy5hdHRycy5yZWwgPSBcXFwic3R5bGVzaGVldFxcXCI7XFxuXFxuXFx0YXR0YWNoVGFnQXR0cnMobGlua0VsZW1lbnQsIG9wdGlvbnMuYXR0cnMpO1xcblxcdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XFxuXFx0cmV0dXJuIGxpbmtFbGVtZW50O1xcbn1cXG5cXG5mdW5jdGlvbiBhdHRhY2hUYWdBdHRycyhlbGVtZW50LCBhdHRycykge1xcblxcdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcXG5cXHRcXHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xcblxcdH0pO1xcbn1cXG5cXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcXG5cXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcXG5cXG5cXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcXG5cXHRcXHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcXG5cXHRcXHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcXG5cXHRcXHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XFxuXFx0XFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XFxuXFx0fSBlbHNlIGlmKG9iai5zb3VyY2VNYXAgJiZcXG5cXHRcXHR0eXBlb2YgVVJMID09PSBcXFwiZnVuY3Rpb25cXFwiICYmXFxuXFx0XFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFxcXCJmdW5jdGlvblxcXCIgJiZcXG5cXHRcXHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJlxcblxcdFxcdHR5cGVvZiBCbG9iID09PSBcXFwiZnVuY3Rpb25cXFwiICYmXFxuXFx0XFx0dHlwZW9mIGJ0b2EgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG5cXHRcXHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcXG5cXHRcXHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBvcHRpb25zKTtcXG5cXHRcXHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcXG5cXHRcXHRcXHRpZihzdHlsZUVsZW1lbnQuaHJlZilcXG5cXHRcXHRcXHRcXHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcXG5cXHRcXHR9O1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xcblxcdFxcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xcblxcdFxcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdHVwZGF0ZShvYmopO1xcblxcblxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcXG5cXHRcXHRpZihuZXdPYmopIHtcXG5cXHRcXHRcXHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0cmVtb3ZlKCk7XFxuXFx0XFx0fVxcblxcdH07XFxufVxcblxcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XFxuXFx0dmFyIHRleHRTdG9yZSA9IFtdO1xcblxcblxcdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XFxuXFx0XFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xcblxcdFxcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcXFxuJyk7XFxuXFx0fTtcXG59KSgpO1xcblxcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcXG5cXHR2YXIgY3NzID0gcmVtb3ZlID8gXFxcIlxcXCIgOiBvYmouY3NzO1xcblxcblxcdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xcblxcdFxcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcXG5cXHRcXHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xcblxcdFxcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcXG5cXHRcXHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcXG5cXHRcXHR9XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XFxuXFx0dmFyIGNzcyA9IG9iai5jc3M7XFxuXFx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xcblxcblxcdGlmKG1lZGlhKSB7XFxuXFx0XFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcXFwibWVkaWFcXFwiLCBtZWRpYSlcXG5cXHR9XFxuXFxuXFx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcXG5cXHRcXHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcXG5cXHRcXHRcXHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xcblxcdFxcdH1cXG5cXHRcXHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVMaW5rKGxpbmtFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcXG5cXHR2YXIgY3NzID0gb2JqLmNzcztcXG5cXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcXG5cXG5cXHQvKiBJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcXG5cXHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xcblxcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxcblxcdGRpcmVjdGx5XFxuXFx0Ki9cXG5cXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcXG5cXG5cXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpe1xcblxcdFxcdGNzcyA9IGZpeFVybHMoY3NzKTtcXG5cXHR9XFxuXFxuXFx0aWYoc291cmNlTWFwKSB7XFxuXFx0XFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcXG5cXHRcXHRjc3MgKz0gXFxcIlxcXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcXFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFxcXCIgKi9cXFwiO1xcblxcdH1cXG5cXG5cXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFxcXCJ0ZXh0L2Nzc1xcXCIgfSk7XFxuXFxuXFx0dmFyIG9sZFNyYyA9IGxpbmtFbGVtZW50LmhyZWY7XFxuXFxuXFx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XFxuXFxuXFx0aWYob2xkU3JjKVxcblxcdFxcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5kbFluQmhZMnM2THk4dkxpOStMeTVmYzNSNWJHVXRiRzloWkdWeVFEQXVNVFl1TVVCemRIbHNaUzFzYjJGa1pYSXZZV1JrVTNSNWJHVnpMbXB6UDJSaU9HUWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklrRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4dlFrRkJiMEk3UVVGRGNFSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUlVGQlJUdEJRVU5HTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUlVGQlJUdEJRVU5HTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEZRVUZGTzBGQlEwWTdRVUZEUVN4RlFVRkZPMEZCUTBZN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJMR2RDUVVGblFpeHRRa0ZCYlVJN1FVRkRia003UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzWjBKQlFXZENMSE5DUVVGelFqdEJRVU4wUXp0QlFVTkJPMEZCUTBFc2EwSkJRV3RDTERKQ1FVRXlRanRCUVVNM1F6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFTeGxRVUZsTEcxQ1FVRnRRanRCUVVOc1F6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMR2xDUVVGcFFpd3lRa0ZCTWtJN1FVRkROVU03UVVGRFFUdEJRVU5CTEZGQlFWRXNkVUpCUVhWQ08wRkJReTlDTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRU3hwUWtGQmFVSXNkVUpCUVhWQ08wRkJRM2hETzBGQlEwRTdRVUZEUVN3eVFrRkJNa0k3UVVGRE0wSTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEdWQlFXVXNhVUpCUVdsQ08wRkJRMmhETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hqUVVGak8wRkJRMlE3UVVGRFFTeG5RMEZCWjBNc2MwSkJRWE5DTzBGQlEzUkVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUdEJRVU5CTEVWQlFVVTdRVUZEUmp0QlFVTkJMRVZCUVVVN1FVRkRSanRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVWQlFVVTdRVUZEUmpzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hGUVVGRk8wRkJRMFk3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSVUZCUlR0QlFVTkdPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeERRVUZET3p0QlFVVkVPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTEVWQlFVVTdRVUZEUmp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTEVWQlFVVTdRVUZEUmp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJMSFZFUVVGMVJEdEJRVU4yUkRzN1FVRkZRU3cyUWtGQk5rSXNiVUpCUVcxQ096dEJRVVZvUkRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRWlMQ0ptYVd4bElqb2lNVEF1YW5NaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SXZLbHh1WEhSTlNWUWdUR2xqWlc1elpTQm9kSFJ3T2k4dmQzZDNMbTl3Wlc1emIzVnlZMlV1YjNKbkwyeHBZMlZ1YzJWekwyMXBkQzFzYVdObGJuTmxMbkJvY0Z4dVhIUkJkWFJvYjNJZ1ZHOWlhV0Z6SUV0dmNIQmxjbk1nUUhOdmEzSmhYRzRxTDF4dWRtRnlJSE4wZVd4bGMwbHVSRzl0SUQwZ2UzMHNYRzVjZEcxbGJXOXBlbVVnUFNCbWRXNWpkR2x2YmlobWJpa2dlMXh1WEhSY2RIWmhjaUJ0Wlcxdk8xeHVYSFJjZEhKbGRIVnliaUJtZFc1amRHbHZiaUFvS1NCN1hHNWNkRngwWEhScFppQW9kSGx3Wlc5bUlHMWxiVzhnUFQwOUlGd2lkVzVrWldacGJtVmtYQ0lwSUcxbGJXOGdQU0JtYmk1aGNIQnNlU2gwYUdsekxDQmhjbWQxYldWdWRITXBPMXh1WEhSY2RGeDBjbVYwZFhKdUlHMWxiVzg3WEc1Y2RGeDBmVHRjYmx4MGZTeGNibHgwYVhOUGJHUkpSU0E5SUcxbGJXOXBlbVVvWm5WdVkzUnBiMjRvS1NCN1hHNWNkRngwTHk4Z1ZHVnpkQ0JtYjNJZ1NVVWdQRDBnT1NCaGN5QndjbTl3YjNObFpDQmllU0JDY205M2MyVnlhR0ZqYTNOY2JseDBYSFF2THlCQWMyVmxJR2gwZEhBNkx5OWljbTkzYzJWeWFHRmphM011WTI5dEx5Tm9ZV05yTFdVM01XUTROamt5WmpZMU16TTBNVGN6Wm1WbE56RTFZekl5TW1OaU9EQTFYRzVjZEZ4MEx5OGdWR1Z6ZEhNZ1ptOXlJR1Y0YVhOMFpXNWpaU0J2WmlCemRHRnVaR0Z5WkNCbmJHOWlZV3h6SUdseklIUnZJR0ZzYkc5M0lITjBlV3hsTFd4dllXUmxjaUJjYmx4MFhIUXZMeUIwYnlCdmNHVnlZWFJsSUdOdmNuSmxZM1JzZVNCcGJuUnZJRzV2YmkxemRHRnVaR0Z5WkNCbGJuWnBjbTl1YldWdWRITmNibHgwWEhRdkx5QkFjMlZsSUdoMGRIQnpPaTh2WjJsMGFIVmlMbU52YlM5M1pXSndZV05yTFdOdmJuUnlhV0l2YzNSNWJHVXRiRzloWkdWeUwybHpjM1ZsY3k4eE56ZGNibHgwWEhSeVpYUjFjbTRnZDJsdVpHOTNJQ1ltSUdSdlkzVnRaVzUwSUNZbUlHUnZZM1Z0Wlc1MExtRnNiQ0FtSmlBaGQybHVaRzkzTG1GMGIySTdYRzVjZEgwcExGeHVYSFJuWlhSRmJHVnRaVzUwSUQwZ0tHWjFibU4wYVc5dUtHWnVLU0I3WEc1Y2RGeDBkbUZ5SUcxbGJXOGdQU0I3ZlR0Y2JseDBYSFJ5WlhSMWNtNGdablZ1WTNScGIyNG9jMlZzWldOMGIzSXBJSHRjYmx4MFhIUmNkR2xtSUNoMGVYQmxiMllnYldWdGIxdHpaV3hsWTNSdmNsMGdQVDA5SUZ3aWRXNWtaV1pwYm1Wa1hDSXBJSHRjYmx4MFhIUmNkRngwYldWdGIxdHpaV3hsWTNSdmNsMGdQU0JtYmk1allXeHNLSFJvYVhNc0lITmxiR1ZqZEc5eUtUdGNibHgwWEhSY2RIMWNibHgwWEhSY2RISmxkSFZ5YmlCdFpXMXZXM05sYkdWamRHOXlYVnh1WEhSY2RIMDdYRzVjZEgwcEtHWjFibU4wYVc5dUlDaHpkSGxzWlZSaGNtZGxkQ2tnZTF4dVhIUmNkSEpsZEhWeWJpQmtiMk4xYldWdWRDNXhkV1Z5ZVZObGJHVmpkRzl5S0hOMGVXeGxWR0Z5WjJWMEtWeHVYSFI5S1N4Y2JseDBjMmx1WjJ4bGRHOXVSV3hsYldWdWRDQTlJRzUxYkd3c1hHNWNkSE5wYm1kc1pYUnZia052ZFc1MFpYSWdQU0F3TEZ4dVhIUnpkSGxzWlVWc1pXMWxiblJ6U1c1elpYSjBaV1JCZEZSdmNDQTlJRnRkTEZ4dVhIUm1hWGhWY214eklEMGdjbVZ4ZFdseVpTaGNJaTR2Wm1sNFZYSnNjMXdpS1R0Y2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpaHNhWE4wTENCdmNIUnBiMjV6S1NCN1hHNWNkR2xtS0hSNWNHVnZaaUJFUlVKVlJ5QWhQVDBnWENKMWJtUmxabWx1WldSY0lpQW1KaUJFUlVKVlJ5a2dlMXh1WEhSY2RHbG1LSFI1Y0dWdlppQmtiMk4xYldWdWRDQWhQVDBnWENKdlltcGxZM1JjSWlrZ2RHaHliM2NnYm1WM0lFVnljbTl5S0Z3aVZHaGxJSE4wZVd4bExXeHZZV1JsY2lCallXNXViM1FnWW1VZ2RYTmxaQ0JwYmlCaElHNXZiaTFpY205M2MyVnlJR1Z1ZG1seWIyNXRaVzUwWENJcE8xeHVYSFI5WEc1Y2JseDBiM0IwYVc5dWN5QTlJRzl3ZEdsdmJuTWdmSHdnZTMwN1hHNWNkRzl3ZEdsdmJuTXVZWFIwY25NZ1BTQjBlWEJsYjJZZ2IzQjBhVzl1Y3k1aGRIUnljeUE5UFQwZ1hDSnZZbXBsWTNSY0lpQS9JRzl3ZEdsdmJuTXVZWFIwY25NZ09pQjdmVHRjYmx4dVhIUXZMeUJHYjNKalpTQnphVzVuYkdVdGRHRm5JSE52YkhWMGFXOXVJRzl1SUVsRk5pMDVMQ0IzYUdsamFDQm9ZWE1nWVNCb1lYSmtJR3hwYldsMElHOXVJSFJvWlNBaklHOW1JRHh6ZEhsc1pUNWNibHgwTHk4Z2RHRm5jeUJwZENCM2FXeHNJR0ZzYkc5M0lHOXVJR0VnY0dGblpWeHVYSFJwWmlBb2RIbHdaVzltSUc5d2RHbHZibk11YzJsdVoyeGxkRzl1SUQwOVBTQmNJblZ1WkdWbWFXNWxaRndpS1NCdmNIUnBiMjV6TG5OcGJtZHNaWFJ2YmlBOUlHbHpUMnhrU1VVb0tUdGNibHh1WEhRdkx5QkNlU0JrWldaaGRXeDBMQ0JoWkdRZ1BITjBlV3hsUGlCMFlXZHpJSFJ2SUhSb1pTQThhR1ZoWkQ0Z1pXeGxiV1Z1ZEZ4dVhIUnBaaUFvZEhsd1pXOW1JRzl3ZEdsdmJuTXVhVzV6WlhKMFNXNTBieUE5UFQwZ1hDSjFibVJsWm1sdVpXUmNJaWtnYjNCMGFXOXVjeTVwYm5ObGNuUkpiblJ2SUQwZ1hDSm9aV0ZrWENJN1hHNWNibHgwTHk4Z1Fua2daR1ZtWVhWc2RDd2dZV1JrSUR4emRIbHNaVDRnZEdGbmN5QjBieUIwYUdVZ1ltOTBkRzl0SUc5bUlIUm9aU0IwWVhKblpYUmNibHgwYVdZZ0tIUjVjR1Z2WmlCdmNIUnBiMjV6TG1sdWMyVnlkRUYwSUQwOVBTQmNJblZ1WkdWbWFXNWxaRndpS1NCdmNIUnBiMjV6TG1sdWMyVnlkRUYwSUQwZ1hDSmliM1IwYjIxY0lqdGNibHh1WEhSMllYSWdjM1I1YkdWeklEMGdiR2x6ZEZSdlUzUjViR1Z6S0d4cGMzUXBPMXh1WEhSaFpHUlRkSGxzWlhOVWIwUnZiU2h6ZEhsc1pYTXNJRzl3ZEdsdmJuTXBPMXh1WEc1Y2RISmxkSFZ5YmlCbWRXNWpkR2x2YmlCMWNHUmhkR1VvYm1WM1RHbHpkQ2tnZTF4dVhIUmNkSFpoY2lCdFlYbFNaVzF2ZG1VZ1BTQmJYVHRjYmx4MFhIUm1iM0lvZG1GeUlHa2dQU0F3T3lCcElEd2djM1I1YkdWekxteGxibWQwYURzZ2FTc3JLU0I3WEc1Y2RGeDBYSFIyWVhJZ2FYUmxiU0E5SUhOMGVXeGxjMXRwWFR0Y2JseDBYSFJjZEhaaGNpQmtiMjFUZEhsc1pTQTlJSE4wZVd4bGMwbHVSRzl0VzJsMFpXMHVhV1JkTzF4dVhIUmNkRngwWkc5dFUzUjViR1V1Y21WbWN5MHRPMXh1WEhSY2RGeDBiV0Y1VW1WdGIzWmxMbkIxYzJnb1pHOXRVM1I1YkdVcE8xeHVYSFJjZEgxY2JseDBYSFJwWmlodVpYZE1hWE4wS1NCN1hHNWNkRngwWEhSMllYSWdibVYzVTNSNWJHVnpJRDBnYkdsemRGUnZVM1I1YkdWektHNWxkMHhwYzNRcE8xeHVYSFJjZEZ4MFlXUmtVM1I1YkdWelZHOUViMjBvYm1WM1UzUjViR1Z6TENCdmNIUnBiMjV6S1R0Y2JseDBYSFI5WEc1Y2RGeDBabTl5S0haaGNpQnBJRDBnTURzZ2FTQThJRzFoZVZKbGJXOTJaUzVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVYSFJjZEZ4MGRtRnlJR1J2YlZOMGVXeGxJRDBnYldGNVVtVnRiM1psVzJsZE8xeHVYSFJjZEZ4MGFXWW9aRzl0VTNSNWJHVXVjbVZtY3lBOVBUMGdNQ2tnZTF4dVhIUmNkRngwWEhSbWIzSW9kbUZ5SUdvZ1BTQXdPeUJxSUR3Z1pHOXRVM1I1YkdVdWNHRnlkSE11YkdWdVozUm9PeUJxS3lzcFhHNWNkRngwWEhSY2RGeDBaRzl0VTNSNWJHVXVjR0Z5ZEhOYmFsMG9LVHRjYmx4MFhIUmNkRngwWkdWc1pYUmxJSE4wZVd4bGMwbHVSRzl0VzJSdmJWTjBlV3hsTG1sa1hUdGNibHgwWEhSY2RIMWNibHgwWEhSOVhHNWNkSDA3WEc1OU8xeHVYRzVtZFc1amRHbHZiaUJoWkdSVGRIbHNaWE5VYjBSdmJTaHpkSGxzWlhNc0lHOXdkR2x2Ym5NcElIdGNibHgwWm05eUtIWmhjaUJwSUQwZ01Ec2dhU0E4SUhOMGVXeGxjeTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVYSFJjZEhaaGNpQnBkR1Z0SUQwZ2MzUjViR1Z6VzJsZE8xeHVYSFJjZEhaaGNpQmtiMjFUZEhsc1pTQTlJSE4wZVd4bGMwbHVSRzl0VzJsMFpXMHVhV1JkTzF4dVhIUmNkR2xtS0dSdmJWTjBlV3hsS1NCN1hHNWNkRngwWEhSa2IyMVRkSGxzWlM1eVpXWnpLeXM3WEc1Y2RGeDBYSFJtYjNJb2RtRnlJR29nUFNBd095QnFJRHdnWkc5dFUzUjViR1V1Y0dGeWRITXViR1Z1WjNSb095QnFLeXNwSUh0Y2JseDBYSFJjZEZ4MFpHOXRVM1I1YkdVdWNHRnlkSE5iYWwwb2FYUmxiUzV3WVhKMGMxdHFYU2s3WEc1Y2RGeDBYSFI5WEc1Y2RGeDBYSFJtYjNJb095QnFJRHdnYVhSbGJTNXdZWEowY3k1c1pXNW5kR2c3SUdvckt5a2dlMXh1WEhSY2RGeDBYSFJrYjIxVGRIbHNaUzV3WVhKMGN5NXdkWE5vS0dGa1pGTjBlV3hsS0dsMFpXMHVjR0Z5ZEhOYmFsMHNJRzl3ZEdsdmJuTXBLVHRjYmx4MFhIUmNkSDFjYmx4MFhIUjlJR1ZzYzJVZ2UxeHVYSFJjZEZ4MGRtRnlJSEJoY25SeklEMGdXMTA3WEc1Y2RGeDBYSFJtYjNJb2RtRnlJR29nUFNBd095QnFJRHdnYVhSbGJTNXdZWEowY3k1c1pXNW5kR2c3SUdvckt5a2dlMXh1WEhSY2RGeDBYSFJ3WVhKMGN5NXdkWE5vS0dGa1pGTjBlV3hsS0dsMFpXMHVjR0Z5ZEhOYmFsMHNJRzl3ZEdsdmJuTXBLVHRjYmx4MFhIUmNkSDFjYmx4MFhIUmNkSE4wZVd4bGMwbHVSRzl0VzJsMFpXMHVhV1JkSUQwZ2UybGtPaUJwZEdWdExtbGtMQ0J5Wldaek9pQXhMQ0J3WVhKMGN6b2djR0Z5ZEhOOU8xeHVYSFJjZEgxY2JseDBmVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQnNhWE4wVkc5VGRIbHNaWE1vYkdsemRDa2dlMXh1WEhSMllYSWdjM1I1YkdWeklEMGdXMTA3WEc1Y2RIWmhjaUJ1WlhkVGRIbHNaWE1nUFNCN2ZUdGNibHgwWm05eUtIWmhjaUJwSUQwZ01Ec2dhU0E4SUd4cGMzUXViR1Z1WjNSb095QnBLeXNwSUh0Y2JseDBYSFIyWVhJZ2FYUmxiU0E5SUd4cGMzUmJhVjA3WEc1Y2RGeDBkbUZ5SUdsa0lEMGdhWFJsYlZzd1hUdGNibHgwWEhSMllYSWdZM056SUQwZ2FYUmxiVnN4WFR0Y2JseDBYSFIyWVhJZ2JXVmthV0VnUFNCcGRHVnRXekpkTzF4dVhIUmNkSFpoY2lCemIzVnlZMlZOWVhBZ1BTQnBkR1Z0V3pOZE8xeHVYSFJjZEhaaGNpQndZWEowSUQwZ2UyTnpjem9nWTNOekxDQnRaV1JwWVRvZ2JXVmthV0VzSUhOdmRYSmpaVTFoY0RvZ2MyOTFjbU5sVFdGd2ZUdGNibHgwWEhScFppZ2hibVYzVTNSNWJHVnpXMmxrWFNsY2JseDBYSFJjZEhOMGVXeGxjeTV3ZFhOb0tHNWxkMU4wZVd4bGMxdHBaRjBnUFNCN2FXUTZJR2xrTENCd1lYSjBjem9nVzNCaGNuUmRmU2s3WEc1Y2RGeDBaV3h6WlZ4dVhIUmNkRngwYm1WM1UzUjViR1Z6VzJsa1hTNXdZWEowY3k1d2RYTm9LSEJoY25RcE8xeHVYSFI5WEc1Y2RISmxkSFZ5YmlCemRIbHNaWE03WEc1OVhHNWNibVoxYm1OMGFXOXVJR2x1YzJWeWRGTjBlV3hsUld4bGJXVnVkQ2h2Y0hScGIyNXpMQ0J6ZEhsc1pVVnNaVzFsYm5RcElIdGNibHgwZG1GeUlITjBlV3hsVkdGeVoyVjBJRDBnWjJWMFJXeGxiV1Z1ZENodmNIUnBiMjV6TG1sdWMyVnlkRWx1ZEc4cFhHNWNkR2xtSUNnaGMzUjViR1ZVWVhKblpYUXBJSHRjYmx4MFhIUjBhSEp2ZHlCdVpYY2dSWEp5YjNJb1hDSkRiM1ZzWkc0bmRDQm1hVzVrSUdFZ2MzUjViR1VnZEdGeVoyVjBMaUJVYUdseklIQnliMkpoWW14NUlHMWxZVzV6SUhSb1lYUWdkR2hsSUhaaGJIVmxJR1p2Y2lCMGFHVWdKMmx1YzJWeWRFbHVkRzhuSUhCaGNtRnRaWFJsY2lCcGN5QnBiblpoYkdsa0xsd2lLVHRjYmx4MGZWeHVYSFIyWVhJZ2JHRnpkRk4wZVd4bFJXeGxiV1Z1ZEVsdWMyVnlkR1ZrUVhSVWIzQWdQU0J6ZEhsc1pVVnNaVzFsYm5SelNXNXpaWEowWldSQmRGUnZjRnR6ZEhsc1pVVnNaVzFsYm5SelNXNXpaWEowWldSQmRGUnZjQzVzWlc1bmRHZ2dMU0F4WFR0Y2JseDBhV1lnS0c5d2RHbHZibk11YVc1elpYSjBRWFFnUFQwOUlGd2lkRzl3WENJcElIdGNibHgwWEhScFppZ2hiR0Z6ZEZOMGVXeGxSV3hsYldWdWRFbHVjMlZ5ZEdWa1FYUlViM0FwSUh0Y2JseDBYSFJjZEhOMGVXeGxWR0Z5WjJWMExtbHVjMlZ5ZEVKbFptOXlaU2h6ZEhsc1pVVnNaVzFsYm5Rc0lITjBlV3hsVkdGeVoyVjBMbVpwY25OMFEyaHBiR1FwTzF4dVhIUmNkSDBnWld4elpTQnBaaWhzWVhOMFUzUjViR1ZGYkdWdFpXNTBTVzV6WlhKMFpXUkJkRlJ2Y0M1dVpYaDBVMmxpYkdsdVp5a2dlMXh1WEhSY2RGeDBjM1I1YkdWVVlYSm5aWFF1YVc1elpYSjBRbVZtYjNKbEtITjBlV3hsUld4bGJXVnVkQ3dnYkdGemRGTjBlV3hsUld4bGJXVnVkRWx1YzJWeWRHVmtRWFJVYjNBdWJtVjRkRk5wWW14cGJtY3BPMXh1WEhSY2RIMGdaV3h6WlNCN1hHNWNkRngwWEhSemRIbHNaVlJoY21kbGRDNWhjSEJsYm1SRGFHbHNaQ2h6ZEhsc1pVVnNaVzFsYm5RcE8xeHVYSFJjZEgxY2JseDBYSFJ6ZEhsc1pVVnNaVzFsYm5SelNXNXpaWEowWldSQmRGUnZjQzV3ZFhOb0tITjBlV3hsUld4bGJXVnVkQ2s3WEc1Y2RIMGdaV3h6WlNCcFppQW9iM0IwYVc5dWN5NXBibk5sY25SQmRDQTlQVDBnWENKaWIzUjBiMjFjSWlrZ2UxeHVYSFJjZEhOMGVXeGxWR0Z5WjJWMExtRndjR1Z1WkVOb2FXeGtLSE4wZVd4bFJXeGxiV1Z1ZENrN1hHNWNkSDBnWld4elpTQjdYRzVjZEZ4MGRHaHliM2NnYm1WM0lFVnljbTl5S0Z3aVNXNTJZV3hwWkNCMllXeDFaU0JtYjNJZ2NHRnlZVzFsZEdWeUlDZHBibk5sY25SQmRDY3VJRTExYzNRZ1ltVWdKM1J2Y0NjZ2IzSWdKMkp2ZEhSdmJTY3VYQ0lwTzF4dVhIUjlYRzU5WEc1Y2JtWjFibU4wYVc5dUlISmxiVzkyWlZOMGVXeGxSV3hsYldWdWRDaHpkSGxzWlVWc1pXMWxiblFwSUh0Y2JseDBjM1I1YkdWRmJHVnRaVzUwTG5CaGNtVnVkRTV2WkdVdWNtVnRiM1psUTJocGJHUW9jM1I1YkdWRmJHVnRaVzUwS1R0Y2JseDBkbUZ5SUdsa2VDQTlJSE4wZVd4bFJXeGxiV1Z1ZEhOSmJuTmxjblJsWkVGMFZHOXdMbWx1WkdWNFQyWW9jM1I1YkdWRmJHVnRaVzUwS1R0Y2JseDBhV1lvYVdSNElENDlJREFwSUh0Y2JseDBYSFJ6ZEhsc1pVVnNaVzFsYm5SelNXNXpaWEowWldSQmRGUnZjQzV6Y0d4cFkyVW9hV1I0TENBeEtUdGNibHgwZlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJqY21WaGRHVlRkSGxzWlVWc1pXMWxiblFvYjNCMGFXOXVjeWtnZTF4dVhIUjJZWElnYzNSNWJHVkZiR1Z0Wlc1MElEMGdaRzlqZFcxbGJuUXVZM0psWVhSbFJXeGxiV1Z1ZENoY0luTjBlV3hsWENJcE8xeHVYSFJ2Y0hScGIyNXpMbUYwZEhKekxuUjVjR1VnUFNCY0luUmxlSFF2WTNOelhDSTdYRzVjYmx4MFlYUjBZV05vVkdGblFYUjBjbk1vYzNSNWJHVkZiR1Z0Wlc1MExDQnZjSFJwYjI1ekxtRjBkSEp6S1R0Y2JseDBhVzV6WlhKMFUzUjViR1ZGYkdWdFpXNTBLRzl3ZEdsdmJuTXNJSE4wZVd4bFJXeGxiV1Z1ZENrN1hHNWNkSEpsZEhWeWJpQnpkSGxzWlVWc1pXMWxiblE3WEc1OVhHNWNibVoxYm1OMGFXOXVJR055WldGMFpVeHBibXRGYkdWdFpXNTBLRzl3ZEdsdmJuTXBJSHRjYmx4MGRtRnlJR3hwYm10RmJHVnRaVzUwSUQwZ1pHOWpkVzFsYm5RdVkzSmxZWFJsUld4bGJXVnVkQ2hjSW14cGJtdGNJaWs3WEc1Y2RHOXdkR2x2Ym5NdVlYUjBjbk11ZEhsd1pTQTlJRndpZEdWNGRDOWpjM05jSWp0Y2JseDBiM0IwYVc5dWN5NWhkSFJ5Y3k1eVpXd2dQU0JjSW5OMGVXeGxjMmhsWlhSY0lqdGNibHh1WEhSaGRIUmhZMmhVWVdkQmRIUnljeWhzYVc1clJXeGxiV1Z1ZEN3Z2IzQjBhVzl1Y3k1aGRIUnljeWs3WEc1Y2RHbHVjMlZ5ZEZOMGVXeGxSV3hsYldWdWRDaHZjSFJwYjI1ekxDQnNhVzVyUld4bGJXVnVkQ2s3WEc1Y2RISmxkSFZ5YmlCc2FXNXJSV3hsYldWdWREdGNibjFjYmx4dVpuVnVZM1JwYjI0Z1lYUjBZV05vVkdGblFYUjBjbk1vWld4bGJXVnVkQ3dnWVhSMGNuTXBJSHRjYmx4MFQySnFaV04wTG10bGVYTW9ZWFIwY25NcExtWnZja1ZoWTJnb1puVnVZM1JwYjI0Z0tHdGxlU2tnZTF4dVhIUmNkR1ZzWlcxbGJuUXVjMlYwUVhSMGNtbGlkWFJsS0d0bGVTd2dZWFIwY25OYmEyVjVYU2s3WEc1Y2RIMHBPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmhaR1JUZEhsc1pTaHZZbW9zSUc5d2RHbHZibk1wSUh0Y2JseDBkbUZ5SUhOMGVXeGxSV3hsYldWdWRDd2dkWEJrWVhSbExDQnlaVzF2ZG1VN1hHNWNibHgwYVdZZ0tHOXdkR2x2Ym5NdWMybHVaMnhsZEc5dUtTQjdYRzVjZEZ4MGRtRnlJSE4wZVd4bFNXNWtaWGdnUFNCemFXNW5iR1YwYjI1RGIzVnVkR1Z5S3lzN1hHNWNkRngwYzNSNWJHVkZiR1Z0Wlc1MElEMGdjMmx1WjJ4bGRHOXVSV3hsYldWdWRDQjhmQ0FvYzJsdVoyeGxkRzl1Uld4bGJXVnVkQ0E5SUdOeVpXRjBaVk4wZVd4bFJXeGxiV1Z1ZENodmNIUnBiMjV6S1NrN1hHNWNkRngwZFhCa1lYUmxJRDBnWVhCd2JIbFViMU5wYm1kc1pYUnZibFJoWnk1aWFXNWtLRzUxYkd3c0lITjBlV3hsUld4bGJXVnVkQ3dnYzNSNWJHVkpibVJsZUN3Z1ptRnNjMlVwTzF4dVhIUmNkSEpsYlc5MlpTQTlJR0Z3Y0d4NVZHOVRhVzVuYkdWMGIyNVVZV2N1WW1sdVpDaHVkV3hzTENCemRIbHNaVVZzWlcxbGJuUXNJSE4wZVd4bFNXNWtaWGdzSUhSeWRXVXBPMXh1WEhSOUlHVnNjMlVnYVdZb2IySnFMbk52ZFhKalpVMWhjQ0FtSmx4dVhIUmNkSFI1Y0dWdlppQlZVa3dnUFQwOUlGd2lablZ1WTNScGIyNWNJaUFtSmx4dVhIUmNkSFI1Y0dWdlppQlZVa3d1WTNKbFlYUmxUMkpxWldOMFZWSk1JRDA5UFNCY0ltWjFibU4wYVc5dVhDSWdKaVpjYmx4MFhIUjBlWEJsYjJZZ1ZWSk1MbkpsZG05clpVOWlhbVZqZEZWU1RDQTlQVDBnWENKbWRXNWpkR2x2Ymx3aUlDWW1YRzVjZEZ4MGRIbHdaVzltSUVKc2IySWdQVDA5SUZ3aVpuVnVZM1JwYjI1Y0lpQW1KbHh1WEhSY2RIUjVjR1Z2WmlCaWRHOWhJRDA5UFNCY0ltWjFibU4wYVc5dVhDSXBJSHRjYmx4MFhIUnpkSGxzWlVWc1pXMWxiblFnUFNCamNtVmhkR1ZNYVc1clJXeGxiV1Z1ZENodmNIUnBiMjV6S1R0Y2JseDBYSFIxY0dSaGRHVWdQU0IxY0dSaGRHVk1hVzVyTG1KcGJtUW9iblZzYkN3Z2MzUjViR1ZGYkdWdFpXNTBMQ0J2Y0hScGIyNXpLVHRjYmx4MFhIUnlaVzF2ZG1VZ1BTQm1kVzVqZEdsdmJpZ3BJSHRjYmx4MFhIUmNkSEpsYlc5MlpWTjBlV3hsUld4bGJXVnVkQ2h6ZEhsc1pVVnNaVzFsYm5RcE8xeHVYSFJjZEZ4MGFXWW9jM1I1YkdWRmJHVnRaVzUwTG1oeVpXWXBYRzVjZEZ4MFhIUmNkRlZTVEM1eVpYWnZhMlZQWW1wbFkzUlZVa3dvYzNSNWJHVkZiR1Z0Wlc1MExtaHlaV1lwTzF4dVhIUmNkSDA3WEc1Y2RIMGdaV3h6WlNCN1hHNWNkRngwYzNSNWJHVkZiR1Z0Wlc1MElEMGdZM0psWVhSbFUzUjViR1ZGYkdWdFpXNTBLRzl3ZEdsdmJuTXBPMXh1WEhSY2RIVndaR0YwWlNBOUlHRndjR3g1Vkc5VVlXY3VZbWx1WkNodWRXeHNMQ0J6ZEhsc1pVVnNaVzFsYm5RcE8xeHVYSFJjZEhKbGJXOTJaU0E5SUdaMWJtTjBhVzl1S0NrZ2UxeHVYSFJjZEZ4MGNtVnRiM1psVTNSNWJHVkZiR1Z0Wlc1MEtITjBlV3hsUld4bGJXVnVkQ2s3WEc1Y2RGeDBmVHRjYmx4MGZWeHVYRzVjZEhWd1pHRjBaU2h2WW1vcE8xeHVYRzVjZEhKbGRIVnliaUJtZFc1amRHbHZiaUIxY0dSaGRHVlRkSGxzWlNodVpYZFBZbW9wSUh0Y2JseDBYSFJwWmlodVpYZFBZbW9wSUh0Y2JseDBYSFJjZEdsbUtHNWxkMDlpYWk1amMzTWdQVDA5SUc5aWFpNWpjM01nSmlZZ2JtVjNUMkpxTG0xbFpHbGhJRDA5UFNCdlltb3ViV1ZrYVdFZ0ppWWdibVYzVDJKcUxuTnZkWEpqWlUxaGNDQTlQVDBnYjJKcUxuTnZkWEpqWlUxaGNDbGNibHgwWEhSY2RGeDBjbVYwZFhKdU8xeHVYSFJjZEZ4MGRYQmtZWFJsS0c5aWFpQTlJRzVsZDA5aWFpazdYRzVjZEZ4MGZTQmxiSE5sSUh0Y2JseDBYSFJjZEhKbGJXOTJaU2dwTzF4dVhIUmNkSDFjYmx4MGZUdGNibjFjYmx4dWRtRnlJSEpsY0d4aFkyVlVaWGgwSUQwZ0tHWjFibU4wYVc5dUlDZ3BJSHRjYmx4MGRtRnlJSFJsZUhSVGRHOXlaU0E5SUZ0ZE8xeHVYRzVjZEhKbGRIVnliaUJtZFc1amRHbHZiaUFvYVc1a1pYZ3NJSEpsY0d4aFkyVnRaVzUwS1NCN1hHNWNkRngwZEdWNGRGTjBiM0psVzJsdVpHVjRYU0E5SUhKbGNHeGhZMlZ0Wlc1ME8xeHVYSFJjZEhKbGRIVnliaUIwWlhoMFUzUnZjbVV1Wm1sc2RHVnlLRUp2YjJ4bFlXNHBMbXB2YVc0b0oxeGNiaWNwTzF4dVhIUjlPMXh1ZlNrb0tUdGNibHh1Wm5WdVkzUnBiMjRnWVhCd2JIbFViMU5wYm1kc1pYUnZibFJoWnloemRIbHNaVVZzWlcxbGJuUXNJR2x1WkdWNExDQnlaVzF2ZG1Vc0lHOWlhaWtnZTF4dVhIUjJZWElnWTNOeklEMGdjbVZ0YjNabElEOGdYQ0pjSWlBNklHOWlhaTVqYzNNN1hHNWNibHgwYVdZZ0tITjBlV3hsUld4bGJXVnVkQzV6ZEhsc1pWTm9aV1YwS1NCN1hHNWNkRngwYzNSNWJHVkZiR1Z0Wlc1MExuTjBlV3hsVTJobFpYUXVZM056VkdWNGRDQTlJSEpsY0d4aFkyVlVaWGgwS0dsdVpHVjRMQ0JqYzNNcE8xeHVYSFI5SUdWc2MyVWdlMXh1WEhSY2RIWmhjaUJqYzNOT2IyUmxJRDBnWkc5amRXMWxiblF1WTNKbFlYUmxWR1Y0ZEU1dlpHVW9ZM056S1R0Y2JseDBYSFIyWVhJZ1kyaHBiR1JPYjJSbGN5QTlJSE4wZVd4bFJXeGxiV1Z1ZEM1amFHbHNaRTV2WkdWek8xeHVYSFJjZEdsbUlDaGphR2xzWkU1dlpHVnpXMmx1WkdWNFhTa2djM1I1YkdWRmJHVnRaVzUwTG5KbGJXOTJaVU5vYVd4a0tHTm9hV3hrVG05a1pYTmJhVzVrWlhoZEtUdGNibHgwWEhScFppQW9ZMmhwYkdST2IyUmxjeTVzWlc1bmRHZ3BJSHRjYmx4MFhIUmNkSE4wZVd4bFJXeGxiV1Z1ZEM1cGJuTmxjblJDWldadmNtVW9ZM056VG05a1pTd2dZMmhwYkdST2IyUmxjMXRwYm1SbGVGMHBPMXh1WEhSY2RIMGdaV3h6WlNCN1hHNWNkRngwWEhSemRIbHNaVVZzWlcxbGJuUXVZWEJ3Wlc1a1EyaHBiR1FvWTNOelRtOWtaU2s3WEc1Y2RGeDBmVnh1WEhSOVhHNTlYRzVjYm1aMWJtTjBhVzl1SUdGd2NHeDVWRzlVWVdjb2MzUjViR1ZGYkdWdFpXNTBMQ0J2WW1vcElIdGNibHgwZG1GeUlHTnpjeUE5SUc5aWFpNWpjM003WEc1Y2RIWmhjaUJ0WldScFlTQTlJRzlpYWk1dFpXUnBZVHRjYmx4dVhIUnBaaWh0WldScFlTa2dlMXh1WEhSY2RITjBlV3hsUld4bGJXVnVkQzV6WlhSQmRIUnlhV0oxZEdVb1hDSnRaV1JwWVZ3aUxDQnRaV1JwWVNsY2JseDBmVnh1WEc1Y2RHbG1LSE4wZVd4bFJXeGxiV1Z1ZEM1emRIbHNaVk5vWldWMEtTQjdYRzVjZEZ4MGMzUjViR1ZGYkdWdFpXNTBMbk4wZVd4bFUyaGxaWFF1WTNOelZHVjRkQ0E5SUdOemN6dGNibHgwZlNCbGJITmxJSHRjYmx4MFhIUjNhR2xzWlNoemRIbHNaVVZzWlcxbGJuUXVabWx5YzNSRGFHbHNaQ2tnZTF4dVhIUmNkRngwYzNSNWJHVkZiR1Z0Wlc1MExuSmxiVzkyWlVOb2FXeGtLSE4wZVd4bFJXeGxiV1Z1ZEM1bWFYSnpkRU5vYVd4a0tUdGNibHgwWEhSOVhHNWNkRngwYzNSNWJHVkZiR1Z0Wlc1MExtRndjR1Z1WkVOb2FXeGtLR1J2WTNWdFpXNTBMbU55WldGMFpWUmxlSFJPYjJSbEtHTnpjeWtwTzF4dVhIUjlYRzU5WEc1Y2JtWjFibU4wYVc5dUlIVndaR0YwWlV4cGJtc29iR2x1YTBWc1pXMWxiblFzSUc5d2RHbHZibk1zSUc5aWFpa2dlMXh1WEhSMllYSWdZM056SUQwZ2IySnFMbU56Y3p0Y2JseDBkbUZ5SUhOdmRYSmpaVTFoY0NBOUlHOWlhaTV6YjNWeVkyVk5ZWEE3WEc1Y2JseDBMeW9nU1dZZ1kyOXVkbVZ5ZEZSdlFXSnpiMngxZEdWVmNteHpJR2x6YmlkMElHUmxabWx1WldRc0lHSjFkQ0J6YjNWeVkyVnRZWEJ6SUdGeVpTQmxibUZpYkdWa1hHNWNkR0Z1WkNCMGFHVnlaU0JwY3lCdWJ5QndkV0pzYVdOUVlYUm9JR1JsWm1sdVpXUWdkR2hsYmlCc1pYUnpJSFIxY200Z1kyOXVkbVZ5ZEZSdlFXSnpiMngxZEdWVmNteHpYRzVjZEc5dUlHSjVJR1JsWm1GMWJIUXVJQ0JQZEdobGNuZHBjMlVnWkdWbVlYVnNkQ0IwYnlCMGFHVWdZMjl1ZG1WeWRGUnZRV0p6YjJ4MWRHVlZjbXh6SUc5d2RHbHZibHh1WEhSa2FYSmxZM1JzZVZ4dVhIUXFMMXh1WEhSMllYSWdZWFYwYjBacGVGVnliSE1nUFNCdmNIUnBiMjV6TG1OdmJuWmxjblJVYjBGaWMyOXNkWFJsVlhKc2N5QTlQVDBnZFc1a1pXWnBibVZrSUNZbUlITnZkWEpqWlUxaGNEdGNibHh1WEhScFppQW9iM0IwYVc5dWN5NWpiMjUyWlhKMFZHOUJZbk52YkhWMFpWVnliSE1nZkh3Z1lYVjBiMFpwZUZWeWJITXBlMXh1WEhSY2RHTnpjeUE5SUdacGVGVnliSE1vWTNOektUdGNibHgwZlZ4dVhHNWNkR2xtS0hOdmRYSmpaVTFoY0NrZ2UxeHVYSFJjZEM4dklHaDBkSEE2THk5emRHRmphMjkyWlhKbWJHOTNMbU52YlM5aEx6STJOakF6T0RjMVhHNWNkRngwWTNOeklDczlJRndpWEZ4dUx5b2pJSE52ZFhKalpVMWhjSEJwYm1kVlVrdzlaR0YwWVRwaGNIQnNhV05oZEdsdmJpOXFjMjl1TzJKaGMyVTJOQ3hjSWlBcklHSjBiMkVvZFc1bGMyTmhjR1VvWlc1amIyUmxWVkpKUTI5dGNHOXVaVzUwS0VwVFQwNHVjM1J5YVc1bmFXWjVLSE52ZFhKalpVMWhjQ2twS1NrZ0t5QmNJaUFxTDF3aU8xeHVYSFI5WEc1Y2JseDBkbUZ5SUdKc2IySWdQU0J1WlhjZ1FteHZZaWhiWTNOelhTd2dleUIwZVhCbE9pQmNJblJsZUhRdlkzTnpYQ0lnZlNrN1hHNWNibHgwZG1GeUlHOXNaRk55WXlBOUlHeHBibXRGYkdWdFpXNTBMbWh5WldZN1hHNWNibHgwYkdsdWEwVnNaVzFsYm5RdWFISmxaaUE5SUZWU1RDNWpjbVZoZEdWUFltcGxZM1JWVWt3b1lteHZZaWs3WEc1Y2JseDBhV1lvYjJ4a1UzSmpLVnh1WEhSY2RGVlNUQzV5WlhadmEyVlBZbXBsWTNSVlVrd29iMnhrVTNKaktUdGNibjFjYmx4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTh1WDNOMGVXeGxMV3h2WVdSbGNrQXdMakUyTGpGQWMzUjViR1V0Ykc5aFpHVnlMMkZrWkZOMGVXeGxjeTVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTVRCY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJbDBzSW5OdmRYSmpaVkp2YjNRaU9pSWlmUT09XCIpO1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCJcXG4vKipcXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xcbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxcbiAqXFxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXFxuICpcXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFxcXCJmaXhlc1xcXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXFxuICpcXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cXG4gKlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcXG5cXG4gIGlmICghbG9jYXRpb24pIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKFxcXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblxcXCIpO1xcbiAgfVxcblxcblxcdC8vIGJsYW5rIG9yIG51bGw/XFxuXFx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHQgIHJldHVybiBjc3M7XFxuICB9XFxuXFxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXFxcIi8vXFxcIiArIGxvY2F0aW9uLmhvc3Q7XFxuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXFxcL1teXFxcXC9dKiQvLCBcXFwiL1xcXCIpO1xcblxcblxcdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxcblxcdC8qXFxuXFx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cXG5cXHRhIHN0cmluZy5cXG5cXG5cXHQgL3VybFxcXFxzKlxcXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFxcXCJ1cmxcXFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcXG5cXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXFxuXFx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXFxuXFx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXFxuXFx0ICAgICAgICAgfCAgPSBPUlxcblxcdCAgICAgICAgIFxcXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcXG5cXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcXG5cXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcXG5cXHQgICAgICAgICAgICAgICAgIHwgID0gT1JcXG5cXHQgICAgICAgICAgICAgICAgIFxcXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcXG5cXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXFxuXFx0ICAgICAgICAgICAgICAgICBcXFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xcblxcdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxcbiAgICAgICAgICAgICAgKlxcXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcXG5cXHQgXFxcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcXG5cXG5cXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXFxuXFx0ICovXFxuXFx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxcXFxzKlxcXFwoKCg/OlteKShdfFxcXFwoKD86W14pKF0rfFxcXFwoW14pKF0qXFxcXCkpKlxcXFwpKSopXFxcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xcblxcdFxcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcXG5cXHRcXHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxcblxcdFxcdFxcdC50cmltKClcXG5cXHRcXHRcXHQucmVwbGFjZSgvXlxcXCIoLiopXFxcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcXG5cXHRcXHRcXHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XFxuXFxuXFx0XFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2VcXG5cXHRcXHRpZiAoL14oI3xkYXRhOnxodHRwOlxcXFwvXFxcXC98aHR0cHM6XFxcXC9cXFxcL3xmaWxlOlxcXFwvXFxcXC9cXFxcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcXG5cXHRcXHQgIHJldHVybiBmdWxsTWF0Y2g7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXFxuXFx0XFx0dmFyIG5ld1VybDtcXG5cXG5cXHRcXHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXFxcIi8vXFxcIikgPT09IDApIHtcXG5cXHRcXHQgIFxcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cXG5cXHRcXHRcXHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XFxuXFx0XFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcXFwiL1xcXCIpID09PSAwKSB7XFxuXFx0XFx0XFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXFxuXFx0XFx0XFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XFxuXFx0XFx0XFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFxcXC5cXFxcLy8sIFxcXCJcXFwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcXG5cXHRcXHRyZXR1cm4gXFxcInVybChcXFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFxcXCIpXFxcIjtcXG5cXHR9KTtcXG5cXG5cXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xcblxcdHJldHVybiBmaXhlZENzcztcXG59O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluZGxZbkJoWTJzNkx5OHZMaTkrTHk1ZmMzUjViR1V0Ykc5aFpHVnlRREF1TVRZdU1VQnpkSGxzWlMxc2IyRmtaWEl2Wm1sNFZYSnNjeTVxY3o5aE5HTTVJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3gzUTBGQmQwTXNWMEZCVnl4RlFVRkZPMEZCUTNKRUxIZERRVUYzUXl4WFFVRlhMRVZCUVVVN08wRkJSWEpFTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEVzYzBOQlFYTkRPMEZCUTNSRExFZEJRVWM3UVVGRFNEdEJRVU5CTERoRVFVRTRSRHRCUVVNNVJEczdRVUZGUVR0QlFVTkJPMEZCUTBFc1JVRkJSVHM3UVVGRlJqdEJRVU5CTzBGQlEwRWlMQ0ptYVd4bElqb2lNVEV1YW5NaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNiaThxS2x4dUlDb2dWMmhsYmlCemIzVnlZMlVnYldGd2N5QmhjbVVnWlc1aFlteGxaQ3dnWUhOMGVXeGxMV3h2WVdSbGNtQWdkWE5sY3lCaElHeHBibXNnWld4bGJXVnVkQ0IzYVhSb0lHRWdaR0YwWVMxMWNta2dkRzljYmlBcUlHVnRZbVZrSUhSb1pTQmpjM01nYjI0Z2RHaGxJSEJoWjJVdUlGUm9hWE1nWW5KbFlXdHpJR0ZzYkNCeVpXeGhkR2wyWlNCMWNteHpJR0psWTJGMWMyVWdibTkzSUhSb1pYa2dZWEpsSUhKbGJHRjBhWFpsSUhSdklHRmNiaUFxSUdKMWJtUnNaU0JwYm5OMFpXRmtJRzltSUhSb1pTQmpkWEp5Wlc1MElIQmhaMlV1WEc0Z0tseHVJQ29nVDI1bElITnZiSFYwYVc5dUlHbHpJSFJ2SUc5dWJIa2dkWE5sSUdaMWJHd2dkWEpzY3l3Z1luVjBJSFJvWVhRZ2JXRjVJR0psSUdsdGNHOXpjMmxpYkdVdVhHNGdLbHh1SUNvZ1NXNXpkR1ZoWkN3Z2RHaHBjeUJtZFc1amRHbHZiaUJjSW1acGVHVnpYQ0lnZEdobElISmxiR0YwYVhabElIVnliSE1nZEc4Z1ltVWdZV0p6YjJ4MWRHVWdZV05qYjNKa2FXNW5JSFJ2SUhSb1pTQmpkWEp5Wlc1MElIQmhaMlVnYkc5allYUnBiMjR1WEc0Z0tseHVJQ29nUVNCeWRXUnBiV1Z1ZEdGeWVTQjBaWE4wSUhOMWFYUmxJR2x6SUd4dlkyRjBaV1FnWVhRZ1lIUmxjM1F2Wm1sNFZYSnNjeTVxYzJBZ1lXNWtJR05oYmlCaVpTQnlkVzRnZG1saElIUm9aU0JnYm5CdElIUmxjM1JnSUdOdmJXMWhibVF1WEc0Z0tseHVJQ292WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0Z0tHTnpjeWtnZTF4dUlDQXZMeUJuWlhRZ1kzVnljbVZ1ZENCc2IyTmhkR2x2Ymx4dUlDQjJZWElnYkc5allYUnBiMjRnUFNCMGVYQmxiMllnZDJsdVpHOTNJQ0U5UFNCY0luVnVaR1ZtYVc1bFpGd2lJQ1ltSUhkcGJtUnZkeTVzYjJOaGRHbHZianRjYmx4dUlDQnBaaUFvSVd4dlkyRjBhVzl1S1NCN1hHNGdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLRndpWm1sNFZYSnNjeUJ5WlhGMWFYSmxjeUIzYVc1a2IzY3ViRzlqWVhScGIyNWNJaWs3WEc0Z0lIMWNibHh1WEhRdkx5QmliR0Z1YXlCdmNpQnVkV3hzUDF4dVhIUnBaaUFvSVdOemN5QjhmQ0IwZVhCbGIyWWdZM056SUNFOVBTQmNJbk4wY21sdVoxd2lLU0I3WEc1Y2RDQWdjbVYwZFhKdUlHTnpjenRjYmlBZ2ZWeHVYRzRnSUhaaGNpQmlZWE5sVlhKc0lEMGdiRzlqWVhScGIyNHVjSEp2ZEc5amIyd2dLeUJjSWk4dlhDSWdLeUJzYjJOaGRHbHZiaTVvYjNOME8xeHVJQ0IyWVhJZ1kzVnljbVZ1ZEVScGNpQTlJR0poYzJWVmNtd2dLeUJzYjJOaGRHbHZiaTV3WVhSb2JtRnRaUzV5WlhCc1lXTmxLQzljWEM5YlhseGNMMTBxSkM4c0lGd2lMMXdpS1R0Y2JseHVYSFF2THlCamIyNTJaWEowSUdWaFkyZ2dkWEpzS0M0dUxpbGNibHgwTHlwY2JseDBWR2hwY3lCeVpXZDFiR0Z5SUdWNGNISmxjM05wYjI0Z2FYTWdhblZ6ZENCaElIZGhlU0IwYnlCeVpXTjFjbk5wZG1Wc2VTQnRZWFJqYUNCaWNtRmphMlYwY3lCM2FYUm9hVzVjYmx4MFlTQnpkSEpwYm1jdVhHNWNibHgwSUM5MWNteGNYSE1xWEZ3b0lDQTlJRTFoZEdOb0lHOXVJSFJvWlNCM2IzSmtJRndpZFhKc1hDSWdkMmwwYUNCaGJua2dkMmhwZEdWemNHRmpaU0JoWm5SbGNpQnBkQ0JoYm1RZ2RHaGxiaUJoSUhCaGNtVnVjMXh1WEhRZ0lDQW9JQ0E5SUZOMFlYSjBJR0VnWTJGd2RIVnlhVzVuSUdkeWIzVndYRzVjZENBZ0lDQWdLRDg2SUNBOUlGTjBZWEowSUdFZ2JtOXVMV05oY0hSMWNtbHVaeUJuY205MWNGeHVYSFFnSUNBZ0lDQWdJQ0JiWGlrb1hTQWdQU0JOWVhSamFDQmhibmwwYUdsdVp5QjBhR0YwSUdsemJpZDBJR0VnY0dGeVpXNTBhR1Z6WlhOY2JseDBJQ0FnSUNBZ0lDQWdmQ0FnUFNCUFVseHVYSFFnSUNBZ0lDQWdJQ0JjWENnZ0lEMGdUV0YwWTJnZ1lTQnpkR0Z5ZENCd1lYSmxiblJvWlhObGMxeHVYSFFnSUNBZ0lDQWdJQ0FnSUNBZ0tEODZJQ0E5SUZOMFlYSjBJR0Z1YjNSb1pYSWdibTl1TFdOaGNIUjFjbWx1WnlCbmNtOTFjSE5jYmx4MElDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCYlhpa29YU3NnSUQwZ1RXRjBZMmdnWVc1NWRHaHBibWNnZEdoaGRDQnBjMjRuZENCaElIQmhjbVZ1ZEdobGMyVnpYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZkNBZ1BTQlBVbHh1WEhRZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUZ4Y0tDQWdQU0JOWVhSamFDQmhJSE4wWVhKMElIQmhjbVZ1ZEdobGMyVnpYRzVjZENBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lGdGVLU2hkS2lBZ1BTQk5ZWFJqYUNCaGJubDBhR2x1WnlCMGFHRjBJR2x6YmlkMElHRWdjR0Z5Wlc1MGFHVnpaWE5jYmx4MElDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCY1hDa2dJRDBnVFdGMFkyZ2dZU0JsYm1RZ2NHRnlaVzUwYUdWelpYTmNibHgwSUNBZ0lDQWdJQ0FnSUNBZ0lDa2dJRDBnUlc1a0lFZHliM1Z3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ3BjWENrZ1BTQk5ZWFJqYUNCaGJubDBhR2x1WnlCaGJtUWdkR2hsYmlCaElHTnNiM05sSUhCaGNtVnVjMXh1SUNBZ0lDQWdJQ0FnSUNrZ0lEMGdRMnh2YzJVZ2JtOXVMV05oY0hSMWNtbHVaeUJuY205MWNGeHVJQ0FnSUNBZ0lDQWdJQ29nSUQwZ1RXRjBZMmdnWVc1NWRHaHBibWRjYmlBZ0lDQWdJQ0FwSUNBOUlFTnNiM05sSUdOaGNIUjFjbWx1WnlCbmNtOTFjRnh1WEhRZ1hGd3BJQ0E5SUUxaGRHTm9JR0VnWTJ4dmMyVWdjR0Z5Wlc1elhHNWNibHgwSUM5bmFTQWdQU0JIWlhRZ1lXeHNJRzFoZEdOb1pYTXNJRzV2ZENCMGFHVWdabWx5YzNRdUlDQkNaU0JqWVhObElHbHVjMlZ1YzJsMGFYWmxMbHh1WEhRZ0tpOWNibHgwZG1GeUlHWnBlR1ZrUTNOeklEMGdZM056TG5KbGNHeGhZMlVvTDNWeWJGeGNjeXBjWENnb0tEODZXMTRwS0YxOFhGd29LRDg2VzE0cEtGMHJmRnhjS0Z0ZUtTaGRLbHhjS1NrcVhGd3BLU29wWEZ3cEwyZHBMQ0JtZFc1amRHbHZiaWhtZFd4c1RXRjBZMmdzSUc5eWFXZFZjbXdwSUh0Y2JseDBYSFF2THlCemRISnBjQ0J4ZFc5MFpYTWdLR2xtSUhSb1pYa2daWGhwYzNRcFhHNWNkRngwZG1GeUlIVnVjWFZ2ZEdWa1QzSnBaMVZ5YkNBOUlHOXlhV2RWY214Y2JseDBYSFJjZEM1MGNtbHRLQ2xjYmx4MFhIUmNkQzV5WlhCc1lXTmxLQzllWENJb0xpb3BYQ0lrTHl3Z1puVnVZM1JwYjI0b2J5d2dKREVwZXlCeVpYUjFjbTRnSkRFN0lIMHBYRzVjZEZ4MFhIUXVjbVZ3YkdGalpTZ3ZYaWNvTGlvcEp5UXZMQ0JtZFc1amRHbHZiaWh2TENBa01TbDdJSEpsZEhWeWJpQWtNVHNnZlNrN1hHNWNibHgwWEhRdkx5QmhiSEpsWVdSNUlHRWdablZzYkNCMWNtdy9JRzV2SUdOb1lXNW5aVnh1WEhSY2RHbG1JQ2d2WGlnamZHUmhkR0U2ZkdoMGRIQTZYRnd2WEZ3dmZHaDBkSEJ6T2x4Y0wxeGNMM3htYVd4bE9seGNMMXhjTDF4Y0x5a3ZhUzUwWlhOMEtIVnVjWFZ2ZEdWa1QzSnBaMVZ5YkNrcElIdGNibHgwWEhRZ0lISmxkSFZ5YmlCbWRXeHNUV0YwWTJnN1hHNWNkRngwZlZ4dVhHNWNkRngwTHk4Z1kyOXVkbVZ5ZENCMGFHVWdkWEpzSUhSdklHRWdablZzYkNCMWNteGNibHgwWEhSMllYSWdibVYzVlhKc08xeHVYRzVjZEZ4MGFXWWdLSFZ1Y1hWdmRHVmtUM0pwWjFWeWJDNXBibVJsZUU5bUtGd2lMeTljSWlrZ1BUMDlJREFwSUh0Y2JseDBYSFFnSUZ4MEx5OVVUMFJQT2lCemFHOTFiR1FnZDJVZ1lXUmtJSEJ5YjNSdlkyOXNQMXh1WEhSY2RGeDBibVYzVlhKc0lEMGdkVzV4ZFc5MFpXUlBjbWxuVlhKc08xeHVYSFJjZEgwZ1pXeHpaU0JwWmlBb2RXNXhkVzkwWldSUGNtbG5WWEpzTG1sdVpHVjRUMllvWENJdlhDSXBJRDA5UFNBd0tTQjdYRzVjZEZ4MFhIUXZMeUJ3WVhSb0lITm9iM1ZzWkNCaVpTQnlaV3hoZEdsMlpTQjBieUIwYUdVZ1ltRnpaU0IxY214Y2JseDBYSFJjZEc1bGQxVnliQ0E5SUdKaGMyVlZjbXdnS3lCMWJuRjFiM1JsWkU5eWFXZFZjbXc3SUM4dklHRnNjbVZoWkhrZ2MzUmhjblJ6SUhkcGRHZ2dKeThuWEc1Y2RGeDBmU0JsYkhObElIdGNibHgwWEhSY2RDOHZJSEJoZEdnZ2MyaHZkV3hrSUdKbElISmxiR0YwYVhabElIUnZJR04xY25KbGJuUWdaR2x5WldOMGIzSjVYRzVjZEZ4MFhIUnVaWGRWY213Z1BTQmpkWEp5Wlc1MFJHbHlJQ3NnZFc1eGRXOTBaV1JQY21sblZYSnNMbkpsY0d4aFkyVW9MMTVjWEM1Y1hDOHZMQ0JjSWx3aUtUc2dMeThnVTNSeWFYQWdiR1ZoWkdsdVp5QW5MaThuWEc1Y2RGeDBmVnh1WEc1Y2RGeDBMeThnYzJWdVpDQmlZV05ySUhSb1pTQm1hWGhsWkNCMWNtd29MaTR1S1Z4dVhIUmNkSEpsZEhWeWJpQmNJblZ5YkNoY0lpQXJJRXBUVDA0dWMzUnlhVzVuYVdaNUtHNWxkMVZ5YkNrZ0t5QmNJaWxjSWp0Y2JseDBmU2s3WEc1Y2JseDBMeThnYzJWdVpDQmlZV05ySUhSb1pTQm1hWGhsWkNCamMzTmNibHgwY21WMGRYSnVJR1pwZUdWa1EzTnpPMXh1ZlR0Y2JseHVYRzVjYmk4dkx5OHZMeTh2THk4dkx5OHZMeTh2TDF4dUx5OGdWMFZDVUVGRFN5QkdUMDlVUlZKY2JpOHZJQzR2Zmk4dVgzTjBlV3hsTFd4dllXUmxja0F3TGpFMkxqRkFjM1I1YkdVdGJHOWhaR1Z5TDJacGVGVnliSE11YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURFeFhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0pkTENKemIzVnlZMlZTYjI5MElqb2lJbjA9XCIpO1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCIvLyB0aGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxcbiAgcmF3U2NyaXB0RXhwb3J0cyxcXG4gIGNvbXBpbGVkVGVtcGxhdGUsXFxuICBzY29wZUlkLFxcbiAgY3NzTW9kdWxlc1xcbikge1xcbiAgdmFyIGVzTW9kdWxlXFxuICB2YXIgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzIHx8IHt9XFxuXFxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXFxuICB2YXIgdHlwZSA9IHR5cGVvZiByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcXG4gIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xcbiAgICBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XFxuICB9XFxuXFxuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXFxuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXFxuICAgIDogc2NyaXB0RXhwb3J0c1xcblxcbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xcbiAgaWYgKGNvbXBpbGVkVGVtcGxhdGUpIHtcXG4gICAgb3B0aW9ucy5yZW5kZXIgPSBjb21waWxlZFRlbXBsYXRlLnJlbmRlclxcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXFxuICB9XFxuXFxuICAvLyBzY29wZWRJZFxcbiAgaWYgKHNjb3BlSWQpIHtcXG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9IHNjb3BlSWRcXG4gIH1cXG5cXG4gIC8vIGluamVjdCBjc3NNb2R1bGVzXFxuICBpZiAoY3NzTW9kdWxlcykge1xcbiAgICB2YXIgY29tcHV0ZWQgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMuY29tcHV0ZWQgfHwgbnVsbClcXG4gICAgT2JqZWN0LmtleXMoY3NzTW9kdWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgdmFyIG1vZHVsZSA9IGNzc01vZHVsZXNba2V5XVxcbiAgICAgIGNvbXB1dGVkW2tleV0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2R1bGUgfVxcbiAgICB9KVxcbiAgICBvcHRpb25zLmNvbXB1dGVkID0gY29tcHV0ZWRcXG4gIH1cXG5cXG4gIHJldHVybiB7XFxuICAgIGVzTW9kdWxlOiBlc01vZHVsZSxcXG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcXG4gICAgb3B0aW9uczogb3B0aW9uc1xcbiAgfVxcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbmRsWW5CaFkyczZMeTh2TGk5K0x5NWZkblZsTFd4dllXUmxja0F4TVM0ekxqUkFkblZsTFd4dllXUmxjaTlzYVdJdlkyOXRjRzl1Wlc1MExXNXZjbTFoYkdsNlpYSXVhbk0vTmpJek9TSmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaVFVRkJRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHMURRVUZ0UXp0QlFVTnVReXhMUVVGTE8wRkJRMHc3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVpTENKbWFXeGxJam9pTVRJdWFuTWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUl2THlCMGFHbHpJRzF2WkhWc1pTQnBjeUJoSUhKMWJuUnBiV1VnZFhScGJHbDBlU0JtYjNJZ1kyeGxZVzVsY2lCamIyMXdiMjVsYm5RZ2JXOWtkV3hsSUc5MWRIQjFkQ0JoYm1RZ2QybHNiRnh1THk4Z1ltVWdhVzVqYkhWa1pXUWdhVzRnZEdobElHWnBibUZzSUhkbFluQmhZMnNnZFhObGNpQmlkVzVrYkdWY2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpQnViM0p0WVd4cGVtVkRiMjF3YjI1bGJuUWdLRnh1SUNCeVlYZFRZM0pwY0hSRmVIQnZjblJ6TEZ4dUlDQmpiMjF3YVd4bFpGUmxiWEJzWVhSbExGeHVJQ0J6WTI5d1pVbGtMRnh1SUNCamMzTk5iMlIxYkdWelhHNHBJSHRjYmlBZ2RtRnlJR1Z6VFc5a2RXeGxYRzRnSUhaaGNpQnpZM0pwY0hSRmVIQnZjblJ6SUQwZ2NtRjNVMk55YVhCMFJYaHdiM0owY3lBOUlISmhkMU5qY21sd2RFVjRjRzl5ZEhNZ2ZId2dlMzFjYmx4dUlDQXZMeUJGVXpZZ2JXOWtkV3hsY3lCcGJuUmxjbTl3WEc0Z0lIWmhjaUIwZVhCbElEMGdkSGx3Wlc5bUlISmhkMU5qY21sd2RFVjRjRzl5ZEhNdVpHVm1ZWFZzZEZ4dUlDQnBaaUFvZEhsd1pTQTlQVDBnSjI5aWFtVmpkQ2NnZkh3Z2RIbHdaU0E5UFQwZ0oyWjFibU4wYVc5dUp5a2dlMXh1SUNBZ0lHVnpUVzlrZFd4bElEMGdjbUYzVTJOeWFYQjBSWGh3YjNKMGMxeHVJQ0FnSUhOamNtbHdkRVY0Y0c5eWRITWdQU0J5WVhkVFkzSnBjSFJGZUhCdmNuUnpMbVJsWm1GMWJIUmNiaUFnZlZ4dVhHNGdJQzh2SUZaMVpTNWxlSFJsYm1RZ1kyOXVjM1J5ZFdOMGIzSWdaWGh3YjNKMElHbHVkR1Z5YjNCY2JpQWdkbUZ5SUc5d2RHbHZibk1nUFNCMGVYQmxiMllnYzJOeWFYQjBSWGh3YjNKMGN5QTlQVDBnSjJaMWJtTjBhVzl1SjF4dUlDQWdJRDhnYzJOeWFYQjBSWGh3YjNKMGN5NXZjSFJwYjI1elhHNGdJQ0FnT2lCelkzSnBjSFJGZUhCdmNuUnpYRzVjYmlBZ0x5OGdjbVZ1WkdWeUlHWjFibU4wYVc5dWMxeHVJQ0JwWmlBb1kyOXRjR2xzWldSVVpXMXdiR0YwWlNrZ2UxeHVJQ0FnSUc5d2RHbHZibk11Y21WdVpHVnlJRDBnWTI5dGNHbHNaV1JVWlcxd2JHRjBaUzV5Wlc1a1pYSmNiaUFnSUNCdmNIUnBiMjV6TG5OMFlYUnBZMUpsYm1SbGNrWnVjeUE5SUdOdmJYQnBiR1ZrVkdWdGNHeGhkR1V1YzNSaGRHbGpVbVZ1WkdWeVJtNXpYRzRnSUgxY2JseHVJQ0F2THlCelkyOXdaV1JKWkZ4dUlDQnBaaUFvYzJOdmNHVkpaQ2tnZTF4dUlDQWdJRzl3ZEdsdmJuTXVYM05qYjNCbFNXUWdQU0J6WTI5d1pVbGtYRzRnSUgxY2JseHVJQ0F2THlCcGJtcGxZM1FnWTNOelRXOWtkV3hsYzF4dUlDQnBaaUFvWTNOelRXOWtkV3hsY3lrZ2UxeHVJQ0FnSUhaaGNpQmpiMjF3ZFhSbFpDQTlJRTlpYW1WamRDNWpjbVZoZEdVb2IzQjBhVzl1Y3k1amIyMXdkWFJsWkNCOGZDQnVkV3hzS1Z4dUlDQWdJRTlpYW1WamRDNXJaWGx6S0dOemMwMXZaSFZzWlhNcExtWnZja1ZoWTJnb1puVnVZM1JwYjI0Z0tHdGxlU2tnZTF4dUlDQWdJQ0FnZG1GeUlHMXZaSFZzWlNBOUlHTnpjMDF2WkhWc1pYTmJhMlY1WFZ4dUlDQWdJQ0FnWTI5dGNIVjBaV1JiYTJWNVhTQTlJR1oxYm1OMGFXOXVJQ2dwSUhzZ2NtVjBkWEp1SUcxdlpIVnNaU0I5WEc0Z0lDQWdmU2xjYmlBZ0lDQnZjSFJwYjI1ekxtTnZiWEIxZEdWa0lEMGdZMjl0Y0hWMFpXUmNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQjdYRzRnSUNBZ1pYTk5iMlIxYkdVNklHVnpUVzlrZFd4bExGeHVJQ0FnSUdWNGNHOXlkSE02SUhOamNtbHdkRVY0Y0c5eWRITXNYRzRnSUNBZ2IzQjBhVzl1Y3pvZ2IzQjBhVzl1YzF4dUlDQjlYRzU5WEc1Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2TGw5MmRXVXRiRzloWkdWeVFERXhMak11TkVCMmRXVXRiRzloWkdWeUwyeHBZaTlqYjIxd2IyNWxiblF0Ym05eWJXRnNhWHBsY2k1cWMxeHVMeThnYlc5a2RXeGxJR2xrSUQwZ01USmNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWwwc0luTnZkWEpqWlZKdmIzUWlPaUlpZlE9PVwiKTtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcXG4gIHJldHVybiBfYygnZGl2Jywge1xcbiAgICBhdHRyczoge1xcbiAgICAgIFxcXCJpZFxcXCI6IFxcXCJhcHBcXFwiXFxuICAgIH1cXG4gIH0sIFtfYygnaDEnLCBbX3ZtLl92KF92bS5fcyhfdm0ubXNnKSldKV0pXFxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxcbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxcbmlmIChmYWxzZSkge1xcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xcbiAgICAgcmVxdWlyZShcXFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXFxcIikucmVyZW5kZXIoXFxcImRhdGEtdi03ZGUzZTdkOFxcXCIsIG1vZHVsZS5leHBvcnRzKVxcbiAgfVxcbn0vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbmRsWW5CaFkyczZMeTh2TGk5aGNIQXZkblZsTG5aMVpUOWtZVEUxSWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxHZENRVUZuUWl4dFFrRkJiVUlzWVVGQllTd3dRa0ZCTUVJN1FVRkRNVVU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnc1EwRkJRenRCUVVORU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJJaXdpWm1sc1pTSTZJakV6TG1weklpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2liVzlrZFd4bExtVjRjRzl5ZEhNOWUzSmxibVJsY2pwbWRXNWpkR2x2YmlBb0tYdDJZWElnWDNadFBYUm9hWE03ZG1GeUlGOW9QVjkyYlM0a1kzSmxZWFJsUld4bGJXVnVkRHQyWVhJZ1gyTTlYM1p0TGw5elpXeG1MbDlqZkh4ZmFEdGNiaUFnY21WMGRYSnVJRjlqS0Nka2FYWW5MQ0I3WEc0Z0lDQWdZWFIwY25NNklIdGNiaUFnSUNBZ0lGd2lhV1JjSWpvZ1hDSmhjSEJjSWx4dUlDQWdJSDFjYmlBZ2ZTd2dXMTlqS0Nkb01TY3NJRnRmZG0wdVgzWW9YM1p0TGw5ektGOTJiUzV0YzJjcEtWMHBYU2xjYm4wc2MzUmhkR2xqVW1WdVpHVnlSbTV6T2lCYlhYMWNibTF2WkhWc1pTNWxlSEJ2Y25SekxuSmxibVJsY2k1ZmQybDBhRk4wY21sd2NHVmtJRDBnZEhKMVpWeHVhV1lnS0cxdlpIVnNaUzVvYjNRcElIdGNiaUFnYlc5a2RXeGxMbWh2ZEM1aFkyTmxjSFFvS1Z4dUlDQnBaaUFvYlc5a2RXeGxMbWh2ZEM1a1lYUmhLU0I3WEc0Z0lDQWdJSEpsY1hWcGNtVW9YQ0oyZFdVdGJHOWhaR1Z5TDI1dlpHVmZiVzlrZFd4bGN5OTJkV1V0YUc5MExYSmxiRzloWkMxaGNHbGNJaWt1Y21WeVpXNWtaWElvWENKa1lYUmhMWFl0TjJSbE0yVTNaRGhjSWl3Z2JXOWtkV3hsTG1WNGNHOXlkSE1wWEc0Z0lIMWNibjFjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZMbDkyZFdVdGJHOWhaR1Z5UURFeExqTXVORUIyZFdVdGJHOWhaR1Z5TDJ4cFlpOTBaVzF3YkdGMFpTMWpiMjF3YVd4bGNqOTdYQ0pwWkZ3aU9sd2laR0YwWVMxMkxUZGtaVE5sTjJRNFhDSjlJUzR2Zmk4dVgzWjFaUzFzYjJGa1pYSkFNVEV1TXk0MFFIWjFaUzFzYjJGa1pYSXZiR2xpTDNObGJHVmpkRzl5TG1welAzUjVjR1U5ZEdWdGNHeGhkR1VtYVc1a1pYZzlNQ0V1TDJGd2NDOTJkV1V1ZG5WbFhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBeE0xeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpWFN3aWMyOTFjbU5sVW05dmRDSTZJaUo5XCIpO1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcXG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XFxuXFxudmFyIGxvb2t1cCA9IFtdXFxudmFyIHJldkxvb2t1cCA9IFtdXFxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxcblxcbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXFxuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcXG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxcbn1cXG5cXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcXG5cXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XFxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXFxuICB9XFxuXFxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXFxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXFxufVxcblxcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXFxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxcbn1cXG5cXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XFxuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcXG5cXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXFxuXFxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXFxuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cXG5cXG4gIHZhciBMID0gMFxcblxcbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcXG4gIH1cXG5cXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcXG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXFxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBhcnJcXG59XFxuXFxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcXG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxcbn1cXG5cXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciB0bXBcXG4gIHZhciBvdXRwdXQgPSBbXVxcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcXG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcXG4gIH1cXG4gIHJldHVybiBvdXRwdXQuam9pbignJylcXG59XFxuXFxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcXG4gIHZhciB0bXBcXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xcbiAgdmFyIG91dHB1dCA9ICcnXFxuICB2YXIgcGFydHMgPSBbXVxcbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXFxuXFxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXFxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XFxuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXFxuICB9XFxuXFxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXFxuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxcbiAgICBvdXRwdXQgKz0gJz09J1xcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XFxuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXFxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXFxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXFxuICAgIG91dHB1dCArPSAnPSdcXG4gIH1cXG5cXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxcblxcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluZGxZbkJoWTJzNkx5OHZMaTkrTDJKaGMyVTJOQzFxY3k5cGJtUmxlQzVxY3o4eVlXUmtJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRU3hyUTBGQmEwTXNVMEZCVXp0QlFVTXpRenRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN08wRkJSVUVzYjBKQlFXOUNMRTlCUVU4N1FVRkRNMEk3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNjVUpCUVhGQ0xGTkJRVk03UVVGRE9VSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTERCRFFVRXdReXhWUVVGVk8wRkJRM0JFTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQklpd2labWxzWlNJNklqRTBMbXB6SWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaUozVnpaU0J6ZEhKcFkzUW5YRzVjYm1WNGNHOXlkSE11WW5sMFpVeGxibWQwYUNBOUlHSjVkR1ZNWlc1bmRHaGNibVY0Y0c5eWRITXVkRzlDZVhSbFFYSnlZWGtnUFNCMGIwSjVkR1ZCY25KaGVWeHVaWGh3YjNKMGN5NW1jbTl0UW5sMFpVRnljbUY1SUQwZ1puSnZiVUo1ZEdWQmNuSmhlVnh1WEc1MllYSWdiRzl2YTNWd0lEMGdXMTFjYm5aaGNpQnlaWFpNYjI5cmRYQWdQU0JiWFZ4dWRtRnlJRUZ5Y2lBOUlIUjVjR1Z2WmlCVmFXNTBPRUZ5Y21GNUlDRTlQU0FuZFc1a1pXWnBibVZrSnlBL0lGVnBiblE0UVhKeVlYa2dPaUJCY25KaGVWeHVYRzUyWVhJZ1kyOWtaU0E5SUNkQlFrTkVSVVpIU0VsS1MweE5UazlRVVZKVFZGVldWMWhaV21GaVkyUmxabWRvYVdwcmJHMXViM0J4Y25OMGRYWjNlSGw2TURFeU16UTFOamM0T1NzdkoxeHVabTl5SUNoMllYSWdhU0E5SURBc0lHeGxiaUE5SUdOdlpHVXViR1Z1WjNSb095QnBJRHdnYkdWdU95QXJLMmtwSUh0Y2JpQWdiRzl2YTNWd1cybGRJRDBnWTI5a1pWdHBYVnh1SUNCeVpYWk1iMjlyZFhCYlkyOWtaUzVqYUdGeVEyOWtaVUYwS0drcFhTQTlJR2xjYm4xY2JseHVjbVYyVEc5dmEzVndXeWN0Snk1amFHRnlRMjlrWlVGMEtEQXBYU0E5SURZeVhHNXlaWFpNYjI5cmRYQmJKMThuTG1Ob1lYSkRiMlJsUVhRb01DbGRJRDBnTmpOY2JseHVablZ1WTNScGIyNGdjR3hoWTJWSWIyeGtaWEp6UTI5MWJuUWdLR0kyTkNrZ2UxeHVJQ0IyWVhJZ2JHVnVJRDBnWWpZMExteGxibWQwYUZ4dUlDQnBaaUFvYkdWdUlDVWdOQ0ErSURBcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjBsdWRtRnNhV1FnYzNSeWFXNW5MaUJNWlc1bmRHZ2diWFZ6ZENCaVpTQmhJRzExYkhScGNHeGxJRzltSURRbktWeHVJQ0I5WEc1Y2JpQWdMeThnZEdobElHNTFiV0psY2lCdlppQmxjWFZoYkNCemFXZHVjeUFvY0d4aFkyVWdhRzlzWkdWeWN5bGNiaUFnTHk4Z2FXWWdkR2hsY21VZ1lYSmxJSFIzYnlCd2JHRmpaV2h2YkdSbGNuTXNJSFJvWVc0Z2RHaGxJSFIzYnlCamFHRnlZV04wWlhKeklHSmxabTl5WlNCcGRGeHVJQ0F2THlCeVpYQnlaWE5sYm5RZ2IyNWxJR0o1ZEdWY2JpQWdMeThnYVdZZ2RHaGxjbVVnYVhNZ2IyNXNlU0J2Ym1Vc0lIUm9aVzRnZEdobElIUm9jbVZsSUdOb1lYSmhZM1JsY25NZ1ltVm1iM0psSUdsMElISmxjSEpsYzJWdWRDQXlJR0o1ZEdWelhHNGdJQzh2SUhSb2FYTWdhWE1nYW5WemRDQmhJR05vWldGd0lHaGhZMnNnZEc4Z2JtOTBJR1J2SUdsdVpHVjRUMllnZEhkcFkyVmNiaUFnY21WMGRYSnVJR0kyTkZ0c1pXNGdMU0F5WFNBOVBUMGdKejBuSUQ4Z01pQTZJR0kyTkZ0c1pXNGdMU0F4WFNBOVBUMGdKejBuSUQ4Z01TQTZJREJjYm4xY2JseHVablZ1WTNScGIyNGdZbmwwWlV4bGJtZDBhQ0FvWWpZMEtTQjdYRzRnSUM4dklHSmhjMlUyTkNCcGN5QTBMek1nS3lCMWNDQjBieUIwZDI4Z1kyaGhjbUZqZEdWeWN5QnZaaUIwYUdVZ2IzSnBaMmx1WVd3Z1pHRjBZVnh1SUNCeVpYUjFjbTRnWWpZMExteGxibWQwYUNBcUlETWdMeUEwSUMwZ2NHeGhZMlZJYjJ4a1pYSnpRMjkxYm5Rb1lqWTBLVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQjBiMEo1ZEdWQmNuSmhlU0FvWWpZMEtTQjdYRzRnSUhaaGNpQnBMQ0JxTENCc0xDQjBiWEFzSUhCc1lXTmxTRzlzWkdWeWN5d2dZWEp5WEc0Z0lIWmhjaUJzWlc0Z1BTQmlOalF1YkdWdVozUm9YRzRnSUhCc1lXTmxTRzlzWkdWeWN5QTlJSEJzWVdObFNHOXNaR1Z5YzBOdmRXNTBLR0kyTkNsY2JseHVJQ0JoY25JZ1BTQnVaWGNnUVhKeUtHeGxiaUFxSURNZ0x5QTBJQzBnY0d4aFkyVkliMnhrWlhKektWeHVYRzRnSUM4dklHbG1JSFJvWlhKbElHRnlaU0J3YkdGalpXaHZiR1JsY25Nc0lHOXViSGtnWjJWMElIVndJSFJ2SUhSb1pTQnNZWE4wSUdOdmJYQnNaWFJsSURRZ1kyaGhjbk5jYmlBZ2JDQTlJSEJzWVdObFNHOXNaR1Z5Y3lBK0lEQWdQeUJzWlc0Z0xTQTBJRG9nYkdWdVhHNWNiaUFnZG1GeUlFd2dQU0F3WEc1Y2JpQWdabTl5SUNocElEMGdNQ3dnYWlBOUlEQTdJR2tnUENCc095QnBJQ3M5SURRc0lHb2dLejBnTXlrZ2UxeHVJQ0FnSUhSdGNDQTlJQ2h5WlhaTWIyOXJkWEJiWWpZMExtTm9ZWEpEYjJSbFFYUW9hU2xkSUR3OElERTRLU0I4SUNoeVpYWk1iMjlyZFhCYllqWTBMbU5vWVhKRGIyUmxRWFFvYVNBcklERXBYU0E4UENBeE1pa2dmQ0FvY21WMlRHOXZhM1Z3VzJJMk5DNWphR0Z5UTI5a1pVRjBLR2tnS3lBeUtWMGdQRHdnTmlrZ2ZDQnlaWFpNYjI5cmRYQmJZalkwTG1Ob1lYSkRiMlJsUVhRb2FTQXJJRE1wWFZ4dUlDQWdJR0Z5Y2x0TUt5dGRJRDBnS0hSdGNDQStQaUF4TmlrZ0ppQXdlRVpHWEc0Z0lDQWdZWEp5VzB3cksxMGdQU0FvZEcxd0lENCtJRGdwSUNZZ01IaEdSbHh1SUNBZ0lHRnljbHRNS3l0ZElEMGdkRzF3SUNZZ01IaEdSbHh1SUNCOVhHNWNiaUFnYVdZZ0tIQnNZV05sU0c5c1pHVnljeUE5UFQwZ01pa2dlMXh1SUNBZ0lIUnRjQ0E5SUNoeVpYWk1iMjlyZFhCYllqWTBMbU5vWVhKRGIyUmxRWFFvYVNsZElEdzhJRElwSUh3Z0tISmxka3h2YjJ0MWNGdGlOalF1WTJoaGNrTnZaR1ZCZENocElDc2dNU2xkSUQ0K0lEUXBYRzRnSUNBZ1lYSnlXMHdySzEwZ1BTQjBiWEFnSmlBd2VFWkdYRzRnSUgwZ1pXeHpaU0JwWmlBb2NHeGhZMlZJYjJ4a1pYSnpJRDA5UFNBeEtTQjdYRzRnSUNBZ2RHMXdJRDBnS0hKbGRreHZiMnQxY0Z0aU5qUXVZMmhoY2tOdlpHVkJkQ2hwS1YwZ1BEd2dNVEFwSUh3Z0tISmxka3h2YjJ0MWNGdGlOalF1WTJoaGNrTnZaR1ZCZENocElDc2dNU2xkSUR3OElEUXBJSHdnS0hKbGRreHZiMnQxY0Z0aU5qUXVZMmhoY2tOdlpHVkJkQ2hwSUNzZ01pbGRJRDQrSURJcFhHNGdJQ0FnWVhKeVcwd3JLMTBnUFNBb2RHMXdJRDQrSURncElDWWdNSGhHUmx4dUlDQWdJR0Z5Y2x0TUt5dGRJRDBnZEcxd0lDWWdNSGhHUmx4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUdGeWNseHVmVnh1WEc1bWRXNWpkR2x2YmlCMGNtbHdiR1YwVkc5Q1lYTmxOalFnS0c1MWJTa2dlMXh1SUNCeVpYUjFjbTRnYkc5dmEzVndXMjUxYlNBK1BpQXhPQ0FtSURCNE0wWmRJQ3NnYkc5dmEzVndXMjUxYlNBK1BpQXhNaUFtSURCNE0wWmRJQ3NnYkc5dmEzVndXMjUxYlNBK1BpQTJJQ1lnTUhnelJsMGdLeUJzYjI5cmRYQmJiblZ0SUNZZ01IZ3pSbDFjYm4xY2JseHVablZ1WTNScGIyNGdaVzVqYjJSbFEyaDFibXNnS0hWcGJuUTRMQ0J6ZEdGeWRDd2daVzVrS1NCN1hHNGdJSFpoY2lCMGJYQmNiaUFnZG1GeUlHOTFkSEIxZENBOUlGdGRYRzRnSUdadmNpQW9kbUZ5SUdrZ1BTQnpkR0Z5ZERzZ2FTQThJR1Z1WkRzZ2FTQXJQU0F6S1NCN1hHNGdJQ0FnZEcxd0lEMGdLSFZwYm5RNFcybGRJRHc4SURFMktTQXJJQ2gxYVc1ME9GdHBJQ3NnTVYwZ1BEd2dPQ2tnS3lBb2RXbHVkRGhiYVNBcklESmRLVnh1SUNBZ0lHOTFkSEIxZEM1d2RYTm9LSFJ5YVhCc1pYUlViMEpoYzJVMk5DaDBiWEFwS1Z4dUlDQjlYRzRnSUhKbGRIVnliaUJ2ZFhSd2RYUXVhbTlwYmlnbkp5bGNibjFjYmx4dVpuVnVZM1JwYjI0Z1puSnZiVUo1ZEdWQmNuSmhlU0FvZFdsdWREZ3BJSHRjYmlBZ2RtRnlJSFJ0Y0Z4dUlDQjJZWElnYkdWdUlEMGdkV2x1ZERndWJHVnVaM1JvWEc0Z0lIWmhjaUJsZUhSeVlVSjVkR1Z6SUQwZ2JHVnVJQ1VnTXlBdkx5QnBaaUIzWlNCb1lYWmxJREVnWW5sMFpTQnNaV1owTENCd1lXUWdNaUJpZVhSbGMxeHVJQ0IyWVhJZ2IzVjBjSFYwSUQwZ0p5ZGNiaUFnZG1GeUlIQmhjblJ6SUQwZ1cxMWNiaUFnZG1GeUlHMWhlRU5vZFc1clRHVnVaM1JvSUQwZ01UWXpPRE1nTHk4Z2JYVnpkQ0JpWlNCdGRXeDBhWEJzWlNCdlppQXpYRzVjYmlBZ0x5OGdaMjhnZEdoeWIzVm5hQ0IwYUdVZ1lYSnlZWGtnWlhabGNua2dkR2h5WldVZ1lubDBaWE1zSUhkbEoyeHNJR1JsWVd3Z2QybDBhQ0IwY21GcGJHbHVaeUJ6ZEhWbVppQnNZWFJsY2x4dUlDQm1iM0lnS0haaGNpQnBJRDBnTUN3Z2JHVnVNaUE5SUd4bGJpQXRJR1Y0ZEhKaFFubDBaWE03SUdrZ1BDQnNaVzR5T3lCcElDczlJRzFoZUVOb2RXNXJUR1Z1WjNSb0tTQjdYRzRnSUNBZ2NHRnlkSE11Y0hWemFDaGxibU52WkdWRGFIVnVheWgxYVc1ME9Dd2dhU3dnS0drZ0t5QnRZWGhEYUhWdWEweGxibWQwYUNrZ1BpQnNaVzR5SUQ4Z2JHVnVNaUE2SUNocElDc2diV0Y0UTJoMWJtdE1aVzVuZEdncEtTbGNiaUFnZlZ4dVhHNGdJQzh2SUhCaFpDQjBhR1VnWlc1a0lIZHBkR2dnZW1WeWIzTXNJR0oxZENCdFlXdGxJSE4xY21VZ2RHOGdibTkwSUdadmNtZGxkQ0IwYUdVZ1pYaDBjbUVnWW5sMFpYTmNiaUFnYVdZZ0tHVjRkSEpoUW5sMFpYTWdQVDA5SURFcElIdGNiaUFnSUNCMGJYQWdQU0IxYVc1ME9GdHNaVzRnTFNBeFhWeHVJQ0FnSUc5MWRIQjFkQ0FyUFNCc2IyOXJkWEJiZEcxd0lENCtJREpkWEc0Z0lDQWdiM1YwY0hWMElDczlJR3h2YjJ0MWNGc29kRzF3SUR3OElEUXBJQ1lnTUhnelJsMWNiaUFnSUNCdmRYUndkWFFnS3owZ0p6MDlKMXh1SUNCOUlHVnNjMlVnYVdZZ0tHVjRkSEpoUW5sMFpYTWdQVDA5SURJcElIdGNiaUFnSUNCMGJYQWdQU0FvZFdsdWREaGJiR1Z1SUMwZ01sMGdQRHdnT0NrZ0t5QW9kV2x1ZERoYmJHVnVJQzBnTVYwcFhHNGdJQ0FnYjNWMGNIVjBJQ3M5SUd4dmIydDFjRnQwYlhBZ1BqNGdNVEJkWEc0Z0lDQWdiM1YwY0hWMElDczlJR3h2YjJ0MWNGc29kRzF3SUQ0K0lEUXBJQ1lnTUhnelJsMWNiaUFnSUNCdmRYUndkWFFnS3owZ2JHOXZhM1Z3V3loMGJYQWdQRHdnTWlrZ0ppQXdlRE5HWFZ4dUlDQWdJRzkxZEhCMWRDQXJQU0FuUFNkY2JpQWdmVnh1WEc0Z0lIQmhjblJ6TG5CMWMyZ29iM1YwY0hWMEtWeHVYRzRnSUhKbGRIVnliaUJ3WVhKMGN5NXFiMmx1S0NjbktWeHVmVnh1WEc1Y2JseHVMeTh2THk4dkx5OHZMeTh2THk4dkx5OHZYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVbHh1THk4Z0xpOStMMkpoYzJVMk5DMXFjeTlwYm1SbGVDNXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdNVFJjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lsMHNJbk52ZFhKalpWSnZiM1FpT2lJaWZRPT1cIik7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIVxcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxcbiAqXFxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XFxuICogQGxpY2Vuc2UgIE1JVFxcbiAqL1xcbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXFxuXFxuXFxuXFxudmFyIGJhc2U2NCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpXFxudmFyIGllZWU3NTQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KVxcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNylcXG5cXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcXG5cXG4vKipcXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXFxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxcbiAqXFxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cXG4gKlxcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cXG4gKlxcbiAqIE5vdGU6XFxuICpcXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cXG4gKlxcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxcbiAqXFxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXFxuXFxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcXG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cXG4gKi9cXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxcblxcbi8qXFxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxcbiAqL1xcbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxcblxcbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcXG4gIHRyeSB7XFxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxcbiAgfSBjYXRjaCAoZSkge1xcbiAgICByZXR1cm4gZmFsc2VcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XFxuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcXG4gICAgPyAweDdmZmZmZmZmXFxuICAgIDogMHgzZmZmZmZmZlxcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxcbiAgfVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcXG4gIH0gZWxzZSB7XFxuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcXG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXFxuICAgIH1cXG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcXG4gIH1cXG5cXG4gIHJldHVybiB0aGF0XFxufVxcblxcbi8qKlxcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXFxuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcXG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxcbiAqXFxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxcbiAqL1xcblxcbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcXG4gIH1cXG5cXG4gIC8vIENvbW1vbiBjYXNlLlxcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XFxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXFxuICAgICAgKVxcbiAgICB9XFxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXFxuICB9XFxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXFxuXFxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXFxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcXG4gIHJldHVybiBhcnJcXG59XFxuXFxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcInZhbHVlXFxcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXFxuICB9XFxuXFxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XFxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcXG4gIH1cXG5cXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XFxuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxcbiAgfVxcblxcbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXFxufVxcblxcbi8qKlxcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXFxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXFxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcXG4gKiovXFxuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXFxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXFxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XFxuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XFxuICAgICAgdmFsdWU6IG51bGwsXFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXFxuICAgIH0pXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcXG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcInNpemVcXFwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFxcInNpemVcXFwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XFxuICBhc3NlcnRTaXplKHNpemUpXFxuICBpZiAoc2l6ZSA8PSAwKSB7XFxuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcXG4gIH1cXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcXG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXFxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXFxuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXFxuICB9XFxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXFxufVxcblxcbi8qKlxcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXFxuICoqL1xcbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxcbn1cXG5cXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xcbiAgYXNzZXJ0U2l6ZShzaXplKVxcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcXG4gICAgICB0aGF0W2ldID0gMFxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gdGhhdFxcbn1cXG5cXG4vKipcXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxcbiAqICovXFxuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcXG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxcbn1cXG4vKipcXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cXG4gKi9cXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcXG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XFxuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcXG4gICAgZW5jb2RpbmcgPSAndXRmOCdcXG4gIH1cXG5cXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJlbmNvZGluZ1xcXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXFxuICB9XFxuXFxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxcblxcbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcXG5cXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXFxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcXG4gIH1cXG5cXG4gIHJldHVybiB0aGF0XFxufVxcblxcbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XFxuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XFxuICB9XFxuICByZXR1cm4gdGhhdFxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxcblxcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXFxcJ29mZnNldFxcXFwnIGlzIG91dCBvZiBib3VuZHMnKVxcbiAgfVxcblxcbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFxcXCdsZW5ndGhcXFxcJyBpcyBvdXQgb2YgYm91bmRzJylcXG4gIH1cXG5cXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcXG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcXG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcXG4gIH0gZWxzZSB7XFxuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcXG4gIH1cXG5cXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcXG4gICAgdGhhdCA9IGFycmF5XFxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxcbiAgfSBlbHNlIHtcXG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcXG4gIH1cXG4gIHJldHVybiB0aGF0XFxufVxcblxcbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XFxuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcXG5cXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XFxuICAgICAgcmV0dXJuIHRoYXRcXG4gICAgfVxcblxcbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXFxuICAgIHJldHVybiB0aGF0XFxuICB9XFxuXFxuICBpZiAob2JqKSB7XFxuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcXG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XFxuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXFxuICAgICAgfVxcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcXG4gICAgfVxcblxcbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XFxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXFxuICAgIH1cXG4gIH1cXG5cXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxcbn1cXG5cXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcXG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxcbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXFxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcXG4gIH1cXG4gIHJldHVybiBsZW5ndGggfCAwXFxufVxcblxcbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXFxuICAgIGxlbmd0aCA9IDBcXG4gIH1cXG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcXG59XFxuXFxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcXG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXFxufVxcblxcbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcXG4gIH1cXG5cXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxcblxcbiAgdmFyIHggPSBhLmxlbmd0aFxcbiAgdmFyIHkgPSBiLmxlbmd0aFxcblxcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcXG4gICAgICB4ID0gYVtpXVxcbiAgICAgIHkgPSBiW2ldXFxuICAgICAgYnJlYWtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcXG4gIHJldHVybiAwXFxufVxcblxcbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcXG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XFxuICAgIGNhc2UgJ2hleCc6XFxuICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICBjYXNlICd1dGYtOCc6XFxuICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgY2FzZSAnbGF0aW4xJzpcXG4gICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgY2FzZSAndWNzMic6XFxuICAgIGNhc2UgJ3Vjcy0yJzpcXG4gICAgY2FzZSAndXRmMTZsZSc6XFxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcXG4gICAgICByZXR1cm4gdHJ1ZVxcbiAgICBkZWZhdWx0OlxcbiAgICAgIHJldHVybiBmYWxzZVxcbiAgfVxcbn1cXG5cXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcXG4gIGlmICghaXNBcnJheShsaXN0KSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwibGlzdFxcXCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcXG4gIH1cXG5cXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXFxuICB9XFxuXFxuICB2YXIgaVxcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGxlbmd0aCA9IDBcXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcXG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXFxuICB2YXIgcG9zID0gMFxcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJsaXN0XFxcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxcbiAgICB9XFxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxcbiAgfVxcbiAgcmV0dXJuIGJ1ZmZlclxcbn1cXG5cXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcXG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcXG4gIH1cXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XFxuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxcbiAgfVxcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XFxuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXFxuICB9XFxuXFxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcXG5cXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcXG4gIGZvciAoOzspIHtcXG4gICAgc3dpdGNoIChlbmNvZGluZykge1xcbiAgICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgICBjYXNlICdsYXRpbjEnOlxcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XFxuICAgICAgICByZXR1cm4gbGVuXFxuICAgICAgY2FzZSAndXRmOCc6XFxuICAgICAgY2FzZSAndXRmLTgnOlxcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXFxuICAgICAgY2FzZSAndWNzMic6XFxuICAgICAgY2FzZSAndWNzLTInOlxcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcXG4gICAgICAgIHJldHVybiBsZW4gKiAyXFxuICAgICAgY2FzZSAnaGV4JzpcXG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcXG4gICAgICBjYXNlICdiYXNlNjQnOlxcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxcbiAgICB9XFxuICB9XFxufVxcbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxcblxcbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXFxuXFxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFxcXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXFxcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XFxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxcblxcbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXFxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXFxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcXG4gICAgc3RhcnQgPSAwXFxuICB9XFxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XFxuICAgIHJldHVybiAnJ1xcbiAgfVxcblxcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XFxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXFxuICB9XFxuXFxuICBpZiAoZW5kIDw9IDApIHtcXG4gICAgcmV0dXJuICcnXFxuICB9XFxuXFxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxcbiAgZW5kID4+Pj0gMFxcbiAgc3RhcnQgPj4+PSAwXFxuXFxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XFxuICAgIHJldHVybiAnJ1xcbiAgfVxcblxcbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcXG5cXG4gIHdoaWxlICh0cnVlKSB7XFxuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcXG4gICAgICBjYXNlICdoZXgnOlxcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgY2FzZSAndXRmOCc6XFxuICAgICAgY2FzZSAndXRmLTgnOlxcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgY2FzZSAnbGF0aW4xJzpcXG4gICAgICBjYXNlICdiaW5hcnknOlxcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGNhc2UgJ3VjczInOlxcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcXG4gICAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgICBjYXNlICd1dGYtMTZsZSc6XFxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3RcXG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxcblxcbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcXG4gIHZhciBpID0gYltuXVxcbiAgYltuXSA9IGJbbV1cXG4gIGJbbV0gPSBpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcXG4gIH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcXG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcXG4gIH1cXG4gIHJldHVybiB0aGlzXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcXG4gIH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcXG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXFxuICB9XFxuICByZXR1cm4gdGhpc1xcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XFxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXFxuICB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XFxuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXFxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXFxuICB9XFxuICByZXR1cm4gdGhpc1xcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXFxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xcbiAgdmFyIHN0ciA9ICcnXFxuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXFxuICB9XFxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcXG4gIH1cXG5cXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHN0YXJ0ID0gMFxcbiAgfVxcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXFxuICB9XFxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcXG4gICAgdGhpc1N0YXJ0ID0gMFxcbiAgfVxcbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcXG4gIH1cXG5cXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcXG4gIH1cXG5cXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcXG4gICAgcmV0dXJuIDBcXG4gIH1cXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xcbiAgICByZXR1cm4gLTFcXG4gIH1cXG4gIGlmIChzdGFydCA+PSBlbmQpIHtcXG4gICAgcmV0dXJuIDFcXG4gIH1cXG5cXG4gIHN0YXJ0ID4+Pj0gMFxcbiAgZW5kID4+Pj0gMFxcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxcbiAgdGhpc0VuZCA+Pj49IDBcXG5cXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXFxuXFxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcXG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcXG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxcblxcbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXFxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcXG4gICAgICB4ID0gdGhpc0NvcHlbaV1cXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxcbiAgICAgIGJyZWFrXFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXFxuICBpZiAoeSA8IHgpIHJldHVybiAxXFxuICByZXR1cm4gMFxcbn1cXG5cXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cXG4vL1xcbi8vIEFyZ3VtZW50czpcXG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXFxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXFxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXFxuXFxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcXG4gICAgYnl0ZU9mZnNldCA9IDBcXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcXG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XFxuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxcbiAgfVxcbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxcbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XFxuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFxcXCJmb29cXFwiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXFxuICB9XFxuXFxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcXG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcXG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXFxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XFxuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXFxuICAgIGVsc2UgcmV0dXJuIC0xXFxuICB9XFxuXFxuICAvLyBOb3JtYWxpemUgdmFsXFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcXG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcXG4gIH1cXG5cXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcXG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgIHJldHVybiAtMVxcbiAgICB9XFxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXFxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XFxuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgaWYgKGRpcikge1xcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxcbiAgfVxcblxcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcXG59XFxuXFxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xcbiAgdmFyIGluZGV4U2l6ZSA9IDFcXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxcblxcbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcXG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcXG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcXG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcXG4gICAgICAgIHJldHVybiAtMVxcbiAgICAgIH1cXG4gICAgICBpbmRleFNpemUgPSAyXFxuICAgICAgYXJyTGVuZ3RoIC89IDJcXG4gICAgICB2YWxMZW5ndGggLz0gMlxcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcXG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xcbiAgICAgIHJldHVybiBidWZbaV1cXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgaVxcbiAgaWYgKGRpcikge1xcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcXG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcXG4gICAgICB9XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XFxuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcXG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcXG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxcbiAgICAgICAgICBicmVha1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiAtMVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcXG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcXG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcXG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcXG59XFxuXFxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcXG4gIGlmICghbGVuZ3RoKSB7XFxuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xcbiAgfSBlbHNlIHtcXG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxcblxcbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcXG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxcbiAgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXFxuICB9XFxuICByZXR1cm4gaVxcbn1cXG5cXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGVuY29kaW5nID0gJ3V0ZjgnXFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXFxuICAgIG9mZnNldCA9IDBcXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xcbiAgICBlbmNvZGluZyA9IG9mZnNldFxcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxcbiAgICBvZmZzZXQgPSAwXFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XFxuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcXG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXFxuICAgIH0gZWxzZSB7XFxuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcXG4gICAgfVxcbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xcbiAgfSBlbHNlIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKFxcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcXG4gICAgKVxcbiAgfVxcblxcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcXG5cXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXFxuICB9XFxuXFxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xcblxcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcXG4gIGZvciAoOzspIHtcXG4gICAgc3dpdGNoIChlbmNvZGluZykge1xcbiAgICAgIGNhc2UgJ2hleCc6XFxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBjYXNlICd1dGY4JzpcXG4gICAgICBjYXNlICd1dGYtOCc6XFxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAnYXNjaWknOlxcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBjYXNlICdsYXRpbjEnOlxcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XFxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBjYXNlICdiYXNlNjQnOlxcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ3VjczInOlxcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcXG4gICAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgICBjYXNlICd1dGYtMTZsZSc6XFxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xcbiAgcmV0dXJuIHtcXG4gICAgdHlwZTogJ0J1ZmZlcicsXFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XFxuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxcbiAgdmFyIHJlcyA9IFtdXFxuXFxuICB2YXIgaSA9IHN0YXJ0XFxuICB3aGlsZSAoaSA8IGVuZCkge1xcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXFxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxcbiAgICAgIDogMVxcblxcbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XFxuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxcblxcbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xcbiAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXFxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XFxuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXFxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XFxuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlIDM6XFxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXFxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XFxuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXFxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSA0OlxcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXFxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXFxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XFxuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXFxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XFxuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcXG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXFxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXFxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XFxuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxcbiAgICB9XFxuXFxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXFxuICB9XFxuXFxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcXG59XFxuXFxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxcbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcXG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcXG5cXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcXG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcXG4gIH1cXG5cXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXFxcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFxcXCIuXFxuICB2YXIgcmVzID0gJydcXG4gIHZhciBpID0gMFxcbiAgd2hpbGUgKGkgPCBsZW4pIHtcXG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXFxuICAgICAgU3RyaW5nLFxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcXG4gICAgKVxcbiAgfVxcbiAgcmV0dXJuIHJlc1xcbn1cXG5cXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciByZXQgPSAnJ1xcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxcblxcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcXG4gIH1cXG4gIHJldHVybiByZXRcXG59XFxuXFxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgdmFyIHJldCA9ICcnXFxuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXFxuXFxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXFxuICB9XFxuICByZXR1cm4gcmV0XFxufVxcblxcbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXFxuXFxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXFxuXFxuICB2YXIgb3V0ID0gJydcXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XFxuICAgIG91dCArPSB0b0hleChidWZbaV0pXFxuICB9XFxuICByZXR1cm4gb3V0XFxufVxcblxcbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcXG4gIHZhciByZXMgPSAnJ1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcXG4gIH1cXG4gIHJldHVybiByZXNcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XFxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcXG4gIHN0YXJ0ID0gfn5zdGFydFxcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxcblxcbiAgaWYgKHN0YXJ0IDwgMCkge1xcbiAgICBzdGFydCArPSBsZW5cXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XFxuICAgIHN0YXJ0ID0gbGVuXFxuICB9XFxuXFxuICBpZiAoZW5kIDwgMCkge1xcbiAgICBlbmQgKz0gbGVuXFxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xcbiAgICBlbmQgPSBsZW5cXG4gIH1cXG5cXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcXG5cXG4gIHZhciBuZXdCdWZcXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXFxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXFxuICB9IGVsc2Uge1xcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gbmV3QnVmXFxufVxcblxcbi8qXFxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXFxuICovXFxuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcXG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXFxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcXG5cXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cXG4gIHZhciBtdWwgPSAxXFxuICB2YXIgaSA9IDBcXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXFxuICB9XFxuXFxuICByZXR1cm4gdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxcbiAgfVxcblxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxcbiAgdmFyIG11bCA9IDFcXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXFxuICB9XFxuXFxuICByZXR1cm4gdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG5cXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcXG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxcbiAgICB0aGlzW29mZnNldCArIDNdKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxcblxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBpID0gMFxcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcXG4gIH1cXG4gIG11bCAqPSAweDgwXFxuXFxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxcblxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxcblxcbiAgdmFyIGkgPSBieXRlTGVuZ3RoXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxcbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcXG4gIH1cXG4gIG11bCAqPSAweDgwXFxuXFxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxcblxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXFxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXFxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXFxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XFxuICAgICh0aGlzW29mZnNldCArIDNdKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJidWZmZXJcXFwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFxcInZhbHVlXFxcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXFxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxcbiAgfVxcblxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBpID0gMFxcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcXG4gIH1cXG5cXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcXG4gIHZhciBtdWwgPSAxXFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXFxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXFxuICB9XFxuXFxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXFxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXFxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxcbiAgcmV0dXJuIG9mZnNldCArIDFcXG59XFxuXFxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XFxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxcbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxcbiAgfVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxcbiAgfSBlbHNlIHtcXG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcXG4gIH1cXG4gIHJldHVybiBvZmZzZXQgKyAyXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICB9IGVsc2Uge1xcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcXG4gIH1cXG4gIHJldHVybiBvZmZzZXQgKyAyXFxufVxcblxcbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXFxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XFxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcXG4gIH1cXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gIH0gZWxzZSB7XFxuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXFxuICB9XFxuICByZXR1cm4gb2Zmc2V0ICsgNFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXFxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxcbiAgfSBlbHNlIHtcXG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXFxuICB9XFxuICByZXR1cm4gb2Zmc2V0ICsgNFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxcblxcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcXG4gIH1cXG5cXG4gIHZhciBpID0gMFxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBzdWIgPSAwXFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XFxuICAgICAgc3ViID0gMVxcbiAgICB9XFxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXFxuXFxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxcbiAgfVxcblxcbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBzdWIgPSAwXFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXFxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcXG4gICAgICBzdWIgPSAxXFxuICAgIH1cXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxcbiAgfVxcblxcbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXFxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXFxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICByZXR1cm4gb2Zmc2V0ICsgMVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcXG4gIH0gZWxzZSB7XFxuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXFxuICB9XFxuICByZXR1cm4gb2Zmc2V0ICsgMlxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcXG4gIH0gZWxzZSB7XFxuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxcbiAgfVxcbiAgcmV0dXJuIG9mZnNldCArIDJcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXFxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxcbiAgfSBlbHNlIHtcXG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcXG4gIH1cXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXFxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxcbiAgfSBlbHNlIHtcXG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXFxuICB9XFxuICByZXR1cm4gb2Zmc2V0ICsgNFxcbn1cXG5cXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxcbn1cXG5cXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXFxuICB9XFxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxcbn1cXG5cXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXFxuICB9XFxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcXG4gIHJldHVybiBvZmZzZXQgKyA4XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxcbn1cXG5cXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXFxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxcblxcbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXFxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxcblxcbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXFxuICB9XFxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXFxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcXG5cXG4gIC8vIEFyZSB3ZSBvb2I/XFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcXG4gIH1cXG5cXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxcbiAgdmFyIGlcXG5cXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxcbiAgICB9XFxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XFxuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXFxuICAgICAgdGFyZ2V0LFxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcXG4gICAgICB0YXJnZXRTdGFydFxcbiAgICApXFxuICB9XFxuXFxuICByZXR1cm4gbGVuXFxufVxcblxcbi8vIFVzYWdlOlxcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcXG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcXG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XFxuICAgICAgc3RhcnQgPSAwXFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xcbiAgICAgIGVuY29kaW5nID0gZW5kXFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcXG4gICAgfVxcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xcbiAgICAgICAgdmFsID0gY29kZVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXFxuICAgIH1cXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcXG4gICAgfVxcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xcbiAgICB2YWwgPSB2YWwgJiAyNTVcXG4gIH1cXG5cXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxcbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxcbiAgfVxcblxcbiAgaWYgKGVuZCA8PSBzdGFydCkge1xcbiAgICByZXR1cm4gdGhpc1xcbiAgfVxcblxcbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxcblxcbiAgaWYgKCF2YWwpIHZhbCA9IDBcXG5cXG4gIHZhciBpXFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xcbiAgICAgIHRoaXNbaV0gPSB2YWxcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcXG4gICAgICA/IHZhbFxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XFxuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXNcXG59XFxuXFxuLy8gSEVMUEVSIEZVTkNUSU9OU1xcbi8vID09PT09PT09PT09PT09PT1cXG5cXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFxcXC8wLTlBLVphLXotX10vZ1xcblxcbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXFxcbiBhbmQgXFxcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcXG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXFxuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcXG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xcbiAgICBzdHIgPSBzdHIgKyAnPSdcXG4gIH1cXG4gIHJldHVybiBzdHJcXG59XFxuXFxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XFxuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXFxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXFxccyt8XFxcXHMrJC9nLCAnJylcXG59XFxuXFxuZnVuY3Rpb24gdG9IZXggKG4pIHtcXG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXFxufVxcblxcbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XFxuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XFxuICB2YXIgY29kZVBvaW50XFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXFxuICB2YXIgYnl0ZXMgPSBbXVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxcblxcbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XFxuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcXG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XFxuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXFxuICAgICAgICAgIGNvbnRpbnVlXFxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcXG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcXG4gICAgICAgICAgY29udGludWVcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcXG5cXG4gICAgICAgIGNvbnRpbnVlXFxuICAgICAgfVxcblxcbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcXG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XFxuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcXG4gICAgICAgIGNvbnRpbnVlXFxuICAgICAgfVxcblxcbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXFxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcXG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXFxuICAgIH1cXG5cXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcXG5cXG4gICAgLy8gZW5jb2RlIHV0ZjhcXG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcXG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xcbiAgICAgIGJ5dGVzLnB1c2goXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXFxuICAgICAgKVxcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcXG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcXG4gICAgICBieXRlcy5wdXNoKFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxcbiAgICAgIClcXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xcbiAgICAgIGJ5dGVzLnB1c2goXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxcbiAgICAgIClcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBieXRlc1xcbn1cXG5cXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxcbiAgfVxcbiAgcmV0dXJuIGJ5dGVBcnJheVxcbn1cXG5cXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xcbiAgdmFyIGMsIGhpLCBsb1xcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcXG5cXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXFxuICAgIGhpID0gYyA+PiA4XFxuICAgIGxvID0gYyAlIDI1NlxcbiAgICBieXRlQXJyYXkucHVzaChsbylcXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXFxuICB9XFxuXFxuICByZXR1cm4gYnl0ZUFycmF5XFxufVxcblxcbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxcbn1cXG5cXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcXG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cXG4gIH1cXG4gIHJldHVybiBpXFxufVxcblxcbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcXG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxcbn1cXG5cXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygxKSkpLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5kbFluQmhZMnM2THk4dkxpOStMMkoxWm1abGNpOXBibVJsZUM1cWN6OHhZVFUxSWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2NVSkJRWEZDTEcxRVFVRnRSRHRCUVVONFJUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVSkJRVzFDTEZWQlFWVTdRVUZETjBJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2FVSkJRV2xDTEZsQlFWazdRVUZETjBJN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQkxEQkNRVUV3UWp0QlFVTXhRanRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUczdRVUZGUVN4MVEwRkJkVU1zVTBGQlV6dEJRVU5vUkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hsUVVGbExHbENRVUZwUWp0QlFVTm9RenRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJMR0ZCUVdFc2FVSkJRV2xDTzBGQlF6bENPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxGTkJRVk03UVVGRFZEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMR2xDUVVGcFFpeFRRVUZUTzBGQlF6RkNPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hwUWtGQmFVSXNVMEZCVXp0QlFVTXhRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHBRa0ZCYVVJc1UwRkJVenRCUVVNeFFqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEdkRVFVRm5SQ3hGUVVGRk8wRkJRMnhFTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQkxHbENRVUZwUWl4VFFVRlRPMEZCUXpGQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeDVRMEZCZVVNN1FVRkRla003UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNUMEZCVHp0QlFVTlFPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMSGRDUVVGM1FpeGxRVUZsTzBGQlEzWkRPMEZCUTBFN1FVRkRRVHRCUVVOQkxFOUJRVTg3UVVGRFVEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQkxIZENRVUYzUWl4UlFVRlJPMEZCUTJoRE8wRkJRMEVzY1VKQlFYRkNMR1ZCUVdVN1FVRkRjRU03UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2FVSkJRV2xDTEZsQlFWazdRVUZETjBJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVN4VFFVRlRPMEZCUTFRN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJMSEZDUVVGeFFpeFRRVUZUTzBGQlF6bENPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRU3h4UWtGQmNVSXNVMEZCVXp0QlFVTTVRanRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVN4eFFrRkJjVUlzVTBGQlV6dEJRVU01UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4cFFrRkJhVUlzYTBKQlFXdENPMEZCUTI1RE8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVN4dFFrRkJiVUlzWTBGQll6dEJRVU5xUXp0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRXNkVVJCUVhWRUxFOUJRVTg3UVVGRE9VUTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJMSFZFUVVGMVJDeFBRVUZQTzBGQlF6bEVPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTEd0Q1FVRnJRanRCUVVOc1FqdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxIRkNRVUZ4UWl4UlFVRlJPMEZCUXpkQ08wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVN4bFFVRmxMRk5CUVZNN1FVRkRlRUk3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3h0UWtGQmJVSXNVMEZCVXp0QlFVTTFRanRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1pVRkJaU3hwUWtGQmFVSTdRVUZEYUVNN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFTeHBRa0ZCYVVJc1dVRkJXVHRCUVVNM1FqczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4VFFVRlRPMEZCUTFRN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzYVVKQlFXbENMR2RDUVVGblFqdEJRVU5xUXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMR2xDUVVGcFFpeG5Ra0ZCWjBJN1FVRkRha003TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRXNhVUpCUVdsQ0xGbEJRVms3UVVGRE4wSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRWlMQ0ptYVd4bElqb2lNVFV1YW5NaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SXZLaUZjYmlBcUlGUm9aU0JpZFdabVpYSWdiVzlrZFd4bElHWnliMjBnYm05a1pTNXFjeXdnWm05eUlIUm9aU0JpY205M2MyVnlMbHh1SUNwY2JpQXFJRUJoZFhSb2IzSWdJQ0JHWlhKdmMzTWdRV0p2ZFd0b1lXUnBhbVZvSUR4bVpYSnZjM05BWm1WeWIzTnpMbTl5Wno0Z1BHaDBkSEE2THk5bVpYSnZjM011YjNKblBseHVJQ29nUUd4cFkyVnVjMlVnSUUxSlZGeHVJQ292WEc0dktpQmxjMnhwYm5RdFpHbHpZV0pzWlNCdWJ5MXdjbTkwYnlBcUwxeHVYRzRuZFhObElITjBjbWxqZENkY2JseHVkbUZ5SUdKaGMyVTJOQ0E5SUhKbGNYVnBjbVVvSjJKaGMyVTJOQzFxY3ljcFhHNTJZWElnYVdWbFpUYzFOQ0E5SUhKbGNYVnBjbVVvSjJsbFpXVTNOVFFuS1Z4dWRtRnlJR2x6UVhKeVlYa2dQU0J5WlhGMWFYSmxLQ2RwYzJGeWNtRjVKeWxjYmx4dVpYaHdiM0owY3k1Q2RXWm1aWElnUFNCQ2RXWm1aWEpjYm1WNGNHOXlkSE11VTJ4dmQwSjFabVpsY2lBOUlGTnNiM2RDZFdabVpYSmNibVY0Y0c5eWRITXVTVTVUVUVWRFZGOU5RVmhmUWxsVVJWTWdQU0ExTUZ4dVhHNHZLaXBjYmlBcUlFbG1JR0JDZFdabVpYSXVWRmxRUlVSZlFWSlNRVmxmVTFWUVVFOVNWR0E2WEc0Z0tpQWdJRDA5UFNCMGNuVmxJQ0FnSUZWelpTQlZhVzUwT0VGeWNtRjVJR2x0Y0d4bGJXVnVkR0YwYVc5dUlDaG1ZWE4wWlhOMEtWeHVJQ29nSUNBOVBUMGdabUZzYzJVZ0lDQlZjMlVnVDJKcVpXTjBJR2x0Y0d4bGJXVnVkR0YwYVc5dUlDaHRiM04wSUdOdmJYQmhkR2xpYkdVc0lHVjJaVzRnU1VVMktWeHVJQ3BjYmlBcUlFSnliM2R6WlhKeklIUm9ZWFFnYzNWd2NHOXlkQ0IwZVhCbFpDQmhjbkpoZVhNZ1lYSmxJRWxGSURFd0t5d2dSbWx5WldadmVDQTBLeXdnUTJoeWIyMWxJRGNyTENCVFlXWmhjbWtnTlM0eEt5eGNiaUFxSUU5d1pYSmhJREV4TGpZckxDQnBUMU1nTkM0eUt5NWNiaUFxWEc0Z0tpQkVkV1VnZEc4Z2RtRnlhVzkxY3lCaWNtOTNjMlZ5SUdKMVozTXNJSE52YldWMGFXMWxjeUIwYUdVZ1QySnFaV04wSUdsdGNHeGxiV1Z1ZEdGMGFXOXVJSGRwYkd3Z1ltVWdkWE5sWkNCbGRtVnVYRzRnS2lCM2FHVnVJSFJvWlNCaWNtOTNjMlZ5SUhOMWNIQnZjblJ6SUhSNWNHVmtJR0Z5Y21GNWN5NWNiaUFxWEc0Z0tpQk9iM1JsT2x4dUlDcGNiaUFxSUNBZ0xTQkdhWEpsWm05NElEUXRNamtnYkdGamEzTWdjM1Z3Y0c5eWRDQm1iM0lnWVdSa2FXNW5JRzVsZHlCd2NtOXdaWEowYVdWeklIUnZJR0JWYVc1ME9FRnljbUY1WUNCcGJuTjBZVzVqWlhNc1hHNGdLaUFnSUNBZ1UyVmxPaUJvZEhSd2N6b3ZMMkoxWjNwcGJHeGhMbTF2ZW1sc2JHRXViM0puTDNOb2IzZGZZblZuTG1ObmFUOXBaRDAyT1RVME16Z3VYRzRnS2x4dUlDb2dJQ0F0SUVOb2NtOXRaU0E1TFRFd0lHbHpJRzFwYzNOcGJtY2dkR2hsSUdCVWVYQmxaRUZ5Y21GNUxuQnliM1J2ZEhsd1pTNXpkV0poY25KaGVXQWdablZ1WTNScGIyNHVYRzRnS2x4dUlDb2dJQ0F0SUVsRk1UQWdhR0Z6SUdFZ1luSnZhMlZ1SUdCVWVYQmxaRUZ5Y21GNUxuQnliM1J2ZEhsd1pTNXpkV0poY25KaGVXQWdablZ1WTNScGIyNGdkMmhwWTJnZ2NtVjBkWEp1Y3lCaGNuSmhlWE1nYjJaY2JpQXFJQ0FnSUNCcGJtTnZjbkpsWTNRZ2JHVnVaM1JvSUdsdUlITnZiV1VnYzJsMGRXRjBhVzl1Y3k1Y2JseHVJQ29nVjJVZ1pHVjBaV04wSUhSb1pYTmxJR0oxWjJkNUlHSnliM2R6WlhKeklHRnVaQ0J6WlhRZ1lFSjFabVpsY2k1VVdWQkZSRjlCVWxKQldWOVRWVkJRVDFKVVlDQjBieUJnWm1Gc2MyVmdJSE52SUhSb1pYbGNiaUFxSUdkbGRDQjBhR1VnVDJKcVpXTjBJR2x0Y0d4bGJXVnVkR0YwYVc5dUxDQjNhR2xqYUNCcGN5QnpiRzkzWlhJZ1luVjBJR0psYUdGMlpYTWdZMjl5Y21WamRHeDVMbHh1SUNvdlhHNUNkV1ptWlhJdVZGbFFSVVJmUVZKU1FWbGZVMVZRVUU5U1ZDQTlJR2RzYjJKaGJDNVVXVkJGUkY5QlVsSkJXVjlUVlZCUVQxSlVJQ0U5UFNCMWJtUmxabWx1WldSY2JpQWdQeUJuYkc5aVlXd3VWRmxRUlVSZlFWSlNRVmxmVTFWUVVFOVNWRnh1SUNBNklIUjVjR1ZrUVhKeVlYbFRkWEJ3YjNKMEtDbGNibHh1THlwY2JpQXFJRVY0Y0c5eWRDQnJUV0Y0VEdWdVozUm9JR0ZtZEdWeUlIUjVjR1ZrSUdGeWNtRjVJSE4xY0hCdmNuUWdhWE1nWkdWMFpYSnRhVzVsWkM1Y2JpQXFMMXh1Wlhod2IzSjBjeTVyVFdGNFRHVnVaM1JvSUQwZ2EwMWhlRXhsYm1kMGFDZ3BYRzVjYm1aMWJtTjBhVzl1SUhSNWNHVmtRWEp5WVhsVGRYQndiM0owSUNncElIdGNiaUFnZEhKNUlIdGNiaUFnSUNCMllYSWdZWEp5SUQwZ2JtVjNJRlZwYm5RNFFYSnlZWGtvTVNsY2JpQWdJQ0JoY25JdVgxOXdjbTkwYjE5ZklEMGdlMTlmY0hKdmRHOWZYem9nVldsdWREaEJjbkpoZVM1d2NtOTBiM1I1Y0dVc0lHWnZiem9nWm5WdVkzUnBiMjRnS0NrZ2V5QnlaWFIxY200Z05ESWdmWDFjYmlBZ0lDQnlaWFIxY200Z1lYSnlMbVp2YnlncElEMDlQU0EwTWlBbUppQXZMeUIwZVhCbFpDQmhjbkpoZVNCcGJuTjBZVzVqWlhNZ1kyRnVJR0psSUdGMVoyMWxiblJsWkZ4dUlDQWdJQ0FnSUNCMGVYQmxiMllnWVhKeUxuTjFZbUZ5Y21GNUlEMDlQU0FuWm5WdVkzUnBiMjRuSUNZbUlDOHZJR05vY205dFpTQTVMVEV3SUd4aFkyc2dZSE4xWW1GeWNtRjVZRnh1SUNBZ0lDQWdJQ0JoY25JdWMzVmlZWEp5WVhrb01Td2dNU2t1WW5sMFpVeGxibWQwYUNBOVBUMGdNQ0F2THlCcFpURXdJR2hoY3lCaWNtOXJaVzRnWUhOMVltRnljbUY1WUZ4dUlDQjlJR05oZEdOb0lDaGxLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHWmhiSE5sWEc0Z0lIMWNibjFjYmx4dVpuVnVZM1JwYjI0Z2EwMWhlRXhsYm1kMGFDQW9LU0I3WEc0Z0lISmxkSFZ5YmlCQ2RXWm1aWEl1VkZsUVJVUmZRVkpTUVZsZlUxVlFVRTlTVkZ4dUlDQWdJRDhnTUhnM1ptWm1abVptWmx4dUlDQWdJRG9nTUhnelptWm1abVptWmx4dWZWeHVYRzVtZFc1amRHbHZiaUJqY21WaGRHVkNkV1ptWlhJZ0tIUm9ZWFFzSUd4bGJtZDBhQ2tnZTF4dUlDQnBaaUFvYTAxaGVFeGxibWQwYUNncElEd2diR1Z1WjNSb0tTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lGSmhibWRsUlhKeWIzSW9KMGx1ZG1Gc2FXUWdkSGx3WldRZ1lYSnlZWGtnYkdWdVozUm9KeWxjYmlBZ2ZWeHVJQ0JwWmlBb1FuVm1abVZ5TGxSWlVFVkVYMEZTVWtGWlgxTlZVRkJQVWxRcElIdGNiaUFnSUNBdkx5QlNaWFIxY200Z1lXNGdZWFZuYldWdWRHVmtJR0JWYVc1ME9FRnljbUY1WUNCcGJuTjBZVzVqWlN3Z1ptOXlJR0psYzNRZ2NHVnlabTl5YldGdVkyVmNiaUFnSUNCMGFHRjBJRDBnYm1WM0lGVnBiblE0UVhKeVlYa29iR1Z1WjNSb0tWeHVJQ0FnSUhSb1lYUXVYMTl3Y205MGIxOWZJRDBnUW5WbVptVnlMbkJ5YjNSdmRIbHdaVnh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJQzh2SUVaaGJHeGlZV05yT2lCU1pYUjFjbTRnWVc0Z2IySnFaV04wSUdsdWMzUmhibU5sSUc5bUlIUm9aU0JDZFdabVpYSWdZMnhoYzNOY2JpQWdJQ0JwWmlBb2RHaGhkQ0E5UFQwZ2JuVnNiQ2tnZTF4dUlDQWdJQ0FnZEdoaGRDQTlJRzVsZHlCQ2RXWm1aWElvYkdWdVozUm9LVnh1SUNBZ0lIMWNiaUFnSUNCMGFHRjBMbXhsYm1kMGFDQTlJR3hsYm1kMGFGeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlIUm9ZWFJjYm4xY2JseHVMeW9xWEc0Z0tpQlVhR1VnUW5WbVptVnlJR052Ym5OMGNuVmpkRzl5SUhKbGRIVnlibk1nYVc1emRHRnVZMlZ6SUc5bUlHQlZhVzUwT0VGeWNtRjVZQ0IwYUdGMElHaGhkbVVnZEdobGFYSmNiaUFxSUhCeWIzUnZkSGx3WlNCamFHRnVaMlZrSUhSdklHQkNkV1ptWlhJdWNISnZkRzkwZVhCbFlDNGdSblZ5ZEdobGNtMXZjbVVzSUdCQ2RXWm1aWEpnSUdseklHRWdjM1ZpWTJ4aGMzTWdiMlpjYmlBcUlHQlZhVzUwT0VGeWNtRjVZQ3dnYzI4Z2RHaGxJSEpsZEhWeWJtVmtJR2x1YzNSaGJtTmxjeUIzYVd4c0lHaGhkbVVnWVd4c0lIUm9aU0J1YjJSbElHQkNkV1ptWlhKZ0lHMWxkR2h2WkhOY2JpQXFJR0Z1WkNCMGFHVWdZRlZwYm5RNFFYSnlZWGxnSUcxbGRHaHZaSE11SUZOeGRXRnlaU0JpY21GamEyVjBJRzV2ZEdGMGFXOXVJSGR2Y210eklHRnpJR1Y0Y0dWamRHVmtJQzB0SUdsMFhHNGdLaUJ5WlhSMWNtNXpJR0VnYzJsdVoyeGxJRzlqZEdWMExseHVJQ3BjYmlBcUlGUm9aU0JnVldsdWREaEJjbkpoZVdBZ2NISnZkRzkwZVhCbElISmxiV0ZwYm5NZ2RXNXRiMlJwWm1sbFpDNWNiaUFxTDF4dVhHNW1kVzVqZEdsdmJpQkNkV1ptWlhJZ0tHRnlaeXdnWlc1amIyUnBibWRQY2s5bVpuTmxkQ3dnYkdWdVozUm9LU0I3WEc0Z0lHbG1JQ2doUW5WbVptVnlMbFJaVUVWRVgwRlNVa0ZaWDFOVlVGQlBVbFFnSmlZZ0lTaDBhR2x6SUdsdWMzUmhibU5sYjJZZ1FuVm1abVZ5S1NrZ2UxeHVJQ0FnSUhKbGRIVnliaUJ1WlhjZ1FuVm1abVZ5S0dGeVp5d2daVzVqYjJScGJtZFBjazltWm5ObGRDd2diR1Z1WjNSb0tWeHVJQ0I5WEc1Y2JpQWdMeThnUTI5dGJXOXVJR05oYzJVdVhHNGdJR2xtSUNoMGVYQmxiMllnWVhKbklEMDlQU0FuYm5WdFltVnlKeWtnZTF4dUlDQWdJR2xtSUNoMGVYQmxiMllnWlc1amIyUnBibWRQY2s5bVpuTmxkQ0E5UFQwZ0ozTjBjbWx1WnljcElIdGNiaUFnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2loY2JpQWdJQ0FnSUNBZ0owbG1JR1Z1WTI5a2FXNW5JR2x6SUhOd1pXTnBabWxsWkNCMGFHVnVJSFJvWlNCbWFYSnpkQ0JoY21kMWJXVnVkQ0J0ZFhOMElHSmxJR0VnYzNSeWFXNW5KMXh1SUNBZ0lDQWdLVnh1SUNBZ0lIMWNiaUFnSUNCeVpYUjFjbTRnWVd4c2IyTlZibk5oWm1Vb2RHaHBjeXdnWVhKbktWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCbWNtOXRLSFJvYVhNc0lHRnlaeXdnWlc1amIyUnBibWRQY2s5bVpuTmxkQ3dnYkdWdVozUm9LVnh1ZlZ4dVhHNUNkV1ptWlhJdWNHOXZiRk5wZW1VZ1BTQTRNVGt5SUM4dklHNXZkQ0IxYzJWa0lHSjVJSFJvYVhNZ2FXMXdiR1Z0Wlc1MFlYUnBiMjVjYmx4dUx5OGdWRTlFVHpvZ1RHVm5ZV041TENCdWIzUWdibVZsWkdWa0lHRnVlVzF2Y21VdUlGSmxiVzkyWlNCcGJpQnVaWGgwSUcxaGFtOXlJSFpsY25OcGIyNHVYRzVDZFdabVpYSXVYMkYxWjIxbGJuUWdQU0JtZFc1amRHbHZiaUFvWVhKeUtTQjdYRzRnSUdGeWNpNWZYM0J5YjNSdlgxOGdQU0JDZFdabVpYSXVjSEp2ZEc5MGVYQmxYRzRnSUhKbGRIVnliaUJoY25KY2JuMWNibHh1Wm5WdVkzUnBiMjRnWm5KdmJTQW9kR2hoZEN3Z2RtRnNkV1VzSUdWdVkyOWthVzVuVDNKUFptWnpaWFFzSUd4bGJtZDBhQ2tnZTF4dUlDQnBaaUFvZEhsd1pXOW1JSFpoYkhWbElEMDlQU0FuYm5WdFltVnlKeWtnZTF4dUlDQWdJSFJvY205M0lHNWxkeUJVZVhCbFJYSnliM0lvSjF3aWRtRnNkV1ZjSWlCaGNtZDFiV1Z1ZENCdGRYTjBJRzV2ZENCaVpTQmhJRzUxYldKbGNpY3BYRzRnSUgxY2JseHVJQ0JwWmlBb2RIbHdaVzltSUVGeWNtRjVRblZtWm1WeUlDRTlQU0FuZFc1a1pXWnBibVZrSnlBbUppQjJZV3gxWlNCcGJuTjBZVzVqWlc5bUlFRnljbUY1UW5WbVptVnlLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHWnliMjFCY25KaGVVSjFabVpsY2loMGFHRjBMQ0IyWVd4MVpTd2daVzVqYjJScGJtZFBjazltWm5ObGRDd2diR1Z1WjNSb0tWeHVJQ0I5WEc1Y2JpQWdhV1lnS0hSNWNHVnZaaUIyWVd4MVpTQTlQVDBnSjNOMGNtbHVaeWNwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdabkp2YlZOMGNtbHVaeWgwYUdGMExDQjJZV3gxWlN3Z1pXNWpiMlJwYm1kUGNrOW1abk5sZENsY2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCbWNtOXRUMkpxWldOMEtIUm9ZWFFzSUhaaGJIVmxLVnh1ZlZ4dVhHNHZLaXBjYmlBcUlFWjFibU4wYVc5dVlXeHNlU0JsY1hWcGRtRnNaVzUwSUhSdklFSjFabVpsY2loaGNtY3NJR1Z1WTI5a2FXNW5LU0JpZFhRZ2RHaHliM2R6SUdFZ1ZIbHdaVVZ5Y205eVhHNGdLaUJwWmlCMllXeDFaU0JwY3lCaElHNTFiV0psY2k1Y2JpQXFJRUoxWm1abGNpNW1jbTl0S0hOMGNsc3NJR1Z1WTI5a2FXNW5YU2xjYmlBcUlFSjFabVpsY2k1bWNtOXRLR0Z5Y21GNUtWeHVJQ29nUW5WbVptVnlMbVp5YjIwb1luVm1abVZ5S1Z4dUlDb2dRblZtWm1WeUxtWnliMjBvWVhKeVlYbENkV1ptWlhKYkxDQmllWFJsVDJabWMyVjBXeXdnYkdWdVozUm9YVjBwWEc0Z0tpb3ZYRzVDZFdabVpYSXVabkp2YlNBOUlHWjFibU4wYVc5dUlDaDJZV3gxWlN3Z1pXNWpiMlJwYm1kUGNrOW1abk5sZEN3Z2JHVnVaM1JvS1NCN1hHNGdJSEpsZEhWeWJpQm1jbTl0S0c1MWJHd3NJSFpoYkhWbExDQmxibU52WkdsdVowOXlUMlptYzJWMExDQnNaVzVuZEdncFhHNTlYRzVjYm1sbUlDaENkV1ptWlhJdVZGbFFSVVJmUVZKU1FWbGZVMVZRVUU5U1ZDa2dlMXh1SUNCQ2RXWm1aWEl1Y0hKdmRHOTBlWEJsTGw5ZmNISnZkRzlmWHlBOUlGVnBiblE0UVhKeVlYa3VjSEp2ZEc5MGVYQmxYRzRnSUVKMVptWmxjaTVmWDNCeWIzUnZYMThnUFNCVmFXNTBPRUZ5Y21GNVhHNGdJR2xtSUNoMGVYQmxiMllnVTNsdFltOXNJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5QW1KaUJUZVcxaWIyd3VjM0JsWTJsbGN5QW1KbHh1SUNBZ0lDQWdRblZtWm1WeVcxTjViV0p2YkM1emNHVmphV1Z6WFNBOVBUMGdRblZtWm1WeUtTQjdYRzRnSUNBZ0x5OGdSbWw0SUhOMVltRnljbUY1S0NrZ2FXNGdSVk15TURFMkxpQlRaV1U2SUdoMGRIQnpPaTh2WjJsMGFIVmlMbU52YlM5bVpYSnZjM012WW5WbVptVnlMM0IxYkd3dk9UZGNiaUFnSUNCUFltcGxZM1F1WkdWbWFXNWxVSEp2Y0dWeWRIa29RblZtWm1WeUxDQlRlVzFpYjJ3dWMzQmxZMmxsY3l3Z2UxeHVJQ0FnSUNBZ2RtRnNkV1U2SUc1MWJHd3NYRzRnSUNBZ0lDQmpiMjVtYVdkMWNtRmliR1U2SUhSeWRXVmNiaUFnSUNCOUtWeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJR0Z6YzJWeWRGTnBlbVVnS0hOcGVtVXBJSHRjYmlBZ2FXWWdLSFI1Y0dWdlppQnphWHBsSUNFOVBTQW5iblZ0WW1WeUp5a2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QlVlWEJsUlhKeWIzSW9KMXdpYzJsNlpWd2lJR0Z5WjNWdFpXNTBJRzExYzNRZ1ltVWdZU0J1ZFcxaVpYSW5LVnh1SUNCOUlHVnNjMlVnYVdZZ0tITnBlbVVnUENBd0tTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lGSmhibWRsUlhKeWIzSW9KMXdpYzJsNlpWd2lJR0Z5WjNWdFpXNTBJRzExYzNRZ2JtOTBJR0psSUc1bFoyRjBhWFpsSnlsY2JpQWdmVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmhiR3h2WXlBb2RHaGhkQ3dnYzJsNlpTd2dabWxzYkN3Z1pXNWpiMlJwYm1jcElIdGNiaUFnWVhOelpYSjBVMmw2WlNoemFYcGxLVnh1SUNCcFppQW9jMmw2WlNBOFBTQXdLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHTnlaV0YwWlVKMVptWmxjaWgwYUdGMExDQnphWHBsS1Z4dUlDQjlYRzRnSUdsbUlDaG1hV3hzSUNFOVBTQjFibVJsWm1sdVpXUXBJSHRjYmlBZ0lDQXZMeUJQYm14NUlIQmhlU0JoZEhSbGJuUnBiMjRnZEc4Z1pXNWpiMlJwYm1jZ2FXWWdhWFFuY3lCaElITjBjbWx1Wnk0Z1ZHaHBjMXh1SUNBZ0lDOHZJSEJ5WlhabGJuUnpJR0ZqWTJsa1pXNTBZV3hzZVNCelpXNWthVzVuSUdsdUlHRWdiblZ0WW1WeUlIUm9ZWFFnZDI5MWJHUmNiaUFnSUNBdkx5QmlaU0JwYm5SbGNuQnlaWFIwWldRZ1lYTWdZU0J6ZEdGeWRDQnZabVp6WlhRdVhHNGdJQ0FnY21WMGRYSnVJSFI1Y0dWdlppQmxibU52WkdsdVp5QTlQVDBnSjNOMGNtbHVaeWRjYmlBZ0lDQWdJRDhnWTNKbFlYUmxRblZtWm1WeUtIUm9ZWFFzSUhOcGVtVXBMbVpwYkd3b1ptbHNiQ3dnWlc1amIyUnBibWNwWEc0Z0lDQWdJQ0E2SUdOeVpXRjBaVUoxWm1abGNpaDBhR0YwTENCemFYcGxLUzVtYVd4c0tHWnBiR3dwWEc0Z0lIMWNiaUFnY21WMGRYSnVJR055WldGMFpVSjFabVpsY2loMGFHRjBMQ0J6YVhwbEtWeHVmVnh1WEc0dktpcGNiaUFxSUVOeVpXRjBaWE1nWVNCdVpYY2dabWxzYkdWa0lFSjFabVpsY2lCcGJuTjBZVzVqWlM1Y2JpQXFJR0ZzYkc5aktITnBlbVZiTENCbWFXeHNXeXdnWlc1amIyUnBibWRkWFNsY2JpQXFLaTljYmtKMVptWmxjaTVoYkd4dll5QTlJR1oxYm1OMGFXOXVJQ2h6YVhwbExDQm1hV3hzTENCbGJtTnZaR2x1WnlrZ2UxeHVJQ0J5WlhSMWNtNGdZV3hzYjJNb2JuVnNiQ3dnYzJsNlpTd2dabWxzYkN3Z1pXNWpiMlJwYm1jcFhHNTlYRzVjYm1aMWJtTjBhVzl1SUdGc2JHOWpWVzV6WVdabElDaDBhR0YwTENCemFYcGxLU0I3WEc0Z0lHRnpjMlZ5ZEZOcGVtVW9jMmw2WlNsY2JpQWdkR2hoZENBOUlHTnlaV0YwWlVKMVptWmxjaWgwYUdGMExDQnphWHBsSUR3Z01DQS9JREFnT2lCamFHVmphMlZrS0hOcGVtVXBJSHdnTUNsY2JpQWdhV1lnS0NGQ2RXWm1aWEl1VkZsUVJVUmZRVkpTUVZsZlUxVlFVRTlTVkNrZ2UxeHVJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2MybDZaVHNnS3l0cEtTQjdYRzRnSUNBZ0lDQjBhR0YwVzJsZElEMGdNRnh1SUNBZ0lIMWNiaUFnZlZ4dUlDQnlaWFIxY200Z2RHaGhkRnh1ZlZ4dVhHNHZLaXBjYmlBcUlFVnhkV2wyWVd4bGJuUWdkRzhnUW5WbVptVnlLRzUxYlNrc0lHSjVJR1JsWm1GMWJIUWdZM0psWVhSbGN5QmhJRzV2YmkxNlpYSnZMV1pwYkd4bFpDQkNkV1ptWlhJZ2FXNXpkR0Z1WTJVdVhHNGdLaUFxTDF4dVFuVm1abVZ5TG1Gc2JHOWpWVzV6WVdabElEMGdablZ1WTNScGIyNGdLSE5wZW1VcElIdGNiaUFnY21WMGRYSnVJR0ZzYkc5alZXNXpZV1psS0c1MWJHd3NJSE5wZW1VcFhHNTlYRzR2S2lwY2JpQXFJRVZ4ZFdsMllXeGxiblFnZEc4Z1UyeHZkMEoxWm1abGNpaHVkVzBwTENCaWVTQmtaV1poZFd4MElHTnlaV0YwWlhNZ1lTQnViMjR0ZW1WeWJ5MW1hV3hzWldRZ1FuVm1abVZ5SUdsdWMzUmhibU5sTGx4dUlDb3ZYRzVDZFdabVpYSXVZV3hzYjJOVmJuTmhabVZUYkc5M0lEMGdablZ1WTNScGIyNGdLSE5wZW1VcElIdGNiaUFnY21WMGRYSnVJR0ZzYkc5alZXNXpZV1psS0c1MWJHd3NJSE5wZW1VcFhHNTlYRzVjYm1aMWJtTjBhVzl1SUdaeWIyMVRkSEpwYm1jZ0tIUm9ZWFFzSUhOMGNtbHVaeXdnWlc1amIyUnBibWNwSUh0Y2JpQWdhV1lnS0hSNWNHVnZaaUJsYm1OdlpHbHVaeUFoUFQwZ0ozTjBjbWx1WnljZ2ZId2daVzVqYjJScGJtY2dQVDA5SUNjbktTQjdYRzRnSUNBZ1pXNWpiMlJwYm1jZ1BTQW5kWFJtT0NkY2JpQWdmVnh1WEc0Z0lHbG1JQ2doUW5WbVptVnlMbWx6Ulc1amIyUnBibWNvWlc1amIyUnBibWNwS1NCN1hHNGdJQ0FnZEdoeWIzY2dibVYzSUZSNWNHVkZjbkp2Y2lnblhDSmxibU52WkdsdVoxd2lJRzExYzNRZ1ltVWdZU0IyWVd4cFpDQnpkSEpwYm1jZ1pXNWpiMlJwYm1jbktWeHVJQ0I5WEc1Y2JpQWdkbUZ5SUd4bGJtZDBhQ0E5SUdKNWRHVk1aVzVuZEdnb2MzUnlhVzVuTENCbGJtTnZaR2x1WnlrZ2ZDQXdYRzRnSUhSb1lYUWdQU0JqY21WaGRHVkNkV1ptWlhJb2RHaGhkQ3dnYkdWdVozUm9LVnh1WEc0Z0lIWmhjaUJoWTNSMVlXd2dQU0IwYUdGMExuZHlhWFJsS0hOMGNtbHVaeXdnWlc1amIyUnBibWNwWEc1Y2JpQWdhV1lnS0dGamRIVmhiQ0FoUFQwZ2JHVnVaM1JvS1NCN1hHNGdJQ0FnTHk4Z1YzSnBkR2x1WnlCaElHaGxlQ0J6ZEhKcGJtY3NJR1p2Y2lCbGVHRnRjR3hsTENCMGFHRjBJR052Ym5SaGFXNXpJR2x1ZG1Gc2FXUWdZMmhoY21GamRHVnljeUIzYVd4c1hHNGdJQ0FnTHk4Z1kyRjFjMlVnWlhabGNubDBhR2x1WnlCaFpuUmxjaUIwYUdVZ1ptbHljM1FnYVc1MllXeHBaQ0JqYUdGeVlXTjBaWElnZEc4Z1ltVWdhV2R1YjNKbFpDNGdLR1V1Wnk1Y2JpQWdJQ0F2THlBbllXSjRlR05rSnlCM2FXeHNJR0psSUhSeVpXRjBaV1FnWVhNZ0oyRmlKeWxjYmlBZ0lDQjBhR0YwSUQwZ2RHaGhkQzV6YkdsalpTZ3dMQ0JoWTNSMVlXd3BYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdkR2hoZEZ4dWZWeHVYRzVtZFc1amRHbHZiaUJtY205dFFYSnlZWGxNYVd0bElDaDBhR0YwTENCaGNuSmhlU2tnZTF4dUlDQjJZWElnYkdWdVozUm9JRDBnWVhKeVlYa3ViR1Z1WjNSb0lEd2dNQ0EvSURBZ09pQmphR1ZqYTJWa0tHRnljbUY1TG14bGJtZDBhQ2tnZkNBd1hHNGdJSFJvWVhRZ1BTQmpjbVZoZEdWQ2RXWm1aWElvZEdoaGRDd2diR1Z1WjNSb0tWeHVJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUd4bGJtZDBhRHNnYVNBclBTQXhLU0I3WEc0Z0lDQWdkR2hoZEZ0cFhTQTlJR0Z5Y21GNVcybGRJQ1lnTWpVMVhHNGdJSDFjYmlBZ2NtVjBkWEp1SUhSb1lYUmNibjFjYmx4dVpuVnVZM1JwYjI0Z1puSnZiVUZ5Y21GNVFuVm1abVZ5SUNoMGFHRjBMQ0JoY25KaGVTd2dZbmwwWlU5bVpuTmxkQ3dnYkdWdVozUm9LU0I3WEc0Z0lHRnljbUY1TG1KNWRHVk1aVzVuZEdnZ0x5OGdkR2hwY3lCMGFISnZkM01nYVdZZ1lHRnljbUY1WUNCcGN5QnViM1FnWVNCMllXeHBaQ0JCY25KaGVVSjFabVpsY2x4dVhHNGdJR2xtSUNoaWVYUmxUMlptYzJWMElEd2dNQ0I4ZkNCaGNuSmhlUzVpZVhSbFRHVnVaM1JvSUR3Z1lubDBaVTltWm5ObGRDa2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QlNZVzVuWlVWeWNtOXlLQ2RjWENkdlptWnpaWFJjWENjZ2FYTWdiM1YwSUc5bUlHSnZkVzVrY3ljcFhHNGdJSDFjYmx4dUlDQnBaaUFvWVhKeVlYa3VZbmwwWlV4bGJtZDBhQ0E4SUdKNWRHVlBabVp6WlhRZ0t5QW9iR1Z1WjNSb0lIeDhJREFwS1NCN1hHNGdJQ0FnZEdoeWIzY2dibVYzSUZKaGJtZGxSWEp5YjNJb0oxeGNKMnhsYm1kMGFGeGNKeUJwY3lCdmRYUWdiMllnWW05MWJtUnpKeWxjYmlBZ2ZWeHVYRzRnSUdsbUlDaGllWFJsVDJabWMyVjBJRDA5UFNCMWJtUmxabWx1WldRZ0ppWWdiR1Z1WjNSb0lEMDlQU0IxYm1SbFptbHVaV1FwSUh0Y2JpQWdJQ0JoY25KaGVTQTlJRzVsZHlCVmFXNTBPRUZ5Y21GNUtHRnljbUY1S1Z4dUlDQjlJR1ZzYzJVZ2FXWWdLR3hsYm1kMGFDQTlQVDBnZFc1a1pXWnBibVZrS1NCN1hHNGdJQ0FnWVhKeVlYa2dQU0J1WlhjZ1ZXbHVkRGhCY25KaGVTaGhjbkpoZVN3Z1lubDBaVTltWm5ObGRDbGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQmhjbkpoZVNBOUlHNWxkeUJWYVc1ME9FRnljbUY1S0dGeWNtRjVMQ0JpZVhSbFQyWm1jMlYwTENCc1pXNW5kR2dwWEc0Z0lIMWNibHh1SUNCcFppQW9RblZtWm1WeUxsUlpVRVZFWDBGU1VrRlpYMU5WVUZCUFVsUXBJSHRjYmlBZ0lDQXZMeUJTWlhSMWNtNGdZVzRnWVhWbmJXVnVkR1ZrSUdCVmFXNTBPRUZ5Y21GNVlDQnBibk4wWVc1alpTd2dabTl5SUdKbGMzUWdjR1Z5Wm05eWJXRnVZMlZjYmlBZ0lDQjBhR0YwSUQwZ1lYSnlZWGxjYmlBZ0lDQjBhR0YwTGw5ZmNISnZkRzlmWHlBOUlFSjFabVpsY2k1d2NtOTBiM1I1Y0dWY2JpQWdmU0JsYkhObElIdGNiaUFnSUNBdkx5QkdZV3hzWW1GamF6b2dVbVYwZFhKdUlHRnVJRzlpYW1WamRDQnBibk4wWVc1alpTQnZaaUIwYUdVZ1FuVm1abVZ5SUdOc1lYTnpYRzRnSUNBZ2RHaGhkQ0E5SUdaeWIyMUJjbkpoZVV4cGEyVW9kR2hoZEN3Z1lYSnlZWGtwWEc0Z0lIMWNiaUFnY21WMGRYSnVJSFJvWVhSY2JuMWNibHh1Wm5WdVkzUnBiMjRnWm5KdmJVOWlhbVZqZENBb2RHaGhkQ3dnYjJKcUtTQjdYRzRnSUdsbUlDaENkV1ptWlhJdWFYTkNkV1ptWlhJb2IySnFLU2tnZTF4dUlDQWdJSFpoY2lCc1pXNGdQU0JqYUdWamEyVmtLRzlpYWk1c1pXNW5kR2dwSUh3Z01GeHVJQ0FnSUhSb1lYUWdQU0JqY21WaGRHVkNkV1ptWlhJb2RHaGhkQ3dnYkdWdUtWeHVYRzRnSUNBZ2FXWWdLSFJvWVhRdWJHVnVaM1JvSUQwOVBTQXdLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdkR2hoZEZ4dUlDQWdJSDFjYmx4dUlDQWdJRzlpYWk1amIzQjVLSFJvWVhRc0lEQXNJREFzSUd4bGJpbGNiaUFnSUNCeVpYUjFjbTRnZEdoaGRGeHVJQ0I5WEc1Y2JpQWdhV1lnS0c5aWFpa2dlMXh1SUNBZ0lHbG1JQ2dvZEhsd1pXOW1JRUZ5Y21GNVFuVm1abVZ5SUNFOVBTQW5kVzVrWldacGJtVmtKeUFtSmx4dUlDQWdJQ0FnSUNCdlltb3VZblZtWm1WeUlHbHVjM1JoYm1ObGIyWWdRWEp5WVhsQ2RXWm1aWElwSUh4OElDZHNaVzVuZEdnbklHbHVJRzlpYWlrZ2UxeHVJQ0FnSUNBZ2FXWWdLSFI1Y0dWdlppQnZZbW91YkdWdVozUm9JQ0U5UFNBbmJuVnRZbVZ5SnlCOGZDQnBjMjVoYmlodlltb3ViR1Z1WjNSb0tTa2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdZM0psWVhSbFFuVm1abVZ5S0hSb1lYUXNJREFwWEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0J5WlhSMWNtNGdabkp2YlVGeWNtRjVUR2xyWlNoMGFHRjBMQ0J2WW1vcFhHNGdJQ0FnZlZ4dVhHNGdJQ0FnYVdZZ0tHOWlhaTUwZVhCbElEMDlQU0FuUW5WbVptVnlKeUFtSmlCcGMwRnljbUY1S0c5aWFpNWtZWFJoS1NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUdaeWIyMUJjbkpoZVV4cGEyVW9kR2hoZEN3Z2IySnFMbVJoZEdFcFhHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ2RHaHliM2NnYm1WM0lGUjVjR1ZGY25KdmNpZ25SbWx5YzNRZ1lYSm5kVzFsYm5RZ2JYVnpkQ0JpWlNCaElITjBjbWx1Wnl3Z1FuVm1abVZ5TENCQmNuSmhlVUoxWm1abGNpd2dRWEp5WVhrc0lHOXlJR0Z5Y21GNUxXeHBhMlVnYjJKcVpXTjBMaWNwWEc1OVhHNWNibVoxYm1OMGFXOXVJR05vWldOclpXUWdLR3hsYm1kMGFDa2dlMXh1SUNBdkx5Qk9iM1JsT2lCallXNXViM1FnZFhObElHQnNaVzVuZEdnZ1BDQnJUV0Y0VEdWdVozUm9LQ2xnSUdobGNtVWdZbVZqWVhWelpTQjBhR0YwSUdaaGFXeHpJSGRvWlc1Y2JpQWdMeThnYkdWdVozUm9JR2x6SUU1aFRpQW9kMmhwWTJnZ2FYTWdiM1JvWlhKM2FYTmxJR052WlhKalpXUWdkRzhnZW1WeWJ5NHBYRzRnSUdsbUlDaHNaVzVuZEdnZ1BqMGdhMDFoZUV4bGJtZDBhQ2dwS1NCN1hHNGdJQ0FnZEdoeWIzY2dibVYzSUZKaGJtZGxSWEp5YjNJb0owRjBkR1Z0Y0hRZ2RHOGdZV3hzYjJOaGRHVWdRblZtWm1WeUlHeGhjbWRsY2lCMGFHRnVJRzFoZUdsdGRXMGdKeUFyWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSjNOcGVtVTZJREI0SnlBcklHdE5ZWGhNWlc1bmRHZ29LUzUwYjFOMGNtbHVaeWd4TmlrZ0t5QW5JR0o1ZEdWekp5bGNiaUFnZlZ4dUlDQnlaWFIxY200Z2JHVnVaM1JvSUh3Z01GeHVmVnh1WEc1bWRXNWpkR2x2YmlCVGJHOTNRblZtWm1WeUlDaHNaVzVuZEdncElIdGNiaUFnYVdZZ0tDdHNaVzVuZEdnZ0lUMGdiR1Z1WjNSb0tTQjdJQzh2SUdWemJHbHVkQzFrYVhOaFlteGxMV3hwYm1VZ1pYRmxjV1Z4WEc0Z0lDQWdiR1Z1WjNSb0lEMGdNRnh1SUNCOVhHNGdJSEpsZEhWeWJpQkNkV1ptWlhJdVlXeHNiMk1vSzJ4bGJtZDBhQ2xjYm4xY2JseHVRblZtWm1WeUxtbHpRblZtWm1WeUlEMGdablZ1WTNScGIyNGdhWE5DZFdabVpYSWdLR0lwSUh0Y2JpQWdjbVYwZFhKdUlDRWhLR0lnSVQwZ2JuVnNiQ0FtSmlCaUxsOXBjMEoxWm1abGNpbGNibjFjYmx4dVFuVm1abVZ5TG1OdmJYQmhjbVVnUFNCbWRXNWpkR2x2YmlCamIyMXdZWEpsSUNoaExDQmlLU0I3WEc0Z0lHbG1JQ2doUW5WbVptVnlMbWx6UW5WbVptVnlLR0VwSUh4OElDRkNkV1ptWlhJdWFYTkNkV1ptWlhJb1lpa3BJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dWSGx3WlVWeWNtOXlLQ2RCY21kMWJXVnVkSE1nYlhWemRDQmlaU0JDZFdabVpYSnpKeWxjYmlBZ2ZWeHVYRzRnSUdsbUlDaGhJRDA5UFNCaUtTQnlaWFIxY200Z01GeHVYRzRnSUhaaGNpQjRJRDBnWVM1c1pXNW5kR2hjYmlBZ2RtRnlJSGtnUFNCaUxteGxibWQwYUZ4dVhHNGdJR1p2Y2lBb2RtRnlJR2tnUFNBd0xDQnNaVzRnUFNCTllYUm9MbTFwYmloNExDQjVLVHNnYVNBOElHeGxianNnS3l0cEtTQjdYRzRnSUNBZ2FXWWdLR0ZiYVYwZ0lUMDlJR0piYVYwcElIdGNiaUFnSUNBZ0lIZ2dQU0JoVzJsZFhHNGdJQ0FnSUNCNUlEMGdZbHRwWFZ4dUlDQWdJQ0FnWW5KbFlXdGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQnBaaUFvZUNBOElIa3BJSEpsZEhWeWJpQXRNVnh1SUNCcFppQW9lU0E4SUhncElISmxkSFZ5YmlBeFhHNGdJSEpsZEhWeWJpQXdYRzU5WEc1Y2JrSjFabVpsY2k1cGMwVnVZMjlrYVc1bklEMGdablZ1WTNScGIyNGdhWE5GYm1OdlpHbHVaeUFvWlc1amIyUnBibWNwSUh0Y2JpQWdjM2RwZEdOb0lDaFRkSEpwYm1jb1pXNWpiMlJwYm1jcExuUnZURzkzWlhKRFlYTmxLQ2twSUh0Y2JpQWdJQ0JqWVhObElDZG9aWGduT2x4dUlDQWdJR05oYzJVZ0ozVjBaamduT2x4dUlDQWdJR05oYzJVZ0ozVjBaaTA0SnpwY2JpQWdJQ0JqWVhObElDZGhjMk5wYVNjNlhHNGdJQ0FnWTJGelpTQW5iR0YwYVc0eEp6cGNiaUFnSUNCallYTmxJQ2RpYVc1aGNua25PbHh1SUNBZ0lHTmhjMlVnSjJKaGMyVTJOQ2M2WEc0Z0lDQWdZMkZ6WlNBbmRXTnpNaWM2WEc0Z0lDQWdZMkZ6WlNBbmRXTnpMVEluT2x4dUlDQWdJR05oYzJVZ0ozVjBaakUyYkdVbk9seHVJQ0FnSUdOaGMyVWdKM1YwWmkweE5teGxKenBjYmlBZ0lDQWdJSEpsZEhWeWJpQjBjblZsWEc0Z0lDQWdaR1ZtWVhWc2REcGNiaUFnSUNBZ0lISmxkSFZ5YmlCbVlXeHpaVnh1SUNCOVhHNTlYRzVjYmtKMVptWmxjaTVqYjI1allYUWdQU0JtZFc1amRHbHZiaUJqYjI1allYUWdLR3hwYzNRc0lHeGxibWQwYUNrZ2UxeHVJQ0JwWmlBb0lXbHpRWEp5WVhrb2JHbHpkQ2twSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0NkY0lteHBjM1JjSWlCaGNtZDFiV1Z1ZENCdGRYTjBJR0psSUdGdUlFRnljbUY1SUc5bUlFSjFabVpsY25NbktWeHVJQ0I5WEc1Y2JpQWdhV1lnS0d4cGMzUXViR1Z1WjNSb0lEMDlQU0F3S1NCN1hHNGdJQ0FnY21WMGRYSnVJRUoxWm1abGNpNWhiR3h2WXlnd0tWeHVJQ0I5WEc1Y2JpQWdkbUZ5SUdsY2JpQWdhV1lnS0d4bGJtZDBhQ0E5UFQwZ2RXNWtaV1pwYm1Wa0tTQjdYRzRnSUNBZ2JHVnVaM1JvSUQwZ01GeHVJQ0FnSUdadmNpQW9hU0E5SURBN0lHa2dQQ0JzYVhOMExteGxibWQwYURzZ0t5dHBLU0I3WEc0Z0lDQWdJQ0JzWlc1bmRHZ2dLejBnYkdsemRGdHBYUzVzWlc1bmRHaGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQjJZWElnWW5WbVptVnlJRDBnUW5WbVptVnlMbUZzYkc5alZXNXpZV1psS0d4bGJtZDBhQ2xjYmlBZ2RtRnlJSEJ2Y3lBOUlEQmNiaUFnWm05eUlDaHBJRDBnTURzZ2FTQThJR3hwYzNRdWJHVnVaM1JvT3lBcksya3BJSHRjYmlBZ0lDQjJZWElnWW5WbUlEMGdiR2x6ZEZ0cFhWeHVJQ0FnSUdsbUlDZ2hRblZtWm1WeUxtbHpRblZtWm1WeUtHSjFaaWtwSUh0Y2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCVWVYQmxSWEp5YjNJb0oxd2liR2x6ZEZ3aUlHRnlaM1Z0Wlc1MElHMTFjM1FnWW1VZ1lXNGdRWEp5WVhrZ2IyWWdRblZtWm1WeWN5Y3BYRzRnSUNBZ2ZWeHVJQ0FnSUdKMVppNWpiM0I1S0dKMVptWmxjaXdnY0c5ektWeHVJQ0FnSUhCdmN5QXJQU0JpZFdZdWJHVnVaM1JvWEc0Z0lIMWNiaUFnY21WMGRYSnVJR0oxWm1abGNseHVmVnh1WEc1bWRXNWpkR2x2YmlCaWVYUmxUR1Z1WjNSb0lDaHpkSEpwYm1jc0lHVnVZMjlrYVc1bktTQjdYRzRnSUdsbUlDaENkV1ptWlhJdWFYTkNkV1ptWlhJb2MzUnlhVzVuS1NrZ2UxeHVJQ0FnSUhKbGRIVnliaUJ6ZEhKcGJtY3ViR1Z1WjNSb1hHNGdJSDFjYmlBZ2FXWWdLSFI1Y0dWdlppQkJjbkpoZVVKMVptWmxjaUFoUFQwZ0ozVnVaR1ZtYVc1bFpDY2dKaVlnZEhsd1pXOW1JRUZ5Y21GNVFuVm1abVZ5TG1selZtbGxkeUE5UFQwZ0oyWjFibU4wYVc5dUp5QW1KbHh1SUNBZ0lDQWdLRUZ5Y21GNVFuVm1abVZ5TG1selZtbGxkeWh6ZEhKcGJtY3BJSHg4SUhOMGNtbHVaeUJwYm5OMFlXNWpaVzltSUVGeWNtRjVRblZtWm1WeUtTa2dlMXh1SUNBZ0lISmxkSFZ5YmlCemRISnBibWN1WW5sMFpVeGxibWQwYUZ4dUlDQjlYRzRnSUdsbUlDaDBlWEJsYjJZZ2MzUnlhVzVuSUNFOVBTQW5jM1J5YVc1bkp5a2dlMXh1SUNBZ0lITjBjbWx1WnlBOUlDY25JQ3NnYzNSeWFXNW5YRzRnSUgxY2JseHVJQ0IyWVhJZ2JHVnVJRDBnYzNSeWFXNW5MbXhsYm1kMGFGeHVJQ0JwWmlBb2JHVnVJRDA5UFNBd0tTQnlaWFIxY200Z01GeHVYRzRnSUM4dklGVnpaU0JoSUdadmNpQnNiMjl3SUhSdklHRjJiMmxrSUhKbFkzVnljMmx2Ymx4dUlDQjJZWElnYkc5M1pYSmxaRU5oYzJVZ1BTQm1ZV3h6WlZ4dUlDQm1iM0lnS0RzN0tTQjdYRzRnSUNBZ2MzZHBkR05vSUNobGJtTnZaR2x1WnlrZ2UxeHVJQ0FnSUNBZ1kyRnpaU0FuWVhOamFXa25PbHh1SUNBZ0lDQWdZMkZ6WlNBbmJHRjBhVzR4SnpwY2JpQWdJQ0FnSUdOaGMyVWdKMkpwYm1GeWVTYzZYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnNaVzVjYmlBZ0lDQWdJR05oYzJVZ0ozVjBaamduT2x4dUlDQWdJQ0FnWTJGelpTQW5kWFJtTFRnbk9seHVJQ0FnSUNBZ1kyRnpaU0IxYm1SbFptbHVaV1E2WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIxZEdZNFZHOUNlWFJsY3loemRISnBibWNwTG14bGJtZDBhRnh1SUNBZ0lDQWdZMkZ6WlNBbmRXTnpNaWM2WEc0Z0lDQWdJQ0JqWVhObElDZDFZM010TWljNlhHNGdJQ0FnSUNCallYTmxJQ2QxZEdZeE5teGxKenBjYmlBZ0lDQWdJR05oYzJVZ0ozVjBaaTB4Tm14bEp6cGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHeGxiaUFxSURKY2JpQWdJQ0FnSUdOaGMyVWdKMmhsZUNjNlhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCc1pXNGdQajQrSURGY2JpQWdJQ0FnSUdOaGMyVWdKMkpoYzJVMk5DYzZYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmlZWE5sTmpSVWIwSjVkR1Z6S0hOMGNtbHVaeWt1YkdWdVozUm9YRzRnSUNBZ0lDQmtaV1poZFd4ME9seHVJQ0FnSUNBZ0lDQnBaaUFvYkc5M1pYSmxaRU5oYzJVcElISmxkSFZ5YmlCMWRHWTRWRzlDZVhSbGN5aHpkSEpwYm1jcExteGxibWQwYUNBdkx5QmhjM04xYldVZ2RYUm1PRnh1SUNBZ0lDQWdJQ0JsYm1OdlpHbHVaeUE5SUNnbkp5QXJJR1Z1WTI5a2FXNW5LUzUwYjB4dmQyVnlRMkZ6WlNncFhHNGdJQ0FnSUNBZ0lHeHZkMlZ5WldSRFlYTmxJRDBnZEhKMVpWeHVJQ0FnSUgxY2JpQWdmVnh1ZlZ4dVFuVm1abVZ5TG1KNWRHVk1aVzVuZEdnZ1BTQmllWFJsVEdWdVozUm9YRzVjYm1aMWJtTjBhVzl1SUhOc2IzZFViMU4wY21sdVp5QW9aVzVqYjJScGJtY3NJSE4wWVhKMExDQmxibVFwSUh0Y2JpQWdkbUZ5SUd4dmQyVnlaV1JEWVhObElEMGdabUZzYzJWY2JseHVJQ0F2THlCT2J5QnVaV1ZrSUhSdklIWmxjbWxtZVNCMGFHRjBJRndpZEdocGN5NXNaVzVuZEdnZ1BEMGdUVUZZWDFWSlRsUXpNbHdpSUhOcGJtTmxJR2wwSjNNZ1lTQnlaV0ZrTFc5dWJIbGNiaUFnTHk4Z2NISnZjR1Z5ZEhrZ2IyWWdZU0IwZVhCbFpDQmhjbkpoZVM1Y2JseHVJQ0F2THlCVWFHbHpJR0psYUdGMlpYTWdibVZwZEdobGNpQnNhV3RsSUZOMGNtbHVaeUJ1YjNJZ1ZXbHVkRGhCY25KaGVTQnBiaUIwYUdGMElIZGxJSE5sZENCemRHRnlkQzlsYm1SY2JpQWdMeThnZEc4Z2RHaGxhWElnZFhCd1pYSXZiRzkzWlhJZ1ltOTFibVJ6SUdsbUlIUm9aU0IyWVd4MVpTQndZWE56WldRZ2FYTWdiM1YwSUc5bUlISmhibWRsTGx4dUlDQXZMeUIxYm1SbFptbHVaV1FnYVhNZ2FHRnVaR3hsWkNCemNHVmphV0ZzYkhrZ1lYTWdjR1Z5SUVWRFRVRXRNall5SURaMGFDQkZaR2wwYVc5dUxGeHVJQ0F2THlCVFpXTjBhVzl1SURFekxqTXVNeTQzSUZKMWJuUnBiV1VnVTJWdFlXNTBhV056T2lCTFpYbGxaRUpwYm1ScGJtZEpibWwwYVdGc2FYcGhkR2x2Ymk1Y2JpQWdhV1lnS0hOMFlYSjBJRDA5UFNCMWJtUmxabWx1WldRZ2ZId2djM1JoY25RZ1BDQXdLU0I3WEc0Z0lDQWdjM1JoY25RZ1BTQXdYRzRnSUgxY2JpQWdMeThnVW1WMGRYSnVJR1ZoY214NUlHbG1JSE4wWVhKMElENGdkR2hwY3k1c1pXNW5kR2d1SUVSdmJtVWdhR1Z5WlNCMGJ5QndjbVYyWlc1MElIQnZkR1Z1ZEdsaGJDQjFhVzUwTXpKY2JpQWdMeThnWTI5bGNtTnBiMjRnWm1GcGJDQmlaV3h2ZHk1Y2JpQWdhV1lnS0hOMFlYSjBJRDRnZEdocGN5NXNaVzVuZEdncElIdGNiaUFnSUNCeVpYUjFjbTRnSnlkY2JpQWdmVnh1WEc0Z0lHbG1JQ2hsYm1RZ1BUMDlJSFZ1WkdWbWFXNWxaQ0I4ZkNCbGJtUWdQaUIwYUdsekxteGxibWQwYUNrZ2UxeHVJQ0FnSUdWdVpDQTlJSFJvYVhNdWJHVnVaM1JvWEc0Z0lIMWNibHh1SUNCcFppQW9aVzVrSUR3OUlEQXBJSHRjYmlBZ0lDQnlaWFIxY200Z0p5ZGNiaUFnZlZ4dVhHNGdJQzh2SUVadmNtTmxJR052WlhKemFXOXVJSFJ2SUhWcGJuUXpNaTRnVkdocGN5QjNhV3hzSUdGc2MyOGdZMjlsY21ObElHWmhiSE5sZVM5T1lVNGdkbUZzZFdWeklIUnZJREF1WEc0Z0lHVnVaQ0ErUGo0OUlEQmNiaUFnYzNSaGNuUWdQajQrUFNBd1hHNWNiaUFnYVdZZ0tHVnVaQ0E4UFNCemRHRnlkQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQW5KMXh1SUNCOVhHNWNiaUFnYVdZZ0tDRmxibU52WkdsdVp5a2daVzVqYjJScGJtY2dQU0FuZFhSbU9DZGNibHh1SUNCM2FHbHNaU0FvZEhKMVpTa2dlMXh1SUNBZ0lITjNhWFJqYUNBb1pXNWpiMlJwYm1jcElIdGNiaUFnSUNBZ0lHTmhjMlVnSjJobGVDYzZYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQm9aWGhUYkdsalpTaDBhR2x6TENCemRHRnlkQ3dnWlc1a0tWeHVYRzRnSUNBZ0lDQmpZWE5sSUNkMWRHWTRKenBjYmlBZ0lDQWdJR05oYzJVZ0ozVjBaaTA0SnpwY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhWMFpqaFRiR2xqWlNoMGFHbHpMQ0J6ZEdGeWRDd2daVzVrS1Z4dVhHNGdJQ0FnSUNCallYTmxJQ2RoYzJOcGFTYzZYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmhjMk5wYVZOc2FXTmxLSFJvYVhNc0lITjBZWEowTENCbGJtUXBYRzVjYmlBZ0lDQWdJR05oYzJVZ0oyeGhkR2x1TVNjNlhHNGdJQ0FnSUNCallYTmxJQ2RpYVc1aGNua25PbHh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdiR0YwYVc0eFUyeHBZMlVvZEdocGN5d2djM1JoY25Rc0lHVnVaQ2xjYmx4dUlDQWdJQ0FnWTJGelpTQW5ZbUZ6WlRZMEp6cGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHSmhjMlUyTkZOc2FXTmxLSFJvYVhNc0lITjBZWEowTENCbGJtUXBYRzVjYmlBZ0lDQWdJR05oYzJVZ0ozVmpjekluT2x4dUlDQWdJQ0FnWTJGelpTQW5kV056TFRJbk9seHVJQ0FnSUNBZ1kyRnpaU0FuZFhSbU1UWnNaU2M2WEc0Z0lDQWdJQ0JqWVhObElDZDFkR1l0TVRac1pTYzZYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjFkR1l4Tm14bFUyeHBZMlVvZEdocGN5d2djM1JoY25Rc0lHVnVaQ2xjYmx4dUlDQWdJQ0FnWkdWbVlYVnNkRHBjYmlBZ0lDQWdJQ0FnYVdZZ0tHeHZkMlZ5WldSRFlYTmxLU0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0NkVmJtdHViM2R1SUdWdVkyOWthVzVuT2lBbklDc2daVzVqYjJScGJtY3BYRzRnSUNBZ0lDQWdJR1Z1WTI5a2FXNW5JRDBnS0dWdVkyOWthVzVuSUNzZ0p5Y3BMblJ2VEc5M1pYSkRZWE5sS0NsY2JpQWdJQ0FnSUNBZ2JHOTNaWEpsWkVOaGMyVWdQU0IwY25WbFhHNGdJQ0FnZlZ4dUlDQjlYRzU5WEc1Y2JpOHZJRlJvWlNCd2NtOXdaWEowZVNCcGN5QjFjMlZrSUdKNUlHQkNkV1ptWlhJdWFYTkNkV1ptWlhKZ0lHRnVaQ0JnYVhNdFluVm1abVZ5WUNBb2FXNGdVMkZtWVhKcElEVXROeWtnZEc4Z1pHVjBaV04wWEc0dkx5QkNkV1ptWlhJZ2FXNXpkR0Z1WTJWekxseHVRblZtWm1WeUxuQnliM1J2ZEhsd1pTNWZhWE5DZFdabVpYSWdQU0IwY25WbFhHNWNibVoxYm1OMGFXOXVJSE4zWVhBZ0tHSXNJRzRzSUcwcElIdGNiaUFnZG1GeUlHa2dQU0JpVzI1ZFhHNGdJR0piYmwwZ1BTQmlXMjFkWEc0Z0lHSmJiVjBnUFNCcFhHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1YzNkaGNERTJJRDBnWm5WdVkzUnBiMjRnYzNkaGNERTJJQ2dwSUh0Y2JpQWdkbUZ5SUd4bGJpQTlJSFJvYVhNdWJHVnVaM1JvWEc0Z0lHbG1JQ2hzWlc0Z0pTQXlJQ0U5UFNBd0tTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lGSmhibWRsUlhKeWIzSW9KMEoxWm1abGNpQnphWHBsSUcxMWMzUWdZbVVnWVNCdGRXeDBhWEJzWlNCdlppQXhOaTFpYVhSekp5bGNiaUFnZlZ4dUlDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR3hsYmpzZ2FTQXJQU0F5S1NCN1hHNGdJQ0FnYzNkaGNDaDBhR2x6TENCcExDQnBJQ3NnTVNsY2JpQWdmVnh1SUNCeVpYUjFjbTRnZEdocGMxeHVmVnh1WEc1Q2RXWm1aWEl1Y0hKdmRHOTBlWEJsTG5OM1lYQXpNaUE5SUdaMWJtTjBhVzl1SUhOM1lYQXpNaUFvS1NCN1hHNGdJSFpoY2lCc1pXNGdQU0IwYUdsekxteGxibWQwYUZ4dUlDQnBaaUFvYkdWdUlDVWdOQ0FoUFQwZ01Da2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QlNZVzVuWlVWeWNtOXlLQ2RDZFdabVpYSWdjMmw2WlNCdGRYTjBJR0psSUdFZ2JYVnNkR2x3YkdVZ2IyWWdNekl0WW1sMGN5Y3BYRzRnSUgxY2JpQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JzWlc0N0lHa2dLejBnTkNrZ2UxeHVJQ0FnSUhOM1lYQW9kR2hwY3l3Z2FTd2dhU0FySURNcFhHNGdJQ0FnYzNkaGNDaDBhR2x6TENCcElDc2dNU3dnYVNBcklESXBYRzRnSUgxY2JpQWdjbVYwZFhKdUlIUm9hWE5jYm4xY2JseHVRblZtWm1WeUxuQnliM1J2ZEhsd1pTNXpkMkZ3TmpRZ1BTQm1kVzVqZEdsdmJpQnpkMkZ3TmpRZ0tDa2dlMXh1SUNCMllYSWdiR1Z1SUQwZ2RHaHBjeTVzWlc1bmRHaGNiaUFnYVdZZ0tHeGxiaUFsSURnZ0lUMDlJREFwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnVW1GdVoyVkZjbkp2Y2lnblFuVm1abVZ5SUhOcGVtVWdiWFZ6ZENCaVpTQmhJRzExYkhScGNHeGxJRzltSURZMExXSnBkSE1uS1Z4dUlDQjlYRzRnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2JHVnVPeUJwSUNzOUlEZ3BJSHRjYmlBZ0lDQnpkMkZ3S0hSb2FYTXNJR2tzSUdrZ0t5QTNLVnh1SUNBZ0lITjNZWEFvZEdocGN5d2dhU0FySURFc0lHa2dLeUEyS1Z4dUlDQWdJSE4zWVhBb2RHaHBjeXdnYVNBcklESXNJR2tnS3lBMUtWeHVJQ0FnSUhOM1lYQW9kR2hwY3l3Z2FTQXJJRE1zSUdrZ0t5QTBLVnh1SUNCOVhHNGdJSEpsZEhWeWJpQjBhR2x6WEc1OVhHNWNia0oxWm1abGNpNXdjbTkwYjNSNWNHVXVkRzlUZEhKcGJtY2dQU0JtZFc1amRHbHZiaUIwYjFOMGNtbHVaeUFvS1NCN1hHNGdJSFpoY2lCc1pXNW5kR2dnUFNCMGFHbHpMbXhsYm1kMGFDQjhJREJjYmlBZ2FXWWdLR3hsYm1kMGFDQTlQVDBnTUNrZ2NtVjBkWEp1SUNjblhHNGdJR2xtSUNoaGNtZDFiV1Z1ZEhNdWJHVnVaM1JvSUQwOVBTQXdLU0J5WlhSMWNtNGdkWFJtT0ZOc2FXTmxLSFJvYVhNc0lEQXNJR3hsYm1kMGFDbGNiaUFnY21WMGRYSnVJSE5zYjNkVWIxTjBjbWx1Wnk1aGNIQnNlU2gwYUdsekxDQmhjbWQxYldWdWRITXBYRzU5WEc1Y2JrSjFabVpsY2k1d2NtOTBiM1I1Y0dVdVpYRjFZV3h6SUQwZ1puVnVZM1JwYjI0Z1pYRjFZV3h6SUNoaUtTQjdYRzRnSUdsbUlDZ2hRblZtWm1WeUxtbHpRblZtWm1WeUtHSXBLU0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0NkQmNtZDFiV1Z1ZENCdGRYTjBJR0psSUdFZ1FuVm1abVZ5SnlsY2JpQWdhV1lnS0hSb2FYTWdQVDA5SUdJcElISmxkSFZ5YmlCMGNuVmxYRzRnSUhKbGRIVnliaUJDZFdabVpYSXVZMjl0Y0dGeVpTaDBhR2x6TENCaUtTQTlQVDBnTUZ4dWZWeHVYRzVDZFdabVpYSXVjSEp2ZEc5MGVYQmxMbWx1YzNCbFkzUWdQU0JtZFc1amRHbHZiaUJwYm5Od1pXTjBJQ2dwSUh0Y2JpQWdkbUZ5SUhOMGNpQTlJQ2NuWEc0Z0lIWmhjaUJ0WVhnZ1BTQmxlSEJ2Y25SekxrbE9VMUJGUTFSZlRVRllYMEpaVkVWVFhHNGdJR2xtSUNoMGFHbHpMbXhsYm1kMGFDQStJREFwSUh0Y2JpQWdJQ0J6ZEhJZ1BTQjBhR2x6TG5SdlUzUnlhVzVuS0Nkb1pYZ25MQ0F3TENCdFlYZ3BMbTFoZEdOb0tDOHVleko5TDJjcExtcHZhVzRvSnlBbktWeHVJQ0FnSUdsbUlDaDBhR2x6TG14bGJtZDBhQ0ErSUcxaGVDa2djM1J5SUNzOUlDY2dMaTR1SUNkY2JpQWdmVnh1SUNCeVpYUjFjbTRnSnp4Q2RXWm1aWElnSnlBcklITjBjaUFySUNjK0oxeHVmVnh1WEc1Q2RXWm1aWEl1Y0hKdmRHOTBlWEJsTG1OdmJYQmhjbVVnUFNCbWRXNWpkR2x2YmlCamIyMXdZWEpsSUNoMFlYSm5aWFFzSUhOMFlYSjBMQ0JsYm1Rc0lIUm9hWE5UZEdGeWRDd2dkR2hwYzBWdVpDa2dlMXh1SUNCcFppQW9JVUoxWm1abGNpNXBjMEoxWm1abGNpaDBZWEpuWlhRcEtTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lGUjVjR1ZGY25KdmNpZ25RWEpuZFcxbGJuUWdiWFZ6ZENCaVpTQmhJRUoxWm1abGNpY3BYRzRnSUgxY2JseHVJQ0JwWmlBb2MzUmhjblFnUFQwOUlIVnVaR1ZtYVc1bFpDa2dlMXh1SUNBZ0lITjBZWEowSUQwZ01GeHVJQ0I5WEc0Z0lHbG1JQ2hsYm1RZ1BUMDlJSFZ1WkdWbWFXNWxaQ2tnZTF4dUlDQWdJR1Z1WkNBOUlIUmhjbWRsZENBL0lIUmhjbWRsZEM1c1pXNW5kR2dnT2lBd1hHNGdJSDFjYmlBZ2FXWWdLSFJvYVhOVGRHRnlkQ0E5UFQwZ2RXNWtaV1pwYm1Wa0tTQjdYRzRnSUNBZ2RHaHBjMU4wWVhKMElEMGdNRnh1SUNCOVhHNGdJR2xtSUNoMGFHbHpSVzVrSUQwOVBTQjFibVJsWm1sdVpXUXBJSHRjYmlBZ0lDQjBhR2x6Ulc1a0lEMGdkR2hwY3k1c1pXNW5kR2hjYmlBZ2ZWeHVYRzRnSUdsbUlDaHpkR0Z5ZENBOElEQWdmSHdnWlc1a0lENGdkR0Z5WjJWMExteGxibWQwYUNCOGZDQjBhR2x6VTNSaGNuUWdQQ0F3SUh4OElIUm9hWE5GYm1RZ1BpQjBhR2x6TG14bGJtZDBhQ2tnZTF4dUlDQWdJSFJvY205M0lHNWxkeUJTWVc1blpVVnljbTl5S0NkdmRYUWdiMllnY21GdVoyVWdhVzVrWlhnbktWeHVJQ0I5WEc1Y2JpQWdhV1lnS0hSb2FYTlRkR0Z5ZENBK1BTQjBhR2x6Ulc1a0lDWW1JSE4wWVhKMElENDlJR1Z1WkNrZ2UxeHVJQ0FnSUhKbGRIVnliaUF3WEc0Z0lIMWNiaUFnYVdZZ0tIUm9hWE5UZEdGeWRDQStQU0IwYUdselJXNWtLU0I3WEc0Z0lDQWdjbVYwZFhKdUlDMHhYRzRnSUgxY2JpQWdhV1lnS0hOMFlYSjBJRDQ5SUdWdVpDa2dlMXh1SUNBZ0lISmxkSFZ5YmlBeFhHNGdJSDFjYmx4dUlDQnpkR0Z5ZENBK1BqNDlJREJjYmlBZ1pXNWtJRDQrUGowZ01GeHVJQ0IwYUdselUzUmhjblFnUGo0K1BTQXdYRzRnSUhSb2FYTkZibVFnUGo0K1BTQXdYRzVjYmlBZ2FXWWdLSFJvYVhNZ1BUMDlJSFJoY21kbGRDa2djbVYwZFhKdUlEQmNibHh1SUNCMllYSWdlQ0E5SUhSb2FYTkZibVFnTFNCMGFHbHpVM1JoY25SY2JpQWdkbUZ5SUhrZ1BTQmxibVFnTFNCemRHRnlkRnh1SUNCMllYSWdiR1Z1SUQwZ1RXRjBhQzV0YVc0b2VDd2dlU2xjYmx4dUlDQjJZWElnZEdocGMwTnZjSGtnUFNCMGFHbHpMbk5zYVdObEtIUm9hWE5UZEdGeWRDd2dkR2hwYzBWdVpDbGNiaUFnZG1GeUlIUmhjbWRsZEVOdmNIa2dQU0IwWVhKblpYUXVjMnhwWTJVb2MzUmhjblFzSUdWdVpDbGNibHh1SUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHeGxianNnS3l0cEtTQjdYRzRnSUNBZ2FXWWdLSFJvYVhORGIzQjVXMmxkSUNFOVBTQjBZWEpuWlhSRGIzQjVXMmxkS1NCN1hHNGdJQ0FnSUNCNElEMGdkR2hwYzBOdmNIbGJhVjFjYmlBZ0lDQWdJSGtnUFNCMFlYSm5aWFJEYjNCNVcybGRYRzRnSUNBZ0lDQmljbVZoYTF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUdsbUlDaDRJRHdnZVNrZ2NtVjBkWEp1SUMweFhHNGdJR2xtSUNoNUlEd2dlQ2tnY21WMGRYSnVJREZjYmlBZ2NtVjBkWEp1SURCY2JuMWNibHh1THk4Z1JtbHVaSE1nWldsMGFHVnlJSFJvWlNCbWFYSnpkQ0JwYm1SbGVDQnZaaUJnZG1Gc1lDQnBiaUJnWW5WbVptVnlZQ0JoZENCdlptWnpaWFFnUGowZ1lHSjVkR1ZQWm1aelpYUmdMRnh1THk4Z1QxSWdkR2hsSUd4aGMzUWdhVzVrWlhnZ2IyWWdZSFpoYkdBZ2FXNGdZR0oxWm1abGNtQWdZWFFnYjJabWMyVjBJRHc5SUdCaWVYUmxUMlptYzJWMFlDNWNiaTh2WEc0dkx5QkJjbWQxYldWdWRITTZYRzR2THlBdElHSjFabVpsY2lBdElHRWdRblZtWm1WeUlIUnZJSE5sWVhKamFGeHVMeThnTFNCMllXd2dMU0JoSUhOMGNtbHVaeXdnUW5WbVptVnlMQ0J2Y2lCdWRXMWlaWEpjYmk4dklDMGdZbmwwWlU5bVpuTmxkQ0F0SUdGdUlHbHVaR1Y0SUdsdWRHOGdZR0oxWm1abGNtQTdJSGRwYkd3Z1ltVWdZMnhoYlhCbFpDQjBieUJoYmlCcGJuUXpNbHh1THk4Z0xTQmxibU52WkdsdVp5QXRJR0Z1SUc5d2RHbHZibUZzSUdWdVkyOWthVzVuTENCeVpXeGxkbUZ1ZENCcGN5QjJZV3dnYVhNZ1lTQnpkSEpwYm1kY2JpOHZJQzBnWkdseUlDMGdkSEoxWlNCbWIzSWdhVzVrWlhoUFppd2dabUZzYzJVZ1ptOXlJR3hoYzNSSmJtUmxlRTltWEc1bWRXNWpkR2x2YmlCaWFXUnBjbVZqZEdsdmJtRnNTVzVrWlhoUFppQW9ZblZtWm1WeUxDQjJZV3dzSUdKNWRHVlBabVp6WlhRc0lHVnVZMjlrYVc1bkxDQmthWElwSUh0Y2JpQWdMeThnUlcxd2RIa2dZblZtWm1WeUlHMWxZVzV6SUc1dklHMWhkR05vWEc0Z0lHbG1JQ2hpZFdabVpYSXViR1Z1WjNSb0lEMDlQU0F3S1NCeVpYUjFjbTRnTFRGY2JseHVJQ0F2THlCT2IzSnRZV3hwZW1VZ1lubDBaVTltWm5ObGRGeHVJQ0JwWmlBb2RIbHdaVzltSUdKNWRHVlBabVp6WlhRZ1BUMDlJQ2R6ZEhKcGJtY25LU0I3WEc0Z0lDQWdaVzVqYjJScGJtY2dQU0JpZVhSbFQyWm1jMlYwWEc0Z0lDQWdZbmwwWlU5bVpuTmxkQ0E5SURCY2JpQWdmU0JsYkhObElHbG1JQ2hpZVhSbFQyWm1jMlYwSUQ0Z01IZzNabVptWm1abVppa2dlMXh1SUNBZ0lHSjVkR1ZQWm1aelpYUWdQU0F3ZURkbVptWm1abVptWEc0Z0lIMGdaV3h6WlNCcFppQW9ZbmwwWlU5bVpuTmxkQ0E4SUMwd2VEZ3dNREF3TURBd0tTQjdYRzRnSUNBZ1lubDBaVTltWm5ObGRDQTlJQzB3ZURnd01EQXdNREF3WEc0Z0lIMWNiaUFnWW5sMFpVOW1abk5sZENBOUlDdGllWFJsVDJabWMyVjBJQ0F2THlCRGIyVnlZMlVnZEc4Z1RuVnRZbVZ5TGx4dUlDQnBaaUFvYVhOT1lVNG9ZbmwwWlU5bVpuTmxkQ2twSUh0Y2JpQWdJQ0F2THlCaWVYUmxUMlptYzJWME9pQnBkQ0JwZENkeklIVnVaR1ZtYVc1bFpDd2diblZzYkN3Z1RtRk9MQ0JjSW1admIxd2lMQ0JsZEdNc0lITmxZWEpqYUNCM2FHOXNaU0JpZFdabVpYSmNiaUFnSUNCaWVYUmxUMlptYzJWMElEMGdaR2x5SUQ4Z01DQTZJQ2hpZFdabVpYSXViR1Z1WjNSb0lDMGdNU2xjYmlBZ2ZWeHVYRzRnSUM4dklFNXZjbTFoYkdsNlpTQmllWFJsVDJabWMyVjBPaUJ1WldkaGRHbDJaU0J2Wm1aelpYUnpJSE4wWVhKMElHWnliMjBnZEdobElHVnVaQ0J2WmlCMGFHVWdZblZtWm1WeVhHNGdJR2xtSUNoaWVYUmxUMlptYzJWMElEd2dNQ2tnWW5sMFpVOW1abk5sZENBOUlHSjFabVpsY2k1c1pXNW5kR2dnS3lCaWVYUmxUMlptYzJWMFhHNGdJR2xtSUNoaWVYUmxUMlptYzJWMElENDlJR0oxWm1abGNpNXNaVzVuZEdncElIdGNiaUFnSUNCcFppQW9aR2x5S1NCeVpYUjFjbTRnTFRGY2JpQWdJQ0JsYkhObElHSjVkR1ZQWm1aelpYUWdQU0JpZFdabVpYSXViR1Z1WjNSb0lDMGdNVnh1SUNCOUlHVnNjMlVnYVdZZ0tHSjVkR1ZQWm1aelpYUWdQQ0F3S1NCN1hHNGdJQ0FnYVdZZ0tHUnBjaWtnWW5sMFpVOW1abk5sZENBOUlEQmNiaUFnSUNCbGJITmxJSEpsZEhWeWJpQXRNVnh1SUNCOVhHNWNiaUFnTHk4Z1RtOXliV0ZzYVhwbElIWmhiRnh1SUNCcFppQW9kSGx3Wlc5bUlIWmhiQ0E5UFQwZ0ozTjBjbWx1WnljcElIdGNiaUFnSUNCMllXd2dQU0JDZFdabVpYSXVabkp2YlNoMllXd3NJR1Z1WTI5a2FXNW5LVnh1SUNCOVhHNWNiaUFnTHk4Z1JtbHVZV3hzZVN3Z2MyVmhjbU5vSUdWcGRHaGxjaUJwYm1SbGVFOW1JQ2hwWmlCa2FYSWdhWE1nZEhKMVpTa2diM0lnYkdGemRFbHVaR1Y0VDJaY2JpQWdhV1lnS0VKMVptWmxjaTVwYzBKMVptWmxjaWgyWVd3cEtTQjdYRzRnSUNBZ0x5OGdVM0JsWTJsaGJDQmpZWE5sT2lCc2IyOXJhVzVuSUdadmNpQmxiWEIwZVNCemRISnBibWN2WW5WbVptVnlJR0ZzZDJGNWN5Qm1ZV2xzYzF4dUlDQWdJR2xtSUNoMllXd3ViR1Z1WjNSb0lEMDlQU0F3S1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnTFRGY2JpQWdJQ0I5WEc0Z0lDQWdjbVYwZFhKdUlHRnljbUY1U1c1a1pYaFBaaWhpZFdabVpYSXNJSFpoYkN3Z1lubDBaVTltWm5ObGRDd2daVzVqYjJScGJtY3NJR1JwY2lsY2JpQWdmU0JsYkhObElHbG1JQ2gwZVhCbGIyWWdkbUZzSUQwOVBTQW5iblZ0WW1WeUp5a2dlMXh1SUNBZ0lIWmhiQ0E5SUhaaGJDQW1JREI0UmtZZ0x5OGdVMlZoY21Ob0lHWnZjaUJoSUdKNWRHVWdkbUZzZFdVZ1d6QXRNalUxWFZ4dUlDQWdJR2xtSUNoQ2RXWm1aWEl1VkZsUVJVUmZRVkpTUVZsZlUxVlFVRTlTVkNBbUpseHVJQ0FnSUNBZ0lDQjBlWEJsYjJZZ1ZXbHVkRGhCY25KaGVTNXdjbTkwYjNSNWNHVXVhVzVrWlhoUFppQTlQVDBnSjJaMWJtTjBhVzl1SnlrZ2UxeHVJQ0FnSUNBZ2FXWWdLR1JwY2lrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1ZXbHVkRGhCY25KaGVTNXdjbTkwYjNSNWNHVXVhVzVrWlhoUFppNWpZV3hzS0dKMVptWmxjaXdnZG1Gc0xDQmllWFJsVDJabWMyVjBLVnh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlGVnBiblE0UVhKeVlYa3VjSEp2ZEc5MGVYQmxMbXhoYzNSSmJtUmxlRTltTG1OaGJHd29ZblZtWm1WeUxDQjJZV3dzSUdKNWRHVlBabVp6WlhRcFhHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dUlDQWdJSEpsZEhWeWJpQmhjbkpoZVVsdVpHVjRUMllvWW5WbVptVnlMQ0JiSUhaaGJDQmRMQ0JpZVhSbFQyWm1jMlYwTENCbGJtTnZaR2x1Wnl3Z1pHbHlLVnh1SUNCOVhHNWNiaUFnZEdoeWIzY2dibVYzSUZSNWNHVkZjbkp2Y2lnbmRtRnNJRzExYzNRZ1ltVWdjM1J5YVc1bkxDQnVkVzFpWlhJZ2IzSWdRblZtWm1WeUp5bGNibjFjYmx4dVpuVnVZM1JwYjI0Z1lYSnlZWGxKYm1SbGVFOW1JQ2hoY25Jc0lIWmhiQ3dnWW5sMFpVOW1abk5sZEN3Z1pXNWpiMlJwYm1jc0lHUnBjaWtnZTF4dUlDQjJZWElnYVc1a1pYaFRhWHBsSUQwZ01WeHVJQ0IyWVhJZ1lYSnlUR1Z1WjNSb0lEMGdZWEp5TG14bGJtZDBhRnh1SUNCMllYSWdkbUZzVEdWdVozUm9JRDBnZG1Gc0xteGxibWQwYUZ4dVhHNGdJR2xtSUNobGJtTnZaR2x1WnlBaFBUMGdkVzVrWldacGJtVmtLU0I3WEc0Z0lDQWdaVzVqYjJScGJtY2dQU0JUZEhKcGJtY29aVzVqYjJScGJtY3BMblJ2VEc5M1pYSkRZWE5sS0NsY2JpQWdJQ0JwWmlBb1pXNWpiMlJwYm1jZ1BUMDlJQ2QxWTNNeUp5QjhmQ0JsYm1OdlpHbHVaeUE5UFQwZ0ozVmpjeTB5SnlCOGZGeHVJQ0FnSUNBZ0lDQmxibU52WkdsdVp5QTlQVDBnSjNWMFpqRTJiR1VuSUh4OElHVnVZMjlrYVc1bklEMDlQU0FuZFhSbUxURTJiR1VuS1NCN1hHNGdJQ0FnSUNCcFppQW9ZWEp5TG14bGJtZDBhQ0E4SURJZ2ZId2dkbUZzTG14bGJtZDBhQ0E4SURJcElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlDMHhYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnBibVJsZUZOcGVtVWdQU0F5WEc0Z0lDQWdJQ0JoY25KTVpXNW5kR2dnTHowZ01seHVJQ0FnSUNBZ2RtRnNUR1Z1WjNSb0lDODlJREpjYmlBZ0lDQWdJR0o1ZEdWUFptWnpaWFFnTHowZ01seHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lHWjFibU4wYVc5dUlISmxZV1FnS0dKMVppd2dhU2tnZTF4dUlDQWdJR2xtSUNocGJtUmxlRk5wZW1VZ1BUMDlJREVwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJpZFdaYmFWMWNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnY21WMGRYSnVJR0oxWmk1eVpXRmtWVWx1ZERFMlFrVW9hU0FxSUdsdVpHVjRVMmw2WlNsY2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCMllYSWdhVnh1SUNCcFppQW9aR2x5S1NCN1hHNGdJQ0FnZG1GeUlHWnZkVzVrU1c1a1pYZ2dQU0F0TVZ4dUlDQWdJR1p2Y2lBb2FTQTlJR0o1ZEdWUFptWnpaWFE3SUdrZ1BDQmhjbkpNWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ2FXWWdLSEpsWVdRb1lYSnlMQ0JwS1NBOVBUMGdjbVZoWkNoMllXd3NJR1p2ZFc1a1NXNWtaWGdnUFQwOUlDMHhJRDhnTUNBNklHa2dMU0JtYjNWdVpFbHVaR1Y0S1NrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvWm05MWJtUkpibVJsZUNBOVBUMGdMVEVwSUdadmRXNWtTVzVrWlhnZ1BTQnBYRzRnSUNBZ0lDQWdJR2xtSUNocElDMGdabTkxYm1SSmJtUmxlQ0FySURFZ1BUMDlJSFpoYkV4bGJtZDBhQ2tnY21WMGRYSnVJR1p2ZFc1a1NXNWtaWGdnS2lCcGJtUmxlRk5wZW1WY2JpQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDaG1iM1Z1WkVsdVpHVjRJQ0U5UFNBdE1Ta2dhU0F0UFNCcElDMGdabTkxYm1SSmJtUmxlRnh1SUNBZ0lDQWdJQ0JtYjNWdVpFbHVaR1Y0SUQwZ0xURmNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNGdJSDBnWld4elpTQjdYRzRnSUNBZ2FXWWdLR0o1ZEdWUFptWnpaWFFnS3lCMllXeE1aVzVuZEdnZ1BpQmhjbkpNWlc1bmRHZ3BJR0o1ZEdWUFptWnpaWFFnUFNCaGNuSk1aVzVuZEdnZ0xTQjJZV3hNWlc1bmRHaGNiaUFnSUNCbWIzSWdLR2tnUFNCaWVYUmxUMlptYzJWME95QnBJRDQ5SURBN0lHa3RMU2tnZTF4dUlDQWdJQ0FnZG1GeUlHWnZkVzVrSUQwZ2RISjFaVnh1SUNBZ0lDQWdabTl5SUNoMllYSWdhaUE5SURBN0lHb2dQQ0IyWVd4TVpXNW5kR2c3SUdvckt5a2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb2NtVmhaQ2hoY25Jc0lHa2dLeUJxS1NBaFBUMGdjbVZoWkNoMllXd3NJR29wS1NCN1hHNGdJQ0FnSUNBZ0lDQWdabTkxYm1RZ1BTQm1ZV3h6WlZ4dUlDQWdJQ0FnSUNBZ0lHSnlaV0ZyWEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUdsbUlDaG1iM1Z1WkNrZ2NtVjBkWEp1SUdsY2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnTFRGY2JuMWNibHh1UW5WbVptVnlMbkJ5YjNSdmRIbHdaUzVwYm1Oc2RXUmxjeUE5SUdaMWJtTjBhVzl1SUdsdVkyeDFaR1Z6SUNoMllXd3NJR0o1ZEdWUFptWnpaWFFzSUdWdVkyOWthVzVuS1NCN1hHNGdJSEpsZEhWeWJpQjBhR2x6TG1sdVpHVjRUMllvZG1Gc0xDQmllWFJsVDJabWMyVjBMQ0JsYm1OdlpHbHVaeWtnSVQwOUlDMHhYRzU5WEc1Y2JrSjFabVpsY2k1d2NtOTBiM1I1Y0dVdWFXNWtaWGhQWmlBOUlHWjFibU4wYVc5dUlHbHVaR1Y0VDJZZ0tIWmhiQ3dnWW5sMFpVOW1abk5sZEN3Z1pXNWpiMlJwYm1jcElIdGNiaUFnY21WMGRYSnVJR0pwWkdseVpXTjBhVzl1WVd4SmJtUmxlRTltS0hSb2FYTXNJSFpoYkN3Z1lubDBaVTltWm5ObGRDd2daVzVqYjJScGJtY3NJSFJ5ZFdVcFhHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1YkdGemRFbHVaR1Y0VDJZZ1BTQm1kVzVqZEdsdmJpQnNZWE4wU1c1a1pYaFBaaUFvZG1Gc0xDQmllWFJsVDJabWMyVjBMQ0JsYm1OdlpHbHVaeWtnZTF4dUlDQnlaWFIxY200Z1ltbGthWEpsWTNScGIyNWhiRWx1WkdWNFQyWW9kR2hwY3l3Z2RtRnNMQ0JpZVhSbFQyWm1jMlYwTENCbGJtTnZaR2x1Wnl3Z1ptRnNjMlVwWEc1OVhHNWNibVoxYm1OMGFXOXVJR2hsZUZkeWFYUmxJQ2hpZFdZc0lITjBjbWx1Wnl3Z2IyWm1jMlYwTENCc1pXNW5kR2dwSUh0Y2JpQWdiMlptYzJWMElEMGdUblZ0WW1WeUtHOW1abk5sZENrZ2ZId2dNRnh1SUNCMllYSWdjbVZ0WVdsdWFXNW5JRDBnWW5WbUxteGxibWQwYUNBdElHOW1abk5sZEZ4dUlDQnBaaUFvSVd4bGJtZDBhQ2tnZTF4dUlDQWdJR3hsYm1kMGFDQTlJSEpsYldGcGJtbHVaMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJR3hsYm1kMGFDQTlJRTUxYldKbGNpaHNaVzVuZEdncFhHNGdJQ0FnYVdZZ0tHeGxibWQwYUNBK0lISmxiV0ZwYm1sdVp5a2dlMXh1SUNBZ0lDQWdiR1Z1WjNSb0lEMGdjbVZ0WVdsdWFXNW5YRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdMeThnYlhWemRDQmlaU0JoYmlCbGRtVnVJRzUxYldKbGNpQnZaaUJrYVdkcGRITmNiaUFnZG1GeUlITjBja3hsYmlBOUlITjBjbWx1Wnk1c1pXNW5kR2hjYmlBZ2FXWWdLSE4wY2t4bGJpQWxJRElnSVQwOUlEQXBJSFJvY205M0lHNWxkeUJVZVhCbFJYSnliM0lvSjBsdWRtRnNhV1FnYUdWNElITjBjbWx1WnljcFhHNWNiaUFnYVdZZ0tHeGxibWQwYUNBK0lITjBja3hsYmlBdklESXBJSHRjYmlBZ0lDQnNaVzVuZEdnZ1BTQnpkSEpNWlc0Z0x5QXlYRzRnSUgxY2JpQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JzWlc1bmRHZzdJQ3NyYVNrZ2UxeHVJQ0FnSUhaaGNpQndZWEp6WldRZ1BTQndZWEp6WlVsdWRDaHpkSEpwYm1jdWMzVmljM1J5S0drZ0tpQXlMQ0F5S1N3Z01UWXBYRzRnSUNBZ2FXWWdLR2x6VG1GT0tIQmhjbk5sWkNrcElISmxkSFZ5YmlCcFhHNGdJQ0FnWW5WbVcyOW1abk5sZENBcklHbGRJRDBnY0dGeWMyVmtYRzRnSUgxY2JpQWdjbVYwZFhKdUlHbGNibjFjYmx4dVpuVnVZM1JwYjI0Z2RYUm1PRmR5YVhSbElDaGlkV1lzSUhOMGNtbHVaeXdnYjJabWMyVjBMQ0JzWlc1bmRHZ3BJSHRjYmlBZ2NtVjBkWEp1SUdKc2FYUkNkV1ptWlhJb2RYUm1PRlJ2UW5sMFpYTW9jM1J5YVc1bkxDQmlkV1l1YkdWdVozUm9JQzBnYjJabWMyVjBLU3dnWW5WbUxDQnZabVp6WlhRc0lHeGxibWQwYUNsY2JuMWNibHh1Wm5WdVkzUnBiMjRnWVhOamFXbFhjbWwwWlNBb1luVm1MQ0J6ZEhKcGJtY3NJRzltWm5ObGRDd2diR1Z1WjNSb0tTQjdYRzRnSUhKbGRIVnliaUJpYkdsMFFuVm1abVZ5S0dGelkybHBWRzlDZVhSbGN5aHpkSEpwYm1jcExDQmlkV1lzSUc5bVpuTmxkQ3dnYkdWdVozUm9LVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQnNZWFJwYmpGWGNtbDBaU0FvWW5WbUxDQnpkSEpwYm1jc0lHOW1abk5sZEN3Z2JHVnVaM1JvS1NCN1hHNGdJSEpsZEhWeWJpQmhjMk5wYVZkeWFYUmxLR0oxWml3Z2MzUnlhVzVuTENCdlptWnpaWFFzSUd4bGJtZDBhQ2xjYm4xY2JseHVablZ1WTNScGIyNGdZbUZ6WlRZMFYzSnBkR1VnS0dKMVppd2djM1J5YVc1bkxDQnZabVp6WlhRc0lHeGxibWQwYUNrZ2UxeHVJQ0J5WlhSMWNtNGdZbXhwZEVKMVptWmxjaWhpWVhObE5qUlViMEo1ZEdWektITjBjbWx1Wnlrc0lHSjFaaXdnYjJabWMyVjBMQ0JzWlc1bmRHZ3BYRzU5WEc1Y2JtWjFibU4wYVc5dUlIVmpjekpYY21sMFpTQW9ZblZtTENCemRISnBibWNzSUc5bVpuTmxkQ3dnYkdWdVozUm9LU0I3WEc0Z0lISmxkSFZ5YmlCaWJHbDBRblZtWm1WeUtIVjBaakUyYkdWVWIwSjVkR1Z6S0hOMGNtbHVaeXdnWW5WbUxteGxibWQwYUNBdElHOW1abk5sZENrc0lHSjFaaXdnYjJabWMyVjBMQ0JzWlc1bmRHZ3BYRzU5WEc1Y2JrSjFabVpsY2k1d2NtOTBiM1I1Y0dVdWQzSnBkR1VnUFNCbWRXNWpkR2x2YmlCM2NtbDBaU0FvYzNSeWFXNW5MQ0J2Wm1aelpYUXNJR3hsYm1kMGFDd2daVzVqYjJScGJtY3BJSHRjYmlBZ0x5OGdRblZtWm1WeUkzZHlhWFJsS0hOMGNtbHVaeWxjYmlBZ2FXWWdLRzltWm5ObGRDQTlQVDBnZFc1a1pXWnBibVZrS1NCN1hHNGdJQ0FnWlc1amIyUnBibWNnUFNBbmRYUm1PQ2RjYmlBZ0lDQnNaVzVuZEdnZ1BTQjBhR2x6TG14bGJtZDBhRnh1SUNBZ0lHOW1abk5sZENBOUlEQmNiaUFnTHk4Z1FuVm1abVZ5STNkeWFYUmxLSE4wY21sdVp5d2daVzVqYjJScGJtY3BYRzRnSUgwZ1pXeHpaU0JwWmlBb2JHVnVaM1JvSUQwOVBTQjFibVJsWm1sdVpXUWdKaVlnZEhsd1pXOW1JRzltWm5ObGRDQTlQVDBnSjNOMGNtbHVaeWNwSUh0Y2JpQWdJQ0JsYm1OdlpHbHVaeUE5SUc5bVpuTmxkRnh1SUNBZ0lHeGxibWQwYUNBOUlIUm9hWE11YkdWdVozUm9YRzRnSUNBZ2IyWm1jMlYwSUQwZ01GeHVJQ0F2THlCQ2RXWm1aWElqZDNKcGRHVW9jM1J5YVc1bkxDQnZabVp6WlhSYkxDQnNaVzVuZEdoZFd5d2daVzVqYjJScGJtZGRLVnh1SUNCOUlHVnNjMlVnYVdZZ0tHbHpSbWx1YVhSbEtHOW1abk5sZENrcElIdGNiaUFnSUNCdlptWnpaWFFnUFNCdlptWnpaWFFnZkNBd1hHNGdJQ0FnYVdZZ0tHbHpSbWx1YVhSbEtHeGxibWQwYUNrcElIdGNiaUFnSUNBZ0lHeGxibWQwYUNBOUlHeGxibWQwYUNCOElEQmNiaUFnSUNBZ0lHbG1JQ2hsYm1OdlpHbHVaeUE5UFQwZ2RXNWtaV1pwYm1Wa0tTQmxibU52WkdsdVp5QTlJQ2QxZEdZNEoxeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0JsYm1OdlpHbHVaeUE5SUd4bGJtZDBhRnh1SUNBZ0lDQWdiR1Z1WjNSb0lEMGdkVzVrWldacGJtVmtYRzRnSUNBZ2ZWeHVJQ0F2THlCc1pXZGhZM2tnZDNKcGRHVW9jM1J5YVc1bkxDQmxibU52WkdsdVp5d2diMlptYzJWMExDQnNaVzVuZEdncElDMGdjbVZ0YjNabElHbHVJSFl3TGpFelhHNGdJSDBnWld4elpTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0Z4dUlDQWdJQ0FnSjBKMVptWmxjaTUzY21sMFpTaHpkSEpwYm1jc0lHVnVZMjlrYVc1bkxDQnZabVp6WlhSYkxDQnNaVzVuZEdoZEtTQnBjeUJ1YnlCc2IyNW5aWElnYzNWd2NHOXlkR1ZrSjF4dUlDQWdJQ2xjYmlBZ2ZWeHVYRzRnSUhaaGNpQnlaVzFoYVc1cGJtY2dQU0IwYUdsekxteGxibWQwYUNBdElHOW1abk5sZEZ4dUlDQnBaaUFvYkdWdVozUm9JRDA5UFNCMWJtUmxabWx1WldRZ2ZId2diR1Z1WjNSb0lENGdjbVZ0WVdsdWFXNW5LU0JzWlc1bmRHZ2dQU0J5WlcxaGFXNXBibWRjYmx4dUlDQnBaaUFvS0hOMGNtbHVaeTVzWlc1bmRHZ2dQaUF3SUNZbUlDaHNaVzVuZEdnZ1BDQXdJSHg4SUc5bVpuTmxkQ0E4SURBcEtTQjhmQ0J2Wm1aelpYUWdQaUIwYUdsekxteGxibWQwYUNrZ2UxeHVJQ0FnSUhSb2NtOTNJRzVsZHlCU1lXNW5aVVZ5Y205eUtDZEJkSFJsYlhCMElIUnZJSGR5YVhSbElHOTFkSE5wWkdVZ1luVm1abVZ5SUdKdmRXNWtjeWNwWEc0Z0lIMWNibHh1SUNCcFppQW9JV1Z1WTI5a2FXNW5LU0JsYm1OdlpHbHVaeUE5SUNkMWRHWTRKMXh1WEc0Z0lIWmhjaUJzYjNkbGNtVmtRMkZ6WlNBOUlHWmhiSE5sWEc0Z0lHWnZjaUFvT3pzcElIdGNiaUFnSUNCemQybDBZMmdnS0dWdVkyOWthVzVuS1NCN1hHNGdJQ0FnSUNCallYTmxJQ2RvWlhnbk9seHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2FHVjRWM0pwZEdVb2RHaHBjeXdnYzNSeWFXNW5MQ0J2Wm1aelpYUXNJR3hsYm1kMGFDbGNibHh1SUNBZ0lDQWdZMkZ6WlNBbmRYUm1PQ2M2WEc0Z0lDQWdJQ0JqWVhObElDZDFkR1l0T0NjNlhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMWRHWTRWM0pwZEdVb2RHaHBjeXdnYzNSeWFXNW5MQ0J2Wm1aelpYUXNJR3hsYm1kMGFDbGNibHh1SUNBZ0lDQWdZMkZ6WlNBbllYTmphV2tuT2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnWVhOamFXbFhjbWwwWlNoMGFHbHpMQ0J6ZEhKcGJtY3NJRzltWm5ObGRDd2diR1Z1WjNSb0tWeHVYRzRnSUNBZ0lDQmpZWE5sSUNkc1lYUnBiakVuT2x4dUlDQWdJQ0FnWTJGelpTQW5ZbWx1WVhKNUp6cGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHeGhkR2x1TVZkeWFYUmxLSFJvYVhNc0lITjBjbWx1Wnl3Z2IyWm1jMlYwTENCc1pXNW5kR2dwWEc1Y2JpQWdJQ0FnSUdOaGMyVWdKMkpoYzJVMk5DYzZYRzRnSUNBZ0lDQWdJQzh2SUZkaGNtNXBibWM2SUcxaGVFeGxibWQwYUNCdWIzUWdkR0ZyWlc0Z2FXNTBieUJoWTJOdmRXNTBJR2x1SUdKaGMyVTJORmR5YVhSbFhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCaVlYTmxOalJYY21sMFpTaDBhR2x6TENCemRISnBibWNzSUc5bVpuTmxkQ3dnYkdWdVozUm9LVnh1WEc0Z0lDQWdJQ0JqWVhObElDZDFZM015SnpwY2JpQWdJQ0FnSUdOaGMyVWdKM1ZqY3kweUp6cGNiaUFnSUNBZ0lHTmhjMlVnSjNWMFpqRTJiR1VuT2x4dUlDQWdJQ0FnWTJGelpTQW5kWFJtTFRFMmJHVW5PbHh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkV056TWxkeWFYUmxLSFJvYVhNc0lITjBjbWx1Wnl3Z2IyWm1jMlYwTENCc1pXNW5kR2dwWEc1Y2JpQWdJQ0FnSUdSbFptRjFiSFE2WEc0Z0lDQWdJQ0FnSUdsbUlDaHNiM2RsY21Wa1EyRnpaU2tnZEdoeWIzY2dibVYzSUZSNWNHVkZjbkp2Y2lnblZXNXJibTkzYmlCbGJtTnZaR2x1WnpvZ0p5QXJJR1Z1WTI5a2FXNW5LVnh1SUNBZ0lDQWdJQ0JsYm1OdlpHbHVaeUE5SUNnbkp5QXJJR1Z1WTI5a2FXNW5LUzUwYjB4dmQyVnlRMkZ6WlNncFhHNGdJQ0FnSUNBZ0lHeHZkMlZ5WldSRFlYTmxJRDBnZEhKMVpWeHVJQ0FnSUgxY2JpQWdmVnh1ZlZ4dVhHNUNkV1ptWlhJdWNISnZkRzkwZVhCbExuUnZTbE5QVGlBOUlHWjFibU4wYVc5dUlIUnZTbE5QVGlBb0tTQjdYRzRnSUhKbGRIVnliaUI3WEc0Z0lDQWdkSGx3WlRvZ0owSjFabVpsY2ljc1hHNGdJQ0FnWkdGMFlUb2dRWEp5WVhrdWNISnZkRzkwZVhCbExuTnNhV05sTG1OaGJHd29kR2hwY3k1ZllYSnlJSHg4SUhSb2FYTXNJREFwWEc0Z0lIMWNibjFjYmx4dVpuVnVZM1JwYjI0Z1ltRnpaVFkwVTJ4cFkyVWdLR0oxWml3Z2MzUmhjblFzSUdWdVpDa2dlMXh1SUNCcFppQW9jM1JoY25RZ1BUMDlJREFnSmlZZ1pXNWtJRDA5UFNCaWRXWXViR1Z1WjNSb0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUdKaGMyVTJOQzVtY205dFFubDBaVUZ5Y21GNUtHSjFaaWxjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0J5WlhSMWNtNGdZbUZ6WlRZMExtWnliMjFDZVhSbFFYSnlZWGtvWW5WbUxuTnNhV05sS0hOMFlYSjBMQ0JsYm1RcEtWeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJSFYwWmpoVGJHbGpaU0FvWW5WbUxDQnpkR0Z5ZEN3Z1pXNWtLU0I3WEc0Z0lHVnVaQ0E5SUUxaGRHZ3ViV2x1S0dKMVppNXNaVzVuZEdnc0lHVnVaQ2xjYmlBZ2RtRnlJSEpsY3lBOUlGdGRYRzVjYmlBZ2RtRnlJR2tnUFNCemRHRnlkRnh1SUNCM2FHbHNaU0FvYVNBOElHVnVaQ2tnZTF4dUlDQWdJSFpoY2lCbWFYSnpkRUo1ZEdVZ1BTQmlkV1piYVYxY2JpQWdJQ0IyWVhJZ1kyOWtaVkJ2YVc1MElEMGdiblZzYkZ4dUlDQWdJSFpoY2lCaWVYUmxjMUJsY2xObGNYVmxibU5sSUQwZ0tHWnBjbk4wUW5sMFpTQStJREI0UlVZcElEOGdORnh1SUNBZ0lDQWdPaUFvWm1seWMzUkNlWFJsSUQ0Z01IaEVSaWtnUHlBelhHNGdJQ0FnSUNBNklDaG1hWEp6ZEVKNWRHVWdQaUF3ZUVKR0tTQS9JREpjYmlBZ0lDQWdJRG9nTVZ4dVhHNGdJQ0FnYVdZZ0tHa2dLeUJpZVhSbGMxQmxjbE5sY1hWbGJtTmxJRHc5SUdWdVpDa2dlMXh1SUNBZ0lDQWdkbUZ5SUhObFkyOXVaRUo1ZEdVc0lIUm9hWEprUW5sMFpTd2dabTkxY25Sb1FubDBaU3dnZEdWdGNFTnZaR1ZRYjJsdWRGeHVYRzRnSUNBZ0lDQnpkMmwwWTJnZ0tHSjVkR1Z6VUdWeVUyVnhkV1Z1WTJVcElIdGNiaUFnSUNBZ0lDQWdZMkZ6WlNBeE9seHVJQ0FnSUNBZ0lDQWdJR2xtSUNobWFYSnpkRUo1ZEdVZ1BDQXdlRGd3S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjJSbFVHOXBiblFnUFNCbWFYSnpkRUo1ZEdWY2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnWW5KbFlXdGNiaUFnSUNBZ0lDQWdZMkZ6WlNBeU9seHVJQ0FnSUNBZ0lDQWdJSE5sWTI5dVpFSjVkR1VnUFNCaWRXWmJhU0FySURGZFhHNGdJQ0FnSUNBZ0lDQWdhV1lnS0NoelpXTnZibVJDZVhSbElDWWdNSGhETUNrZ1BUMDlJREI0T0RBcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhSbGJYQkRiMlJsVUc5cGJuUWdQU0FvWm1seWMzUkNlWFJsSUNZZ01IZ3hSaWtnUER3Z01IZzJJSHdnS0hObFkyOXVaRUo1ZEdVZ0ppQXdlRE5HS1Z4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0hSbGJYQkRiMlJsVUc5cGJuUWdQaUF3ZURkR0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZaR1ZRYjJsdWRDQTlJSFJsYlhCRGIyUmxVRzlwYm5SY2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdZbkpsWVd0Y2JpQWdJQ0FnSUNBZ1kyRnpaU0F6T2x4dUlDQWdJQ0FnSUNBZ0lITmxZMjl1WkVKNWRHVWdQU0JpZFdaYmFTQXJJREZkWEc0Z0lDQWdJQ0FnSUNBZ2RHaHBjbVJDZVhSbElEMGdZblZtVzJrZ0t5QXlYVnh1SUNBZ0lDQWdJQ0FnSUdsbUlDZ29jMlZqYjI1a1FubDBaU0FtSURCNFF6QXBJRDA5UFNBd2VEZ3dJQ1ltSUNoMGFHbHlaRUo1ZEdVZ0ppQXdlRU13S1NBOVBUMGdNSGc0TUNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdWdGNFTnZaR1ZRYjJsdWRDQTlJQ2htYVhKemRFSjVkR1VnSmlBd2VFWXBJRHc4SURCNFF5QjhJQ2h6WldOdmJtUkNlWFJsSUNZZ01IZ3pSaWtnUER3Z01IZzJJSHdnS0hSb2FYSmtRbmwwWlNBbUlEQjRNMFlwWEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvZEdWdGNFTnZaR1ZRYjJsdWRDQStJREI0TjBaR0lDWW1JQ2gwWlcxd1EyOWtaVkJ2YVc1MElEd2dNSGhFT0RBd0lIeDhJSFJsYlhCRGIyUmxVRzlwYm5RZ1BpQXdlRVJHUmtZcEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZaR1ZRYjJsdWRDQTlJSFJsYlhCRGIyUmxVRzlwYm5SY2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdZbkpsWVd0Y2JpQWdJQ0FnSUNBZ1kyRnpaU0EwT2x4dUlDQWdJQ0FnSUNBZ0lITmxZMjl1WkVKNWRHVWdQU0JpZFdaYmFTQXJJREZkWEc0Z0lDQWdJQ0FnSUNBZ2RHaHBjbVJDZVhSbElEMGdZblZtVzJrZ0t5QXlYVnh1SUNBZ0lDQWdJQ0FnSUdadmRYSjBhRUo1ZEdVZ1BTQmlkV1piYVNBcklETmRYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tDaHpaV052Ym1SQ2VYUmxJQ1lnTUhoRE1Da2dQVDA5SURCNE9EQWdKaVlnS0hSb2FYSmtRbmwwWlNBbUlEQjRRekFwSUQwOVBTQXdlRGd3SUNZbUlDaG1iM1Z5ZEdoQ2VYUmxJQ1lnTUhoRE1Da2dQVDA5SURCNE9EQXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUmxiWEJEYjJSbFVHOXBiblFnUFNBb1ptbHljM1JDZVhSbElDWWdNSGhHS1NBOFBDQXdlREV5SUh3Z0tITmxZMjl1WkVKNWRHVWdKaUF3ZUROR0tTQThQQ0F3ZUVNZ2ZDQW9kR2hwY21SQ2VYUmxJQ1lnTUhnelJpa2dQRHdnTUhnMklId2dLR1p2ZFhKMGFFSjVkR1VnSmlBd2VETkdLVnh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLSFJsYlhCRGIyUmxVRzlwYm5RZ1BpQXdlRVpHUmtZZ0ppWWdkR1Z0Y0VOdlpHVlFiMmx1ZENBOElEQjRNVEV3TURBd0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZaR1ZRYjJsdWRDQTlJSFJsYlhCRGIyUmxVRzlwYm5SY2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dVhHNGdJQ0FnYVdZZ0tHTnZaR1ZRYjJsdWRDQTlQVDBnYm5Wc2JDa2dlMXh1SUNBZ0lDQWdMeThnZDJVZ1pHbGtJRzV2ZENCblpXNWxjbUYwWlNCaElIWmhiR2xrSUdOdlpHVlFiMmx1ZENCemJ5QnBibk5sY25RZ1lWeHVJQ0FnSUNBZ0x5OGdjbVZ3YkdGalpXMWxiblFnWTJoaGNpQW9WU3RHUmtaRUtTQmhibVFnWVdSMllXNWpaU0J2Ym14NUlERWdZbmwwWlZ4dUlDQWdJQ0FnWTI5a1pWQnZhVzUwSUQwZ01IaEdSa1pFWEc0Z0lDQWdJQ0JpZVhSbGMxQmxjbE5sY1hWbGJtTmxJRDBnTVZ4dUlDQWdJSDBnWld4elpTQnBaaUFvWTI5a1pWQnZhVzUwSUQ0Z01IaEdSa1pHS1NCN1hHNGdJQ0FnSUNBdkx5QmxibU52WkdVZ2RHOGdkWFJtTVRZZ0tITjFjbkp2WjJGMFpTQndZV2x5SUdSaGJtTmxLVnh1SUNBZ0lDQWdZMjlrWlZCdmFXNTBJQzA5SURCNE1UQXdNREJjYmlBZ0lDQWdJSEpsY3k1d2RYTm9LR052WkdWUWIybHVkQ0ErUGo0Z01UQWdKaUF3ZUROR1JpQjhJREI0UkRnd01DbGNiaUFnSUNBZ0lHTnZaR1ZRYjJsdWRDQTlJREI0UkVNd01DQjhJR052WkdWUWIybHVkQ0FtSURCNE0wWkdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2NtVnpMbkIxYzJnb1kyOWtaVkJ2YVc1MEtWeHVJQ0FnSUdrZ0t6MGdZbmwwWlhOUVpYSlRaWEYxWlc1alpWeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlHUmxZMjlrWlVOdlpHVlFiMmx1ZEhOQmNuSmhlU2h5WlhNcFhHNTlYRzVjYmk4dklFSmhjMlZrSUc5dUlHaDBkSEE2THk5emRHRmphMjkyWlhKbWJHOTNMbU52YlM5aEx6SXlOelEzTWpjeUx6WTRNRGMwTWl3Z2RHaGxJR0p5YjNkelpYSWdkMmwwYUZ4dUx5OGdkR2hsSUd4dmQyVnpkQ0JzYVcxcGRDQnBjeUJEYUhKdmJXVXNJSGRwZEdnZ01IZ3hNREF3TUNCaGNtZHpMbHh1THk4Z1YyVWdaMjhnTVNCdFlXZHVhWFIxWkdVZ2JHVnpjeXdnWm05eUlITmhabVYwZVZ4dWRtRnlJRTFCV0Y5QlVrZFZUVVZPVkZOZlRFVk9SMVJJSUQwZ01IZ3hNREF3WEc1Y2JtWjFibU4wYVc5dUlHUmxZMjlrWlVOdlpHVlFiMmx1ZEhOQmNuSmhlU0FvWTI5a1pWQnZhVzUwY3lrZ2UxeHVJQ0IyWVhJZ2JHVnVJRDBnWTI5a1pWQnZhVzUwY3k1c1pXNW5kR2hjYmlBZ2FXWWdLR3hsYmlBOFBTQk5RVmhmUVZKSFZVMUZUbFJUWDB4RlRrZFVTQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQlRkSEpwYm1jdVpuSnZiVU5vWVhKRGIyUmxMbUZ3Y0d4NUtGTjBjbWx1Wnl3Z1kyOWtaVkJ2YVc1MGN5a2dMeThnWVhadmFXUWdaWGgwY21FZ2MyeHBZMlVvS1Z4dUlDQjlYRzVjYmlBZ0x5OGdSR1ZqYjJSbElHbHVJR05vZFc1cmN5QjBieUJoZG05cFpDQmNJbU5oYkd3Z2MzUmhZMnNnYzJsNlpTQmxlR05sWldSbFpGd2lMbHh1SUNCMllYSWdjbVZ6SUQwZ0p5ZGNiaUFnZG1GeUlHa2dQU0F3WEc0Z0lIZG9hV3hsSUNocElEd2diR1Z1S1NCN1hHNGdJQ0FnY21WeklDczlJRk4wY21sdVp5NW1jbTl0UTJoaGNrTnZaR1V1WVhCd2JIa29YRzRnSUNBZ0lDQlRkSEpwYm1jc1hHNGdJQ0FnSUNCamIyUmxVRzlwYm5SekxuTnNhV05sS0drc0lHa2dLejBnVFVGWVgwRlNSMVZOUlU1VVUxOU1SVTVIVkVncFhHNGdJQ0FnS1Z4dUlDQjlYRzRnSUhKbGRIVnliaUJ5WlhOY2JuMWNibHh1Wm5WdVkzUnBiMjRnWVhOamFXbFRiR2xqWlNBb1luVm1MQ0J6ZEdGeWRDd2daVzVrS1NCN1hHNGdJSFpoY2lCeVpYUWdQU0FuSjF4dUlDQmxibVFnUFNCTllYUm9MbTFwYmloaWRXWXViR1Z1WjNSb0xDQmxibVFwWEc1Y2JpQWdabTl5SUNoMllYSWdhU0E5SUhOMFlYSjBPeUJwSUR3Z1pXNWtPeUFySzJrcElIdGNiaUFnSUNCeVpYUWdLejBnVTNSeWFXNW5MbVp5YjIxRGFHRnlRMjlrWlNoaWRXWmJhVjBnSmlBd2VEZEdLVnh1SUNCOVhHNGdJSEpsZEhWeWJpQnlaWFJjYm4xY2JseHVablZ1WTNScGIyNGdiR0YwYVc0eFUyeHBZMlVnS0dKMVppd2djM1JoY25Rc0lHVnVaQ2tnZTF4dUlDQjJZWElnY21WMElEMGdKeWRjYmlBZ1pXNWtJRDBnVFdGMGFDNXRhVzRvWW5WbUxteGxibWQwYUN3Z1pXNWtLVnh1WEc0Z0lHWnZjaUFvZG1GeUlHa2dQU0J6ZEdGeWREc2dhU0E4SUdWdVpEc2dLeXRwS1NCN1hHNGdJQ0FnY21WMElDczlJRk4wY21sdVp5NW1jbTl0UTJoaGNrTnZaR1VvWW5WbVcybGRLVnh1SUNCOVhHNGdJSEpsZEhWeWJpQnlaWFJjYm4xY2JseHVablZ1WTNScGIyNGdhR1Y0VTJ4cFkyVWdLR0oxWml3Z2MzUmhjblFzSUdWdVpDa2dlMXh1SUNCMllYSWdiR1Z1SUQwZ1luVm1MbXhsYm1kMGFGeHVYRzRnSUdsbUlDZ2hjM1JoY25RZ2ZId2djM1JoY25RZ1BDQXdLU0J6ZEdGeWRDQTlJREJjYmlBZ2FXWWdLQ0ZsYm1RZ2ZId2daVzVrSUR3Z01DQjhmQ0JsYm1RZ1BpQnNaVzRwSUdWdVpDQTlJR3hsYmx4dVhHNGdJSFpoY2lCdmRYUWdQU0FuSjF4dUlDQm1iM0lnS0haaGNpQnBJRDBnYzNSaGNuUTdJR2tnUENCbGJtUTdJQ3NyYVNrZ2UxeHVJQ0FnSUc5MWRDQXJQU0IwYjBobGVDaGlkV1piYVYwcFhHNGdJSDFjYmlBZ2NtVjBkWEp1SUc5MWRGeHVmVnh1WEc1bWRXNWpkR2x2YmlCMWRHWXhObXhsVTJ4cFkyVWdLR0oxWml3Z2MzUmhjblFzSUdWdVpDa2dlMXh1SUNCMllYSWdZbmwwWlhNZ1BTQmlkV1l1YzJ4cFkyVW9jM1JoY25Rc0lHVnVaQ2xjYmlBZ2RtRnlJSEpsY3lBOUlDY25YRzRnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z1lubDBaWE11YkdWdVozUm9PeUJwSUNzOUlESXBJSHRjYmlBZ0lDQnlaWE1nS3owZ1UzUnlhVzVuTG1aeWIyMURhR0Z5UTI5a1pTaGllWFJsYzF0cFhTQXJJR0o1ZEdWelcya2dLeUF4WFNBcUlESTFOaWxjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdjbVZ6WEc1OVhHNWNia0oxWm1abGNpNXdjbTkwYjNSNWNHVXVjMnhwWTJVZ1BTQm1kVzVqZEdsdmJpQnpiR2xqWlNBb2MzUmhjblFzSUdWdVpDa2dlMXh1SUNCMllYSWdiR1Z1SUQwZ2RHaHBjeTVzWlc1bmRHaGNiaUFnYzNSaGNuUWdQU0IrZm5OMFlYSjBYRzRnSUdWdVpDQTlJR1Z1WkNBOVBUMGdkVzVrWldacGJtVmtJRDhnYkdWdUlEb2dmbjVsYm1SY2JseHVJQ0JwWmlBb2MzUmhjblFnUENBd0tTQjdYRzRnSUNBZ2MzUmhjblFnS3owZ2JHVnVYRzRnSUNBZ2FXWWdLSE4wWVhKMElEd2dNQ2tnYzNSaGNuUWdQU0F3WEc0Z0lIMGdaV3h6WlNCcFppQW9jM1JoY25RZ1BpQnNaVzRwSUh0Y2JpQWdJQ0J6ZEdGeWRDQTlJR3hsYmx4dUlDQjlYRzVjYmlBZ2FXWWdLR1Z1WkNBOElEQXBJSHRjYmlBZ0lDQmxibVFnS3owZ2JHVnVYRzRnSUNBZ2FXWWdLR1Z1WkNBOElEQXBJR1Z1WkNBOUlEQmNiaUFnZlNCbGJITmxJR2xtSUNobGJtUWdQaUJzWlc0cElIdGNiaUFnSUNCbGJtUWdQU0JzWlc1Y2JpQWdmVnh1WEc0Z0lHbG1JQ2hsYm1RZ1BDQnpkR0Z5ZENrZ1pXNWtJRDBnYzNSaGNuUmNibHh1SUNCMllYSWdibVYzUW5WbVhHNGdJR2xtSUNoQ2RXWm1aWEl1VkZsUVJVUmZRVkpTUVZsZlUxVlFVRTlTVkNrZ2UxeHVJQ0FnSUc1bGQwSjFaaUE5SUhSb2FYTXVjM1ZpWVhKeVlYa29jM1JoY25Rc0lHVnVaQ2xjYmlBZ0lDQnVaWGRDZFdZdVgxOXdjbTkwYjE5ZklEMGdRblZtWm1WeUxuQnliM1J2ZEhsd1pWeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lIWmhjaUJ6YkdsalpVeGxiaUE5SUdWdVpDQXRJSE4wWVhKMFhHNGdJQ0FnYm1WM1FuVm1JRDBnYm1WM0lFSjFabVpsY2loemJHbGpaVXhsYml3Z2RXNWtaV1pwYm1Wa0tWeHVJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2MyeHBZMlZNWlc0N0lDc3JhU2tnZTF4dUlDQWdJQ0FnYm1WM1FuVm1XMmxkSUQwZ2RHaHBjMXRwSUNzZ2MzUmhjblJkWEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnY21WMGRYSnVJRzVsZDBKMVpseHVmVnh1WEc0dktseHVJQ29nVG1WbFpDQjBieUJ0WVd0bElITjFjbVVnZEdoaGRDQmlkV1ptWlhJZ2FYTnVKM1FnZEhKNWFXNW5JSFJ2SUhkeWFYUmxJRzkxZENCdlppQmliM1Z1WkhNdVhHNGdLaTljYm1aMWJtTjBhVzl1SUdOb1pXTnJUMlptYzJWMElDaHZabVp6WlhRc0lHVjRkQ3dnYkdWdVozUm9LU0I3WEc0Z0lHbG1JQ2dvYjJabWMyVjBJQ1VnTVNrZ0lUMDlJREFnZkh3Z2IyWm1jMlYwSUR3Z01Da2dkR2h5YjNjZ2JtVjNJRkpoYm1kbFJYSnliM0lvSjI5bVpuTmxkQ0JwY3lCdWIzUWdkV2x1ZENjcFhHNGdJR2xtSUNodlptWnpaWFFnS3lCbGVIUWdQaUJzWlc1bmRHZ3BJSFJvY205M0lHNWxkeUJTWVc1blpVVnljbTl5S0NkVWNubHBibWNnZEc4Z1lXTmpaWE56SUdKbGVXOXVaQ0JpZFdabVpYSWdiR1Z1WjNSb0p5bGNibjFjYmx4dVFuVm1abVZ5TG5CeWIzUnZkSGx3WlM1eVpXRmtWVWx1ZEV4RklEMGdablZ1WTNScGIyNGdjbVZoWkZWSmJuUk1SU0FvYjJabWMyVjBMQ0JpZVhSbFRHVnVaM1JvTENCdWIwRnpjMlZ5ZENrZ2UxeHVJQ0J2Wm1aelpYUWdQU0J2Wm1aelpYUWdmQ0F3WEc0Z0lHSjVkR1ZNWlc1bmRHZ2dQU0JpZVhSbFRHVnVaM1JvSUh3Z01GeHVJQ0JwWmlBb0lXNXZRWE56WlhKMEtTQmphR1ZqYTA5bVpuTmxkQ2h2Wm1aelpYUXNJR0o1ZEdWTVpXNW5kR2dzSUhSb2FYTXViR1Z1WjNSb0tWeHVYRzRnSUhaaGNpQjJZV3dnUFNCMGFHbHpXMjltWm5ObGRGMWNiaUFnZG1GeUlHMTFiQ0E5SURGY2JpQWdkbUZ5SUdrZ1BTQXdYRzRnSUhkb2FXeGxJQ2dySzJrZ1BDQmllWFJsVEdWdVozUm9JQ1ltSUNodGRXd2dLajBnTUhneE1EQXBLU0I3WEc0Z0lDQWdkbUZzSUNzOUlIUm9hWE5iYjJabWMyVjBJQ3NnYVYwZ0tpQnRkV3hjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUIyWVd4Y2JuMWNibHh1UW5WbVptVnlMbkJ5YjNSdmRIbHdaUzV5WldGa1ZVbHVkRUpGSUQwZ1puVnVZM1JwYjI0Z2NtVmhaRlZKYm5SQ1JTQW9iMlptYzJWMExDQmllWFJsVEdWdVozUm9MQ0J1YjBGemMyVnlkQ2tnZTF4dUlDQnZabVp6WlhRZ1BTQnZabVp6WlhRZ2ZDQXdYRzRnSUdKNWRHVk1aVzVuZEdnZ1BTQmllWFJsVEdWdVozUm9JSHdnTUZ4dUlDQnBaaUFvSVc1dlFYTnpaWEowS1NCN1hHNGdJQ0FnWTJobFkydFBabVp6WlhRb2IyWm1jMlYwTENCaWVYUmxUR1Z1WjNSb0xDQjBhR2x6TG14bGJtZDBhQ2xjYmlBZ2ZWeHVYRzRnSUhaaGNpQjJZV3dnUFNCMGFHbHpXMjltWm5ObGRDQXJJQzB0WW5sMFpVeGxibWQwYUYxY2JpQWdkbUZ5SUcxMWJDQTlJREZjYmlBZ2QyaHBiR1VnS0dKNWRHVk1aVzVuZEdnZ1BpQXdJQ1ltSUNodGRXd2dLajBnTUhneE1EQXBLU0I3WEc0Z0lDQWdkbUZzSUNzOUlIUm9hWE5iYjJabWMyVjBJQ3NnTFMxaWVYUmxUR1Z1WjNSb1hTQXFJRzExYkZ4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUhaaGJGeHVmVnh1WEc1Q2RXWm1aWEl1Y0hKdmRHOTBlWEJsTG5KbFlXUlZTVzUwT0NBOUlHWjFibU4wYVc5dUlISmxZV1JWU1c1ME9DQW9iMlptYzJWMExDQnViMEZ6YzJWeWRDa2dlMXh1SUNCcFppQW9JVzV2UVhOelpYSjBLU0JqYUdWamEwOW1abk5sZENodlptWnpaWFFzSURFc0lIUm9hWE11YkdWdVozUm9LVnh1SUNCeVpYUjFjbTRnZEdocGMxdHZabVp6WlhSZFhHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1Y21WaFpGVkpiblF4Tmt4RklEMGdablZ1WTNScGIyNGdjbVZoWkZWSmJuUXhOa3hGSUNodlptWnpaWFFzSUc1dlFYTnpaWEowS1NCN1hHNGdJR2xtSUNnaGJtOUJjM05sY25RcElHTm9aV05yVDJabWMyVjBLRzltWm5ObGRDd2dNaXdnZEdocGN5NXNaVzVuZEdncFhHNGdJSEpsZEhWeWJpQjBhR2x6VzI5bVpuTmxkRjBnZkNBb2RHaHBjMXR2Wm1aelpYUWdLeUF4WFNBOFBDQTRLVnh1ZlZ4dVhHNUNkV1ptWlhJdWNISnZkRzkwZVhCbExuSmxZV1JWU1c1ME1UWkNSU0E5SUdaMWJtTjBhVzl1SUhKbFlXUlZTVzUwTVRaQ1JTQW9iMlptYzJWMExDQnViMEZ6YzJWeWRDa2dlMXh1SUNCcFppQW9JVzV2UVhOelpYSjBLU0JqYUdWamEwOW1abk5sZENodlptWnpaWFFzSURJc0lIUm9hWE11YkdWdVozUm9LVnh1SUNCeVpYUjFjbTRnS0hSb2FYTmJiMlptYzJWMFhTQThQQ0E0S1NCOElIUm9hWE5iYjJabWMyVjBJQ3NnTVYxY2JuMWNibHh1UW5WbVptVnlMbkJ5YjNSdmRIbHdaUzV5WldGa1ZVbHVkRE15VEVVZ1BTQm1kVzVqZEdsdmJpQnlaV0ZrVlVsdWRETXlURVVnS0c5bVpuTmxkQ3dnYm05QmMzTmxjblFwSUh0Y2JpQWdhV1lnS0NGdWIwRnpjMlZ5ZENrZ1kyaGxZMnRQWm1aelpYUW9iMlptYzJWMExDQTBMQ0IwYUdsekxteGxibWQwYUNsY2JseHVJQ0J5WlhSMWNtNGdLQ2gwYUdselcyOW1abk5sZEYwcElIeGNiaUFnSUNBZ0lDaDBhR2x6VzI5bVpuTmxkQ0FySURGZElEdzhJRGdwSUh4Y2JpQWdJQ0FnSUNoMGFHbHpXMjltWm5ObGRDQXJJREpkSUR3OElERTJLU2tnSzF4dUlDQWdJQ0FnS0hSb2FYTmJiMlptYzJWMElDc2dNMTBnS2lBd2VERXdNREF3TURBcFhHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1Y21WaFpGVkpiblF6TWtKRklEMGdablZ1WTNScGIyNGdjbVZoWkZWSmJuUXpNa0pGSUNodlptWnpaWFFzSUc1dlFYTnpaWEowS1NCN1hHNGdJR2xtSUNnaGJtOUJjM05sY25RcElHTm9aV05yVDJabWMyVjBLRzltWm5ObGRDd2dOQ3dnZEdocGN5NXNaVzVuZEdncFhHNWNiaUFnY21WMGRYSnVJQ2gwYUdselcyOW1abk5sZEYwZ0tpQXdlREV3TURBd01EQXBJQ3RjYmlBZ0lDQW9LSFJvYVhOYmIyWm1jMlYwSUNzZ01WMGdQRHdnTVRZcElIeGNiaUFnSUNBb2RHaHBjMXR2Wm1aelpYUWdLeUF5WFNBOFBDQTRLU0I4WEc0Z0lDQWdkR2hwYzF0dlptWnpaWFFnS3lBelhTbGNibjFjYmx4dVFuVm1abVZ5TG5CeWIzUnZkSGx3WlM1eVpXRmtTVzUwVEVVZ1BTQm1kVzVqZEdsdmJpQnlaV0ZrU1c1MFRFVWdLRzltWm5ObGRDd2dZbmwwWlV4bGJtZDBhQ3dnYm05QmMzTmxjblFwSUh0Y2JpQWdiMlptYzJWMElEMGdiMlptYzJWMElId2dNRnh1SUNCaWVYUmxUR1Z1WjNSb0lEMGdZbmwwWlV4bGJtZDBhQ0I4SURCY2JpQWdhV1lnS0NGdWIwRnpjMlZ5ZENrZ1kyaGxZMnRQWm1aelpYUW9iMlptYzJWMExDQmllWFJsVEdWdVozUm9MQ0IwYUdsekxteGxibWQwYUNsY2JseHVJQ0IyWVhJZ2RtRnNJRDBnZEdocGMxdHZabVp6WlhSZFhHNGdJSFpoY2lCdGRXd2dQU0F4WEc0Z0lIWmhjaUJwSUQwZ01GeHVJQ0IzYUdsc1pTQW9LeXRwSUR3Z1lubDBaVXhsYm1kMGFDQW1KaUFvYlhWc0lDbzlJREI0TVRBd0tTa2dlMXh1SUNBZ0lIWmhiQ0FyUFNCMGFHbHpXMjltWm5ObGRDQXJJR2xkSUNvZ2JYVnNYRzRnSUgxY2JpQWdiWFZzSUNvOUlEQjRPREJjYmx4dUlDQnBaaUFvZG1Gc0lENDlJRzExYkNrZ2RtRnNJQzA5SUUxaGRHZ3VjRzkzS0RJc0lEZ2dLaUJpZVhSbFRHVnVaM1JvS1Z4dVhHNGdJSEpsZEhWeWJpQjJZV3hjYm4xY2JseHVRblZtWm1WeUxuQnliM1J2ZEhsd1pTNXlaV0ZrU1c1MFFrVWdQU0JtZFc1amRHbHZiaUJ5WldGa1NXNTBRa1VnS0c5bVpuTmxkQ3dnWW5sMFpVeGxibWQwYUN3Z2JtOUJjM05sY25RcElIdGNiaUFnYjJabWMyVjBJRDBnYjJabWMyVjBJSHdnTUZ4dUlDQmllWFJsVEdWdVozUm9JRDBnWW5sMFpVeGxibWQwYUNCOElEQmNiaUFnYVdZZ0tDRnViMEZ6YzJWeWRDa2dZMmhsWTJ0UFptWnpaWFFvYjJabWMyVjBMQ0JpZVhSbFRHVnVaM1JvTENCMGFHbHpMbXhsYm1kMGFDbGNibHh1SUNCMllYSWdhU0E5SUdKNWRHVk1aVzVuZEdoY2JpQWdkbUZ5SUcxMWJDQTlJREZjYmlBZ2RtRnlJSFpoYkNBOUlIUm9hWE5iYjJabWMyVjBJQ3NnTFMxcFhWeHVJQ0IzYUdsc1pTQW9hU0ErSURBZ0ppWWdLRzExYkNBcVBTQXdlREV3TUNrcElIdGNiaUFnSUNCMllXd2dLejBnZEdocGMxdHZabVp6WlhRZ0t5QXRMV2xkSUNvZ2JYVnNYRzRnSUgxY2JpQWdiWFZzSUNvOUlEQjRPREJjYmx4dUlDQnBaaUFvZG1Gc0lENDlJRzExYkNrZ2RtRnNJQzA5SUUxaGRHZ3VjRzkzS0RJc0lEZ2dLaUJpZVhSbFRHVnVaM1JvS1Z4dVhHNGdJSEpsZEhWeWJpQjJZV3hjYm4xY2JseHVRblZtWm1WeUxuQnliM1J2ZEhsd1pTNXlaV0ZrU1c1ME9DQTlJR1oxYm1OMGFXOXVJSEpsWVdSSmJuUTRJQ2h2Wm1aelpYUXNJRzV2UVhOelpYSjBLU0I3WEc0Z0lHbG1JQ2doYm05QmMzTmxjblFwSUdOb1pXTnJUMlptYzJWMEtHOW1abk5sZEN3Z01Td2dkR2hwY3k1c1pXNW5kR2dwWEc0Z0lHbG1JQ2doS0hSb2FYTmJiMlptYzJWMFhTQW1JREI0T0RBcEtTQnlaWFIxY200Z0tIUm9hWE5iYjJabWMyVjBYU2xjYmlBZ2NtVjBkWEp1SUNnb01IaG1aaUF0SUhSb2FYTmJiMlptYzJWMFhTQXJJREVwSUNvZ0xURXBYRzU5WEc1Y2JrSjFabVpsY2k1d2NtOTBiM1I1Y0dVdWNtVmhaRWx1ZERFMlRFVWdQU0JtZFc1amRHbHZiaUJ5WldGa1NXNTBNVFpNUlNBb2IyWm1jMlYwTENCdWIwRnpjMlZ5ZENrZ2UxeHVJQ0JwWmlBb0lXNXZRWE56WlhKMEtTQmphR1ZqYTA5bVpuTmxkQ2h2Wm1aelpYUXNJRElzSUhSb2FYTXViR1Z1WjNSb0tWeHVJQ0IyWVhJZ2RtRnNJRDBnZEdocGMxdHZabVp6WlhSZElId2dLSFJvYVhOYmIyWm1jMlYwSUNzZ01WMGdQRHdnT0NsY2JpQWdjbVYwZFhKdUlDaDJZV3dnSmlBd2VEZ3dNREFwSUQ4Z2RtRnNJSHdnTUhoR1JrWkdNREF3TUNBNklIWmhiRnh1ZlZ4dVhHNUNkV1ptWlhJdWNISnZkRzkwZVhCbExuSmxZV1JKYm5ReE5rSkZJRDBnWm5WdVkzUnBiMjRnY21WaFpFbHVkREUyUWtVZ0tHOW1abk5sZEN3Z2JtOUJjM05sY25RcElIdGNiaUFnYVdZZ0tDRnViMEZ6YzJWeWRDa2dZMmhsWTJ0UFptWnpaWFFvYjJabWMyVjBMQ0F5TENCMGFHbHpMbXhsYm1kMGFDbGNiaUFnZG1GeUlIWmhiQ0E5SUhSb2FYTmJiMlptYzJWMElDc2dNVjBnZkNBb2RHaHBjMXR2Wm1aelpYUmRJRHc4SURncFhHNGdJSEpsZEhWeWJpQW9kbUZzSUNZZ01IZzRNREF3S1NBL0lIWmhiQ0I4SURCNFJrWkdSakF3TURBZ09pQjJZV3hjYm4xY2JseHVRblZtWm1WeUxuQnliM1J2ZEhsd1pTNXlaV0ZrU1c1ME16Sk1SU0E5SUdaMWJtTjBhVzl1SUhKbFlXUkpiblF6TWt4RklDaHZabVp6WlhRc0lHNXZRWE56WlhKMEtTQjdYRzRnSUdsbUlDZ2hibTlCYzNObGNuUXBJR05vWldOclQyWm1jMlYwS0c5bVpuTmxkQ3dnTkN3Z2RHaHBjeTVzWlc1bmRHZ3BYRzVjYmlBZ2NtVjBkWEp1SUNoMGFHbHpXMjltWm5ObGRGMHBJSHhjYmlBZ0lDQW9kR2hwYzF0dlptWnpaWFFnS3lBeFhTQThQQ0E0S1NCOFhHNGdJQ0FnS0hSb2FYTmJiMlptYzJWMElDc2dNbDBnUER3Z01UWXBJSHhjYmlBZ0lDQW9kR2hwYzF0dlptWnpaWFFnS3lBelhTQThQQ0F5TkNsY2JuMWNibHh1UW5WbVptVnlMbkJ5YjNSdmRIbHdaUzV5WldGa1NXNTBNekpDUlNBOUlHWjFibU4wYVc5dUlISmxZV1JKYm5Rek1rSkZJQ2h2Wm1aelpYUXNJRzV2UVhOelpYSjBLU0I3WEc0Z0lHbG1JQ2doYm05QmMzTmxjblFwSUdOb1pXTnJUMlptYzJWMEtHOW1abk5sZEN3Z05Dd2dkR2hwY3k1c1pXNW5kR2dwWEc1Y2JpQWdjbVYwZFhKdUlDaDBhR2x6VzI5bVpuTmxkRjBnUER3Z01qUXBJSHhjYmlBZ0lDQW9kR2hwYzF0dlptWnpaWFFnS3lBeFhTQThQQ0F4TmlrZ2ZGeHVJQ0FnSUNoMGFHbHpXMjltWm5ObGRDQXJJREpkSUR3OElEZ3BJSHhjYmlBZ0lDQW9kR2hwYzF0dlptWnpaWFFnS3lBelhTbGNibjFjYmx4dVFuVm1abVZ5TG5CeWIzUnZkSGx3WlM1eVpXRmtSbXh2WVhSTVJTQTlJR1oxYm1OMGFXOXVJSEpsWVdSR2JHOWhkRXhGSUNodlptWnpaWFFzSUc1dlFYTnpaWEowS1NCN1hHNGdJR2xtSUNnaGJtOUJjM05sY25RcElHTm9aV05yVDJabWMyVjBLRzltWm5ObGRDd2dOQ3dnZEdocGN5NXNaVzVuZEdncFhHNGdJSEpsZEhWeWJpQnBaV1ZsTnpVMExuSmxZV1FvZEdocGN5d2diMlptYzJWMExDQjBjblZsTENBeU15d2dOQ2xjYm4xY2JseHVRblZtWm1WeUxuQnliM1J2ZEhsd1pTNXlaV0ZrUm14dllYUkNSU0E5SUdaMWJtTjBhVzl1SUhKbFlXUkdiRzloZEVKRklDaHZabVp6WlhRc0lHNXZRWE56WlhKMEtTQjdYRzRnSUdsbUlDZ2hibTlCYzNObGNuUXBJR05vWldOclQyWm1jMlYwS0c5bVpuTmxkQ3dnTkN3Z2RHaHBjeTVzWlc1bmRHZ3BYRzRnSUhKbGRIVnliaUJwWldWbE56VTBMbkpsWVdRb2RHaHBjeXdnYjJabWMyVjBMQ0JtWVd4elpTd2dNak1zSURRcFhHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1Y21WaFpFUnZkV0pzWlV4RklEMGdablZ1WTNScGIyNGdjbVZoWkVSdmRXSnNaVXhGSUNodlptWnpaWFFzSUc1dlFYTnpaWEowS1NCN1hHNGdJR2xtSUNnaGJtOUJjM05sY25RcElHTm9aV05yVDJabWMyVjBLRzltWm5ObGRDd2dPQ3dnZEdocGN5NXNaVzVuZEdncFhHNGdJSEpsZEhWeWJpQnBaV1ZsTnpVMExuSmxZV1FvZEdocGN5d2diMlptYzJWMExDQjBjblZsTENBMU1pd2dPQ2xjYm4xY2JseHVRblZtWm1WeUxuQnliM1J2ZEhsd1pTNXlaV0ZrUkc5MVlteGxRa1VnUFNCbWRXNWpkR2x2YmlCeVpXRmtSRzkxWW14bFFrVWdLRzltWm5ObGRDd2dibTlCYzNObGNuUXBJSHRjYmlBZ2FXWWdLQ0Z1YjBGemMyVnlkQ2tnWTJobFkydFBabVp6WlhRb2IyWm1jMlYwTENBNExDQjBhR2x6TG14bGJtZDBhQ2xjYmlBZ2NtVjBkWEp1SUdsbFpXVTNOVFF1Y21WaFpDaDBhR2x6TENCdlptWnpaWFFzSUdaaGJITmxMQ0ExTWl3Z09DbGNibjFjYmx4dVpuVnVZM1JwYjI0Z1kyaGxZMnRKYm5RZ0tHSjFaaXdnZG1Gc2RXVXNJRzltWm5ObGRDd2daWGgwTENCdFlYZ3NJRzFwYmlrZ2UxeHVJQ0JwWmlBb0lVSjFabVpsY2k1cGMwSjFabVpsY2loaWRXWXBLU0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0NkY0ltSjFabVpsY2x3aUlHRnlaM1Z0Wlc1MElHMTFjM1FnWW1VZ1lTQkNkV1ptWlhJZ2FXNXpkR0Z1WTJVbktWeHVJQ0JwWmlBb2RtRnNkV1VnUGlCdFlYZ2dmSHdnZG1Gc2RXVWdQQ0J0YVc0cElIUm9jbTkzSUc1bGR5QlNZVzVuWlVWeWNtOXlLQ2RjSW5aaGJIVmxYQ0lnWVhKbmRXMWxiblFnYVhNZ2IzVjBJRzltSUdKdmRXNWtjeWNwWEc0Z0lHbG1JQ2h2Wm1aelpYUWdLeUJsZUhRZ1BpQmlkV1l1YkdWdVozUm9LU0IwYUhKdmR5QnVaWGNnVW1GdVoyVkZjbkp2Y2lnblNXNWtaWGdnYjNWMElHOW1JSEpoYm1kbEp5bGNibjFjYmx4dVFuVm1abVZ5TG5CeWIzUnZkSGx3WlM1M2NtbDBaVlZKYm5STVJTQTlJR1oxYm1OMGFXOXVJSGR5YVhSbFZVbHVkRXhGSUNoMllXeDFaU3dnYjJabWMyVjBMQ0JpZVhSbFRHVnVaM1JvTENCdWIwRnpjMlZ5ZENrZ2UxeHVJQ0IyWVd4MVpTQTlJQ3QyWVd4MVpWeHVJQ0J2Wm1aelpYUWdQU0J2Wm1aelpYUWdmQ0F3WEc0Z0lHSjVkR1ZNWlc1bmRHZ2dQU0JpZVhSbFRHVnVaM1JvSUh3Z01GeHVJQ0JwWmlBb0lXNXZRWE56WlhKMEtTQjdYRzRnSUNBZ2RtRnlJRzFoZUVKNWRHVnpJRDBnVFdGMGFDNXdiM2NvTWl3Z09DQXFJR0o1ZEdWTVpXNW5kR2dwSUMwZ01WeHVJQ0FnSUdOb1pXTnJTVzUwS0hSb2FYTXNJSFpoYkhWbExDQnZabVp6WlhRc0lHSjVkR1ZNWlc1bmRHZ3NJRzFoZUVKNWRHVnpMQ0F3S1Z4dUlDQjlYRzVjYmlBZ2RtRnlJRzExYkNBOUlERmNiaUFnZG1GeUlHa2dQU0F3WEc0Z0lIUm9hWE5iYjJabWMyVjBYU0E5SUhaaGJIVmxJQ1lnTUhoR1JseHVJQ0IzYUdsc1pTQW9LeXRwSUR3Z1lubDBaVXhsYm1kMGFDQW1KaUFvYlhWc0lDbzlJREI0TVRBd0tTa2dlMXh1SUNBZ0lIUm9hWE5iYjJabWMyVjBJQ3NnYVYwZ1BTQW9kbUZzZFdVZ0x5QnRkV3dwSUNZZ01IaEdSbHh1SUNCOVhHNWNiaUFnY21WMGRYSnVJRzltWm5ObGRDQXJJR0o1ZEdWTVpXNW5kR2hjYm4xY2JseHVRblZtWm1WeUxuQnliM1J2ZEhsd1pTNTNjbWwwWlZWSmJuUkNSU0E5SUdaMWJtTjBhVzl1SUhkeWFYUmxWVWx1ZEVKRklDaDJZV3gxWlN3Z2IyWm1jMlYwTENCaWVYUmxUR1Z1WjNSb0xDQnViMEZ6YzJWeWRDa2dlMXh1SUNCMllXeDFaU0E5SUN0MllXeDFaVnh1SUNCdlptWnpaWFFnUFNCdlptWnpaWFFnZkNBd1hHNGdJR0o1ZEdWTVpXNW5kR2dnUFNCaWVYUmxUR1Z1WjNSb0lId2dNRnh1SUNCcFppQW9JVzV2UVhOelpYSjBLU0I3WEc0Z0lDQWdkbUZ5SUcxaGVFSjVkR1Z6SUQwZ1RXRjBhQzV3YjNjb01pd2dPQ0FxSUdKNWRHVk1aVzVuZEdncElDMGdNVnh1SUNBZ0lHTm9aV05yU1c1MEtIUm9hWE1zSUhaaGJIVmxMQ0J2Wm1aelpYUXNJR0o1ZEdWTVpXNW5kR2dzSUcxaGVFSjVkR1Z6TENBd0tWeHVJQ0I5WEc1Y2JpQWdkbUZ5SUdrZ1BTQmllWFJsVEdWdVozUm9JQzBnTVZ4dUlDQjJZWElnYlhWc0lEMGdNVnh1SUNCMGFHbHpXMjltWm5ObGRDQXJJR2xkSUQwZ2RtRnNkV1VnSmlBd2VFWkdYRzRnSUhkb2FXeGxJQ2d0TFdrZ1BqMGdNQ0FtSmlBb2JYVnNJQ285SURCNE1UQXdLU2tnZTF4dUlDQWdJSFJvYVhOYmIyWm1jMlYwSUNzZ2FWMGdQU0FvZG1Gc2RXVWdMeUJ0ZFd3cElDWWdNSGhHUmx4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUc5bVpuTmxkQ0FySUdKNWRHVk1aVzVuZEdoY2JuMWNibHh1UW5WbVptVnlMbkJ5YjNSdmRIbHdaUzUzY21sMFpWVkpiblE0SUQwZ1puVnVZM1JwYjI0Z2QzSnBkR1ZWU1c1ME9DQW9kbUZzZFdVc0lHOW1abk5sZEN3Z2JtOUJjM05sY25RcElIdGNiaUFnZG1Gc2RXVWdQU0FyZG1Gc2RXVmNiaUFnYjJabWMyVjBJRDBnYjJabWMyVjBJSHdnTUZ4dUlDQnBaaUFvSVc1dlFYTnpaWEowS1NCamFHVmphMGx1ZENoMGFHbHpMQ0IyWVd4MVpTd2diMlptYzJWMExDQXhMQ0F3ZUdabUxDQXdLVnh1SUNCcFppQW9JVUoxWm1abGNpNVVXVkJGUkY5QlVsSkJXVjlUVlZCUVQxSlVLU0IyWVd4MVpTQTlJRTFoZEdndVpteHZiM0lvZG1Gc2RXVXBYRzRnSUhSb2FYTmJiMlptYzJWMFhTQTlJQ2gyWVd4MVpTQW1JREI0Wm1ZcFhHNGdJSEpsZEhWeWJpQnZabVp6WlhRZ0t5QXhYRzU5WEc1Y2JtWjFibU4wYVc5dUlHOWlhbVZqZEZkeWFYUmxWVWx1ZERFMklDaGlkV1lzSUhaaGJIVmxMQ0J2Wm1aelpYUXNJR3hwZEhSc1pVVnVaR2xoYmlrZ2UxeHVJQ0JwWmlBb2RtRnNkV1VnUENBd0tTQjJZV3gxWlNBOUlEQjRabVptWmlBcklIWmhiSFZsSUNzZ01WeHVJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Dd2dhaUE5SUUxaGRHZ3ViV2x1S0dKMVppNXNaVzVuZEdnZ0xTQnZabVp6WlhRc0lESXBPeUJwSUR3Z2Fqc2dLeXRwS1NCN1hHNGdJQ0FnWW5WbVcyOW1abk5sZENBcklHbGRJRDBnS0haaGJIVmxJQ1lnS0RCNFptWWdQRHdnS0RnZ0tpQW9iR2wwZEd4bFJXNWthV0Z1SUQ4Z2FTQTZJREVnTFNCcEtTa3BLU0ErUGo1Y2JpQWdJQ0FnSUNoc2FYUjBiR1ZGYm1ScFlXNGdQeUJwSURvZ01TQXRJR2twSUNvZ09GeHVJQ0I5WEc1OVhHNWNia0oxWm1abGNpNXdjbTkwYjNSNWNHVXVkM0pwZEdWVlNXNTBNVFpNUlNBOUlHWjFibU4wYVc5dUlIZHlhWFJsVlVsdWRERTJURVVnS0haaGJIVmxMQ0J2Wm1aelpYUXNJRzV2UVhOelpYSjBLU0I3WEc0Z0lIWmhiSFZsSUQwZ0szWmhiSFZsWEc0Z0lHOW1abk5sZENBOUlHOW1abk5sZENCOElEQmNiaUFnYVdZZ0tDRnViMEZ6YzJWeWRDa2dZMmhsWTJ0SmJuUW9kR2hwY3l3Z2RtRnNkV1VzSUc5bVpuTmxkQ3dnTWl3Z01IaG1abVptTENBd0tWeHVJQ0JwWmlBb1FuVm1abVZ5TGxSWlVFVkVYMEZTVWtGWlgxTlZVRkJQVWxRcElIdGNiaUFnSUNCMGFHbHpXMjltWm5ObGRGMGdQU0FvZG1Gc2RXVWdKaUF3ZUdabUtWeHVJQ0FnSUhSb2FYTmJiMlptYzJWMElDc2dNVjBnUFNBb2RtRnNkV1VnUGo0K0lEZ3BYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdiMkpxWldOMFYzSnBkR1ZWU1c1ME1UWW9kR2hwY3l3Z2RtRnNkV1VzSUc5bVpuTmxkQ3dnZEhKMVpTbGNiaUFnZlZ4dUlDQnlaWFIxY200Z2IyWm1jMlYwSUNzZ01seHVmVnh1WEc1Q2RXWm1aWEl1Y0hKdmRHOTBlWEJsTG5keWFYUmxWVWx1ZERFMlFrVWdQU0JtZFc1amRHbHZiaUIzY21sMFpWVkpiblF4TmtKRklDaDJZV3gxWlN3Z2IyWm1jMlYwTENCdWIwRnpjMlZ5ZENrZ2UxeHVJQ0IyWVd4MVpTQTlJQ3QyWVd4MVpWeHVJQ0J2Wm1aelpYUWdQU0J2Wm1aelpYUWdmQ0F3WEc0Z0lHbG1JQ2doYm05QmMzTmxjblFwSUdOb1pXTnJTVzUwS0hSb2FYTXNJSFpoYkhWbExDQnZabVp6WlhRc0lESXNJREI0Wm1abVppd2dNQ2xjYmlBZ2FXWWdLRUoxWm1abGNpNVVXVkJGUkY5QlVsSkJXVjlUVlZCUVQxSlVLU0I3WEc0Z0lDQWdkR2hwYzF0dlptWnpaWFJkSUQwZ0tIWmhiSFZsSUQ0K1BpQTRLVnh1SUNBZ0lIUm9hWE5iYjJabWMyVjBJQ3NnTVYwZ1BTQW9kbUZzZFdVZ0ppQXdlR1ptS1Z4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUc5aWFtVmpkRmR5YVhSbFZVbHVkREUyS0hSb2FYTXNJSFpoYkhWbExDQnZabVp6WlhRc0lHWmhiSE5sS1Z4dUlDQjlYRzRnSUhKbGRIVnliaUJ2Wm1aelpYUWdLeUF5WEc1OVhHNWNibVoxYm1OMGFXOXVJRzlpYW1WamRGZHlhWFJsVlVsdWRETXlJQ2hpZFdZc0lIWmhiSFZsTENCdlptWnpaWFFzSUd4cGRIUnNaVVZ1WkdsaGJpa2dlMXh1SUNCcFppQW9kbUZzZFdVZ1BDQXdLU0IyWVd4MVpTQTlJREI0Wm1abVptWm1abVlnS3lCMllXeDFaU0FySURGY2JpQWdabTl5SUNoMllYSWdhU0E5SURBc0lHb2dQU0JOWVhSb0xtMXBiaWhpZFdZdWJHVnVaM1JvSUMwZ2IyWm1jMlYwTENBMEtUc2dhU0E4SUdvN0lDc3JhU2tnZTF4dUlDQWdJR0oxWmx0dlptWnpaWFFnS3lCcFhTQTlJQ2gyWVd4MVpTQStQajRnS0d4cGRIUnNaVVZ1WkdsaGJpQS9JR2tnT2lBeklDMGdhU2tnS2lBNEtTQW1JREI0Wm1aY2JpQWdmVnh1ZlZ4dVhHNUNkV1ptWlhJdWNISnZkRzkwZVhCbExuZHlhWFJsVlVsdWRETXlURVVnUFNCbWRXNWpkR2x2YmlCM2NtbDBaVlZKYm5Rek1reEZJQ2gyWVd4MVpTd2diMlptYzJWMExDQnViMEZ6YzJWeWRDa2dlMXh1SUNCMllXeDFaU0E5SUN0MllXeDFaVnh1SUNCdlptWnpaWFFnUFNCdlptWnpaWFFnZkNBd1hHNGdJR2xtSUNnaGJtOUJjM05sY25RcElHTm9aV05yU1c1MEtIUm9hWE1zSUhaaGJIVmxMQ0J2Wm1aelpYUXNJRFFzSURCNFptWm1abVptWm1Zc0lEQXBYRzRnSUdsbUlDaENkV1ptWlhJdVZGbFFSVVJmUVZKU1FWbGZVMVZRVUU5U1ZDa2dlMXh1SUNBZ0lIUm9hWE5iYjJabWMyVjBJQ3NnTTEwZ1BTQW9kbUZzZFdVZ1BqNCtJREkwS1Z4dUlDQWdJSFJvYVhOYmIyWm1jMlYwSUNzZ01sMGdQU0FvZG1Gc2RXVWdQajQrSURFMktWeHVJQ0FnSUhSb2FYTmJiMlptYzJWMElDc2dNVjBnUFNBb2RtRnNkV1VnUGo0K0lEZ3BYRzRnSUNBZ2RHaHBjMXR2Wm1aelpYUmRJRDBnS0haaGJIVmxJQ1lnTUhobVppbGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQnZZbXBsWTNSWGNtbDBaVlZKYm5Rek1paDBhR2x6TENCMllXeDFaU3dnYjJabWMyVjBMQ0IwY25WbEtWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCdlptWnpaWFFnS3lBMFhHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1ZDNKcGRHVlZTVzUwTXpKQ1JTQTlJR1oxYm1OMGFXOXVJSGR5YVhSbFZVbHVkRE15UWtVZ0tIWmhiSFZsTENCdlptWnpaWFFzSUc1dlFYTnpaWEowS1NCN1hHNGdJSFpoYkhWbElEMGdLM1poYkhWbFhHNGdJRzltWm5ObGRDQTlJRzltWm5ObGRDQjhJREJjYmlBZ2FXWWdLQ0Z1YjBGemMyVnlkQ2tnWTJobFkydEpiblFvZEdocGN5d2dkbUZzZFdVc0lHOW1abk5sZEN3Z05Dd2dNSGhtWm1abVptWm1aaXdnTUNsY2JpQWdhV1lnS0VKMVptWmxjaTVVV1ZCRlJGOUJVbEpCV1Y5VFZWQlFUMUpVS1NCN1hHNGdJQ0FnZEdocGMxdHZabVp6WlhSZElEMGdLSFpoYkhWbElENCtQaUF5TkNsY2JpQWdJQ0IwYUdselcyOW1abk5sZENBcklERmRJRDBnS0haaGJIVmxJRDQrUGlBeE5pbGNiaUFnSUNCMGFHbHpXMjltWm5ObGRDQXJJREpkSUQwZ0tIWmhiSFZsSUQ0K1BpQTRLVnh1SUNBZ0lIUm9hWE5iYjJabWMyVjBJQ3NnTTEwZ1BTQW9kbUZzZFdVZ0ppQXdlR1ptS1Z4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUc5aWFtVmpkRmR5YVhSbFZVbHVkRE15S0hSb2FYTXNJSFpoYkhWbExDQnZabVp6WlhRc0lHWmhiSE5sS1Z4dUlDQjlYRzRnSUhKbGRIVnliaUJ2Wm1aelpYUWdLeUEwWEc1OVhHNWNia0oxWm1abGNpNXdjbTkwYjNSNWNHVXVkM0pwZEdWSmJuUk1SU0E5SUdaMWJtTjBhVzl1SUhkeWFYUmxTVzUwVEVVZ0tIWmhiSFZsTENCdlptWnpaWFFzSUdKNWRHVk1aVzVuZEdnc0lHNXZRWE56WlhKMEtTQjdYRzRnSUhaaGJIVmxJRDBnSzNaaGJIVmxYRzRnSUc5bVpuTmxkQ0E5SUc5bVpuTmxkQ0I4SURCY2JpQWdhV1lnS0NGdWIwRnpjMlZ5ZENrZ2UxeHVJQ0FnSUhaaGNpQnNhVzFwZENBOUlFMWhkR2d1Y0c5M0tESXNJRGdnS2lCaWVYUmxUR1Z1WjNSb0lDMGdNU2xjYmx4dUlDQWdJR05vWldOclNXNTBLSFJvYVhNc0lIWmhiSFZsTENCdlptWnpaWFFzSUdKNWRHVk1aVzVuZEdnc0lHeHBiV2wwSUMwZ01Td2dMV3hwYldsMEtWeHVJQ0I5WEc1Y2JpQWdkbUZ5SUdrZ1BTQXdYRzRnSUhaaGNpQnRkV3dnUFNBeFhHNGdJSFpoY2lCemRXSWdQU0F3WEc0Z0lIUm9hWE5iYjJabWMyVjBYU0E5SUhaaGJIVmxJQ1lnTUhoR1JseHVJQ0IzYUdsc1pTQW9LeXRwSUR3Z1lubDBaVXhsYm1kMGFDQW1KaUFvYlhWc0lDbzlJREI0TVRBd0tTa2dlMXh1SUNBZ0lHbG1JQ2gyWVd4MVpTQThJREFnSmlZZ2MzVmlJRDA5UFNBd0lDWW1JSFJvYVhOYmIyWm1jMlYwSUNzZ2FTQXRJREZkSUNFOVBTQXdLU0I3WEc0Z0lDQWdJQ0J6ZFdJZ1BTQXhYRzRnSUNBZ2ZWeHVJQ0FnSUhSb2FYTmJiMlptYzJWMElDc2dhVjBnUFNBb0tIWmhiSFZsSUM4Z2JYVnNLU0ErUGlBd0tTQXRJSE4xWWlBbUlEQjRSa1pjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJ2Wm1aelpYUWdLeUJpZVhSbFRHVnVaM1JvWEc1OVhHNWNia0oxWm1abGNpNXdjbTkwYjNSNWNHVXVkM0pwZEdWSmJuUkNSU0E5SUdaMWJtTjBhVzl1SUhkeWFYUmxTVzUwUWtVZ0tIWmhiSFZsTENCdlptWnpaWFFzSUdKNWRHVk1aVzVuZEdnc0lHNXZRWE56WlhKMEtTQjdYRzRnSUhaaGJIVmxJRDBnSzNaaGJIVmxYRzRnSUc5bVpuTmxkQ0E5SUc5bVpuTmxkQ0I4SURCY2JpQWdhV1lnS0NGdWIwRnpjMlZ5ZENrZ2UxeHVJQ0FnSUhaaGNpQnNhVzFwZENBOUlFMWhkR2d1Y0c5M0tESXNJRGdnS2lCaWVYUmxUR1Z1WjNSb0lDMGdNU2xjYmx4dUlDQWdJR05vWldOclNXNTBLSFJvYVhNc0lIWmhiSFZsTENCdlptWnpaWFFzSUdKNWRHVk1aVzVuZEdnc0lHeHBiV2wwSUMwZ01Td2dMV3hwYldsMEtWeHVJQ0I5WEc1Y2JpQWdkbUZ5SUdrZ1BTQmllWFJsVEdWdVozUm9JQzBnTVZ4dUlDQjJZWElnYlhWc0lEMGdNVnh1SUNCMllYSWdjM1ZpSUQwZ01GeHVJQ0IwYUdselcyOW1abk5sZENBcklHbGRJRDBnZG1Gc2RXVWdKaUF3ZUVaR1hHNGdJSGRvYVd4bElDZ3RMV2tnUGowZ01DQW1KaUFvYlhWc0lDbzlJREI0TVRBd0tTa2dlMXh1SUNBZ0lHbG1JQ2gyWVd4MVpTQThJREFnSmlZZ2MzVmlJRDA5UFNBd0lDWW1JSFJvYVhOYmIyWm1jMlYwSUNzZ2FTQXJJREZkSUNFOVBTQXdLU0I3WEc0Z0lDQWdJQ0J6ZFdJZ1BTQXhYRzRnSUNBZ2ZWeHVJQ0FnSUhSb2FYTmJiMlptYzJWMElDc2dhVjBnUFNBb0tIWmhiSFZsSUM4Z2JYVnNLU0ErUGlBd0tTQXRJSE4xWWlBbUlEQjRSa1pjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJ2Wm1aelpYUWdLeUJpZVhSbFRHVnVaM1JvWEc1OVhHNWNia0oxWm1abGNpNXdjbTkwYjNSNWNHVXVkM0pwZEdWSmJuUTRJRDBnWm5WdVkzUnBiMjRnZDNKcGRHVkpiblE0SUNoMllXeDFaU3dnYjJabWMyVjBMQ0J1YjBGemMyVnlkQ2tnZTF4dUlDQjJZV3gxWlNBOUlDdDJZV3gxWlZ4dUlDQnZabVp6WlhRZ1BTQnZabVp6WlhRZ2ZDQXdYRzRnSUdsbUlDZ2hibTlCYzNObGNuUXBJR05vWldOclNXNTBLSFJvYVhNc0lIWmhiSFZsTENCdlptWnpaWFFzSURFc0lEQjROMllzSUMwd2VEZ3dLVnh1SUNCcFppQW9JVUoxWm1abGNpNVVXVkJGUkY5QlVsSkJXVjlUVlZCUVQxSlVLU0IyWVd4MVpTQTlJRTFoZEdndVpteHZiM0lvZG1Gc2RXVXBYRzRnSUdsbUlDaDJZV3gxWlNBOElEQXBJSFpoYkhWbElEMGdNSGhtWmlBcklIWmhiSFZsSUNzZ01WeHVJQ0IwYUdselcyOW1abk5sZEYwZ1BTQW9kbUZzZFdVZ0ppQXdlR1ptS1Z4dUlDQnlaWFIxY200Z2IyWm1jMlYwSUNzZ01WeHVmVnh1WEc1Q2RXWm1aWEl1Y0hKdmRHOTBlWEJsTG5keWFYUmxTVzUwTVRaTVJTQTlJR1oxYm1OMGFXOXVJSGR5YVhSbFNXNTBNVFpNUlNBb2RtRnNkV1VzSUc5bVpuTmxkQ3dnYm05QmMzTmxjblFwSUh0Y2JpQWdkbUZzZFdVZ1BTQXJkbUZzZFdWY2JpQWdiMlptYzJWMElEMGdiMlptYzJWMElId2dNRnh1SUNCcFppQW9JVzV2UVhOelpYSjBLU0JqYUdWamEwbHVkQ2gwYUdsekxDQjJZV3gxWlN3Z2IyWm1jMlYwTENBeUxDQXdlRGRtWm1Zc0lDMHdlRGd3TURBcFhHNGdJR2xtSUNoQ2RXWm1aWEl1VkZsUVJVUmZRVkpTUVZsZlUxVlFVRTlTVkNrZ2UxeHVJQ0FnSUhSb2FYTmJiMlptYzJWMFhTQTlJQ2gyWVd4MVpTQW1JREI0Wm1ZcFhHNGdJQ0FnZEdocGMxdHZabVp6WlhRZ0t5QXhYU0E5SUNoMllXeDFaU0ErUGo0Z09DbGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQnZZbXBsWTNSWGNtbDBaVlZKYm5ReE5paDBhR2x6TENCMllXeDFaU3dnYjJabWMyVjBMQ0IwY25WbEtWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCdlptWnpaWFFnS3lBeVhHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1ZDNKcGRHVkpiblF4TmtKRklEMGdablZ1WTNScGIyNGdkM0pwZEdWSmJuUXhOa0pGSUNoMllXeDFaU3dnYjJabWMyVjBMQ0J1YjBGemMyVnlkQ2tnZTF4dUlDQjJZV3gxWlNBOUlDdDJZV3gxWlZ4dUlDQnZabVp6WlhRZ1BTQnZabVp6WlhRZ2ZDQXdYRzRnSUdsbUlDZ2hibTlCYzNObGNuUXBJR05vWldOclNXNTBLSFJvYVhNc0lIWmhiSFZsTENCdlptWnpaWFFzSURJc0lEQjROMlptWml3Z0xUQjRPREF3TUNsY2JpQWdhV1lnS0VKMVptWmxjaTVVV1ZCRlJGOUJVbEpCV1Y5VFZWQlFUMUpVS1NCN1hHNGdJQ0FnZEdocGMxdHZabVp6WlhSZElEMGdLSFpoYkhWbElENCtQaUE0S1Z4dUlDQWdJSFJvYVhOYmIyWm1jMlYwSUNzZ01WMGdQU0FvZG1Gc2RXVWdKaUF3ZUdabUtWeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lHOWlhbVZqZEZkeWFYUmxWVWx1ZERFMktIUm9hWE1zSUhaaGJIVmxMQ0J2Wm1aelpYUXNJR1poYkhObEtWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCdlptWnpaWFFnS3lBeVhHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1ZDNKcGRHVkpiblF6TWt4RklEMGdablZ1WTNScGIyNGdkM0pwZEdWSmJuUXpNa3hGSUNoMllXeDFaU3dnYjJabWMyVjBMQ0J1YjBGemMyVnlkQ2tnZTF4dUlDQjJZV3gxWlNBOUlDdDJZV3gxWlZ4dUlDQnZabVp6WlhRZ1BTQnZabVp6WlhRZ2ZDQXdYRzRnSUdsbUlDZ2hibTlCYzNObGNuUXBJR05vWldOclNXNTBLSFJvYVhNc0lIWmhiSFZsTENCdlptWnpaWFFzSURRc0lEQjROMlptWm1abVptWXNJQzB3ZURnd01EQXdNREF3S1Z4dUlDQnBaaUFvUW5WbVptVnlMbFJaVUVWRVgwRlNVa0ZaWDFOVlVGQlBVbFFwSUh0Y2JpQWdJQ0IwYUdselcyOW1abk5sZEYwZ1BTQW9kbUZzZFdVZ0ppQXdlR1ptS1Z4dUlDQWdJSFJvYVhOYmIyWm1jMlYwSUNzZ01WMGdQU0FvZG1Gc2RXVWdQajQrSURncFhHNGdJQ0FnZEdocGMxdHZabVp6WlhRZ0t5QXlYU0E5SUNoMllXeDFaU0ErUGo0Z01UWXBYRzRnSUNBZ2RHaHBjMXR2Wm1aelpYUWdLeUF6WFNBOUlDaDJZV3gxWlNBK1BqNGdNalFwWEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnYjJKcVpXTjBWM0pwZEdWVlNXNTBNeklvZEdocGN5d2dkbUZzZFdVc0lHOW1abk5sZEN3Z2RISjFaU2xjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdiMlptYzJWMElDc2dORnh1ZlZ4dVhHNUNkV1ptWlhJdWNISnZkRzkwZVhCbExuZHlhWFJsU1c1ME16SkNSU0E5SUdaMWJtTjBhVzl1SUhkeWFYUmxTVzUwTXpKQ1JTQW9kbUZzZFdVc0lHOW1abk5sZEN3Z2JtOUJjM05sY25RcElIdGNiaUFnZG1Gc2RXVWdQU0FyZG1Gc2RXVmNiaUFnYjJabWMyVjBJRDBnYjJabWMyVjBJSHdnTUZ4dUlDQnBaaUFvSVc1dlFYTnpaWEowS1NCamFHVmphMGx1ZENoMGFHbHpMQ0IyWVd4MVpTd2diMlptYzJWMExDQTBMQ0F3ZURkbVptWm1abVptTENBdE1IZzRNREF3TURBd01DbGNiaUFnYVdZZ0tIWmhiSFZsSUR3Z01Da2dkbUZzZFdVZ1BTQXdlR1ptWm1abVptWm1JQ3NnZG1Gc2RXVWdLeUF4WEc0Z0lHbG1JQ2hDZFdabVpYSXVWRmxRUlVSZlFWSlNRVmxmVTFWUVVFOVNWQ2tnZTF4dUlDQWdJSFJvYVhOYmIyWm1jMlYwWFNBOUlDaDJZV3gxWlNBK1BqNGdNalFwWEc0Z0lDQWdkR2hwYzF0dlptWnpaWFFnS3lBeFhTQTlJQ2gyWVd4MVpTQStQajRnTVRZcFhHNGdJQ0FnZEdocGMxdHZabVp6WlhRZ0t5QXlYU0E5SUNoMllXeDFaU0ErUGo0Z09DbGNiaUFnSUNCMGFHbHpXMjltWm5ObGRDQXJJRE5kSUQwZ0tIWmhiSFZsSUNZZ01IaG1aaWxjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0J2WW1wbFkzUlhjbWwwWlZWSmJuUXpNaWgwYUdsekxDQjJZV3gxWlN3Z2IyWm1jMlYwTENCbVlXeHpaU2xjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdiMlptYzJWMElDc2dORnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmphR1ZqYTBsRlJVVTNOVFFnS0dKMVppd2dkbUZzZFdVc0lHOW1abk5sZEN3Z1pYaDBMQ0J0WVhnc0lHMXBiaWtnZTF4dUlDQnBaaUFvYjJabWMyVjBJQ3NnWlhoMElENGdZblZtTG14bGJtZDBhQ2tnZEdoeWIzY2dibVYzSUZKaGJtZGxSWEp5YjNJb0owbHVaR1Y0SUc5MWRDQnZaaUJ5WVc1blpTY3BYRzRnSUdsbUlDaHZabVp6WlhRZ1BDQXdLU0IwYUhKdmR5QnVaWGNnVW1GdVoyVkZjbkp2Y2lnblNXNWtaWGdnYjNWMElHOW1JSEpoYm1kbEp5bGNibjFjYmx4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZHYkc5aGRDQW9ZblZtTENCMllXeDFaU3dnYjJabWMyVjBMQ0JzYVhSMGJHVkZibVJwWVc0c0lHNXZRWE56WlhKMEtTQjdYRzRnSUdsbUlDZ2hibTlCYzNObGNuUXBJSHRjYmlBZ0lDQmphR1ZqYTBsRlJVVTNOVFFvWW5WbUxDQjJZV3gxWlN3Z2IyWm1jMlYwTENBMExDQXpMalF3TWpneU16UTJOak00TlRJNE9EWmxLek00TENBdE15NDBNREk0TWpNME5qWXpPRFV5T0RnMlpTc3pPQ2xjYmlBZ2ZWeHVJQ0JwWldWbE56VTBMbmR5YVhSbEtHSjFaaXdnZG1Gc2RXVXNJRzltWm5ObGRDd2diR2wwZEd4bFJXNWthV0Z1TENBeU15d2dOQ2xjYmlBZ2NtVjBkWEp1SUc5bVpuTmxkQ0FySURSY2JuMWNibHh1UW5WbVptVnlMbkJ5YjNSdmRIbHdaUzUzY21sMFpVWnNiMkYwVEVVZ1BTQm1kVzVqZEdsdmJpQjNjbWwwWlVac2IyRjBURVVnS0haaGJIVmxMQ0J2Wm1aelpYUXNJRzV2UVhOelpYSjBLU0I3WEc0Z0lISmxkSFZ5YmlCM2NtbDBaVVpzYjJGMEtIUm9hWE1zSUhaaGJIVmxMQ0J2Wm1aelpYUXNJSFJ5ZFdVc0lHNXZRWE56WlhKMEtWeHVmVnh1WEc1Q2RXWm1aWEl1Y0hKdmRHOTBlWEJsTG5keWFYUmxSbXh2WVhSQ1JTQTlJR1oxYm1OMGFXOXVJSGR5YVhSbFJteHZZWFJDUlNBb2RtRnNkV1VzSUc5bVpuTmxkQ3dnYm05QmMzTmxjblFwSUh0Y2JpQWdjbVYwZFhKdUlIZHlhWFJsUm14dllYUW9kR2hwY3l3Z2RtRnNkV1VzSUc5bVpuTmxkQ3dnWm1Gc2MyVXNJRzV2UVhOelpYSjBLVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQjNjbWwwWlVSdmRXSnNaU0FvWW5WbUxDQjJZV3gxWlN3Z2IyWm1jMlYwTENCc2FYUjBiR1ZGYm1ScFlXNHNJRzV2UVhOelpYSjBLU0I3WEc0Z0lHbG1JQ2doYm05QmMzTmxjblFwSUh0Y2JpQWdJQ0JqYUdWamEwbEZSVVUzTlRRb1luVm1MQ0IyWVd4MVpTd2diMlptYzJWMExDQTRMQ0F4TGpjNU56WTVNekV6TkRnMk1qTXhOVGRGS3pNd09Dd2dMVEV1TnprM05qa3pNVE0wT0RZeU16RTFOMFVyTXpBNEtWeHVJQ0I5WEc0Z0lHbGxaV1UzTlRRdWQzSnBkR1VvWW5WbUxDQjJZV3gxWlN3Z2IyWm1jMlYwTENCc2FYUjBiR1ZGYm1ScFlXNHNJRFV5TENBNEtWeHVJQ0J5WlhSMWNtNGdiMlptYzJWMElDc2dPRnh1ZlZ4dVhHNUNkV1ptWlhJdWNISnZkRzkwZVhCbExuZHlhWFJsUkc5MVlteGxURVVnUFNCbWRXNWpkR2x2YmlCM2NtbDBaVVJ2ZFdKc1pVeEZJQ2gyWVd4MVpTd2diMlptYzJWMExDQnViMEZ6YzJWeWRDa2dlMXh1SUNCeVpYUjFjbTRnZDNKcGRHVkViM1ZpYkdVb2RHaHBjeXdnZG1Gc2RXVXNJRzltWm5ObGRDd2dkSEoxWlN3Z2JtOUJjM05sY25RcFhHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1ZDNKcGRHVkViM1ZpYkdWQ1JTQTlJR1oxYm1OMGFXOXVJSGR5YVhSbFJHOTFZbXhsUWtVZ0tIWmhiSFZsTENCdlptWnpaWFFzSUc1dlFYTnpaWEowS1NCN1hHNGdJSEpsZEhWeWJpQjNjbWwwWlVSdmRXSnNaU2gwYUdsekxDQjJZV3gxWlN3Z2IyWm1jMlYwTENCbVlXeHpaU3dnYm05QmMzTmxjblFwWEc1OVhHNWNiaTh2SUdOdmNIa29kR0Z5WjJWMFFuVm1abVZ5TENCMFlYSm5aWFJUZEdGeWREMHdMQ0J6YjNWeVkyVlRkR0Z5ZEQwd0xDQnpiM1Z5WTJWRmJtUTlZblZtWm1WeUxteGxibWQwYUNsY2JrSjFabVpsY2k1d2NtOTBiM1I1Y0dVdVkyOXdlU0E5SUdaMWJtTjBhVzl1SUdOdmNIa2dLSFJoY21kbGRDd2dkR0Z5WjJWMFUzUmhjblFzSUhOMFlYSjBMQ0JsYm1RcElIdGNiaUFnYVdZZ0tDRnpkR0Z5ZENrZ2MzUmhjblFnUFNBd1hHNGdJR2xtSUNnaFpXNWtJQ1ltSUdWdVpDQWhQVDBnTUNrZ1pXNWtJRDBnZEdocGN5NXNaVzVuZEdoY2JpQWdhV1lnS0hSaGNtZGxkRk4wWVhKMElENDlJSFJoY21kbGRDNXNaVzVuZEdncElIUmhjbWRsZEZOMFlYSjBJRDBnZEdGeVoyVjBMbXhsYm1kMGFGeHVJQ0JwWmlBb0lYUmhjbWRsZEZOMFlYSjBLU0IwWVhKblpYUlRkR0Z5ZENBOUlEQmNiaUFnYVdZZ0tHVnVaQ0ErSURBZ0ppWWdaVzVrSUR3Z2MzUmhjblFwSUdWdVpDQTlJSE4wWVhKMFhHNWNiaUFnTHk4Z1EyOXdlU0F3SUdKNWRHVnpPeUIzWlNkeVpTQmtiMjVsWEc0Z0lHbG1JQ2hsYm1RZ1BUMDlJSE4wWVhKMEtTQnlaWFIxY200Z01GeHVJQ0JwWmlBb2RHRnlaMlYwTG14bGJtZDBhQ0E5UFQwZ01DQjhmQ0IwYUdsekxteGxibWQwYUNBOVBUMGdNQ2tnY21WMGRYSnVJREJjYmx4dUlDQXZMeUJHWVhSaGJDQmxjbkp2Y2lCamIyNWthWFJwYjI1elhHNGdJR2xtSUNoMFlYSm5aWFJUZEdGeWRDQThJREFwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnVW1GdVoyVkZjbkp2Y2lnbmRHRnlaMlYwVTNSaGNuUWdiM1YwSUc5bUlHSnZkVzVrY3ljcFhHNGdJSDFjYmlBZ2FXWWdLSE4wWVhKMElEd2dNQ0I4ZkNCemRHRnlkQ0ErUFNCMGFHbHpMbXhsYm1kMGFDa2dkR2h5YjNjZ2JtVjNJRkpoYm1kbFJYSnliM0lvSjNOdmRYSmpaVk4wWVhKMElHOTFkQ0J2WmlCaWIzVnVaSE1uS1Z4dUlDQnBaaUFvWlc1a0lEd2dNQ2tnZEdoeWIzY2dibVYzSUZKaGJtZGxSWEp5YjNJb0ozTnZkWEpqWlVWdVpDQnZkWFFnYjJZZ1ltOTFibVJ6SnlsY2JseHVJQ0F2THlCQmNtVWdkMlVnYjI5aVAxeHVJQ0JwWmlBb1pXNWtJRDRnZEdocGN5NXNaVzVuZEdncElHVnVaQ0E5SUhSb2FYTXViR1Z1WjNSb1hHNGdJR2xtSUNoMFlYSm5aWFF1YkdWdVozUm9JQzBnZEdGeVoyVjBVM1JoY25RZ1BDQmxibVFnTFNCemRHRnlkQ2tnZTF4dUlDQWdJR1Z1WkNBOUlIUmhjbWRsZEM1c1pXNW5kR2dnTFNCMFlYSm5aWFJUZEdGeWRDQXJJSE4wWVhKMFhHNGdJSDFjYmx4dUlDQjJZWElnYkdWdUlEMGdaVzVrSUMwZ2MzUmhjblJjYmlBZ2RtRnlJR2xjYmx4dUlDQnBaaUFvZEdocGN5QTlQVDBnZEdGeVoyVjBJQ1ltSUhOMFlYSjBJRHdnZEdGeVoyVjBVM1JoY25RZ0ppWWdkR0Z5WjJWMFUzUmhjblFnUENCbGJtUXBJSHRjYmlBZ0lDQXZMeUJrWlhOalpXNWthVzVuSUdOdmNIa2dabkp2YlNCbGJtUmNiaUFnSUNCbWIzSWdLR2tnUFNCc1pXNGdMU0F4T3lCcElENDlJREE3SUMwdGFTa2dlMXh1SUNBZ0lDQWdkR0Z5WjJWMFcya2dLeUIwWVhKblpYUlRkR0Z5ZEYwZ1BTQjBhR2x6VzJrZ0t5QnpkR0Z5ZEYxY2JpQWdJQ0I5WEc0Z0lIMGdaV3h6WlNCcFppQW9iR1Z1SUR3Z01UQXdNQ0I4ZkNBaFFuVm1abVZ5TGxSWlVFVkVYMEZTVWtGWlgxTlZVRkJQVWxRcElIdGNiaUFnSUNBdkx5QmhjMk5sYm1ScGJtY2dZMjl3ZVNCbWNtOXRJSE4wWVhKMFhHNGdJQ0FnWm05eUlDaHBJRDBnTURzZ2FTQThJR3hsYmpzZ0t5dHBLU0I3WEc0Z0lDQWdJQ0IwWVhKblpYUmJhU0FySUhSaGNtZGxkRk4wWVhKMFhTQTlJSFJvYVhOYmFTQXJJSE4wWVhKMFhWeHVJQ0FnSUgxY2JpQWdmU0JsYkhObElIdGNiaUFnSUNCVmFXNTBPRUZ5Y21GNUxuQnliM1J2ZEhsd1pTNXpaWFF1WTJGc2JDaGNiaUFnSUNBZ0lIUmhjbWRsZEN4Y2JpQWdJQ0FnSUhSb2FYTXVjM1ZpWVhKeVlYa29jM1JoY25Rc0lITjBZWEowSUNzZ2JHVnVLU3hjYmlBZ0lDQWdJSFJoY21kbGRGTjBZWEowWEc0Z0lDQWdLVnh1SUNCOVhHNWNiaUFnY21WMGRYSnVJR3hsYmx4dWZWeHVYRzR2THlCVmMyRm5aVHBjYmk4dklDQWdJR0oxWm1abGNpNW1hV3hzS0c1MWJXSmxjbHNzSUc5bVpuTmxkRnNzSUdWdVpGMWRLVnh1THk4Z0lDQWdZblZtWm1WeUxtWnBiR3dvWW5WbVptVnlXeXdnYjJabWMyVjBXeXdnWlc1a1hWMHBYRzR2THlBZ0lDQmlkV1ptWlhJdVptbHNiQ2h6ZEhKcGJtZGJMQ0J2Wm1aelpYUmJMQ0JsYm1SZFhWc3NJR1Z1WTI5a2FXNW5YU2xjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1Wm1sc2JDQTlJR1oxYm1OMGFXOXVJR1pwYkd3Z0tIWmhiQ3dnYzNSaGNuUXNJR1Z1WkN3Z1pXNWpiMlJwYm1jcElIdGNiaUFnTHk4Z1NHRnVaR3hsSUhOMGNtbHVaeUJqWVhObGN6cGNiaUFnYVdZZ0tIUjVjR1Z2WmlCMllXd2dQVDA5SUNkemRISnBibWNuS1NCN1hHNGdJQ0FnYVdZZ0tIUjVjR1Z2WmlCemRHRnlkQ0E5UFQwZ0ozTjBjbWx1WnljcElIdGNiaUFnSUNBZ0lHVnVZMjlrYVc1bklEMGdjM1JoY25SY2JpQWdJQ0FnSUhOMFlYSjBJRDBnTUZ4dUlDQWdJQ0FnWlc1a0lEMGdkR2hwY3k1c1pXNW5kR2hjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLSFI1Y0dWdlppQmxibVFnUFQwOUlDZHpkSEpwYm1jbktTQjdYRzRnSUNBZ0lDQmxibU52WkdsdVp5QTlJR1Z1WkZ4dUlDQWdJQ0FnWlc1a0lEMGdkR2hwY3k1c1pXNW5kR2hjYmlBZ0lDQjlYRzRnSUNBZ2FXWWdLSFpoYkM1c1pXNW5kR2dnUFQwOUlERXBJSHRjYmlBZ0lDQWdJSFpoY2lCamIyUmxJRDBnZG1Gc0xtTm9ZWEpEYjJSbFFYUW9NQ2xjYmlBZ0lDQWdJR2xtSUNoamIyUmxJRHdnTWpVMktTQjdYRzRnSUNBZ0lDQWdJSFpoYkNBOUlHTnZaR1ZjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzRnSUNBZ2FXWWdLR1Z1WTI5a2FXNW5JQ0U5UFNCMWJtUmxabWx1WldRZ0ppWWdkSGx3Wlc5bUlHVnVZMjlrYVc1bklDRTlQU0FuYzNSeWFXNW5KeWtnZTF4dUlDQWdJQ0FnZEdoeWIzY2dibVYzSUZSNWNHVkZjbkp2Y2lnblpXNWpiMlJwYm1jZ2JYVnpkQ0JpWlNCaElITjBjbWx1WnljcFhHNGdJQ0FnZlZ4dUlDQWdJR2xtSUNoMGVYQmxiMllnWlc1amIyUnBibWNnUFQwOUlDZHpkSEpwYm1jbklDWW1JQ0ZDZFdabVpYSXVhWE5GYm1OdlpHbHVaeWhsYm1OdlpHbHVaeWtwSUh0Y2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCVWVYQmxSWEp5YjNJb0oxVnVhMjV2ZDI0Z1pXNWpiMlJwYm1jNklDY2dLeUJsYm1OdlpHbHVaeWxjYmlBZ0lDQjlYRzRnSUgwZ1pXeHpaU0JwWmlBb2RIbHdaVzltSUhaaGJDQTlQVDBnSjI1MWJXSmxjaWNwSUh0Y2JpQWdJQ0IyWVd3Z1BTQjJZV3dnSmlBeU5UVmNiaUFnZlZ4dVhHNGdJQzh2SUVsdWRtRnNhV1FnY21GdVoyVnpJR0Z5WlNCdWIzUWdjMlYwSUhSdklHRWdaR1ZtWVhWc2RDd2djMjhnWTJGdUlISmhibWRsSUdOb1pXTnJJR1ZoY214NUxseHVJQ0JwWmlBb2MzUmhjblFnUENBd0lIeDhJSFJvYVhNdWJHVnVaM1JvSUR3Z2MzUmhjblFnZkh3Z2RHaHBjeTVzWlc1bmRHZ2dQQ0JsYm1RcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1VtRnVaMlZGY25KdmNpZ25UM1YwSUc5bUlISmhibWRsSUdsdVpHVjRKeWxjYmlBZ2ZWeHVYRzRnSUdsbUlDaGxibVFnUEQwZ2MzUmhjblFwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwYzF4dUlDQjlYRzVjYmlBZ2MzUmhjblFnUFNCemRHRnlkQ0ErUGo0Z01GeHVJQ0JsYm1RZ1BTQmxibVFnUFQwOUlIVnVaR1ZtYVc1bFpDQS9JSFJvYVhNdWJHVnVaM1JvSURvZ1pXNWtJRDQrUGlBd1hHNWNiaUFnYVdZZ0tDRjJZV3dwSUhaaGJDQTlJREJjYmx4dUlDQjJZWElnYVZ4dUlDQnBaaUFvZEhsd1pXOW1JSFpoYkNBOVBUMGdKMjUxYldKbGNpY3BJSHRjYmlBZ0lDQm1iM0lnS0drZ1BTQnpkR0Z5ZERzZ2FTQThJR1Z1WkRzZ0t5dHBLU0I3WEc0Z0lDQWdJQ0IwYUdselcybGRJRDBnZG1Gc1hHNGdJQ0FnZlZ4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUhaaGNpQmllWFJsY3lBOUlFSjFabVpsY2k1cGMwSjFabVpsY2loMllXd3BYRzRnSUNBZ0lDQS9JSFpoYkZ4dUlDQWdJQ0FnT2lCMWRHWTRWRzlDZVhSbGN5aHVaWGNnUW5WbVptVnlLSFpoYkN3Z1pXNWpiMlJwYm1jcExuUnZVM1J5YVc1bktDa3BYRzRnSUNBZ2RtRnlJR3hsYmlBOUlHSjVkR1Z6TG14bGJtZDBhRnh1SUNBZ0lHWnZjaUFvYVNBOUlEQTdJR2tnUENCbGJtUWdMU0J6ZEdGeWREc2dLeXRwS1NCN1hHNGdJQ0FnSUNCMGFHbHpXMmtnS3lCemRHRnlkRjBnUFNCaWVYUmxjMXRwSUNVZ2JHVnVYVnh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQjBhR2x6WEc1OVhHNWNiaTh2SUVoRlRGQkZVaUJHVlU1RFZFbFBUbE5jYmk4dklEMDlQVDA5UFQwOVBUMDlQVDA5UFQxY2JseHVkbUZ5SUVsT1ZrRk1TVVJmUWtGVFJUWTBYMUpGSUQwZ0wxdGVLMXhjTHpBdE9VRXRXbUV0ZWkxZlhTOW5YRzVjYm1aMWJtTjBhVzl1SUdKaGMyVTJOR05zWldGdUlDaHpkSElwSUh0Y2JpQWdMeThnVG05a1pTQnpkSEpwY0hNZ2IzVjBJR2x1ZG1Gc2FXUWdZMmhoY21GamRHVnljeUJzYVd0bElGeGNiaUJoYm1RZ1hGeDBJR1p5YjIwZ2RHaGxJSE4wY21sdVp5d2dZbUZ6WlRZMExXcHpJR1J2WlhNZ2JtOTBYRzRnSUhOMGNpQTlJSE4wY21sdVozUnlhVzBvYzNSeUtTNXlaWEJzWVdObEtFbE9Wa0ZNU1VSZlFrRlRSVFkwWDFKRkxDQW5KeWxjYmlBZ0x5OGdUbTlrWlNCamIyNTJaWEowY3lCemRISnBibWR6SUhkcGRHZ2diR1Z1WjNSb0lEd2dNaUIwYnlBbkoxeHVJQ0JwWmlBb2MzUnlMbXhsYm1kMGFDQThJRElwSUhKbGRIVnliaUFuSjF4dUlDQXZMeUJPYjJSbElHRnNiRzkzY3lCbWIzSWdibTl1TFhCaFpHUmxaQ0JpWVhObE5qUWdjM1J5YVc1bmN5QW9iV2x6YzJsdVp5QjBjbUZwYkdsdVp5QTlQVDBwTENCaVlYTmxOalF0YW5NZ1pHOWxjeUJ1YjNSY2JpQWdkMmhwYkdVZ0tITjBjaTVzWlc1bmRHZ2dKU0EwSUNFOVBTQXdLU0I3WEc0Z0lDQWdjM1J5SUQwZ2MzUnlJQ3NnSnowblhHNGdJSDFjYmlBZ2NtVjBkWEp1SUhOMGNseHVmVnh1WEc1bWRXNWpkR2x2YmlCemRISnBibWQwY21sdElDaHpkSElwSUh0Y2JpQWdhV1lnS0hOMGNpNTBjbWx0S1NCeVpYUjFjbTRnYzNSeUxuUnlhVzBvS1Z4dUlDQnlaWFIxY200Z2MzUnlMbkpsY0d4aFkyVW9MMTVjWEhNcmZGeGNjeXNrTDJjc0lDY25LVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQjBiMGhsZUNBb2Jpa2dlMXh1SUNCcFppQW9iaUE4SURFMktTQnlaWFIxY200Z0p6QW5JQ3NnYmk1MGIxTjBjbWx1WnlneE5pbGNiaUFnY21WMGRYSnVJRzR1ZEc5VGRISnBibWNvTVRZcFhHNTlYRzVjYm1aMWJtTjBhVzl1SUhWMFpqaFViMEo1ZEdWeklDaHpkSEpwYm1jc0lIVnVhWFJ6S1NCN1hHNGdJSFZ1YVhSeklEMGdkVzVwZEhNZ2ZId2dTVzVtYVc1cGRIbGNiaUFnZG1GeUlHTnZaR1ZRYjJsdWRGeHVJQ0IyWVhJZ2JHVnVaM1JvSUQwZ2MzUnlhVzVuTG14bGJtZDBhRnh1SUNCMllYSWdiR1ZoWkZOMWNuSnZaMkYwWlNBOUlHNTFiR3hjYmlBZ2RtRnlJR0o1ZEdWeklEMGdXMTFjYmx4dUlDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR3hsYm1kMGFEc2dLeXRwS1NCN1hHNGdJQ0FnWTI5a1pWQnZhVzUwSUQwZ2MzUnlhVzVuTG1Ob1lYSkRiMlJsUVhRb2FTbGNibHh1SUNBZ0lDOHZJR2x6SUhOMWNuSnZaMkYwWlNCamIyMXdiMjVsYm5SY2JpQWdJQ0JwWmlBb1kyOWtaVkJ2YVc1MElENGdNSGhFTjBaR0lDWW1JR052WkdWUWIybHVkQ0E4SURCNFJUQXdNQ2tnZTF4dUlDQWdJQ0FnTHk4Z2JHRnpkQ0JqYUdGeUlIZGhjeUJoSUd4bFlXUmNiaUFnSUNBZ0lHbG1JQ2doYkdWaFpGTjFjbkp2WjJGMFpTa2dlMXh1SUNBZ0lDQWdJQ0F2THlCdWJ5QnNaV0ZrSUhsbGRGeHVJQ0FnSUNBZ0lDQnBaaUFvWTI5a1pWQnZhVzUwSUQ0Z01IaEVRa1pHS1NCN1hHNGdJQ0FnSUNBZ0lDQWdMeThnZFc1bGVIQmxZM1JsWkNCMGNtRnBiRnh1SUNBZ0lDQWdJQ0FnSUdsbUlDZ29kVzVwZEhNZ0xUMGdNeWtnUGlBdE1Ta2dZbmwwWlhNdWNIVnphQ2d3ZUVWR0xDQXdlRUpHTENBd2VFSkVLVnh1SUNBZ0lDQWdJQ0FnSUdOdmJuUnBiblZsWEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2FTQXJJREVnUFQwOUlHeGxibWQwYUNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQzh2SUhWdWNHRnBjbVZrSUd4bFlXUmNiaUFnSUNBZ0lDQWdJQ0JwWmlBb0tIVnVhWFJ6SUMwOUlETXBJRDRnTFRFcElHSjVkR1Z6TG5CMWMyZ29NSGhGUml3Z01IaENSaXdnTUhoQ1JDbGNiaUFnSUNBZ0lDQWdJQ0JqYjI1MGFXNTFaVnh1SUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ0x5OGdkbUZzYVdRZ2JHVmhaRnh1SUNBZ0lDQWdJQ0JzWldGa1UzVnljbTluWVhSbElEMGdZMjlrWlZCdmFXNTBYRzVjYmlBZ0lDQWdJQ0FnWTI5dWRHbHVkV1ZjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnTHk4Z01pQnNaV0ZrY3lCcGJpQmhJSEp2ZDF4dUlDQWdJQ0FnYVdZZ0tHTnZaR1ZRYjJsdWRDQThJREI0UkVNd01Da2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb0tIVnVhWFJ6SUMwOUlETXBJRDRnTFRFcElHSjVkR1Z6TG5CMWMyZ29NSGhGUml3Z01IaENSaXdnTUhoQ1JDbGNiaUFnSUNBZ0lDQWdiR1ZoWkZOMWNuSnZaMkYwWlNBOUlHTnZaR1ZRYjJsdWRGeHVJQ0FnSUNBZ0lDQmpiMjUwYVc1MVpWeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQXZMeUIyWVd4cFpDQnpkWEp5YjJkaGRHVWdjR0ZwY2x4dUlDQWdJQ0FnWTI5a1pWQnZhVzUwSUQwZ0tHeGxZV1JUZFhKeWIyZGhkR1VnTFNBd2VFUTRNREFnUER3Z01UQWdmQ0JqYjJSbFVHOXBiblFnTFNBd2VFUkRNREFwSUNzZ01IZ3hNREF3TUZ4dUlDQWdJSDBnWld4elpTQnBaaUFvYkdWaFpGTjFjbkp2WjJGMFpTa2dlMXh1SUNBZ0lDQWdMeThnZG1Gc2FXUWdZbTF3SUdOb1lYSXNJR0oxZENCc1lYTjBJR05vWVhJZ2QyRnpJR0VnYkdWaFpGeHVJQ0FnSUNBZ2FXWWdLQ2gxYm1sMGN5QXRQU0F6S1NBK0lDMHhLU0JpZVhSbGN5NXdkWE5vS0RCNFJVWXNJREI0UWtZc0lEQjRRa1FwWEc0Z0lDQWdmVnh1WEc0Z0lDQWdiR1ZoWkZOMWNuSnZaMkYwWlNBOUlHNTFiR3hjYmx4dUlDQWdJQzh2SUdWdVkyOWtaU0IxZEdZNFhHNGdJQ0FnYVdZZ0tHTnZaR1ZRYjJsdWRDQThJREI0T0RBcElIdGNiaUFnSUNBZ0lHbG1JQ2dvZFc1cGRITWdMVDBnTVNrZ1BDQXdLU0JpY21WaGExeHVJQ0FnSUNBZ1lubDBaWE11Y0hWemFDaGpiMlJsVUc5cGJuUXBYRzRnSUNBZ2ZTQmxiSE5sSUdsbUlDaGpiMlJsVUc5cGJuUWdQQ0F3ZURnd01Da2dlMXh1SUNBZ0lDQWdhV1lnS0NoMWJtbDBjeUF0UFNBeUtTQThJREFwSUdKeVpXRnJYRzRnSUNBZ0lDQmllWFJsY3k1d2RYTm9LRnh1SUNBZ0lDQWdJQ0JqYjJSbFVHOXBiblFnUGo0Z01IZzJJSHdnTUhoRE1DeGNiaUFnSUNBZ0lDQWdZMjlrWlZCdmFXNTBJQ1lnTUhnelJpQjhJREI0T0RCY2JpQWdJQ0FnSUNsY2JpQWdJQ0I5SUdWc2MyVWdhV1lnS0dOdlpHVlFiMmx1ZENBOElEQjRNVEF3TURBcElIdGNiaUFnSUNBZ0lHbG1JQ2dvZFc1cGRITWdMVDBnTXlrZ1BDQXdLU0JpY21WaGExeHVJQ0FnSUNBZ1lubDBaWE11Y0hWemFDaGNiaUFnSUNBZ0lDQWdZMjlrWlZCdmFXNTBJRDQrSURCNFF5QjhJREI0UlRBc1hHNGdJQ0FnSUNBZ0lHTnZaR1ZRYjJsdWRDQStQaUF3ZURZZ0ppQXdlRE5HSUh3Z01IZzRNQ3hjYmlBZ0lDQWdJQ0FnWTI5a1pWQnZhVzUwSUNZZ01IZ3pSaUI4SURCNE9EQmNiaUFnSUNBZ0lDbGNiaUFnSUNCOUlHVnNjMlVnYVdZZ0tHTnZaR1ZRYjJsdWRDQThJREI0TVRFd01EQXdLU0I3WEc0Z0lDQWdJQ0JwWmlBb0tIVnVhWFJ6SUMwOUlEUXBJRHdnTUNrZ1luSmxZV3RjYmlBZ0lDQWdJR0o1ZEdWekxuQjFjMmdvWEc0Z0lDQWdJQ0FnSUdOdlpHVlFiMmx1ZENBK1BpQXdlREV5SUh3Z01IaEdNQ3hjYmlBZ0lDQWdJQ0FnWTI5a1pWQnZhVzUwSUQ0K0lEQjRReUFtSURCNE0wWWdmQ0F3ZURnd0xGeHVJQ0FnSUNBZ0lDQmpiMlJsVUc5cGJuUWdQajRnTUhnMklDWWdNSGd6UmlCOElEQjRPREFzWEc0Z0lDQWdJQ0FnSUdOdlpHVlFiMmx1ZENBbUlEQjRNMFlnZkNBd2VEZ3dYRzRnSUNBZ0lDQXBYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduU1c1MllXeHBaQ0JqYjJSbElIQnZhVzUwSnlsY2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnWW5sMFpYTmNibjFjYmx4dVpuVnVZM1JwYjI0Z1lYTmphV2xVYjBKNWRHVnpJQ2h6ZEhJcElIdGNiaUFnZG1GeUlHSjVkR1ZCY25KaGVTQTlJRnRkWEc0Z0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2djM1J5TG14bGJtZDBhRHNnS3l0cEtTQjdYRzRnSUNBZ0x5OGdUbTlrWlNkeklHTnZaR1VnYzJWbGJYTWdkRzhnWW1VZ1pHOXBibWNnZEdocGN5QmhibVFnYm05MElDWWdNSGczUmk0dVhHNGdJQ0FnWW5sMFpVRnljbUY1TG5CMWMyZ29jM1J5TG1Ob1lYSkRiMlJsUVhRb2FTa2dKaUF3ZUVaR0tWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCaWVYUmxRWEp5WVhsY2JuMWNibHh1Wm5WdVkzUnBiMjRnZFhSbU1UWnNaVlJ2UW5sMFpYTWdLSE4wY2l3Z2RXNXBkSE1wSUh0Y2JpQWdkbUZ5SUdNc0lHaHBMQ0JzYjF4dUlDQjJZWElnWW5sMFpVRnljbUY1SUQwZ1cxMWNiaUFnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCemRISXViR1Z1WjNSb095QXJLMmtwSUh0Y2JpQWdJQ0JwWmlBb0tIVnVhWFJ6SUMwOUlESXBJRHdnTUNrZ1luSmxZV3RjYmx4dUlDQWdJR01nUFNCemRISXVZMmhoY2tOdlpHVkJkQ2hwS1Z4dUlDQWdJR2hwSUQwZ1l5QStQaUE0WEc0Z0lDQWdiRzhnUFNCaklDVWdNalUyWEc0Z0lDQWdZbmwwWlVGeWNtRjVMbkIxYzJnb2JHOHBYRzRnSUNBZ1lubDBaVUZ5Y21GNUxuQjFjMmdvYUdrcFhHNGdJSDFjYmx4dUlDQnlaWFIxY200Z1lubDBaVUZ5Y21GNVhHNTlYRzVjYm1aMWJtTjBhVzl1SUdKaGMyVTJORlJ2UW5sMFpYTWdLSE4wY2lrZ2UxeHVJQ0J5WlhSMWNtNGdZbUZ6WlRZMExuUnZRbmwwWlVGeWNtRjVLR0poYzJVMk5HTnNaV0Z1S0hOMGNpa3BYRzU5WEc1Y2JtWjFibU4wYVc5dUlHSnNhWFJDZFdabVpYSWdLSE55WXl3Z1pITjBMQ0J2Wm1aelpYUXNJR3hsYm1kMGFDa2dlMXh1SUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHeGxibWQwYURzZ0t5dHBLU0I3WEc0Z0lDQWdhV1lnS0NocElDc2diMlptYzJWMElENDlJR1J6ZEM1c1pXNW5kR2dwSUh4OElDaHBJRDQ5SUhOeVl5NXNaVzVuZEdncEtTQmljbVZoYTF4dUlDQWdJR1J6ZEZ0cElDc2diMlptYzJWMFhTQTlJSE55WTF0cFhWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCcFhHNTlYRzVjYm1aMWJtTjBhVzl1SUdsemJtRnVJQ2gyWVd3cElIdGNiaUFnY21WMGRYSnVJSFpoYkNBaFBUMGdkbUZzSUM4dklHVnpiR2x1ZEMxa2FYTmhZbXhsTFd4cGJtVWdibTh0YzJWc1ppMWpiMjF3WVhKbFhHNTlYRzVjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZblZtWm1WeUwybHVaR1Y0TG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBeE5WeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpWFN3aWMyOTFjbU5sVW05dmRDSTZJaUo5XCIpO1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xcbiAgdmFyIGUsIG1cXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXFxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXFxuICB2YXIgbkJpdHMgPSAtN1xcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXFxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxcblxcbiAgaSArPSBkXFxuXFxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxcbiAgcyA+Pj0gKC1uQml0cylcXG4gIG5CaXRzICs9IGVMZW5cXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XFxuXFxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxcbiAgZSA+Pj0gKC1uQml0cylcXG4gIG5CaXRzICs9IG1MZW5cXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XFxuXFxuICBpZiAoZSA9PT0gMCkge1xcbiAgICBlID0gMSAtIGVCaWFzXFxuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcXG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXFxuICB9IGVsc2Uge1xcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXFxuICAgIGUgPSBlIC0gZUJpYXNcXG4gIH1cXG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXFxufVxcblxcbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcXG4gIHZhciBlLCBtLCBjXFxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXFxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxcblxcbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcXG5cXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XFxuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxcbiAgICBlID0gZU1heFxcbiAgfSBlbHNlIHtcXG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXFxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcXG4gICAgICBlLS1cXG4gICAgICBjICo9IDJcXG4gICAgfVxcbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcXG4gICAgICB2YWx1ZSArPSBydCAvIGNcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcXG4gICAgfVxcbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcXG4gICAgICBlKytcXG4gICAgICBjIC89IDJcXG4gICAgfVxcblxcbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcXG4gICAgICBtID0gMFxcbiAgICAgIGUgPSBlTWF4XFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcXG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcXG4gICAgICBlID0gZSArIGVCaWFzXFxuICAgIH0gZWxzZSB7XFxuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXFxuICAgICAgZSA9IDBcXG4gICAgfVxcbiAgfVxcblxcbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cXG5cXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cXG4gIGVMZW4gKz0gbUxlblxcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxcblxcbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluZGxZbkJoWTJzNkx5OHZMaTkrTDJsbFpXVTNOVFF2YVc1a1pYZ3Vhbk0vTnpCbVpTSmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaVFVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1VVRkJVU3hYUVVGWE96dEJRVVZ1UWp0QlFVTkJPMEZCUTBFN1FVRkRRU3hSUVVGUkxGZEJRVmM3TzBGQlJXNUNPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRU3hSUVVGUkxGZEJRVmM3TzBGQlJXNUNPMEZCUTBFN1FVRkRRU3hSUVVGUkxGVkJRVlU3TzBGQlJXeENPMEZCUTBFaUxDSm1hV3hsSWpvaU1UWXVhbk1pTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKbGVIQnZjblJ6TG5KbFlXUWdQU0JtZFc1amRHbHZiaUFvWW5WbVptVnlMQ0J2Wm1aelpYUXNJR2x6VEVVc0lHMU1aVzRzSUc1Q2VYUmxjeWtnZTF4dUlDQjJZWElnWlN3Z2JWeHVJQ0IyWVhJZ1pVeGxiaUE5SUc1Q2VYUmxjeUFxSURnZ0xTQnRUR1Z1SUMwZ01WeHVJQ0IyWVhJZ1pVMWhlQ0E5SUNneElEdzhJR1ZNWlc0cElDMGdNVnh1SUNCMllYSWdaVUpwWVhNZ1BTQmxUV0Y0SUQ0K0lERmNiaUFnZG1GeUlHNUNhWFJ6SUQwZ0xUZGNiaUFnZG1GeUlHa2dQU0JwYzB4RklEOGdLRzVDZVhSbGN5QXRJREVwSURvZ01GeHVJQ0IyWVhJZ1pDQTlJR2x6VEVVZ1B5QXRNU0E2SURGY2JpQWdkbUZ5SUhNZ1BTQmlkV1ptWlhKYmIyWm1jMlYwSUNzZ2FWMWNibHh1SUNCcElDczlJR1JjYmx4dUlDQmxJRDBnY3lBbUlDZ29NU0E4UENBb0xXNUNhWFJ6S1NrZ0xTQXhLVnh1SUNCeklENCtQU0FvTFc1Q2FYUnpLVnh1SUNCdVFtbDBjeUFyUFNCbFRHVnVYRzRnSUdadmNpQW9PeUJ1UW1sMGN5QStJREE3SUdVZ1BTQmxJQ29nTWpVMklDc2dZblZtWm1WeVcyOW1abk5sZENBcklHbGRMQ0JwSUNzOUlHUXNJRzVDYVhSeklDMDlJRGdwSUh0OVhHNWNiaUFnYlNBOUlHVWdKaUFvS0RFZ1BEd2dLQzF1UW1sMGN5a3BJQzBnTVNsY2JpQWdaU0ErUGowZ0tDMXVRbWwwY3lsY2JpQWdia0pwZEhNZ0t6MGdiVXhsYmx4dUlDQm1iM0lnS0RzZ2JrSnBkSE1nUGlBd095QnRJRDBnYlNBcUlESTFOaUFySUdKMVptWmxjbHR2Wm1aelpYUWdLeUJwWFN3Z2FTQXJQU0JrTENCdVFtbDBjeUF0UFNBNEtTQjdmVnh1WEc0Z0lHbG1JQ2hsSUQwOVBTQXdLU0I3WEc0Z0lDQWdaU0E5SURFZ0xTQmxRbWxoYzF4dUlDQjlJR1ZzYzJVZ2FXWWdLR1VnUFQwOUlHVk5ZWGdwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdiU0EvSUU1aFRpQTZJQ2dvY3lBL0lDMHhJRG9nTVNrZ0tpQkpibVpwYm1sMGVTbGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQnRJRDBnYlNBcklFMWhkR2d1Y0c5M0tESXNJRzFNWlc0cFhHNGdJQ0FnWlNBOUlHVWdMU0JsUW1saGMxeHVJQ0I5WEc0Z0lISmxkSFZ5YmlBb2N5QS9JQzB4SURvZ01Ta2dLaUJ0SUNvZ1RXRjBhQzV3YjNjb01pd2daU0F0SUcxTVpXNHBYRzU5WEc1Y2JtVjRjRzl5ZEhNdWQzSnBkR1VnUFNCbWRXNWpkR2x2YmlBb1luVm1abVZ5TENCMllXeDFaU3dnYjJabWMyVjBMQ0JwYzB4RkxDQnRUR1Z1TENCdVFubDBaWE1wSUh0Y2JpQWdkbUZ5SUdVc0lHMHNJR05jYmlBZ2RtRnlJR1ZNWlc0Z1BTQnVRbmwwWlhNZ0tpQTRJQzBnYlV4bGJpQXRJREZjYmlBZ2RtRnlJR1ZOWVhnZ1BTQW9NU0E4UENCbFRHVnVLU0F0SURGY2JpQWdkbUZ5SUdWQ2FXRnpJRDBnWlUxaGVDQStQaUF4WEc0Z0lIWmhjaUJ5ZENBOUlDaHRUR1Z1SUQwOVBTQXlNeUEvSUUxaGRHZ3VjRzkzS0RJc0lDMHlOQ2tnTFNCTllYUm9MbkJ2ZHlneUxDQXROemNwSURvZ01DbGNiaUFnZG1GeUlHa2dQU0JwYzB4RklEOGdNQ0E2SUNodVFubDBaWE1nTFNBeEtWeHVJQ0IyWVhJZ1pDQTlJR2x6VEVVZ1B5QXhJRG9nTFRGY2JpQWdkbUZ5SUhNZ1BTQjJZV3gxWlNBOElEQWdmSHdnS0haaGJIVmxJRDA5UFNBd0lDWW1JREVnTHlCMllXeDFaU0E4SURBcElEOGdNU0E2SURCY2JseHVJQ0IyWVd4MVpTQTlJRTFoZEdndVlXSnpLSFpoYkhWbEtWeHVYRzRnSUdsbUlDaHBjMDVoVGloMllXeDFaU2tnZkh3Z2RtRnNkV1VnUFQwOUlFbHVabWx1YVhSNUtTQjdYRzRnSUNBZ2JTQTlJR2x6VG1GT0tIWmhiSFZsS1NBL0lERWdPaUF3WEc0Z0lDQWdaU0E5SUdWTllYaGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQmxJRDBnVFdGMGFDNW1iRzl2Y2loTllYUm9MbXh2WnloMllXeDFaU2tnTHlCTllYUm9Ma3hPTWlsY2JpQWdJQ0JwWmlBb2RtRnNkV1VnS2lBb1l5QTlJRTFoZEdndWNHOTNLRElzSUMxbEtTa2dQQ0F4S1NCN1hHNGdJQ0FnSUNCbExTMWNiaUFnSUNBZ0lHTWdLajBnTWx4dUlDQWdJSDFjYmlBZ0lDQnBaaUFvWlNBcklHVkNhV0Z6SUQ0OUlERXBJSHRjYmlBZ0lDQWdJSFpoYkhWbElDczlJSEowSUM4Z1kxeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0IyWVd4MVpTQXJQU0J5ZENBcUlFMWhkR2d1Y0c5M0tESXNJREVnTFNCbFFtbGhjeWxjYmlBZ0lDQjlYRzRnSUNBZ2FXWWdLSFpoYkhWbElDb2dZeUErUFNBeUtTQjdYRzRnSUNBZ0lDQmxLeXRjYmlBZ0lDQWdJR01nTHowZ01seHVJQ0FnSUgxY2JseHVJQ0FnSUdsbUlDaGxJQ3NnWlVKcFlYTWdQajBnWlUxaGVDa2dlMXh1SUNBZ0lDQWdiU0E5SURCY2JpQWdJQ0FnSUdVZ1BTQmxUV0Y0WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2hsSUNzZ1pVSnBZWE1nUGowZ01Ta2dlMXh1SUNBZ0lDQWdiU0E5SUNoMllXeDFaU0FxSUdNZ0xTQXhLU0FxSUUxaGRHZ3VjRzkzS0RJc0lHMU1aVzRwWEc0Z0lDQWdJQ0JsSUQwZ1pTQXJJR1ZDYVdGelhHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJRzBnUFNCMllXeDFaU0FxSUUxaGRHZ3VjRzkzS0RJc0lHVkNhV0Z6SUMwZ01Ta2dLaUJOWVhSb0xuQnZkeWd5TENCdFRHVnVLVnh1SUNBZ0lDQWdaU0E5SURCY2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCbWIzSWdLRHNnYlV4bGJpQStQU0E0T3lCaWRXWm1aWEpiYjJabWMyVjBJQ3NnYVYwZ1BTQnRJQ1lnTUhobVppd2dhU0FyUFNCa0xDQnRJQzg5SURJMU5pd2diVXhsYmlBdFBTQTRLU0I3ZlZ4dVhHNGdJR1VnUFNBb1pTQThQQ0J0VEdWdUtTQjhJRzFjYmlBZ1pVeGxiaUFyUFNCdFRHVnVYRzRnSUdadmNpQW9PeUJsVEdWdUlENGdNRHNnWW5WbVptVnlXMjltWm5ObGRDQXJJR2xkSUQwZ1pTQW1JREI0Wm1Zc0lHa2dLejBnWkN3Z1pTQXZQU0F5TlRZc0lHVk1aVzRnTFQwZ09Da2dlMzFjYmx4dUlDQmlkV1ptWlhKYmIyWm1jMlYwSUNzZ2FTQXRJR1JkSUh3OUlITWdLaUF4TWpoY2JuMWNibHh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOXBaV1ZsTnpVMEwybHVaR1Y0TG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBeE5seHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpWFN3aWMyOTFjbU5sVW05dmRDSTZJaUo5XCIpO1xuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xcbn07XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5kbFluQmhZMnM2THk4dkxpOStMMmx6WVhKeVlYa3ZhVzVrWlhndWFuTS9aV0ZpWXlKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeHBRa0ZCYVVJN08wRkJSV3BDTzBGQlEwRTdRVUZEUVNJc0ltWnBiR1VpT2lJeE55NXFjeUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSW5aaGNpQjBiMU4wY21sdVp5QTlJSHQ5TG5SdlUzUnlhVzVuTzF4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlFRnljbUY1TG1selFYSnlZWGtnZkh3Z1puVnVZM1JwYjI0Z0tHRnljaWtnZTF4dUlDQnlaWFIxY200Z2RHOVRkSEpwYm1jdVkyRnNiQ2hoY25JcElEMDlJQ2RiYjJKcVpXTjBJRUZ5Y21GNVhTYzdYRzU5TzF4dVhHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJsellYSnlZWGt2YVc1a1pYZ3Vhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJREUzWEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSmRMQ0p6YjNWeVkyVlNiMjkwSWpvaUluMD1cIik7XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcXG5cXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcXG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXFxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cXG5cXG52YXIgY2FjaGVkU2V0VGltZW91dDtcXG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xcblxcbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xcbn1cXG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcXG59XFxuKGZ1bmN0aW9uICgpIHtcXG4gICAgdHJ5IHtcXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcXG4gICAgICAgIH1cXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xcbiAgICB9XFxufSAoKSlcXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXFxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9XFxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XFxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXFxuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9IGNhdGNoKGUpe1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XFxuICAgICAgICB9IGNhdGNoKGUpe1xcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuXFxufVxcbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcXG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XFxuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcXG4gICAgfVxcbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXFxuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XFxuICAgIH0gY2F0Y2ggKGUpe1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XFxuICAgICAgICB9IGNhdGNoIChlKXtcXG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG5cXG5cXG59XFxudmFyIHF1ZXVlID0gW107XFxudmFyIGRyYWluaW5nID0gZmFsc2U7XFxudmFyIGN1cnJlbnRRdWV1ZTtcXG52YXIgcXVldWVJbmRleCA9IC0xO1xcblxcbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcXG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcXG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcXG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XFxuICAgIH1cXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xcbiAgICB9XFxufVxcblxcbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XFxuICAgIGlmIChkcmFpbmluZykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xcbiAgICBkcmFpbmluZyA9IHRydWU7XFxuXFxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XFxuICAgIHdoaWxlKGxlbikge1xcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XFxuICAgICAgICBxdWV1ZSA9IFtdO1xcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcXG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcXG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcXG4gICAgfVxcbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XFxufVxcblxcbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XFxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XFxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XFxuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xcbiAgICB9XFxufTtcXG5cXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXFxuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XFxuICAgIHRoaXMuZnVuID0gZnVuO1xcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XFxufVxcbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XFxufTtcXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XFxucHJvY2Vzcy5lbnYgPSB7fTtcXG5wcm9jZXNzLmFyZ3YgPSBbXTtcXG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcXG5wcm9jZXNzLnZlcnNpb25zID0ge307XFxuXFxuZnVuY3Rpb24gbm9vcCgpIHt9XFxuXFxucHJvY2Vzcy5vbiA9IG5vb3A7XFxucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5vbmNlID0gbm9vcDtcXG5wcm9jZXNzLm9mZiA9IG5vb3A7XFxucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XFxuXFxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xcbn07XFxuXFxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcXG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xcbn07XFxucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbmRsWW5CaFkyczZMeTh2TGk5K0wzQnliMk5sYzNNdlluSnZkM05sY2k1cWN6ODRNbVUwSWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRk5CUVZNN1FVRkRWRHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hUUVVGVE8wRkJRMVE3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFc1EwRkJRenRCUVVORU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQkxGTkJRVk03UVVGRFZEdEJRVU5CTzBGQlEwRTdRVUZEUVRzN08wRkJSMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEU3UVVGRFFTeFRRVUZUTzBGQlExUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3T3p0QlFVbEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4MVFrRkJkVUlzYzBKQlFYTkNPMEZCUXpkRE8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNjVUpCUVhGQ08wRkJRM0pDT3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVN3eVFrRkJNa0k3UVVGRE0wSTdRVUZEUVR0QlFVTkJPMEZCUTBFc05FSkJRVFJDTEZWQlFWVWlMQ0ptYVd4bElqb2lNVGd1YW5NaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SXZMeUJ6YUdsdElHWnZjaUIxYzJsdVp5QndjbTlqWlhOeklHbHVJR0p5YjNkelpYSmNiblpoY2lCd2NtOWpaWE56SUQwZ2JXOWtkV3hsTG1WNGNHOXlkSE1nUFNCN2ZUdGNibHh1THk4Z1kyRmphR1ZrSUdaeWIyMGdkMmhoZEdWMlpYSWdaMnh2WW1Gc0lHbHpJSEJ5WlhObGJuUWdjMjhnZEdoaGRDQjBaWE4wSUhKMWJtNWxjbk1nZEdoaGRDQnpkSFZpSUdsMFhHNHZMeUJrYjI0bmRDQmljbVZoYXlCMGFHbHVaM011SUNCQ2RYUWdkMlVnYm1WbFpDQjBieUIzY21Gd0lHbDBJR2x1SUdFZ2RISjVJR05oZEdOb0lHbHVJR05oYzJVZ2FYUWdhWE5jYmk4dklIZHlZWEJ3WldRZ2FXNGdjM1J5YVdOMElHMXZaR1VnWTI5a1pTQjNhR2xqYUNCa2IyVnpiaWQwSUdSbFptbHVaU0JoYm5rZ1oyeHZZbUZzY3k0Z0lFbDBKM01nYVc1emFXUmxJR0ZjYmk4dklHWjFibU4wYVc5dUlHSmxZMkYxYzJVZ2RISjVMMk5oZEdOb1pYTWdaR1Z2Y0hScGJXbDZaU0JwYmlCalpYSjBZV2x1SUdWdVoybHVaWE11WEc1Y2JuWmhjaUJqWVdOb1pXUlRaWFJVYVcxbGIzVjBPMXh1ZG1GeUlHTmhZMmhsWkVOc1pXRnlWR2x0Wlc5MWREdGNibHh1Wm5WdVkzUnBiMjRnWkdWbVlYVnNkRk5sZEZScGJXOTFkQ2dwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KM05sZEZScGJXVnZkWFFnYUdGeklHNXZkQ0JpWldWdUlHUmxabWx1WldRbktUdGNibjFjYm1aMWJtTjBhVzl1SUdSbFptRjFiSFJEYkdWaGNsUnBiV1Z2ZFhRZ0tDa2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2lnblkyeGxZWEpVYVcxbGIzVjBJR2hoY3lCdWIzUWdZbVZsYmlCa1pXWnBibVZrSnlrN1hHNTlYRzRvWm5WdVkzUnBiMjRnS0NrZ2UxeHVJQ0FnSUhSeWVTQjdYRzRnSUNBZ0lDQWdJR2xtSUNoMGVYQmxiMllnYzJWMFZHbHRaVzkxZENBOVBUMGdKMloxYm1OMGFXOXVKeWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZMkZqYUdWa1UyVjBWR2x0Wlc5MWRDQTlJSE5sZEZScGJXVnZkWFE3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpZV05vWldSVFpYUlVhVzFsYjNWMElEMGdaR1ZtWVhWc2RGTmxkRlJwYlc5MWREdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lIMGdZMkYwWTJnZ0tHVXBJSHRjYmlBZ0lDQWdJQ0FnWTJGamFHVmtVMlYwVkdsdFpXOTFkQ0E5SUdSbFptRjFiSFJUWlhSVWFXMXZkWFE3WEc0Z0lDQWdmVnh1SUNBZ0lIUnllU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDaDBlWEJsYjJZZ1kyeGxZWEpVYVcxbGIzVjBJRDA5UFNBblpuVnVZM1JwYjI0bktTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCallXTm9aV1JEYkdWaGNsUnBiV1Z2ZFhRZ1BTQmpiR1ZoY2xScGJXVnZkWFE3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpZV05vWldSRGJHVmhjbFJwYldWdmRYUWdQU0JrWldaaGRXeDBRMnhsWVhKVWFXMWxiM1YwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnZlNCallYUmphQ0FvWlNrZ2UxeHVJQ0FnSUNBZ0lDQmpZV05vWldSRGJHVmhjbFJwYldWdmRYUWdQU0JrWldaaGRXeDBRMnhsWVhKVWFXMWxiM1YwTzF4dUlDQWdJSDFjYm4wZ0tDa3BYRzVtZFc1amRHbHZiaUJ5ZFc1VWFXMWxiM1YwS0daMWJpa2dlMXh1SUNBZ0lHbG1JQ2hqWVdOb1pXUlRaWFJVYVcxbGIzVjBJRDA5UFNCelpYUlVhVzFsYjNWMEtTQjdYRzRnSUNBZ0lDQWdJQzh2Ym05eWJXRnNJR1Z1ZG1seWIyMWxiblJ6SUdsdUlITmhibVVnYzJsMGRXRjBhVzl1YzF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYzJWMFZHbHRaVzkxZENobWRXNHNJREFwTzF4dUlDQWdJSDFjYmlBZ0lDQXZMeUJwWmlCelpYUlVhVzFsYjNWMElIZGhjMjRuZENCaGRtRnBiR0ZpYkdVZ1luVjBJSGRoY3lCc1lYUjBaWElnWkdWbWFXNWxaRnh1SUNBZ0lHbG1JQ2dvWTJGamFHVmtVMlYwVkdsdFpXOTFkQ0E5UFQwZ1pHVm1ZWFZzZEZObGRGUnBiVzkxZENCOGZDQWhZMkZqYUdWa1UyVjBWR2x0Wlc5MWRDa2dKaVlnYzJWMFZHbHRaVzkxZENrZ2UxeHVJQ0FnSUNBZ0lDQmpZV05vWldSVFpYUlVhVzFsYjNWMElEMGdjMlYwVkdsdFpXOTFkRHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSE5sZEZScGJXVnZkWFFvWm5WdUxDQXdLVHRjYmlBZ0lDQjlYRzRnSUNBZ2RISjVJSHRjYmlBZ0lDQWdJQ0FnTHk4Z2QyaGxiaUIzYUdWdUlITnZiV1ZpYjJSNUlHaGhjeUJ6WTNKbGQyVmtJSGRwZEdnZ2MyVjBWR2x0Wlc5MWRDQmlkWFFnYm04Z1NTNUZMaUJ0WVdSa2JtVnpjMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdZMkZqYUdWa1UyVjBWR2x0Wlc5MWRDaG1kVzRzSURBcE8xeHVJQ0FnSUgwZ1kyRjBZMmdvWlNsN1hHNGdJQ0FnSUNBZ0lIUnllU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQXZMeUJYYUdWdUlIZGxJR0Z5WlNCcGJpQkpMa1V1SUdKMWRDQjBhR1VnYzJOeWFYQjBJR2hoY3lCaVpXVnVJR1YyWVd4bFpDQnpieUJKTGtVdUlHUnZaWE51SjNRZ2RISjFjM1FnZEdobElHZHNiMkpoYkNCdlltcGxZM1FnZDJobGJpQmpZV3hzWldRZ2JtOXliV0ZzYkhsY2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQmpZV05vWldSVFpYUlVhVzFsYjNWMExtTmhiR3dvYm5Wc2JDd2dablZ1TENBd0tUdGNiaUFnSUNBZ0lDQWdmU0JqWVhSamFDaGxLWHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDOHZJSE5oYldVZ1lYTWdZV0p2ZG1VZ1luVjBJSGRvWlc0Z2FYUW5jeUJoSUhabGNuTnBiMjRnYjJZZ1NTNUZMaUIwYUdGMElHMTFjM1FnYUdGMlpTQjBhR1VnWjJ4dlltRnNJRzlpYW1WamRDQm1iM0lnSjNSb2FYTW5MQ0JvYjNCbWRXeHNlU0J2ZFhJZ1kyOXVkR1Y0ZENCamIzSnlaV04wSUc5MGFHVnlkMmx6WlNCcGRDQjNhV3hzSUhSb2NtOTNJR0VnWjJ4dlltRnNJR1Z5Y205eVhHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdZMkZqYUdWa1UyVjBWR2x0Wlc5MWRDNWpZV3hzS0hSb2FYTXNJR1oxYml3Z01DazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmx4dWZWeHVablZ1WTNScGIyNGdjblZ1UTJ4bFlYSlVhVzFsYjNWMEtHMWhjbXRsY2lrZ2UxeHVJQ0FnSUdsbUlDaGpZV05vWldSRGJHVmhjbFJwYldWdmRYUWdQVDA5SUdOc1pXRnlWR2x0Wlc5MWRDa2dlMXh1SUNBZ0lDQWdJQ0F2TDI1dmNtMWhiQ0JsYm5acGNtOXRaVzUwY3lCcGJpQnpZVzVsSUhOcGRIVmhkR2x2Ym5OY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUdOc1pXRnlWR2x0Wlc5MWRDaHRZWEpyWlhJcE8xeHVJQ0FnSUgxY2JpQWdJQ0F2THlCcFppQmpiR1ZoY2xScGJXVnZkWFFnZDJGemJpZDBJR0YyWVdsc1lXSnNaU0JpZFhRZ2QyRnpJR3hoZEhSbGNpQmtaV1pwYm1Wa1hHNGdJQ0FnYVdZZ0tDaGpZV05vWldSRGJHVmhjbFJwYldWdmRYUWdQVDA5SUdSbFptRjFiSFJEYkdWaGNsUnBiV1Z2ZFhRZ2ZId2dJV05oWTJobFpFTnNaV0Z5VkdsdFpXOTFkQ2tnSmlZZ1kyeGxZWEpVYVcxbGIzVjBLU0I3WEc0Z0lDQWdJQ0FnSUdOaFkyaGxaRU5zWldGeVZHbHRaVzkxZENBOUlHTnNaV0Z5VkdsdFpXOTFkRHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR05zWldGeVZHbHRaVzkxZENodFlYSnJaWElwTzF4dUlDQWdJSDFjYmlBZ0lDQjBjbmtnZTF4dUlDQWdJQ0FnSUNBdkx5QjNhR1Z1SUhkb1pXNGdjMjl0WldKdlpIa2dhR0Z6SUhOamNtVjNaV1FnZDJsMGFDQnpaWFJVYVcxbGIzVjBJR0oxZENCdWJ5QkpMa1V1SUcxaFpHUnVaWE56WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJqWVdOb1pXUkRiR1ZoY2xScGJXVnZkWFFvYldGeWEyVnlLVHRjYmlBZ0lDQjlJR05oZEdOb0lDaGxLWHRjYmlBZ0lDQWdJQ0FnZEhKNUlIdGNiaUFnSUNBZ0lDQWdJQ0FnSUM4dklGZG9aVzRnZDJVZ1lYSmxJR2x1SUVrdVJTNGdZblYwSUhSb1pTQnpZM0pwY0hRZ2FHRnpJR0psWlc0Z1pYWmhiR1ZrSUhOdklFa3VSUzRnWkc5bGMyNG5kQ0FnZEhKMWMzUWdkR2hsSUdkc2IySmhiQ0J2WW1wbFkzUWdkMmhsYmlCallXeHNaV1FnYm05eWJXRnNiSGxjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCallXTm9aV1JEYkdWaGNsUnBiV1Z2ZFhRdVkyRnNiQ2h1ZFd4c0xDQnRZWEpyWlhJcE8xeHVJQ0FnSUNBZ0lDQjlJR05oZEdOb0lDaGxLWHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDOHZJSE5oYldVZ1lYTWdZV0p2ZG1VZ1luVjBJSGRvWlc0Z2FYUW5jeUJoSUhabGNuTnBiMjRnYjJZZ1NTNUZMaUIwYUdGMElHMTFjM1FnYUdGMlpTQjBhR1VnWjJ4dlltRnNJRzlpYW1WamRDQm1iM0lnSjNSb2FYTW5MQ0JvYjNCbWRXeHNlU0J2ZFhJZ1kyOXVkR1Y0ZENCamIzSnlaV04wSUc5MGFHVnlkMmx6WlNCcGRDQjNhV3hzSUhSb2NtOTNJR0VnWjJ4dlltRnNJR1Z5Y205eUxseHVJQ0FnSUNBZ0lDQWdJQ0FnTHk4Z1UyOXRaU0IyWlhKemFXOXVjeUJ2WmlCSkxrVXVJR2hoZG1VZ1pHbG1abVZ5Wlc1MElISjFiR1Z6SUdadmNpQmpiR1ZoY2xScGJXVnZkWFFnZG5NZ2MyVjBWR2x0Wlc5MWRGeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJR05oWTJobFpFTnNaV0Z5VkdsdFpXOTFkQzVqWVd4c0tIUm9hWE1zSUcxaGNtdGxjaWs3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JseHVYRzU5WEc1MllYSWdjWFZsZFdVZ1BTQmJYVHRjYm5aaGNpQmtjbUZwYm1sdVp5QTlJR1poYkhObE8xeHVkbUZ5SUdOMWNuSmxiblJSZFdWMVpUdGNiblpoY2lCeGRXVjFaVWx1WkdWNElEMGdMVEU3WEc1Y2JtWjFibU4wYVc5dUlHTnNaV0Z1VlhCT1pYaDBWR2xqYXlncElIdGNiaUFnSUNCcFppQW9JV1J5WVdsdWFXNW5JSHg4SUNGamRYSnlaVzUwVVhWbGRXVXBJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVPMXh1SUNBZ0lIMWNiaUFnSUNCa2NtRnBibWx1WnlBOUlHWmhiSE5sTzF4dUlDQWdJR2xtSUNoamRYSnlaVzUwVVhWbGRXVXViR1Z1WjNSb0tTQjdYRzRnSUNBZ0lDQWdJSEYxWlhWbElEMGdZM1Z5Y21WdWRGRjFaWFZsTG1OdmJtTmhkQ2h4ZFdWMVpTazdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2NYVmxkV1ZKYm1SbGVDQTlJQzB4TzF4dUlDQWdJSDFjYmlBZ0lDQnBaaUFvY1hWbGRXVXViR1Z1WjNSb0tTQjdYRzRnSUNBZ0lDQWdJR1J5WVdsdVVYVmxkV1VvS1R0Y2JpQWdJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJR1J5WVdsdVVYVmxkV1VvS1NCN1hHNGdJQ0FnYVdZZ0tHUnlZV2x1YVc1bktTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJqdGNiaUFnSUNCOVhHNGdJQ0FnZG1GeUlIUnBiV1Z2ZFhRZ1BTQnlkVzVVYVcxbGIzVjBLR05zWldGdVZYQk9aWGgwVkdsamF5azdYRzRnSUNBZ1pISmhhVzVwYm1jZ1BTQjBjblZsTzF4dVhHNGdJQ0FnZG1GeUlHeGxiaUE5SUhGMVpYVmxMbXhsYm1kMGFEdGNiaUFnSUNCM2FHbHNaU2hzWlc0cElIdGNiaUFnSUNBZ0lDQWdZM1Z5Y21WdWRGRjFaWFZsSUQwZ2NYVmxkV1U3WEc0Z0lDQWdJQ0FnSUhGMVpYVmxJRDBnVzEwN1hHNGdJQ0FnSUNBZ0lIZG9hV3hsSUNnckszRjFaWFZsU1c1a1pYZ2dQQ0JzWlc0cElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaGpkWEp5Wlc1MFVYVmxkV1VwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamRYSnlaVzUwVVhWbGRXVmJjWFZsZFdWSmJtUmxlRjB1Y25WdUtDazdYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdjWFZsZFdWSmJtUmxlQ0E5SUMweE8xeHVJQ0FnSUNBZ0lDQnNaVzRnUFNCeGRXVjFaUzVzWlc1bmRHZzdYRzRnSUNBZ2ZWeHVJQ0FnSUdOMWNuSmxiblJSZFdWMVpTQTlJRzUxYkd3N1hHNGdJQ0FnWkhKaGFXNXBibWNnUFNCbVlXeHpaVHRjYmlBZ0lDQnlkVzVEYkdWaGNsUnBiV1Z2ZFhRb2RHbHRaVzkxZENrN1hHNTlYRzVjYm5CeWIyTmxjM011Ym1WNGRGUnBZMnNnUFNCbWRXNWpkR2x2YmlBb1puVnVLU0I3WEc0Z0lDQWdkbUZ5SUdGeVozTWdQU0J1WlhjZ1FYSnlZWGtvWVhKbmRXMWxiblJ6TG14bGJtZDBhQ0F0SURFcE8xeHVJQ0FnSUdsbUlDaGhjbWQxYldWdWRITXViR1Z1WjNSb0lENGdNU2tnZTF4dUlDQWdJQ0FnSUNCbWIzSWdLSFpoY2lCcElEMGdNVHNnYVNBOElHRnlaM1Z0Wlc1MGN5NXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZWEpuYzF0cElDMGdNVjBnUFNCaGNtZDFiV1Z1ZEhOYmFWMDdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQjlYRzRnSUNBZ2NYVmxkV1V1Y0hWemFDaHVaWGNnU1hSbGJTaG1kVzRzSUdGeVozTXBLVHRjYmlBZ0lDQnBaaUFvY1hWbGRXVXViR1Z1WjNSb0lEMDlQU0F4SUNZbUlDRmtjbUZwYm1sdVp5a2dlMXh1SUNBZ0lDQWdJQ0J5ZFc1VWFXMWxiM1YwS0dSeVlXbHVVWFZsZFdVcE8xeHVJQ0FnSUgxY2JuMDdYRzVjYmk4dklIWTRJR3hwYTJWeklIQnlaV1JwWTNScFlteGxJRzlpYW1WamRITmNibVoxYm1OMGFXOXVJRWwwWlcwb1puVnVMQ0JoY25KaGVTa2dlMXh1SUNBZ0lIUm9hWE11Wm5WdUlEMGdablZ1TzF4dUlDQWdJSFJvYVhNdVlYSnlZWGtnUFNCaGNuSmhlVHRjYm4xY2JrbDBaVzB1Y0hKdmRHOTBlWEJsTG5KMWJpQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdJQ0IwYUdsekxtWjFiaTVoY0hCc2VTaHVkV3hzTENCMGFHbHpMbUZ5Y21GNUtUdGNibjA3WEc1d2NtOWpaWE56TG5ScGRHeGxJRDBnSjJKeWIzZHpaWEluTzF4dWNISnZZMlZ6Y3k1aWNtOTNjMlZ5SUQwZ2RISjFaVHRjYm5CeWIyTmxjM011Wlc1MklEMGdlMzA3WEc1d2NtOWpaWE56TG1GeVozWWdQU0JiWFR0Y2JuQnliMk5sYzNNdWRtVnljMmx2YmlBOUlDY25PeUF2THlCbGJYQjBlU0J6ZEhKcGJtY2dkRzhnWVhadmFXUWdjbVZuWlhod0lHbHpjM1ZsYzF4dWNISnZZMlZ6Y3k1MlpYSnphVzl1Y3lBOUlIdDlPMXh1WEc1bWRXNWpkR2x2YmlCdWIyOXdLQ2tnZTMxY2JseHVjSEp2WTJWemN5NXZiaUE5SUc1dmIzQTdYRzV3Y205alpYTnpMbUZrWkV4cGMzUmxibVZ5SUQwZ2JtOXZjRHRjYm5CeWIyTmxjM011YjI1alpTQTlJRzV2YjNBN1hHNXdjbTlqWlhOekxtOW1aaUE5SUc1dmIzQTdYRzV3Y205alpYTnpMbkpsYlc5MlpVeHBjM1JsYm1WeUlEMGdibTl2Y0R0Y2JuQnliMk5sYzNNdWNtVnRiM1psUVd4c1RHbHpkR1Z1WlhKeklEMGdibTl2Y0R0Y2JuQnliMk5sYzNNdVpXMXBkQ0E5SUc1dmIzQTdYRzVjYm5CeWIyTmxjM011WW1sdVpHbHVaeUE5SUdaMWJtTjBhVzl1SUNodVlXMWxLU0I3WEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZHdjbTlqWlhOekxtSnBibVJwYm1jZ2FYTWdibTkwSUhOMWNIQnZjblJsWkNjcE8xeHVmVHRjYmx4dWNISnZZMlZ6Y3k1amQyUWdQU0JtZFc1amRHbHZiaUFvS1NCN0lISmxkSFZ5YmlBbkx5Y2dmVHRjYm5CeWIyTmxjM011WTJoa2FYSWdQU0JtZFc1amRHbHZiaUFvWkdseUtTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0Nkd2NtOWpaWE56TG1Ob1pHbHlJR2x6SUc1dmRDQnpkWEJ3YjNKMFpXUW5LVHRjYm4wN1hHNXdjbTlqWlhOekxuVnRZWE5ySUQwZ1puVnVZM1JwYjI0b0tTQjdJSEpsZEhWeWJpQXdPeUI5TzF4dVhHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDNCeWIyTmxjM012WW5KdmQzTmxjaTVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTVRoY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJbDBzSW5OdmRYSmpaVkp2YjNRaU9pSWlmUT09XCIpO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wdWJsaWMvYnVuZGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

eval("var config = __webpack_require__(8);\r\nvar vue = __webpack_require__(1);\r\nmodule.exports = function() {\r\n  var greet = document.createElement('div');\r\n  var Vue = document.createElement('div');\r\n  greet.textContent = config.greetText;\r\n  return greet;\r\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvR3JlZXRlci5qcz9lYjg0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZy5qc29uJyk7XHJcbnZhciB2dWUgPSByZXF1aXJlKCcuL3Z1ZS52dWUnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgZ3JlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICB2YXIgVnVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgZ3JlZXQudGV4dENvbnRlbnQgPSBjb25maWcuZ3JlZXRUZXh0O1xyXG4gIHJldHVybiBncmVldDtcclxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9HcmVldGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    el: '#app',\n    name: 'app',\n    data() {\n        return {\n            msg: 'Welcome to Your Vue.js App'\n        };\n    }\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdnVlLnZ1ZT9lOTdmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFTQTtRQUVBO1VBQ0E7V0FDQTs7aUJBR0E7QUFGQTtBQUdBO0FBUEEiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG48dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGlkPVwiYXBwXCI+XHJcbiAgICAgICAgPGgxPnt7IG1zZyB9fTwvaDE+XHJcblxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG4gICAgZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgICAgIGVsOiAnI2FwcCcsXHJcbiAgICAgICAgbmFtZTogJ2FwcCcsXHJcbiAgICAgICAgZGF0YSAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBtc2c6ICdXZWxjb21lIHRvIFlvdXIgVnVlLmpzIEFwcCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuPC9zY3JpcHQ+XHJcblxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gdnVlLnZ1ZT8yZDg0YTk4OCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(7)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, \"html {\\r\\n  box-sizing: border-box;\\r\\n  -ms-text-size-adjust: 100%;\\r\\n  -webkit-text-size-adjust: 100%;\\r\\n}\\r\\n\\r\\n*, *:before, *:after {\\r\\n  box-sizing: inherit;\\r\\n}\\r\\n\\r\\nbody {\\r\\n  margin: 0;\\r\\n  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;\\r\\n}\\r\\n\\r\\nh1, h2, h3, h4, h5, h6, p, ul {\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n}\", \"\"]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbWFpbi5jc3M/ZGVmYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLCtCQUFnQyw2QkFBNkIsaUNBQWlDLHFDQUFxQyxLQUFLLDhCQUE4QiwwQkFBMEIsS0FBSyxjQUFjLGdCQUFnQixrRUFBa0UsS0FBSyx1Q0FBdUMsZ0JBQWdCLGlCQUFpQixLQUFLOztBQUV2WCIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy8uX2Nzcy1sb2FkZXJAMC4yOC4wQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJodG1sIHtcXHJcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuICAtbXMtdGV4dC1zaXplLWFkanVzdDogMTAwJTtcXHJcXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuKiwgKjpiZWZvcmUsICo6YWZ0ZXIge1xcclxcbiAgYm94LXNpemluZzogaW5oZXJpdDtcXHJcXG59XFxyXFxuXFxyXFxuYm9keSB7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxuICBmb250LWZhbWlseTogJ0hlbHZldGljYSBOZXVlJywgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcXHJcXG59XFxyXFxuXFxyXFxuaDEsIGgyLCBoMywgaDQsIGg1LCBoNiwgcCwgdWwge1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbiAgcGFkZGluZzogMDtcXHJcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly5fY3NzLWxvYWRlckAwLjI4LjBAY3NzLWxvYWRlcj9tb2R1bGVzIS4vYXBwL21haW4uY3NzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap) {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n  var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n  return '/*# ' + data + ' */';\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16).Buffer))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly5fY3NzLWxvYWRlckAwLjI4LjBAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/YjcwZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYzs7QUFFbkU7QUFDQSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXApIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIHZhciBiYXNlNjQgPSBuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgdmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuICByZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly5fY3NzLWxvYWRlckAwLjI4LjBAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

eval("module.exports = {\n\t\"greetText\": \"Hi there and greetings from JSON!\"\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvY29uZmlnLmpzb24/MzAyZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcImdyZWV0VGV4dFwiOiBcIkhpIHRoZXJlIGFuZCBncmVldGluZ3MgZnJvbSBKU09OIVwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL2NvbmZpZy5qc29uXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\t// Test for IE <= 9 as proposed by Browserhacks\n\t\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t\t// Tests for existence of standard globals is to allow style-loader \n\t\t// to operate correctly into non-standard environments\n\t\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\t\treturn window && document && document.all && !window.atob;\n\t}),\n\tgetElement = (function(fn) {\n\t\tvar memo = {};\n\t\treturn function(selector) {\n\t\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t\t}\n\t\t\treturn memo[selector]\n\t\t};\n\t})(function (styleTarget) {\n\t\treturn document.querySelector(styleTarget)\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [],\n\tfixUrls = __webpack_require__(10);\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (typeof options.insertInto === \"undefined\") options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar styleTarget = getElement(options.insertInto)\n\tif (!styleTarget) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\tstyleTarget.insertBefore(styleElement, styleTarget.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\tstyleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\tstyleTarget.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\tstyleTarget.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\toptions.attrs.type = \"text/css\";\n\n\tattachTagAttrs(styleElement, options.attrs);\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\tattachTagAttrs(linkElement, options.attrs);\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction attachTagAttrs(element, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\telement.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement, options);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls){\n\t\tcss = fixUrls(css);\n\t}\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly5fc3R5bGUtbG9hZGVyQDAuMTYuMUBzdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzP2RiOGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XG5cdFx0dmFyIG1lbW87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbWVtbztcblx0XHR9O1xuXHR9LFxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcblx0XHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHRcdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0XHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyIFxuXHRcdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHRcdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRcdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcblx0fSksXG5cdGdldEVsZW1lbnQgPSAoZnVuY3Rpb24oZm4pIHtcblx0XHR2YXIgbWVtbyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdFx0fTtcblx0fSkoZnVuY3Rpb24gKHN0eWxlVGFyZ2V0KSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc3R5bGVUYXJnZXQpXG5cdH0pLFxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW10sXG5cdGZpeFVybHMgPSByZXF1aXJlKFwiLi9maXhVcmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRJbnRvID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xuXHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblx0aWYgKCFzdHlsZVRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0c3R5bGVUYXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgc3R5bGVUYXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHRzdHlsZVRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlVGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdFx0fVxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0c3R5bGVUYXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHR2YXIgaWR4ID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZUVsZW1lbnQpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XG5cdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuXHRhdHRhY2hUYWdBdHRycyhzdHlsZUVsZW1lbnQsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KTtcblx0cmV0dXJuIHN0eWxlRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGF0dGFjaFRhZ0F0dHJzKGxpbmtFbGVtZW50LCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcblx0cmV0dXJuIGxpbmtFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hUYWdBdHRycyhlbGVtZW50LCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuXHRcdGlmKG5ld09iaikge1xuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKiBJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscyl7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcblxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly5fc3R5bGUtbG9hZGVyQDAuMTYuMUBzdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly5fc3R5bGUtbG9hZGVyQDAuMTYuMUBzdHlsZS1sb2FkZXIvZml4VXJscy5qcz9hNGM5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxFQUFFO0FBQ3JELHdDQUF3QyxXQUFXLEVBQUU7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDO0FBQ3RDLEdBQUc7QUFDSDtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uX3N0eWxlLWxvYWRlckAwLjE2LjFAc3R5bGUtbG9hZGVyL2ZpeFVybHMuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(6);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(9)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/._css-loader@0.28.0@css-loader/index.js?modules!./main.css\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/._css-loader@0.28.0@css-loader/index.js?modules!./main.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbWFpbi5jc3M/ODI3YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUFvRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzLy5fY3NzLWxvYWRlckAwLjI4LjBAY3NzLWxvYWRlci9pbmRleC5qcz9tb2R1bGVzIS4vbWFpbi5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy8uX3N0eWxlLWxvYWRlckAwLjE2LjFAc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy8uX2Nzcy1sb2FkZXJAMC4yOC4wQGNzcy1sb2FkZXIvaW5kZXguanM/bW9kdWxlcyEuL21haW4uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvLl9jc3MtbG9hZGVyQDAuMjguMEBjc3MtbG9hZGVyL2luZGV4LmpzP21vZHVsZXMhLi9tYWluLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvbWFpbi5jc3Ncbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

eval("// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = Object.create(options.computed || null)\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n    options.computed = computed\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly5fdnVlLWxvYWRlckAxMS4zLjRAdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanM/NjIzOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0aGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICByYXdTY3JpcHRFeHBvcnRzLFxuICBjb21waWxlZFRlbXBsYXRlLFxuICBzY29wZUlkLFxuICBjc3NNb2R1bGVzXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICAvLyBpbmplY3QgY3NzTW9kdWxlc1xuICBpZiAoY3NzTW9kdWxlcykge1xuICAgIHZhciBjb21wdXRlZCA9IE9iamVjdC5jcmVhdGUob3B0aW9ucy5jb21wdXRlZCB8fCBudWxsKVxuICAgIE9iamVjdC5rZXlzKGNzc01vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG1vZHVsZSA9IGNzc01vZHVsZXNba2V5XVxuICAgICAgY29tcHV0ZWRba2V5XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZHVsZSB9XG4gICAgfSlcbiAgICBvcHRpb25zLmNvbXB1dGVkID0gY29tcHV0ZWRcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLl92dWUtbG9hZGVyQDExLjMuNEB2dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": \"app\"\n    }\n  }, [_c('h1', [_vm._v(_vm._s(_vm.msg))])])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-7de3e7d8\", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvdnVlLnZ1ZT9kYTE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJhcHBcIlxuICAgIH1cbiAgfSwgW19jKCdoMScsIFtfdm0uX3YoX3ZtLl9zKF92bS5tc2cpKV0pXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtN2RlM2U3ZDhcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLl92dWUtbG9hZGVyQDExLjMuNEB2dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTdkZTNlN2Q4XCJ9IS4vfi8uX3Z1ZS1sb2FkZXJAMTEuMy40QHZ1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2FwcC92dWUudnVlXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global) {/*!\n * Vue.js v2.2.6\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction _toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\nfunction isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\n\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b)\n    } catch (e) {\n      // possible circular reference\n      return a === b\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn();\n    }\n  }\n}\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * List of asset types that a component can own.\n   */\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n\n  /**\n   * List of lifecycle hooks.\n   */\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n\n  /**\n   * Max circular updates allowed in a scheduler flush cycle.\n   */\n  _maxUpdateCount: 100\n};\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) { cb.call(ctx); }\n      if (_resolve) { _resolve(ctx); }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName;\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var formatLocation = function (str) {\n    if (str === \"<Anonymous>\") {\n      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n    }\n    return (\"\\n(found in \" + str + \")\")\n  };\n}\n\n/*  */\n\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid$1++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nconfig._lifecycleHooks.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = typeof extendsFrom === 'function'\n      ? mergeOptions(parent, extendsFrom.options, vm)\n      : mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      if (mixin.prototype instanceof Vue$2) {\n        mixin = mixin.options;\n      }\n      parent = mergeOptions(parent, mixin, vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\n/**\n * Assert the type of a value\n */\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (expectedType === 'String') {\n    valid = typeof value === (expectedType = 'string');\n  } else if (expectedType === 'Number') {\n    valid = typeof value === (expectedType = 'number');\n  } else if (expectedType === 'Boolean') {\n    valid = typeof value === (expectedType = 'boolean');\n  } else if (expectedType === 'Function') {\n    valid = typeof value === (expectedType = 'function');\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match && match[1]\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Error in \" + info + \":\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      for (var i = 0; i < fns.length; i++) {\n        fns[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (!cur) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (!old) {\n      if (!cur.fns) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (!on[name]) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (!oldHook) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (oldHook.fns && oldHook.merged) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (c == null || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (last && last.text) {\n        last.text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (c.text && last && last.text) {\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (c.tag && c.key == null && nestedIndex != null) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n}\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  var name, child;\n  for (var i = 0, l = children.length; i < l; i++) {\n    child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n        child.data && (name = child.data.slot)) {\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns\n) {\n  var res = {};\n  for (var i = 0; i < fns.length; i++) {\n    res[fns[i][0]] = fns[i][1];\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // remove reference to DOM nodes (prevents leak)\n    vm.$options._parentElm = vm.$options._refElm = null;\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = true;\n    }\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = false;\n    }\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive == null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar queue = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  queue.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id, vm;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // reset scheduler before updated hook called\n  var oldQueue = queue.slice();\n  resetSchedulerState();\n\n  // call updated hooks\n  index = oldQueue.length;\n  while (index--) {\n    watcher = oldQueue[index];\n    vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i >= 0 && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(Math.max(i, index) + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  if (this.user) {\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    }\n  } else {\n    value = this.getter.call(vm, vm);\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = { key: 1, ref: 1, slot: 1 };\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedProp[key]) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(keys[i])) {\n      proxy(vm, \"_data\", keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production') {\n      if (getter === undefined) {\n        warn(\n          (\"No getter function has been defined for computed property \\\"\" + key + \"\\\".\"),\n          vm\n        );\n        getter = noop;\n      }\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    if (!vnode.componentInstance._isMounted) {\n      vnode.componentInstance._isMounted = true;\n      callHook(vnode.componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      activateChildComponent(vnode.componentInstance, true /* direct */);\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    if (!vnode.componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        vnode.componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(vnode.componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (!Ctor) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (!Ctor.cid) {\n    if (Ctor.resolved) {\n      Ctor = Ctor.resolved;\n    } else {\n      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n        // it's ok to queue this on every render because\n        // $forceUpdate is buffered by the scheduler.\n        context.$forceUpdate();\n      });\n      if (!Ctor) {\n        // return nothing if this is indeed an async component\n        // wait for the callback to trigger parent update.\n        return\n      }\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // transform component v-model data into props & events\n  if (data.model) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractProps(data, Ctor, tag);\n\n  // functional component\n  if (Ctor.options.functional) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (Ctor.options.abstract) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (propOptions) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData);\n    }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    props: props,\n    data: data,\n    parent: context,\n    children: children,\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (inlineTemplate) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  cb\n) {\n  if (factory.requested) {\n    // pool callbacks\n    factory.pendingCallbacks.push(cb);\n  } else {\n    factory.requested = true;\n    var cbs = factory.pendingCallbacks = [cb];\n    var sync = true;\n\n    var resolve = function (res) {\n      if (isObject(res)) {\n        res = baseCtor.extend(res);\n      }\n      // cache resolved\n      factory.resolved = res;\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res);\n        }\n      }\n    };\n\n    var reject = function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n    };\n\n    var res = factory(resolve, reject);\n\n    // handle promise\n    if (res && typeof res.then === 'function' && !factory.resolved) {\n      res.then(resolve, reject);\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.resolved\n  }\n}\n\nfunction extractProps (data, Ctor, tag) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (!propOptions) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  var domProps = data.domProps;\n  if (attrs || props || domProps) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && attrs.hasOwnProperty(keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey) ||\n      checkProp(res, domProps, key, altKey);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (hash) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (on[event]) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (data && data.__ob__) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n      typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (vnode) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (vnode.children) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (child.tag && !child.ns) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      extend(props, bindObject);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp\n) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      for (var key in value) {\n        if (key === 'class' || key === 'style') {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n        }\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm.$vnode = null; // the placeholder node in parent tree\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$options._parentVnode;\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = _toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var inject = vm.$options.inject;\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    // isArray here\n    var isArray = Array.isArray(inject);\n    var keys = isArray\n      ? inject\n      : hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    var loop = function ( i ) {\n      var key = keys[i];\n      var provideKey = isArray ? key : inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          /* istanbul ignore else */\n          if (process.env.NODE_ENV !== 'production') {\n            defineReactive$$1(vm, key, source._provided[provideKey], function () {\n              warn(\n                \"Avoid mutating an injected value directly since the changes will be \" +\n                \"overwritten whenever the provided component re-renders. \" +\n                \"injection being mutated: \\\"\" + key + \"\\\"\",\n                vm\n              );\n            });\n          } else {\n            defineReactive$$1(vm, key, source._provided[provideKey]);\n          }\n          break\n        }\n        source = source.$parent;\n      }\n    };\n\n    for (var i = 0; i < keys.length; i++) loop( i );\n  }\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    for (var i = 0; i < latest.length; i++) {\n      if (sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$2 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$2)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$2);\nstateMixin(Vue$2);\neventsMixin(Vue$2);\nlifecycleMixin(Vue$2);\nrenderMixin(Vue$2);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (pattern instanceof RegExp) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cachedNode);\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    if (!vnode.componentInstance._inactive) {\n      callHook(vnode.componentInstance, 'deactivated');\n    }\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  config._assetTypes.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$2);\n\nObject.defineProperty(Vue$2.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nVue$2.version = '2.2.6';\n\n/*  */\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (childNode.componentInstance) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: child.class\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (staticClass || dynamicClass) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  var res = '';\n  if (!value) {\n    return res\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        if ((stringified = stringifyClass(value[i]))) {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\n\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key &&\n    a.tag === b.tag &&\n    a.isComment === b.isComment &&\n    isDef(a.data) === isDef(b.data) &&\n    sameInputType(a, b)\n  )\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (isDef(parent)) {\n      if (isDef(ref)) {\n        nodeOps.insertBefore(parent, elm, ref);\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n        isTrue(oldVnode.isStatic) &&\n        vnode.key === oldVnode.key &&\n        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n            oldVnode.removeAttribute('server-rendered');\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (attrs.__ob__) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (attrs[key] == null) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (!data.staticClass && !data.class &&\n      (!oldData || (!oldData.staticClass && !oldData.class))) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (transitionClass) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\n\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\n\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar str;\nvar index$1;\n\n/*  */\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (on[RANGE_TOKEN]) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (on[CHECKBOX_RADIO_TOKEN]) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once,\n  capture\n) {\n  if (once) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(event, handler, capture);\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (!oldVnode.data.on && !vnode.data.on) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (props.__ob__) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (props[key] == null) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = cur == null ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if ((modifiers && modifiers.number) || elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (modifiers && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    el.style[normalize(name)] = val;\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (!data.staticStyle && !data.style &&\n      !oldData.staticStyle && !oldData.style) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldVnode.data.staticStyle;\n  var oldStyleBinding = oldVnode.data.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (newStyle[name] == null) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (el._leaveCb) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (el._enterCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (el._enterCb) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (el._leaveCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (!fn) { return false }\n  var invokerFns = fn.fns;\n  if (invokerFns) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (!vnode.data.show) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (!vnode.data.show) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  return /\\d-keep-alive$/.test(rawChild.tag)\n    ? h('keep-alive')\n    : null\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n        mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$2.config.mustUseProp = mustUseProp;\nVue$2.config.isReservedTag = isReservedTag;\nVue$2.config.getTagNamespace = getTagNamespace;\nVue$2.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$2.options.directives, platformDirectives);\nextend(Vue$2.options.components, platformComponents);\n\n// install platform patch function\nVue$2.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$2.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$2);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n      config.productionTip !== false &&\n      inBrowser && typeof console !== 'undefined') {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vue$2);\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(19), __webpack_require__(2)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly5fdnVlQDIuMi42QHZ1ZS9kaXN0L3Z1ZS5ydW50aW1lLmVzbS5qcz8wZmE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlDQUFpQyxFQUFFO0FBQ3JGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7O0FBRXZDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0JBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IscUJBQXFCLGVBQWU7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLHVDQUF1Qyx3QkFBd0IsRUFBRTtBQUNqRSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLG9DQUFvQztBQUNwQztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixVQUFVOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1EQUFtRCxnQ0FBZ0MsRUFBRTtBQUNyRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0IsRUFBRTs7QUFFcEQ7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUMsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUI7QUFDekI7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZELG1CQUFtQiwyQkFBMkI7QUFDOUM7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBa0Q7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3Q0FBd0M7QUFDaEUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsK0JBQStCO0FBQy9GLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQ0FBc0M7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkNBQTZDO0FBQzlFO0FBQ0E7QUFDQSw2Q0FBNkMsNENBQTRDO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDhDQUE4QywyQkFBMkIsRUFBRTtBQUMzRSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEMsNEJBQTRCLEVBQUU7QUFDNUU7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hELDRCQUE0QixnQ0FBZ0M7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FLGlCQUFpQix3QkFBd0IsT0FBTyx1QkFBdUI7QUFDdkU7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPLGtEQUFrRDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0RBQWtEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG1DQUFtQyxnRUFBZ0U7QUFDbkc7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCLE9BQU8sZ0NBQWdDO0FBQy9FLHdEQUF3RCxvQkFBb0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdFQUFnRTtBQUMzRixPQUFPO0FBQ1AsbUNBQW1DLGlDQUFpQztBQUNwRTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxvQkFBb0I7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdDQUFnQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNELHFCQUFxQiw4QkFBOEI7QUFDbkQ7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RCxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDZDQUE2Qzs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0QkFBNEIsRUFBRTtBQUMzRSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywrQkFBK0IsRUFBRTtBQUM5RSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHFDQUFxQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDJDQUEyQyxFQUFFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsY0FBYyxFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRSwwQkFBMEIsRUFBRTtBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0IsRUFBRTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUIsRUFBRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjIuNlxuICogKGMpIDIwMTQtMjAxNyBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gX3RvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC8oW14tXSkoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkdcbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyoqXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cblxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gcG9zc2libGUgY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICByZXR1cm4gYSA9PT0gYlxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbigpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9IHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogTGlzdCBvZiBhc3NldCB0eXBlcyB0aGF0IGEgY29tcG9uZW50IGNhbiBvd24uXG4gICAqL1xuICBfYXNzZXRUeXBlczogW1xuICAgICdjb21wb25lbnQnLFxuICAgICdkaXJlY3RpdmUnLFxuICAgICdmaWx0ZXInXG4gIF0sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgbGlmZWN5Y2xlIGhvb2tzLlxuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBbXG4gICAgJ2JlZm9yZUNyZWF0ZScsXG4gICAgJ2NyZWF0ZWQnLFxuICAgICdiZWZvcmVNb3VudCcsXG4gICAgJ21vdW50ZWQnLFxuICAgICdiZWZvcmVVcGRhdGUnLFxuICAgICd1cGRhdGVkJyxcbiAgICAnYmVmb3JlRGVzdHJveScsXG4gICAgJ2Rlc3Ryb3llZCcsXG4gICAgJ2FjdGl2YXRlZCcsXG4gICAgJ2RlYWN0aXZhdGVkJ1xuICBdLFxuXG4gIC8qKlxuICAgKiBNYXggY2lyY3VsYXIgdXBkYXRlcyBhbGxvd2VkIGluIGEgc2NoZWR1bGVyIGZsdXNoIGN5Y2xlLlxuICAgKi9cbiAgX21heFVwZGF0ZUNvdW50OiAxMDBcbn07XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSAvW15cXHcuJF0vO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNdXRhdGlvbk9ic2VydmVyICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG4vKipcbiAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LlxuICovXG52YXIgbmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG4gIHZhciBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciB0aW1lckZ1bmM7XG5cbiAgZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyICgpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29waWVzW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbiAgLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4gIC8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuICAvLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4gIC8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHZhciBsb2dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB9O1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHAudGhlbihuZXh0VGlja0hhbmRsZXIpLmNhdGNoKGxvZ0Vycm9yKTtcbiAgICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gICAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuICApKSB7XG4gICAgLy8gdXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgICAvLyBlLmcuIFBoYW50b21KUyBJRTExLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsYmFjayB0byBzZXRUaW1lb3V0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrSGFuZGxlciwgMCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBxdWV1ZU5leHRUaWNrIChjYiwgY3R4KSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjYikgeyBjYi5jYWxsKGN0eCk7IH1cbiAgICAgIGlmIChfcmVzb2x2ZSkgeyBfcmVzb2x2ZShjdHgpOyB9XG4gICAgfSk7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRpbWVyRnVuYygpO1xuICAgIH1cbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KSgpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIltWdWUgd2Fybl06IFwiICsgbXNnICsgXCIgXCIgKyAoXG4gICAgICAgIHZtID8gZm9ybWF0TG9jYXRpb24oZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyBcIiBcIiArIChcbiAgICAgICAgdm0gPyBmb3JtYXRMb2NhdGlvbihmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBuYW1lID0gdHlwZW9mIHZtID09PSAnc3RyaW5nJ1xuICAgICAgPyB2bVxuICAgICAgOiB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0ub3B0aW9uc1xuICAgICAgICA/IHZtLm9wdGlvbnMubmFtZVxuICAgICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICAgID8gdm0uJG9wdGlvbnMubmFtZSB8fCB2bS4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgICAgICAgOiB2bS5uYW1lO1xuXG4gICAgdmFyIGZpbGUgPSB2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgZm9ybWF0TG9jYXRpb24gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gXCI8QW5vbnltb3VzPlwiKSB7XG4gICAgICBzdHIgKz0gXCIgLSB1c2UgdGhlIFxcXCJuYW1lXFxcIiBvcHRpb24gZm9yIGJldHRlciBkZWJ1Z2dpbmcgbWVzc2FnZXMuXCI7XG4gICAgfVxuICAgIHJldHVybiAoXCJcXG4oZm91bmQgaW4gXCIgKyBzdHIgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkJDErKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50cyQxW2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZSxcbiAgaXNTZXR0aW5nUHJvcHM6IGZhbHNlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyXG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQgKS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICBjaGlsZFZhbC5jYWxsKHRoaXMpLFxuICAgICAgICBwYXJlbnRWYWwuY2FsbCh0aGlzKVxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuY29uZmlnLl9saWZlY3ljbGVIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgOiByZXNcbn1cblxuY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5XSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGV4dGVuZChyZXQsIGNoaWxkVmFsKTtcbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGlzQnVpbHRJblRhZyhsb3dlcikgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobG93ZXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2lkOiAnICsga2V5XG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IHR5cGVvZiBleHRlbmRzRnJvbSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbS5vcHRpb25zLCB2bSlcbiAgICAgIDogbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbWl4aW4gPSBjaGlsZC5taXhpbnNbaV07XG4gICAgICBpZiAobWl4aW4ucHJvdG90eXBlIGluc3RhbmNlb2YgVnVlJDIpIHtcbiAgICAgICAgbWl4aW4gPSBtaXhpbi5vcHRpb25zO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgbWl4aW4sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicgK1xuICAgICAgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArXG4gICAgICAnLCBnb3QgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpICsgJy4nLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhlIHR5cGUgb2YgYSB2YWx1ZVxuICovXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSAnU3RyaW5nJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ3N0cmluZycpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdudW1iZXInKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdCb29sZWFuJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ2Jvb2xlYW4nKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdGdW5jdGlvbicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdmdW5jdGlvbicpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV1cbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6XCIpLCB2bSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgIFwicmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdG8gZGVjbGFyZSByZWFjdGl2ZSBkYXRhIFwiICtcbiAgICAgIFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YScpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zXG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9ICcnO1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnNcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMpIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuc1tpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoIWN1cikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghb2xkKSB7XG4gICAgICBpZiAoIWN1ci5mbnMpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyKTtcbiAgICAgIH1cbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50Lm9uY2UsIGV2ZW50LmNhcHR1cmUpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKCFvbltuYW1lXSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKCFvbGRIb29rKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG9sZEhvb2suZm5zICYmIG9sZEhvb2subWVyZ2VkKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoYyA9PSBudWxsIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxuICAgIGxhc3QgPSByZXNbcmVzLmxlbmd0aCAtIDFdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSkpO1xuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChsYXN0ICYmIGxhc3QudGV4dCkge1xuICAgICAgICBsYXN0LnRleHQgKz0gU3RyaW5nKGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYy50ZXh0ICYmIGxhc3QgJiYgbGFzdC50ZXh0KSB7XG4gICAgICAgIHJlc1tyZXMubGVuZ3RoIC0gMV0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChjLnRhZyAmJiBjLmtleSA9PSBudWxsICYmIG5lc3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgJiYgYy5jb21wb25lbnRPcHRpb25zOyB9KVswXVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlJCQxKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcbiAgdmFyIG5hbWUsIGNoaWxkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mdW5jdGlvbmFsQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgICAgY2hpbGQuZGF0YSAmJiAobmFtZSA9IGNoaWxkLmRhdGEuc2xvdCkpIHtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWZhdWx0U2xvdC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHdoaXRlc3BhY2VcbiAgaWYgKCFkZWZhdWx0U2xvdC5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgc2xvdHMuZGVmYXVsdCA9IGRlZmF1bHRTbG90O1xuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50IHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZuc1xuKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICByZXNbZm5zW2ldWzBdXSA9IGZuc1tpXVsxXTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIERPTSBub2RlcyAocHJldmVudHMgbGVhaylcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIHZtLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgdm0uJG9wdGlvbnMucHJvcHMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcbiAgfVxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIHF1ZXVlID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgcXVldWUubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkLCB2bTtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IGNvbmZpZy5fbWF4VXBkYXRlQ291bnQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICB3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgPyAoXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3YXRjaGVyLnZtXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzZXQgc2NoZWR1bGVyIGJlZm9yZSB1cGRhdGVkIGhvb2sgY2FsbGVkXG4gIHZhciBvbGRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIHVwZGF0ZWQgaG9va3NcbiAgaW5kZXggPSBvbGRRdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgd2F0Y2hlciA9IG9sZFF1ZXVlW2luZGV4XTtcbiAgICB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPj0gMCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKE1hdGgubWF4KGksIGluZGV4KSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnNcbikge1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICBpZiAodGhpcy51c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfVxuICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gIGlmICh0aGlzLmRlZXApIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG4gIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xuICAgIGlmICghdGhpcyQxLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2gpIHsgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTsgfVxufVxuXG52YXIgaXNSZXNlcnZlZFByb3AgPSB7IGtleTogMSwgcmVmOiAxLCBzbG90OiAxIH07XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGlzUm9vdDtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcFtrZXldKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleXNbaV0pKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsgKGtleXNbaV0pICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleXNbaV0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJObyBnZXR0ZXIgZnVuY3Rpb24gaGFzIGJlZW4gZGVmaW5lZCBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgICBnZXR0ZXIgPSBub29wO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcih2bSwgZ2V0dGVyLCBub29wLCBjb21wdXRlZFdhdGNoZXJPcHRpb25zKTtcblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKHRhcmdldCwga2V5LCB1c2VyRGVmKSB7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAodm0sIGtleSwgaGFuZGxlcikge1xuICB2YXIgb3B0aW9ucztcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgdm0uJHdhdGNoKGtleSwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2sodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmICghQ3Rvcikge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgaWYgKCFDdG9yLmNpZCkge1xuICAgIGlmIChDdG9yLnJlc29sdmVkKSB7XG4gICAgICBDdG9yID0gQ3Rvci5yZXNvbHZlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChDdG9yLCBiYXNlQ3RvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpdCdzIG9rIHRvIHF1ZXVlIHRoaXMgb24gZXZlcnkgcmVuZGVyIGJlY2F1c2VcbiAgICAgICAgLy8gJGZvcmNlVXBkYXRlIGlzIGJ1ZmZlcmVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAgICAgIGNvbnRleHQuJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIGlmICghQ3Rvcikge1xuICAgICAgICAvLyByZXR1cm4gbm90aGluZyBpZiB0aGlzIGlzIGluZGVlZCBhbiBhc3luYyBjb21wb25lbnRcbiAgICAgICAgLy8gd2FpdCBmb3IgdGhlIGNhbGxiYWNrIHRvIHRyaWdnZXIgcGFyZW50IHVwZGF0ZS5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChkYXRhLm1vZGVsKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wcyhkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzXG4gICAgZGF0YSA9IHt9O1xuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH1cbiAgKTtcbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKHByb3BPcHRpb25zKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSk7XG4gICAgfVxuICB9XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgX2NvbnRleHQgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQpO1xuICB2YXIgaCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KF9jb250ZXh0LCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcbiAgdmFyIHZub2RlID0gQ3Rvci5vcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIGgsIHtcbiAgICBwcm9wczogcHJvcHMsXG4gICAgZGF0YTogZGF0YSxcbiAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIHNsb3RzOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQpOyB9XG4gIH0pO1xuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHZub2RlLmZ1bmN0aW9uYWxDb250ZXh0ID0gY29udGV4dDtcbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBwcm9wc0RhdGE6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEsXG4gICAgX2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRMaXN0ZW5lcnM6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMsXG4gICAgX3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZUNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvcixcbiAgY2Jcbikge1xuICBpZiAoZmFjdG9yeS5yZXF1ZXN0ZWQpIHtcbiAgICAvLyBwb29sIGNhbGxiYWNrc1xuICAgIGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNiKTtcbiAgfSBlbHNlIHtcbiAgICBmYWN0b3J5LnJlcXVlc3RlZCA9IHRydWU7XG4gICAgdmFyIGNicyA9IGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcyA9IFtjYl07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgdmFyIHJlc29sdmUgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICByZXMgPSBiYXNlQ3Rvci5leHRlbmQocmVzKTtcbiAgICAgIH1cbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gcmVzO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY2JzW2ldKHJlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAvLyBoYW5kbGUgcHJvbWlzZVxuICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nICYmICFmYWN0b3J5LnJlc29sdmVkKSB7XG4gICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHMgKGRhdGEsIEN0b3IsIHRhZykge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wT3B0aW9ucykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgdmFyIGRvbVByb3BzID0gZGF0YS5kb21Qcm9wcztcbiAgaWYgKGF0dHJzIHx8IHByb3BzIHx8IGRvbVByb3BzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBhdHRycy5oYXNPd25Qcm9wZXJ0eShrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5KSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgZG9tUHJvcHMsIGtleSwgYWx0S2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChoYXNoKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xuICBpZiAoIWRhdGEuaG9vaykge1xuICAgIGRhdGEuaG9vayA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xuICAgIHZhciBvdXJzID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgb25lKGEsIGIsIGMsIGQpO1xuICAgIHR3byhhLCBiLCBjLCBkKTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChvbltldmVudF0pIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoYWx3YXlzTm9ybWFsaXplKSB7IG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTsgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoZGF0YSAmJiBkYXRhLl9fb2JfXykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmICh2bm9kZSkge1xuICAgIGlmIChucykgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIHJldHVyblxuICB9XG4gIGlmICh2bm9kZS5jaGlsZHJlbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC50YWcgJiYgIWNoaWxkLm5zKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgZXh0ZW5kKHByb3BzLCBiaW5kT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2tcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFxuICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2tcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbkFsaWFzXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICByZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdID1cbiAgICB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uJHZub2RlID0gbnVsbDsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDtcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2Rlcyh2bS4kc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICBpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcbiAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlciBmdW5jdGlvblwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpXG4gICAgICAgICAgOiB2bS5fdm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xuXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxuICAvLyB0aGVzZSBhcmUgZXhwb3NlZCBvbiB0aGUgaW5zdGFuY2UgcHJvdG90eXBlIHRvIHJlZHVjZSBnZW5lcmF0ZWQgcmVuZGVyXG4gIC8vIGNvZGUgc2l6ZS5cbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xuICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSBfdG9TdHJpbmc7XG4gIFZ1ZS5wcm90b3R5cGUuX2wgPSByZW5kZXJMaXN0O1xuICBWdWUucHJvdG90eXBlLl90ID0gcmVuZGVyU2xvdDtcbiAgVnVlLnByb3RvdHlwZS5fcSA9IGxvb3NlRXF1YWw7XG4gIFZ1ZS5wcm90b3R5cGUuX2kgPSBsb29zZUluZGV4T2Y7XG4gIFZ1ZS5wcm90b3R5cGUuX20gPSByZW5kZXJTdGF0aWM7XG4gIFZ1ZS5wcm90b3R5cGUuX2YgPSByZXNvbHZlRmlsdGVyO1xuICBWdWUucHJvdG90eXBlLl9rID0gY2hlY2tLZXlDb2RlcztcbiAgVnVlLnByb3RvdHlwZS5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgVnVlLnByb3RvdHlwZS5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIGluamVjdCA9IHZtLiRvcHRpb25zLmluamVjdDtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgLy8gaXNBcnJheSBoZXJlXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGluamVjdCk7XG4gICAgdmFyIGtleXMgPSBpc0FycmF5XG4gICAgICA/IGluamVjdFxuICAgICAgOiBoYXNTeW1ib2xcbiAgICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpc0FycmF5ID8ga2V5IDogaW5qZWN0W2tleV07XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIHByb3ZpZGVLZXkgaW4gc291cmNlLl9wcm92aWRlZCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICAgICAgXCJpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCsrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1pbml0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSQyIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDIpKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUkMik7XG5zdGF0ZU1peGluKFZ1ZSQyKTtcbmV2ZW50c01peGluKFZ1ZSQyKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSQyKTtcbnJlbmRlck1peGluKFZ1ZSQyKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgJ2lkOiAnICsgaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cF07XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoY2FjaGUsIGZpbHRlcikge1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGVkTm9kZSk7XG4gICAgICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKHZub2RlKSB7XG4gIGlmICh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2luYWN0aXZlKSB7XG4gICAgICBjYWxsSG9vayh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgfVxuICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbn1cblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXNcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlW2tleV0pO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgKFxuICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG4gICAgICAgICh0aGlzLmV4Y2x1ZGUgJiYgbWF0Y2hlcyh0aGlzLmV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmICh0aGlzLmNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMi5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5WdWUkMi52ZXJzaW9uID0gJzIuMi42JztcblxuLyogICovXG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2VuQ2xhc3NGcm9tRGF0YShkYXRhKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGNoaWxkLmNsYXNzXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5DbGFzc0Zyb21EYXRhIChkYXRhKSB7XG4gIHZhciBkeW5hbWljQ2xhc3MgPSBkYXRhLmNsYXNzO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBkYXRhLnN0YXRpY0NsYXNzO1xuICBpZiAoc3RhdGljQ2xhc3MgfHwgZHluYW1pY0NsYXNzKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgc3RyaW5naWZpZWQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSkge1xuICAgICAgICBpZiAoKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSkge1xuICAgICAgICAgIHJlcyArPSBzdHJpbmdpZmllZCArICcgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7IHJlcyArPSBrZXkgKyAnICc7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG5cblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWtleSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkgJiYgcmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcblxuLypcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJlxuICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gIClcbn1cblxuLy8gU29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBkeW5hbWljYWxseSBjaGFuZ2luZyB0eXBlIGZvciA8aW5wdXQ+XG4vLyBzbyB0aGV5IG5lZWQgdG8gYmUgdHJlYXRlZCBhcyBkaWZmZXJlbnQgbm9kZXNcbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUJcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZikge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmKSkge1xuICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgIH1cbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KSA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XSA6IG51bGw7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG5ld1N0YXJ0Vm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLHN0eWxlLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFiYWlsZWQpIHtcbiAgICAgICAgICAgICAgYmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fFxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5LCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKCdzZXJ2ZXItcmVuZGVyZWQnKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKCdzZXJ2ZXItcmVuZGVyZWQnKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIC8vIGNvbXBvbmVudCByb290IGVsZW1lbnQgcmVwbGFjZWQuXG4gICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuY3JlYXRlW2ldKGVtcHR5Tm9kZSwgdm5vZGUucGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEuYXR0cnMgJiYgIXZub2RlLmRhdGEuYXR0cnMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChhdHRycy5fX29iX18pIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGF0dHJzW2tleV0gPT0gbnVsbCkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBrZXkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmICghZGF0YS5zdGF0aWNDbGFzcyAmJiAhZGF0YS5jbGFzcyAmJlxuICAgICAgKCFvbGREYXRhIHx8ICghb2xkRGF0YS5zdGF0aWNDbGFzcyAmJiAhb2xkRGF0YS5jbGFzcykpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuLyogICovXG5cbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG5cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIFwiLFwiICsgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuXG5cbi8qKlxuICogcGFyc2UgZGlyZWN0aXZlIG1vZGVsIHRvIGRvIHRoZSBhcnJheSB1cGRhdGUgdHJhbnNmb3JtLiBhW2lkeF0gPSB2YWwgPT4gJCRhLnNwbGljZSgkJGlkeCwgMSwgdmFsKVxuICpcbiAqIGZvciBsb29wIHBvc3NpYmxlIGNhc2VzOlxuICpcbiAqIC0gdGVzdFxuICogLSB0ZXN0W2lkeF1cbiAqIC0gdGVzdFt0ZXN0MVtpZHhdXVxuICogLSB0ZXN0W1wiYVwiXVtpZHhdXG4gKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFbaWR4XV1cbiAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtpZHhdXVxuICpcbiAqL1xuXG52YXIgc3RyO1xudmFyIGluZGV4JDE7XG5cbi8qICAqL1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIHZhciBldmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChvbltSQU5HRV9UT0tFTl0pIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICBpZiAob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSB7XG4gICAgLy8gQ2hyb21lIGZpcmVzIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBjbGljay9jaGFuZ2UsIGxlYWRzIHRvICM0NTIxXG4gICAgZXZlbnQgPSBpc0Nocm9tZSA/ICdjbGljaycgOiAnY2hhbmdlJztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBvbmNlLFxuICBjYXB0dXJlXG4pIHtcbiAgaWYgKG9uY2UpIHtcbiAgICB2YXIgb2xkSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICBoYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IG9sZEhhbmRsZXIoZXYpXG4gICAgICAgIDogb2xkSGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmUkMihldmVudCwgaGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKCFvbGRWbm9kZS5kYXRhLm9uICYmICF2bm9kZS5kYXRhLm9uKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKCFvbGRWbm9kZS5kYXRhLmRvbVByb3BzICYmICF2bm9kZS5kYXRhLmRvbVByb3BzKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKHByb3BzLl9fb2JfXykge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAocHJvcHNba2V5XSA9PSBudWxsKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gY3VyID09IG51bGwgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgdm5vZGUsIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKFxuICBlbG0sXG4gIHZub2RlLFxuICBjaGVja1ZhbFxuKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIHZub2RlLnRhZyA9PT0gJ29wdGlvbicgfHxcbiAgICBpc0RpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNJbnB1dENoYW5nZWQoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNJbnB1dENoYW5nZWQgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXIpIHx8IGVsbS50eXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgfVxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy50cmltKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIGVsLnN0eWxlW25vcm1hbGl6ZShuYW1lKV0gPSB2YWw7XG4gIH1cbn07XG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgdGVzdEVsO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICB0ZXN0RWwgPSB0ZXN0RWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIHRlc3RFbC5zdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciB1cHBlciA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyB1cHBlcjtcbiAgICBpZiAocHJlZml4ZWQgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmICghZGF0YS5zdGF0aWNTdHlsZSAmJiAhZGF0YS5zdHlsZSAmJlxuICAgICAgIW9sZERhdGEuc3RhdGljU3R5bGUgJiYgIW9sZERhdGEuc3R5bGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkVm5vZGUuZGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZFZub2RlLmRhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICB2bm9kZS5kYXRhLnN0eWxlID0gc3R5bGUuX19vYl9fID8gZXh0ZW5kKHt9LCBzdHlsZSkgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKG5ld1N0eWxlW25hbWVdID09IG51bGwpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIudHJpbSgpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gIDogc2V0VGltZW91dDtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pKS5wdXNoKGNscyk7XG4gIGFkZENsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChlbC5fbGVhdmVDYikge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsLl9lbnRlckNiIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChlbC5fZW50ZXJDYikge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwuX2xlYXZlQ2IgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRMZWF2ZUR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbdm5vZGUua2V5XSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoIWZuKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaW52b2tlckZucykge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBjYigpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgZWwudHlwZSA9PT0gJ3RleHQnIHx8IGVsLnR5cGUgPT09ICdwYXNzd29yZCcpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgaWYgKCFpc0FuZHJvaWQpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGVsLm9wdGlvbnMpOyB9KVxuICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBlbC5vcHRpb25zKTtcbiAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb25zW2ldKSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uICYmICFpc0lFOSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogbW9kZWwkMSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIHJldHVybiAvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZylcbiAgICA/IGgoJ2tlZXAtYWxpdmUnKVxuICAgIDogbnVsbFxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJykge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvbGRDaGlsZCAmJiBvbGRDaGlsZC5kYXRhICYmICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQgJiYgKG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSkpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgKTtcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBmID0gYm9keS5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faGFzTW92ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUkMi5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZSQyLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZSQyLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUkMi5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZSQyLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUkMi5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZSQyLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZSQyLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlJDIpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0Nocm9tZSkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgICBpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICApO1xuICB9XG59LCAwKTtcblxuZXhwb3J0IGRlZmF1bHQgVnVlJDI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLl92dWVAMi4yLjZAdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Jhc2U2NC1qcy9pbmRleC5qcz8yYWRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jhc2U2NC1qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(15)\nvar ieee754 = __webpack_require__(17)\nvar isArray = __webpack_require__(18)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2J1ZmZlci9pbmRleC5qcz8xYTU1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVmZmVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2llZWU3NTQvaW5kZXguanM/NzBmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxRQUFRLFVBQVU7O0FBRWxCO0FBQ0EiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pZWVlNzU0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2lzYXJyYXkvaW5kZXguanM/ZWFiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(0);
__webpack_require__(0);
module.exports = __webpack_require__(3);


/***/ })
/******/ ]);